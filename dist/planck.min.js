/**
 * Planck.js v2.0-dev.0
 * @license The MIT license
 * @copyright Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).planck={})}(this,(function(t){"use strict";const e=function(t,e){null==t&&(t={});const s=Object.assign({},t);for(const i in e)e.hasOwnProperty(i)&&void 0===t[i]&&(s[i]=e[i]);if("function"==typeof Object.getOwnPropertySymbols){const i=Object.getOwnPropertySymbols(e);for(let o=0;o<i.length;o++){const n=i[o];e.propertyIsEnumerable(n)&&void 0===t[n]&&(s[n]=e[n])}}return s},s=Object.assign(Object.create(Math),{EPSILON:1e-9,isFinite:function(t){return"number"==typeof t&&isFinite(t)&&!isNaN(t)},assert:function(t){},nextPowerOfTwo:function(t){return t|=t>>1,t|=t>>2,t|=t>>4,t|=t>>8,(t|=t>>16)+1},isPowerOfTwo:function(t){return t>0&&0==(t&t-1)},mod:function(t,e,s){return void 0===e?(s=1,e=0):void 0===s&&(s=e,e=0),s>e?(t=(t-e)%(s-e))+(t<0?s:e):(t=(t-s)%(e-s))+(t<=0?e:s)},clamp:function(t,e,s){return t<e?e:t>s?s:t},random:function(t,e){return void 0===t?(e=1,t=0):void 0===e&&(e=t,t=0),t===e?t:Math.random()*(e-t)+t}});class i{constructor(t,e){void 0===t?(this.x=0,this.y=0):"object"==typeof t?(this.x=t.x,this.y=t.y):(this.x=t,this.y=e)}_serialize(){return{x:this.x,y:this.y}}static _deserialize(t){const e=Object.create(i.prototype);return e.x=t.x,e.y=t.y,e}static zero(){const t=Object.create(i.prototype);return t.x=0,t.y=0,t}static neo(t,e){const s=Object.create(i.prototype);return s.x=t,s.y=e,s}static clone(t){return i.neo(t.x,t.y)}toString(){return JSON.stringify(this)}static isValid(t){return null!=t&&(s.isFinite(t.x)&&s.isFinite(t.y))}static assert(t){}clone(){return i.clone(this)}setZero(){return this.x=0,this.y=0,this}set(t,e){return"object"==typeof t?(this.x=t.x,this.y=t.y):(this.x=t,this.y=e),this}setNum(t,e){return this.x=t,this.y=e,this}setVec2(t){return this.x=t.x,this.y=t.y,this}wSet(t,e,s,i){return void 0!==s||void 0!==i?this.setCombine(t,e,s,i):this.setMul(t,e)}setCombine(t,e,s,i){const o=t*e.x+s*i.x,n=t*e.y+s*i.y;return this.x=o,this.y=n,this}setMul(t,e){const s=t*e.x,i=t*e.y;return this.x=s,this.y=i,this}add(t){return this.x+=t.x,this.y+=t.y,this}wAdd(t,e,s,i){return void 0!==s||void 0!==i?this.addCombine(t,e,s,i):this.addMul(t,e)}addCombine(t,e,s,i){const o=t*e.x+s*i.x,n=t*e.y+s*i.y;return this.x+=o,this.y+=n,this}addMul(t,e){const s=t*e.x,i=t*e.y;return this.x+=s,this.y+=i,this}wSub(t,e,s,i){return void 0!==s||void 0!==i?this.subCombine(t,e,s,i):this.subMul(t,e)}subCombine(t,e,s,i){const o=t*e.x+s*i.x,n=t*e.y+s*i.y;return this.x-=o,this.y-=n,this}subMul(t,e){const s=t*e.x,i=t*e.y;return this.x-=s,this.y-=i,this}sub(t){return this.x-=t.x,this.y-=t.y,this}mul(t){return this.x*=t,this.y*=t,this}length(){return i.lengthOf(this)}lengthSquared(){return i.lengthSquared(this)}normalize(){const t=this.length();if(t<s.EPSILON)return 0;const e=1/t;return this.x*=e,this.y*=e,t}static lengthOf(t){return s.sqrt(t.x*t.x+t.y*t.y)}static lengthSquared(t){return t.x*t.x+t.y*t.y}static distance(t,e){const i=t.x-e.x,o=t.y-e.y;return s.sqrt(i*i+o*o)}static distanceSquared(t,e){const s=t.x-e.x,i=t.y-e.y;return s*s+i*i}static areEqual(t,e){return t===e||"object"==typeof e&&null!==e&&t.x===e.x&&t.y===e.y}static skew(t){return i.neo(-t.y,t.x)}static dot(t,e){return t.x*e.x+t.y*e.y}static cross(t,e){return"number"==typeof e?i.neo(e*t.y,-e*t.x):"number"==typeof t?i.neo(-t*e.y,t*e.x):t.x*e.y-t.y*e.x}static crossVec2Vec2(t,e){return t.x*e.y-t.y*e.x}static crossVec2Num(t,e){return i.neo(e*t.y,-e*t.x)}static crossNumVec2(t,e){return i.neo(-t*e.y,t*e.x)}static addCross(t,e,s){return"number"==typeof s?i.neo(s*e.y+t.x,-s*e.x+t.y):"number"==typeof e?i.neo(-e*s.y+t.x,e*s.x+t.y):void 0}static addCrossVec2Num(t,e,s){return i.neo(s*e.y+t.x,-s*e.x+t.y)}static addCrossNumVec2(t,e,s){return i.neo(-e*s.y+t.x,e*s.x+t.y)}static add(t,e){return i.neo(t.x+e.x,t.y+e.y)}static wAdd(t,e,s,o){return void 0!==s||void 0!==o?i.combine(t,e,s,o):i.mulNumVec2(t,e)}static combine(t,e,s,o){return i.zero().setCombine(t,e,s,o)}static sub(t,e){return i.neo(t.x-e.x,t.y-e.y)}static mul(t,e){return"object"==typeof t?i.neo(t.x*e,t.y*e):"object"==typeof e?i.neo(t*e.x,t*e.y):void 0}static mulVec2Num(t,e){return i.neo(t.x*e,t.y*e)}static mulNumVec2(t,e){return i.neo(t*e.x,t*e.y)}neg(){return this.x=-this.x,this.y=-this.y,this}static neg(t){return i.neo(-t.x,-t.y)}static abs(t){return i.neo(s.abs(t.x),s.abs(t.y))}static mid(t,e){return i.neo(.5*(t.x+e.x),.5*(t.y+e.y))}static upper(t,e){return i.neo(s.max(t.x,e.x),s.max(t.y,e.y))}static lower(t,e){return i.neo(s.min(t.x,e.x),s.min(t.y,e.y))}clamp(t){const e=this.x*this.x+this.y*this.y;if(e>t*t){const i=t/s.sqrt(e);this.x*=i,this.y*=i}return this}static clamp(t,e){const s=i.neo(t.x,t.y);return s.clamp(e),s}static scaleFn(t,e){return function(s){return i.neo(s.x*t,s.y*e)}}static translateFn(t,e){return function(s){return i.neo(s.x+t,s.y+e)}}}class o{constructor(t,e){this.lowerBound=i.zero(),this.upperBound=i.zero(),"object"==typeof t&&this.lowerBound.setVec2(t),"object"==typeof e?this.upperBound.setVec2(e):"object"==typeof t&&this.upperBound.setVec2(t)}isValid(){return o.isValid(this)}static isValid(t){return null!=t&&(i.isValid(t.lowerBound)&&i.isValid(t.upperBound)&&i.sub(t.upperBound,t.lowerBound).lengthSquared()>=0)}static assert(t){}getCenter(){return i.neo(.5*(this.lowerBound.x+this.upperBound.x),.5*(this.lowerBound.y+this.upperBound.y))}getExtents(){return i.neo(.5*(this.upperBound.x-this.lowerBound.x),.5*(this.upperBound.y-this.lowerBound.y))}getPerimeter(){return 2*(this.upperBound.x-this.lowerBound.x+this.upperBound.y-this.lowerBound.y)}combine(t,e){e=e||this;const i=t.lowerBound,o=t.upperBound,n=e.lowerBound,r=e.upperBound,m=s.min(i.x,n.x),h=s.min(i.y,n.y),a=s.max(r.x,o.x),c=s.max(r.y,o.y);this.lowerBound.setNum(m,h),this.upperBound.setNum(a,c)}combinePoints(t,e){this.lowerBound.setNum(s.min(t.x,e.x),s.min(t.y,e.y)),this.upperBound.setNum(s.max(t.x,e.x),s.max(t.y,e.y))}set(t){this.lowerBound.setNum(t.lowerBound.x,t.lowerBound.y),this.upperBound.setNum(t.upperBound.x,t.upperBound.y)}contains(t){let e=!0;return e=e&&this.lowerBound.x<=t.lowerBound.x,e=e&&this.lowerBound.y<=t.lowerBound.y,e=e&&t.upperBound.x<=this.upperBound.x,e=e&&t.upperBound.y<=this.upperBound.y,e}extend(t){return o.extend(this,t),this}static extend(t,e){return t.lowerBound.x-=e,t.lowerBound.y-=e,t.upperBound.x+=e,t.upperBound.y+=e,t}static testOverlap(t,e){const s=e.lowerBound.x-t.upperBound.x,i=t.lowerBound.x-e.upperBound.x,o=e.lowerBound.y-t.upperBound.y,n=t.lowerBound.y-e.upperBound.y;return!(s>0||o>0||i>0||n>0)}static areEqual(t,e){return i.areEqual(t.lowerBound,e.lowerBound)&&i.areEqual(t.upperBound,e.upperBound)}static diff(t,e){const i=s.max(0,s.min(t.upperBound.x,e.upperBound.x)-s.max(e.lowerBound.x,t.lowerBound.x)),o=s.max(0,s.min(t.upperBound.y,e.upperBound.y)-s.max(e.lowerBound.y,t.lowerBound.y));return(t.upperBound.x-t.lowerBound.x)*(t.upperBound.y-t.lowerBound.y)+(e.upperBound.x-e.lowerBound.x)*(e.upperBound.y-e.lowerBound.y)-i*o}rayCast(t,e){let o=-1/0,n=1/0;const r=e.p1,m=i.sub(e.p2,e.p1),h=i.abs(m),a=i.zero();for(let t="x";null!==t;t="x"===t?"y":null)if(h.x<s.EPSILON){if(r[t]<this.lowerBound[t]||this.upperBound[t]<r[t])return!1}else{const e=1/m[t];let i=(this.lowerBound[t]-r[t])*e,h=(this.upperBound[t]-r[t])*e,c=-1;if(i>h){const t=i;i=h,h=t,c=1}if(i>o&&(a.setZero(),a[t]=c,o=i),n=s.min(n,h),o>n)return!1}return!(o<0||e.maxFraction<o)&&(t.fraction=o,t.normal=a,!0)}toString(){return JSON.stringify(this)}static combinePoints(t,e,i){return t.lowerBound.x=s.min(e.x,i.x),t.lowerBound.y=s.min(e.y,i.y),t.upperBound.x=s.max(e.x,i.x),t.upperBound.y=s.max(e.y,i.y),t}static combinedPerimeter(t,e){const i=s.min(t.lowerBound.x,e.lowerBound.x),o=s.min(t.lowerBound.y,e.lowerBound.y);return 2*(s.max(t.upperBound.x,e.upperBound.x)-i+s.max(t.upperBound.y,e.upperBound.y)-o)}}class n{static get polygonRadius(){return 2*n.linearSlop}}n.lengthUnitsPerMeter=1,n.maxManifoldPoints=2,n.maxPolygonVertices=12,n.aabbExtension=.1,n.aabbMultiplier=2,n.linearSlop=.005,n.angularSlop=2/180*Math.PI,n.maxSubSteps=8,n.maxTOIContacts=32,n.maxTOIIterations=20,n.maxDistnceIterations=20,n.velocityThreshold=1,n.maxLinearCorrection=.2,n.maxAngularCorrection=8/180*Math.PI,n.maxTranslation=2,n.maxRotation=.5*Math.PI,n.baumgarte=.2,n.toiBaugarte=.75,n.timeToSleep=.5,n.linearSleepTolerance=.01,n.angularSleepTolerance=2/180*Math.PI;class r{static get maxManifoldPoints(){return n.maxManifoldPoints}static get maxPolygonVertices(){return n.maxPolygonVertices}static get aabbExtension(){return n.aabbExtension*n.lengthUnitsPerMeter}static get aabbMultiplier(){return n.aabbMultiplier}static get linearSlop(){return n.linearSlop*n.lengthUnitsPerMeter}static get linearSlopSquared(){return n.linearSlop*n.lengthUnitsPerMeter*n.linearSlop*n.lengthUnitsPerMeter}static get angularSlop(){return n.angularSlop}static get polygonRadius(){return 2*n.linearSlop}static get maxSubSteps(){return n.maxSubSteps}static get maxTOIContacts(){return n.maxTOIContacts}static get maxTOIIterations(){return n.maxTOIIterations}static get maxDistnceIterations(){return n.maxDistnceIterations}static get velocityThreshold(){return n.velocityThreshold*n.lengthUnitsPerMeter}static get maxLinearCorrection(){return n.maxLinearCorrection*n.lengthUnitsPerMeter}static get maxAngularCorrection(){return n.maxAngularCorrection}static get maxTranslation(){return n.maxTranslation*n.lengthUnitsPerMeter}static get maxTranslationSquared(){return n.maxTranslation*n.lengthUnitsPerMeter*n.maxTranslation*n.lengthUnitsPerMeter}static get maxRotation(){return n.maxRotation}static get maxRotationSquared(){return n.maxRotation*n.maxRotation}static get baumgarte(){return n.baumgarte}static get toiBaugarte(){return n.toiBaugarte}static get timeToSleep(){return n.timeToSleep}static get linearSleepTolerance(){return n.linearSleepTolerance*n.lengthUnitsPerMeter}static get linearSleepToleranceSqr(){return n.linearSleepTolerance*n.lengthUnitsPerMeter*n.linearSleepTolerance*n.lengthUnitsPerMeter}static get angularSleepTolerance(){return n.angularSleepTolerance}static get angularSleepToleranceSqr(){return n.angularSleepTolerance*n.angularSleepTolerance}}class m{constructor(t){this._list=[],this._max=1/0,this._hasCreateFn=!1,this._createCount=0,this._hasAllocateFn=!1,this._allocateCount=0,this._hasReleaseFn=!1,this._releaseCount=0,this._hasDisposeFn=!1,this._disposeCount=0,this._list=[],this._max=t.max||this._max,this._createFn=t.create,this._hasCreateFn="function"==typeof this._createFn,this._allocateFn=t.allocate,this._hasAllocateFn="function"==typeof this._allocateFn,this._releaseFn=t.release,this._hasReleaseFn="function"==typeof this._releaseFn,this._disposeFn=t.dispose,this._hasDisposeFn="function"==typeof this._disposeFn}max(t){return"number"==typeof t?(this._max=t,this):this._max}size(){return this._list.length}allocate(){let t;return this._list.length>0?t=this._list.shift():(this._createCount++,t=this._hasCreateFn?this._createFn():{}),this._allocateCount++,this._hasAllocateFn&&this._allocateFn(t),t}release(t){this._list.length<this._max?(this._releaseCount++,this._hasReleaseFn&&this._releaseFn(t),this._list.push(t)):(this._disposeCount++,this._hasDisposeFn&&(t=this._disposeFn(t)))}toString(){return" +"+this._createCount+" >"+this._allocateCount+" <"+this._releaseCount+" -"+this._disposeCount+" ="+this._list.length+"/"+this._max}}class h{constructor(t){this.aabb=new o,this.userData=null,this.parent=null,this.child1=null,this.child2=null,this.height=-1,this.id=t}toString(){return this.id+": "+this.userData}isLeaf(){return null==this.child1}}const a=new m({create:()=>new h,release(t){t.userData=null,t.parent=null,t.child1=null,t.child2=null,t.height=-1,t.id=void 0}});class c{constructor(){this.inputPool=new m({create:()=>({}),release(t){}}),this.stackPool=new m({create:()=>[],release(t){t.length=0}}),this.iteratorPool=new m({create:()=>new l,release(t){t.close()}}),this.m_root=null,this.m_nodes={},this.m_lastProxyId=0}getUserData(t){return this.m_nodes[t].userData}getFatAABB(t){return this.m_nodes[t].aabb}allocateNode(){const t=a.allocate();return t.id=++this.m_lastProxyId,this.m_nodes[t.id]=t,t}freeNode(t){delete this.m_nodes[t.id],a.release(t)}createProxy(t,e){const s=this.allocateNode();return s.aabb.set(t),o.extend(s.aabb,r.aabbExtension),s.userData=e,s.height=0,this.insertLeaf(s),s.id}destroyProxy(t){const e=this.m_nodes[t];this.removeLeaf(e),this.freeNode(e)}moveProxy(t,e,s){const i=this.m_nodes[t];return!i.aabb.contains(e)&&(this.removeLeaf(i),i.aabb.set(e),e=i.aabb,o.extend(e,r.aabbExtension),s.x<0?e.lowerBound.x+=s.x*r.aabbMultiplier:e.upperBound.x+=s.x*r.aabbMultiplier,s.y<0?e.lowerBound.y+=s.y*r.aabbMultiplier:e.upperBound.y+=s.y*r.aabbMultiplier,this.insertLeaf(i),!0)}insertLeaf(t){if(null==this.m_root)return this.m_root=t,void(this.m_root.parent=null);const e=t.aabb;let s=this.m_root;for(;!s.isLeaf();){const t=s.child1,i=s.child2,n=s.aabb.getPerimeter(),r=o.combinedPerimeter(s.aabb,e),m=2*r,h=2*(r-n);let a=o.combinedPerimeter(e,t.aabb)+h;if(!t.isLeaf()){a-=t.aabb.getPerimeter()}let c=o.combinedPerimeter(e,i.aabb)+h;if(!i.isLeaf()){c-=i.aabb.getPerimeter()}if(m<a&&m<c)break;s=a<c?t:i}const i=s,n=i.parent,r=this.allocateNode();for(r.parent=n,r.userData=null,r.aabb.combine(e,i.aabb),r.height=i.height+1,null!=n?(n.child1===i?n.child1=r:n.child2=r,r.child1=i,r.child2=t,i.parent=r,t.parent=r):(r.child1=i,r.child2=t,i.parent=r,t.parent=r,this.m_root=r),s=t.parent;null!=s;){s=this.balance(s);const t=s.child1,e=s.child2;s.height=1+Math.max(t.height,e.height),s.aabb.combine(t.aabb,e.aabb),s=s.parent}}removeLeaf(t){if(t===this.m_root)return void(this.m_root=null);const e=t.parent,s=e.parent;let i;if(i=e.child1===t?e.child2:e.child1,null!=s){s.child1===e?s.child1=i:s.child2=i,i.parent=s,this.freeNode(e);let t=s;for(;null!=t;){t=this.balance(t);const e=t.child1,s=t.child2;t.aabb.combine(e.aabb,s.aabb),t.height=1+Math.max(e.height,s.height),t=t.parent}}else this.m_root=i,i.parent=null,this.freeNode(e)}balance(t){const e=t;if(e.isLeaf()||e.height<2)return t;const s=e.child1,i=e.child2,o=i.height-s.height;if(o>1){const o=i.child1,n=i.child2;return i.child1=e,i.parent=e.parent,e.parent=i,null!=i.parent?i.parent.child1===t?i.parent.child1=i:i.parent.child2=i:this.m_root=i,o.height>n.height?(i.child2=o,e.child2=n,n.parent=e,e.aabb.combine(s.aabb,n.aabb),i.aabb.combine(e.aabb,o.aabb),e.height=1+Math.max(s.height,n.height),i.height=1+Math.max(e.height,o.height)):(i.child2=n,e.child2=o,o.parent=e,e.aabb.combine(s.aabb,o.aabb),i.aabb.combine(e.aabb,n.aabb),e.height=1+Math.max(s.height,o.height),i.height=1+Math.max(e.height,n.height)),i}if(o<-1){const t=s.child1,o=s.child2;return s.child1=e,s.parent=e.parent,e.parent=s,null!=s.parent?s.parent.child1===e?s.parent.child1=s:s.parent.child2=s:this.m_root=s,t.height>o.height?(s.child2=t,e.child1=o,o.parent=e,e.aabb.combine(i.aabb,o.aabb),s.aabb.combine(e.aabb,t.aabb),e.height=1+Math.max(i.height,o.height),s.height=1+Math.max(e.height,t.height)):(s.child2=o,e.child1=t,t.parent=e,e.aabb.combine(i.aabb,t.aabb),s.aabb.combine(e.aabb,o.aabb),e.height=1+Math.max(i.height,t.height),s.height=1+Math.max(e.height,o.height)),s}return e}getHeight(){return null==this.m_root?0:this.m_root.height}getAreaRatio(){if(null==this.m_root)return 0;const t=this.m_root.aabb.getPerimeter();let e,s=0;const i=this.iteratorPool.allocate().preorder(this.m_root);for(;e=i.next();)e.height<0||(s+=e.aabb.getPerimeter());return this.iteratorPool.release(i),s/t}computeHeight(t){let e;if(e=void 0!==t?this.m_nodes[t]:this.m_root,e.isLeaf())return 0;const s=this.computeHeight(e.child1.id),i=this.computeHeight(e.child2.id);return 1+Math.max(s,i)}validateStructure(t){if(null==t)return;this.m_root;const e=t.child1,s=t.child2;t.isLeaf()||(this.validateStructure(e),this.validateStructure(s))}validateMetrics(t){if(null==t)return;const e=t.child1,s=t.child2;if(t.isLeaf())return;e.height,s.height;(new o).combine(e.aabb,s.aabb),this.validateMetrics(e),this.validateMetrics(s)}validate(){}getMaxBalance(){let t,e=0;const s=this.iteratorPool.allocate().preorder(this.m_root);for(;t=s.next();){if(t.height<=1)continue;const s=Math.abs(t.child2.height-t.child1.height);e=Math.max(e,s)}return this.iteratorPool.release(s),e}rebuildBottomUp(){const t=[];let e,s=0;const i=this.iteratorPool.allocate().preorder(this.m_root);for(;e=i.next();)e.height<0||(e.isLeaf()?(e.parent=null,t[s]=e,++s):this.freeNode(e));for(this.iteratorPool.release(i);s>1;){let e=1/0,i=-1,n=-1;for(let r=0;r<s;++r){const m=t[r].aabb;for(let h=r+1;h<s;++h){const s=t[h].aabb,a=o.combinedPerimeter(m,s);a<e&&(i=r,n=h,e=a)}}const r=t[i],m=t[n],h=this.allocateNode();h.child1=r,h.child2=m,h.height=1+Math.max(r.height,m.height),h.aabb.combine(r.aabb,m.aabb),h.parent=null,r.parent=h,m.parent=h,t[n]=t[s-1],t[i]=h,--s}this.m_root=t[0]}shiftOrigin(t){let e;const s=this.iteratorPool.allocate().preorder(this.m_root);for(;e=s.next();){const s=e.aabb;s.lowerBound.x-=t.x,s.lowerBound.y-=t.y,s.upperBound.x-=t.x,s.upperBound.y-=t.y}this.iteratorPool.release(s)}query(t,e){const s=this.stackPool.allocate();for(s.push(this.m_root);s.length>0;){const i=s.pop();if(null!=i&&o.testOverlap(i.aabb,t))if(i.isLeaf()){if(!1===e(i.id))return}else s.push(i.child1),s.push(i.child2)}this.stackPool.release(s)}rayCast(t,e){const s=t.p1,n=t.p2,r=i.sub(n,s);r.normalize();const m=i.crossNumVec2(1,r),h=i.abs(m);let a=t.maxFraction;const c=new o;let l=i.combine(1-a,s,a,n);c.combinePoints(s,l);const _=this.stackPool.allocate(),u=this.inputPool.allocate();for(_.push(this.m_root);_.length>0;){const r=_.pop();if(null==r)continue;if(!1===o.testOverlap(r.aabb,c))continue;const d=r.aabb.getCenter(),y=r.aabb.getExtents();if(!(Math.abs(i.dot(m,i.sub(s,d)))-i.dot(h,y)>0))if(r.isLeaf()){u.p1=i.clone(t.p1),u.p2=i.clone(t.p2),u.maxFraction=a;const o=e(u,r.id);if(0===o)return;o>0&&(a=o,l=i.combine(1-a,s,a,n),c.combinePoints(s,l))}else _.push(r.child1),_.push(r.child2)}this.stackPool.release(_),this.inputPool.release(u)}}class l{constructor(){this.parents=[],this.states=[]}preorder(t){return this.parents.length=0,this.parents.push(t),this.states.length=0,this.states.push(0),this}next(){for(;this.parents.length>0;){const t=this.parents.length-1,e=this.parents[t];if(0===this.states[t])return this.states[t]=1,e;if(1===this.states[t]&&(this.states[t]=2,e.child1))return this.parents.push(e.child1),this.states.push(1),e.child1;if(2===this.states[t]&&(this.states[t]=3,e.child2))return this.parents.push(e.child2),this.states.push(1),e.child2;this.parents.pop(),this.states.pop()}}close(){this.parents.length=0}}class _{constructor(){this.m_tree=new c,this.m_moveBuffer=[],this.query=(t,e)=>{this.m_tree.query(t,e)},this.queryCallback=t=>{if(t===this.m_queryProxyId)return!0;const e=Math.min(t,this.m_queryProxyId),s=Math.max(t,this.m_queryProxyId),i=this.m_tree.getUserData(e),o=this.m_tree.getUserData(s);return this.m_callback(i,o),!0}}getUserData(t){return this.m_tree.getUserData(t)}testOverlap(t,e){const s=this.m_tree.getFatAABB(t),i=this.m_tree.getFatAABB(e);return o.testOverlap(s,i)}getFatAABB(t){return this.m_tree.getFatAABB(t)}getProxyCount(){return this.m_moveBuffer.length}getTreeHeight(){return this.m_tree.getHeight()}getTreeBalance(){return this.m_tree.getMaxBalance()}getTreeQuality(){return this.m_tree.getAreaRatio()}rayCast(t,e){this.m_tree.rayCast(t,e)}shiftOrigin(t){this.m_tree.shiftOrigin(t)}createProxy(t,e){const s=this.m_tree.createProxy(t,e);return this.bufferMove(s),s}destroyProxy(t){this.unbufferMove(t),this.m_tree.destroyProxy(t)}moveProxy(t,e,s){this.m_tree.moveProxy(t,e,s)&&this.bufferMove(t)}touchProxy(t){this.bufferMove(t)}bufferMove(t){this.m_moveBuffer.push(t)}unbufferMove(t){for(let e=0;e<this.m_moveBuffer.length;++e)this.m_moveBuffer[e]===t&&(this.m_moveBuffer[e]=null)}updatePairs(t){for(this.m_callback=t;this.m_moveBuffer.length>0;){if(this.m_queryProxyId=this.m_moveBuffer.pop(),null===this.m_queryProxyId)continue;const t=this.m_tree.getFatAABB(this.m_queryProxyId);this.m_tree.query(t,this.queryCallback)}}}function u(t,e){return{x:t,y:e}}function d(t,e,s){return t.x=e,t.y=s,t}function y(t,e){return t.x=e.x,t.y=e.y,t}function p(t){return t.x=0,t.y=0,t}function x(t){return t.x=-t.x,t.y=-t.y,t}function A(t,e){return t.x+=e.x,t.y+=e.y,t}function g(t,e){return t.x-=e.x,t.y-=e.y,t}function v(t,e,s){return t.x=e.x-s.x,t.y=e.y-s.y,t}function b(t,e){return t.x*=e,t.y*=e,t}function f(t,e,s){return t.x=e*s.x,t.y=e*s.y,t}function B(t,e,s){return t.x+=e*s.x,t.y+=e*s.y,t}function w(t,e,s){return t.x-=e*s.x,t.y-=e*s.y,t}function V(t,e,s,i,o){return t.x=e*s.x+i*o.x,t.y=e*s.y+i*o.y,t}function C(t){const e=Math.sqrt(t.x*t.x+t.y*t.y);if(e>0){const s=1/e;t.x*=s,t.y*=s}return t}function M(t,e,s){const i=s*e.y,o=-s*e.x;return t.x=i,t.y=o,t}function I(t,e,s){const i=-e*s.y,o=e*s.x;return t.x=i,t.y=o,t}function S(t,e){return t.x*e.y-t.y*e.x}function P(t,e){return t.x*e.x+t.y*e.y}function z(t){return t.x*t.x+t.y*t.y}function T(t,e){const s=t.x-e.x,i=t.y-e.y;return Math.sqrt(s*s+i*i)}function F(t,e){const s=t.x-e.x,i=t.y-e.y;return s*s+i*i}function L(t,e,s){return t.x=e.c*s.x-e.s*s.y,t.y=e.s*s.x+e.c*s.y,t}function q(t,e,s){const i=e.c*s.x+e.s*s.y,o=-e.s*s.x+e.c*s.y;return t.x=i,t.y=o,t}function k(t,e,s){return{p:u(t,e),q:(i=s,{s:Math.sin(i),c:Math.cos(i)})};var i}function N(t,e){return t.p.x=e.p.x,t.p.y=e.p.y,t.q.s=e.q.s,t.q.c=e.q.c,t}function D(t,e,s){const i=e.q.c*s.x-e.q.s*s.y+e.p.x,o=e.q.s*s.x+e.q.c*s.y+e.p.y;return t.x=i,t.y=o,t}function O(t,e,s){const i=s.x-e.p.x,o=s.y-e.p.y,n=e.q.c*i+e.q.s*o,r=-e.q.s*i+e.q.c*o;return t.x=n,t.y=r,t}function j(t,e,s,i){const o=e.q.c*i.x-e.q.s*i.y+e.p.x,n=e.q.s*i.x+e.q.c*i.y+e.p.y,r=o-s.p.x,m=n-s.p.y,h=s.q.c*r+s.q.s*m,a=-s.q.s*r+s.q.c*m;return t.x=h,t.y=a,t}function R(t,e,s){const i=e.q.c*s.q.c+e.q.s*s.q.s,o=e.q.c*s.q.s-e.q.s*s.q.c,n=e.q.c*(s.p.x-e.p.x)+e.q.s*(s.p.y-e.p.y),r=-e.q.s*(s.p.x-e.p.x)+e.q.c*(s.p.y-e.p.y);return t.q.c=i,t.q.s=o,t.p.x=n,t.p.y=r,t}class E{constructor(t){"number"==typeof t?this.setAngle(t):"object"==typeof t?this.setRot(t):this.setIdentity()}static neo(t){const e=Object.create(E.prototype);return e.setAngle(t),e}static clone(t){const e=Object.create(E.prototype);return e.s=t.s,e.c=t.c,e}static identity(){const t=Object.create(E.prototype);return t.s=0,t.c=1,t}static isValid(t){return null!=t&&(s.isFinite(t.s)&&s.isFinite(t.c))}static assert(t){}setIdentity(){this.s=0,this.c=1}set(t){"object"==typeof t?(this.s=t.s,this.c=t.c):(this.s=s.sin(t),this.c=s.cos(t))}setRot(t){this.s=t.s,this.c=t.c}setAngle(t){this.s=s.sin(t),this.c=s.cos(t)}getAngle(){return s.atan2(this.s,this.c)}getXAxis(){return i.neo(this.c,this.s)}getYAxis(){return i.neo(-this.s,this.c)}static mul(t,e){if("c"in e&&"s"in e){const s=E.identity();return s.s=t.s*e.c+t.c*e.s,s.c=t.c*e.c-t.s*e.s,s}if("x"in e&&"y"in e)return i.neo(t.c*e.x-t.s*e.y,t.s*e.x+t.c*e.y)}static mulRot(t,e){const s=E.identity();return s.s=t.s*e.c+t.c*e.s,s.c=t.c*e.c-t.s*e.s,s}static mulVec2(t,e){return i.neo(t.c*e.x-t.s*e.y,t.s*e.x+t.c*e.y)}static mulSub(t,e,s){const o=t.c*(e.x-s.x)-t.s*(e.y-s.y),n=t.s*(e.x-s.x)+t.c*(e.y-s.y);return i.neo(o,n)}static mulT(t,e){if("c"in e&&"s"in e){const s=E.identity();return s.s=t.c*e.s-t.s*e.c,s.c=t.c*e.c+t.s*e.s,s}if("x"in e&&"y"in e)return i.neo(t.c*e.x+t.s*e.y,-t.s*e.x+t.c*e.y)}static mulTRot(t,e){const s=E.identity();return s.s=t.c*e.s-t.s*e.c,s.c=t.c*e.c+t.s*e.s,s}static mulTVec2(t,e){return i.neo(t.c*e.x+t.s*e.y,-t.s*e.x+t.c*e.y)}}const J=u(0,0);class Y{constructor(){this.localCenter=i.zero(),this.c=i.zero(),this.a=0,this.alpha0=0,this.c0=i.zero(),this.a0=0}recycle(){p(this.localCenter),p(this.c),this.a=0,this.alpha0=0,p(this.c0),this.a0=0}setTransform(t){D(J,t,this.localCenter),y(this.c,J),y(this.c0,J),this.a=this.a0=s.atan2(t.q.s,t.q.c)}setLocalCenter(t,e){y(this.localCenter,t),D(J,e,this.localCenter),y(this.c,J),y(this.c0,J)}getTransform(t,e=0){!function(t,e){t.c=Math.cos(e),t.s=Math.sin(e)}(t.q,(1-e)*this.a0+e*this.a),V(t.p,1-e,this.c0,e,this.c),g(t.p,L(J,t.q,this.localCenter))}advance(t){const e=(t-this.alpha0)/(1-this.alpha0);V(this.c0,e,this.c,1-e,this.c0),this.a0=e*this.a+(1-e)*this.a0,this.alpha0=t}forward(){this.a0=this.a,y(this.c0,this.c)}normalize(){const t=s.mod(this.a0,-s.PI,+s.PI);this.a-=this.a0-t,this.a0=t}set(t){y(this.localCenter,t.localCenter),y(this.c,t.c),this.a=t.a,this.alpha0=t.alpha0,y(this.c0,t.c0),this.a0=t.a0}}class W{constructor(t,e){this.p=i.zero(),this.q=E.identity(),void 0!==t&&this.p.setVec2(t),void 0!==e&&this.q.setAngle(e)}static clone(t){const e=Object.create(W.prototype);return e.p=i.clone(t.p),e.q=E.clone(t.q),e}static neo(t,e){const s=Object.create(W.prototype);return s.p=i.clone(t),s.q=E.clone(e),s}static identity(){const t=Object.create(W.prototype);return t.p=i.zero(),t.q=E.identity(),t}setIdentity(){this.p.setZero(),this.q.setIdentity()}set(t,e){void 0===e?(this.p.set(t.p),this.q.set(t.q)):(this.p.set(t),this.q.set(e))}setNum(t,e){this.p.setVec2(t),this.q.setAngle(e)}setTransform(t){this.p.setVec2(t.p),this.q.setRot(t.q)}static isValid(t){return null!=t&&(i.isValid(t.p)&&E.isValid(t.q))}static assert(t){}static mul(t,e){if(Array.isArray(e)){const s=[];for(let i=0;i<e.length;i++)s[i]=W.mul(t,e[i]);return s}return"x"in e&&"y"in e?W.mulVec2(t,e):"p"in e&&"q"in e?W.mulXf(t,e):void 0}static mulAll(t,e){const s=[];for(let i=0;i<e.length;i++)s[i]=W.mul(t,e[i]);return s}static mulFn(t){return function(e){return W.mul(t,e)}}static mulVec2(t,e){const s=t.q.c*e.x-t.q.s*e.y+t.p.x,o=t.q.s*e.x+t.q.c*e.y+t.p.y;return i.neo(s,o)}static mulXf(t,e){const s=W.identity();return s.q=E.mulRot(t.q,e.q),s.p=i.add(E.mulVec2(t.q,e.p),t.p),s}static mulT(t,e){return"x"in e&&"y"in e?W.mulTVec2(t,e):"p"in e&&"q"in e?W.mulTXf(t,e):void 0}static mulTVec2(t,e){const s=e.x-t.p.x,o=e.y-t.p.y,n=t.q.c*s+t.q.s*o,r=-t.q.s*s+t.q.c*o;return i.neo(n,r)}static mulTXf(t,e){const s=W.identity();return s.q.setRot(E.mulTRot(t.q,e.q)),s.p.setVec2(E.mulTVec2(t.q,i.sub(e.p,t.p))),s}}class H{constructor(){this.v=i.zero(),this.w=0}}class Z{constructor(){this.c=i.zero(),this.a=0}getTransform(t,e){return t.q.c=Math.cos(this.a),t.q.s=Math.sin(this.a),t.p.x=this.c.x-(t.q.c*e.x-t.q.s*e.y),t.p.y=this.c.y-(t.q.s*e.x+t.q.c*e.y),t}}function K(t,e,s,i){return t.q.c=Math.cos(i),t.q.s=Math.sin(i),t.p.x=s.x-(t.q.c*e.x-t.q.s*e.y),t.p.y=s.y-(t.q.s*e.x+t.q.c*e.y),t}class U{static isValid(t){return null!=t&&("string"==typeof t.m_type&&"number"==typeof t.m_radius)}}const X=new o,G=new o,Q=u(0,0),$={userData:null,friction:.2,restitution:0,density:0,isSensor:!1,filterGroupIndex:0,filterCategoryBits:1,filterMaskBits:65535};class tt{constructor(t,e){this.aabb=new o,this.fixture=t,this.childIndex=e,this.proxyId}}class et{constructor(t,s,i){s.shape?(i=s,s=s.shape):"number"==typeof i&&(i={density:i}),i=e(i,$),this.m_body=t,this.m_friction=i.friction,this.m_restitution=i.restitution,this.m_density=i.density,this.m_isSensor=i.isSensor,this.m_filterGroupIndex=i.filterGroupIndex,this.m_filterCategoryBits=i.filterCategoryBits,this.m_filterMaskBits=i.filterMaskBits,this.m_shape=s,this.m_next=null,this.m_proxies=[];const o=this.m_shape.getChildCount();for(let t=0;t<o;++t)this.m_proxies[t]=new tt(this,t);this.m_userData=i.userData}_reset(){const t=this.getBody(),e=t.m_world.m_broadPhase;this.destroyProxies(e),this.m_shape._reset&&this.m_shape._reset();const s=this.m_shape.getChildCount();for(let t=0;t<s;++t)this.m_proxies[t]=new tt(this,t);this.createProxies(e,t.m_xf),t.resetMassData()}_serialize(){return{friction:this.m_friction,restitution:this.m_restitution,density:this.m_density,isSensor:this.m_isSensor,filterGroupIndex:this.m_filterGroupIndex,filterCategoryBits:this.m_filterCategoryBits,filterMaskBits:this.m_filterMaskBits,shape:this.m_shape}}static _deserialize(t,e,s){const i=s(U,t.shape);return i&&new et(e,i,t)}getType(){return this.m_shape.m_type}getShape(){return this.m_shape}isSensor(){return this.m_isSensor}setSensor(t){t!=this.m_isSensor&&(this.m_body.setAwake(!0),this.m_isSensor=t)}getUserData(){return this.m_userData}setUserData(t){this.m_userData=t}getBody(){return this.m_body}getNext(){return this.m_next}getDensity(){return this.m_density}setDensity(t){this.m_density=t}getFriction(){return this.m_friction}setFriction(t){this.m_friction=t}getRestitution(){return this.m_restitution}setRestitution(t){this.m_restitution=t}testPoint(t){return this.m_shape.testPoint(this.m_body.getTransform(),t)}rayCast(t,e,s){return this.m_shape.rayCast(t,e,this.m_body.getTransform(),s)}getMassData(t){this.m_shape.computeMass(t,this.m_density)}getAABB(t){return this.m_proxies[t].aabb}createProxies(t,e){const s=this.m_shape.getChildCount();for(let i=0;i<s;++i){const s=this.m_proxies[i];this.m_shape.computeAABB(s.aabb,e,i),s.proxyId=t.createProxy(s.aabb,s)}}destroyProxies(t){for(let e=0;e<this.m_proxies.length;++e){const s=this.m_proxies[e];t.destroyProxy(s.proxyId),s.proxyId=null,s.fixture=null}this.m_proxies.length=0}synchronize(t,e,s){for(let i=0;i<this.m_proxies.length;++i){const o=this.m_proxies[i];this.m_shape.computeAABB(X,e,o.childIndex),this.m_shape.computeAABB(G,s,o.childIndex),o.aabb.combine(X,G),v(Q,s.p,e.p),t.moveProxy(o.proxyId,o.aabb,Q)}}setFilterData(t){this.m_filterGroupIndex=t.groupIndex,this.m_filterCategoryBits=t.categoryBits,this.m_filterMaskBits=t.maskBits,this.refilter()}getFilterGroupIndex(){return this.m_filterGroupIndex}setFilterGroupIndex(t){this.m_filterGroupIndex=t}getFilterCategoryBits(){return this.m_filterCategoryBits}setFilterCategoryBits(t){this.m_filterCategoryBits=t}getFilterMaskBits(){return this.m_filterMaskBits}setFilterMaskBits(t){this.m_filterMaskBits=t}refilter(){if(null==this.m_body)return;let t=this.m_body.getContactList();for(;t;){const e=t.contact,s=e.getFixtureA(),i=e.getFixtureB();s!=this&&i!=this||e.flagForFiltering(),t=t.next}const e=this.m_body.getWorld();if(null==e)return;const s=e.m_broadPhase;for(let t=0;t<this.m_proxies.length;++t)s.touchProxy(this.m_proxies[t].proxyId)}shouldCollide(t){if(t.m_filterGroupIndex===this.m_filterGroupIndex&&0!==t.m_filterGroupIndex)return t.m_filterGroupIndex>0;const e=0!=(t.m_filterMaskBits&this.m_filterCategoryBits),s=0!=(t.m_filterCategoryBits&this.m_filterMaskBits);return e&&s}}const st="static",it="kinematic",ot="dynamic",nt=u(0,0),rt=u(0,0),mt=u(0,0),ht=k(0,0,0),at={type:st,position:i.zero(),angle:0,linearVelocity:i.zero(),angularVelocity:0,linearDamping:0,angularDamping:0,fixedRotation:!1,bullet:!1,gravityScale:1,allowSleep:!0,awake:!0,active:!0,userData:null};class ct{constructor(){this.mass=0,this.center=i.zero(),this.I=0}}class lt{constructor(t,s){s=e(s,at),this.m_world=t,this.m_awakeFlag=s.awake,this.m_autoSleepFlag=s.allowSleep,this.m_bulletFlag=s.bullet,this.m_fixedRotationFlag=s.fixedRotation,this.m_activeFlag=s.active,this.m_islandFlag=!1,this.m_toiFlag=!1,this.m_userData=s.userData,this.m_type=s.type,this.m_type==ot?(this.m_mass=1,this.m_invMass=1):(this.m_mass=0,this.m_invMass=0),this.m_I=0,this.m_invI=0,this.m_xf=W.identity(),this.m_xf.p.setVec2(s.position),this.m_xf.q.setAngle(s.angle),this.m_sweep=new Y,this.m_sweep.setTransform(this.m_xf),this.c_velocity=new H,this.c_position=new Z,this.m_force=i.zero(),this.m_torque=0,this.m_linearVelocity=i.clone(s.linearVelocity),this.m_angularVelocity=s.angularVelocity,this.m_linearDamping=s.linearDamping,this.m_angularDamping=s.angularDamping,this.m_gravityScale=s.gravityScale,this.m_sleepTime=0,this.m_jointList=null,this.m_contactList=null,this.m_fixtureList=null,this.m_prev=null,this.m_next=null,this.m_destroyed=!1}_serialize(){const t=[];for(let e=this.m_fixtureList;e;e=e.m_next)t.push(e);return{type:this.m_type,bullet:this.m_bulletFlag,position:this.m_xf.p,angle:this.m_xf.q.getAngle(),linearVelocity:this.m_linearVelocity,angularVelocity:this.m_angularVelocity,fixtures:t}}static _deserialize(t,e,s){const i=new lt(e,t);if(t.fixtures)for(let e=t.fixtures.length-1;e>=0;e--){const o=s(et,t.fixtures[e],i);i._addFixture(o)}return i}isWorldLocked(){return!(!this.m_world||!this.m_world.isLocked())}getWorld(){return this.m_world}getNext(){return this.m_next}setUserData(t){this.m_userData=t}getUserData(){return this.m_userData}getFixtureList(){return this.m_fixtureList}getJointList(){return this.m_jointList}getContactList(){return this.m_contactList}isStatic(){return this.m_type==st}isDynamic(){return this.m_type==ot}isKinematic(){return this.m_type==it}setStatic(){return this.setType(st),this}setDynamic(){return this.setType(ot),this}setKinematic(){return this.setType(it),this}getType(){return this.m_type}setType(t){if(1==this.isWorldLocked())return;if(this.m_type==t)return;this.m_type=t,this.resetMassData(),this.m_type==st&&(this.m_linearVelocity.setZero(),this.m_angularVelocity=0,this.m_sweep.forward(),this.synchronizeFixtures()),this.setAwake(!0),this.m_force.setZero(),this.m_torque=0;let e=this.m_contactList;for(;e;){const t=e;e=e.next,this.m_world.destroyContact(t.contact)}this.m_contactList=null;const s=this.m_world.m_broadPhase;for(let t=this.m_fixtureList;t;t=t.m_next)for(let e=0;e<t.m_proxies.length;++e)s.touchProxy(t.m_proxies[e].proxyId)}isBullet(){return this.m_bulletFlag}setBullet(t){this.m_bulletFlag=!!t}isSleepingAllowed(){return this.m_autoSleepFlag}setSleepingAllowed(t){this.m_autoSleepFlag=!!t,0==this.m_autoSleepFlag&&this.setAwake(!0)}isAwake(){return this.m_awakeFlag}setAwake(t){t?(this.m_awakeFlag=!0,this.m_sleepTime=0):(this.m_awakeFlag=!1,this.m_sleepTime=0,this.m_linearVelocity.setZero(),this.m_angularVelocity=0,this.m_force.setZero(),this.m_torque=0)}isActive(){return this.m_activeFlag}setActive(t){if(t!=this.m_activeFlag)if(this.m_activeFlag=!!t,this.m_activeFlag){const t=this.m_world.m_broadPhase;for(let e=this.m_fixtureList;e;e=e.m_next)e.createProxies(t,this.m_xf)}else{const t=this.m_world.m_broadPhase;for(let e=this.m_fixtureList;e;e=e.m_next)e.destroyProxies(t);let e=this.m_contactList;for(;e;){const t=e;e=e.next,this.m_world.destroyContact(t.contact)}this.m_contactList=null}}isFixedRotation(){return this.m_fixedRotationFlag}setFixedRotation(t){this.m_fixedRotationFlag!=t&&(this.m_fixedRotationFlag=!!t,this.m_angularVelocity=0,this.resetMassData())}getTransform(){return this.m_xf}setTransform(t,e){if(1==this.isWorldLocked())return;this.m_xf.setNum(t,e),this.m_sweep.setTransform(this.m_xf);const s=this.m_world.m_broadPhase;for(let t=this.m_fixtureList;t;t=t.m_next)t.synchronize(s,this.m_xf,this.m_xf)}synchronizeTransform(){this.m_sweep.getTransform(this.m_xf,1)}synchronizeFixtures(){this.m_sweep.getTransform(ht,0);const t=this.m_world.m_broadPhase;for(let e=this.m_fixtureList;e;e=e.m_next)e.synchronize(t,ht,this.m_xf)}advance(t){this.m_sweep.advance(t),y(this.m_sweep.c,this.m_sweep.c0),this.m_sweep.a=this.m_sweep.a0,this.m_sweep.getTransform(this.m_xf,1)}getPosition(){return this.m_xf.p}setPosition(t){this.setTransform(t,this.m_sweep.a)}getAngle(){return this.m_sweep.a}setAngle(t){this.setTransform(this.m_xf.p,t)}getWorldCenter(){return this.m_sweep.c}getLocalCenter(){return this.m_sweep.localCenter}getLinearVelocity(){return this.m_linearVelocity}getLinearVelocityFromWorldPoint(t){const e=i.sub(t,this.m_sweep.c);return i.add(this.m_linearVelocity,i.crossNumVec2(this.m_angularVelocity,e))}getLinearVelocityFromLocalPoint(t){return this.getLinearVelocityFromWorldPoint(this.getWorldPoint(t))}setLinearVelocity(t){this.m_type!=st&&(i.dot(t,t)>0&&this.setAwake(!0),this.m_linearVelocity.setVec2(t))}getAngularVelocity(){return this.m_angularVelocity}setAngularVelocity(t){this.m_type!=st&&(t*t>0&&this.setAwake(!0),this.m_angularVelocity=t)}getLinearDamping(){return this.m_linearDamping}setLinearDamping(t){this.m_linearDamping=t}getAngularDamping(){return this.m_angularDamping}setAngularDamping(t){this.m_angularDamping=t}getGravityScale(){return this.m_gravityScale}setGravityScale(t){this.m_gravityScale=t}getMass(){return this.m_mass}getInertia(){return this.m_I+this.m_mass*i.dot(this.m_sweep.localCenter,this.m_sweep.localCenter)}getMassData(t){t.mass=this.m_mass,t.I=this.getInertia(),t.center.setVec2(this.m_sweep.localCenter)}resetMassData(){if(this.m_mass=0,this.m_invMass=0,this.m_I=0,this.m_invI=0,p(this.m_sweep.localCenter),this.isStatic()||this.isKinematic())return y(this.m_sweep.c0,this.m_xf.p),y(this.m_sweep.c,this.m_xf.p),void(this.m_sweep.a0=this.m_sweep.a);p(rt);for(let t=this.m_fixtureList;t;t=t.m_next){if(0==t.m_density)continue;const e=new ct;t.getMassData(e),this.m_mass+=e.mass,B(rt,e.mass,e.center),this.m_I+=e.I}this.m_mass>0?(this.m_invMass=1/this.m_mass,f(rt,this.m_invMass,rt)):(this.m_mass=1,this.m_invMass=1),this.m_I>0&&0==this.m_fixedRotationFlag?(this.m_I-=this.m_mass*P(rt,rt),this.m_invI=1/this.m_I):(this.m_I=0,this.m_invI=0),y(nt,this.m_sweep.c),this.m_sweep.setLocalCenter(rt,this.m_xf),v(mt,this.m_sweep.c,nt),I(this.m_linearVelocity,this.m_angularVelocity,mt)}setMassData(t){1!=this.isWorldLocked()&&this.m_type==ot&&(this.m_invMass=0,this.m_I=0,this.m_invI=0,this.m_mass=t.mass,this.m_mass<=0&&(this.m_mass=1),this.m_invMass=1/this.m_mass,t.I>0&&0==this.m_fixedRotationFlag&&(this.m_I=t.I-this.m_mass*P(t.center,t.center),this.m_invI=1/this.m_I),y(nt,this.m_sweep.c),this.m_sweep.setLocalCenter(t.center,this.m_xf),v(mt,this.m_sweep.c,nt),I(this.m_linearVelocity,this.m_angularVelocity,mt))}applyForce(t,e,s=!0){this.m_type==ot&&(s&&0==this.m_awakeFlag&&this.setAwake(!0),this.m_awakeFlag&&(this.m_force.add(t),this.m_torque+=i.crossVec2Vec2(i.sub(e,this.m_sweep.c),t)))}applyForceToCenter(t,e=!0){this.m_type==ot&&(e&&0==this.m_awakeFlag&&this.setAwake(!0),this.m_awakeFlag&&this.m_force.add(t))}applyTorque(t,e=!0){this.m_type==ot&&(e&&0==this.m_awakeFlag&&this.setAwake(!0),this.m_awakeFlag&&(this.m_torque+=t))}applyLinearImpulse(t,e,s=!0){this.m_type==ot&&(s&&0==this.m_awakeFlag&&this.setAwake(!0),this.m_awakeFlag&&(this.m_linearVelocity.addMul(this.m_invMass,t),this.m_angularVelocity+=this.m_invI*i.crossVec2Vec2(i.sub(e,this.m_sweep.c),t)))}applyAngularImpulse(t,e=!0){this.m_type==ot&&(e&&0==this.m_awakeFlag&&this.setAwake(!0),this.m_awakeFlag&&(this.m_angularVelocity+=this.m_invI*t))}shouldCollide(t){if(this.m_type!=ot&&t.m_type!=ot)return!1;for(let e=this.m_jointList;e;e=e.next)if(e.other==t&&0==e.joint.m_collideConnected)return!1;return!0}_addFixture(t){if(1==this.isWorldLocked())return null;if(this.m_activeFlag){const e=this.m_world.m_broadPhase;t.createProxies(e,this.m_xf)}return t.m_next=this.m_fixtureList,this.m_fixtureList=t,t.m_density>0&&this.resetMassData(),this.m_world.m_newFixture=!0,t}createFixture(t,e){if(1==this.isWorldLocked())return null;const s=new et(this,t,e);return this._addFixture(s),s}destroyFixture(t){if(1==this.isWorldLocked())return;if(this.m_fixtureList===t)this.m_fixtureList=t.m_next;else{let e=this.m_fixtureList;for(;null!=e;){if(e.m_next===t){e.m_next=t.m_next;break}e=e.m_next}}let e=this.m_contactList;for(;e;){const s=e.contact;e=e.next;const i=s.getFixtureA(),o=s.getFixtureB();t!=i&&t!=o||this.m_world.destroyContact(s)}if(this.m_activeFlag){const e=this.m_world.m_broadPhase;t.destroyProxies(e)}t.m_body=null,t.m_next=null,this.m_world.publish("remove-fixture",t),this.resetMassData()}getWorldPoint(t){return W.mulVec2(this.m_xf,t)}getWorldVector(t){return E.mulVec2(this.m_xf.q,t)}getLocalPoint(t){return W.mulTVec2(this.m_xf,t)}getLocalVector(t){return E.mulTVec2(this.m_xf.q,t)}}lt.STATIC="static",lt.KINEMATIC="kinematic",lt.DYNAMIC="dynamic";class _t{constructor(){this.other=null,this.joint=null,this.prev=null,this.next=null}}class ut{constructor(t,e,s){this.m_type="unknown-joint",this.m_prev=null,this.m_next=null,this.m_edgeA=new _t,this.m_edgeB=new _t,this.m_islandFlag=!1,e="bodyA"in t?t.bodyA:e,s="bodyB"in t?t.bodyB:s,this.m_bodyA=e,this.m_bodyB=s,this.m_collideConnected=!!t.collideConnected,this.m_userData=t.userData}isActive(){return this.m_bodyA.isActive()&&this.m_bodyB.isActive()}getType(){return this.m_type}getBodyA(){return this.m_bodyA}getBodyB(){return this.m_bodyB}getNext(){return this.m_next}getUserData(){return this.m_userData}setUserData(t){this.m_userData=t}getCollideConnected(){return this.m_collideConnected}shiftOrigin(t){}}const dt={gjkCalls:0,gjkIters:0,gjkMaxIters:0,toiTime:0,toiMaxTime:0,toiCalls:0,toiIters:0,toiMaxIters:0,toiRootIters:0,toiMaxRootIters:0,toString(t){t="string"==typeof t?t:"\n";let e="";for(const s in this)"function"!=typeof this[s]&&"object"!=typeof this[s]&&(e+=s+": "+this[s]+t);return e}};var yt=function(){return Date.now()},pt=function(t){return Date.now()-t};const xt=u(0,0),At=u(0,0),gt=u(0,0),vt=u(0,0),bt=u(0,0),ft=u(0,0),Bt=u(0,0);dt.gjkCalls=0,dt.gjkIters=0,dt.gjkMaxIters=0;class wt{constructor(){this.proxyA=new It,this.proxyB=new It,this.transformA=W.identity(),this.transformB=W.identity(),this.useRadii=!1}recycle(){this.proxyA.recycle(),this.proxyB.recycle(),this.transformA.setIdentity(),this.transformB.setIdentity(),this.useRadii=!1}}class Vt{constructor(){this.pointA=u(0,0),this.pointB=u(0,0),this.distance=0,this.iterations=0}recycle(){p(this.pointA),p(this.pointB),this.distance=0,this.iterations=0}}class Ct{constructor(){this.metric=0,this.indexA=[],this.indexB=[],this.count=0}recycle(){this.metric=0,this.indexA.length=0,this.indexB.length=0,this.count=0}}const Mt=function(t,e,i){++dt.gjkCalls;const o=i.proxyA,n=i.proxyB,m=i.transformA,h=i.transformB;Ft.recycle(),Ft.readCache(e,o,m,n,h);const a=Ft.m_v,c=r.maxDistnceIterations,l=[],_=[];let u=0,d=0;for(;d<c;){u=Ft.m_count;for(let t=0;t<u;++t)l[t]=a[t].indexA,_[t]=a[t].indexB;if(Ft.solve(),3===Ft.m_count)break;const t=Ft.getSearchDirection();if(z(t)<s.EPSILON*s.EPSILON)break;const e=a[Ft.m_count];e.indexA=o.getSupport(q(xt,m.q,f(xt,-1,t))),D(e.wA,m,o.getVertex(e.indexA)),e.indexB=n.getSupport(q(xt,h.q,t)),D(e.wB,h,n.getVertex(e.indexB)),v(e.w,e.wB,e.wA),++d,++dt.gjkIters;let i=!1;for(let t=0;t<u;++t)if(e.indexA===l[t]&&e.indexB===_[t]){i=!0;break}if(i)break;++Ft.m_count}if(dt.gjkMaxIters=s.max(dt.gjkMaxIters,d),Ft.getWitnessPoints(t.pointA,t.pointB),t.distance=T(t.pointA,t.pointB),t.iterations=d,Ft.writeCache(e),i.useRadii){const e=o.m_radius,i=n.m_radius;if(t.distance>e+i&&t.distance>s.EPSILON)t.distance-=e+i,v(At,t.pointB,t.pointA),C(At),B(t.pointA,e,At),w(t.pointB,i,At);else{const e=v(xt,t.pointA,t.pointB);y(t.pointA,e),y(t.pointB,e),t.distance=0}}};class It{constructor(){this.m_vertices=[],this.m_count=0,this.m_radius=0}recycle(){this.m_vertices.length=0,this.m_count=0,this.m_radius=0}getVertexCount(){return this.m_count}getVertex(t){return this.m_vertices[t]}getSupport(t){let e=-1,s=-1/0;for(let i=0;i<this.m_count;++i){const o=P(this.m_vertices[i],t);o>s&&(e=i,s=o)}return e}getSupportVertex(t){return this.m_vertices[this.getSupport(t)]}set(t,e){t.computeDistanceProxy(this,e)}setVertices(t,e,s){this.m_vertices=t,this.m_count=e,this.m_radius=s}}class St{constructor(){this.wA=u(0,0),this.indexA=0,this.wB=u(0,0),this.indexB=0,this.w=u(0,0),this.a=0}recycle(){this.indexA=0,this.indexB=0,p(this.wA),p(this.wB),p(this.w),this.a=0}set(t){this.indexA=t.indexA,this.indexB=t.indexB,y(this.wA,t.wA),y(this.wB,t.wB),y(this.w,t.w),this.a=t.a}}const Pt=u(0,0),zt=u(0,0);class Tt{constructor(){this.m_v1=new St,this.m_v2=new St,this.m_v3=new St,this.m_v=[this.m_v1,this.m_v2,this.m_v3]}recycle(){this.m_v1.recycle(),this.m_v2.recycle(),this.m_v3.recycle(),this.m_count=0}toString(){return 3===this.m_count?["+"+this.m_count,this.m_v1.a,this.m_v1.wA.x,this.m_v1.wA.y,this.m_v1.wB.x,this.m_v1.wB.y,this.m_v2.a,this.m_v2.wA.x,this.m_v2.wA.y,this.m_v2.wB.x,this.m_v2.wB.y,this.m_v3.a,this.m_v3.wA.x,this.m_v3.wA.y,this.m_v3.wB.x,this.m_v3.wB.y].toString():2===this.m_count?["+"+this.m_count,this.m_v1.a,this.m_v1.wA.x,this.m_v1.wA.y,this.m_v1.wB.x,this.m_v1.wB.y,this.m_v2.a,this.m_v2.wA.x,this.m_v2.wA.y,this.m_v2.wB.x,this.m_v2.wB.y].toString():1===this.m_count?["+"+this.m_count,this.m_v1.a,this.m_v1.wA.x,this.m_v1.wA.y,this.m_v1.wB.x,this.m_v1.wB.y].toString():"+"+this.m_count}readCache(t,e,i,o,n){this.m_count=t.count;for(let s=0;s<this.m_count;++s){const r=this.m_v[s];r.indexA=t.indexA[s],r.indexB=t.indexB[s];const m=e.getVertex(r.indexA),h=o.getVertex(r.indexB);D(r.wA,i,m),D(r.wB,n,h),v(r.w,r.wB,r.wA),r.a=0}if(this.m_count>1){const e=t.metric,i=this.getMetric();(i<.5*e||2*e<i||i<s.EPSILON)&&(this.m_count=0)}if(0===this.m_count){const t=this.m_v[0];t.indexA=0,t.indexB=0;const s=e.getVertex(0),r=o.getVertex(0);D(t.wA,i,s),D(t.wB,n,r),v(t.w,t.wB,t.wA),t.a=1,this.m_count=1}}writeCache(t){t.metric=this.getMetric(),t.count=this.m_count;for(let e=0;e<this.m_count;++e)t.indexA[e]=this.m_v[e].indexA,t.indexB[e]=this.m_v[e].indexB}getSearchDirection(){const t=this.m_v1,e=this.m_v2;switch(this.m_v3,this.m_count){case 1:return d(Pt,-t.w.x,-t.w.y);case 2:v(gt,e.w,t.w);return-S(gt,t.w)>0?d(Pt,-gt.y,gt.x):d(Pt,gt.y,-gt.x);default:return p(Pt)}}getClosestPoint(){const t=this.m_v1,e=this.m_v2;switch(this.m_v3,this.m_count){case 0:return p(zt);case 1:return y(zt,t.w);case 2:return V(zt,t.a,t.w,e.a,e.w);case 3:default:return p(zt)}}getWitnessPoints(t,e){const s=this.m_v1,i=this.m_v2,o=this.m_v3;switch(this.m_count){case 0:break;case 1:y(t,s.wA),y(e,s.wB);break;case 2:V(t,s.a,s.wA,i.a,i.wA),V(e,s.a,s.wB,i.a,i.wB);break;case 3:e.x=t.x=s.a*s.wA.x+i.a*i.wA.x+o.a*o.wA.x,e.y=t.y=s.a*s.wA.y+i.a*i.wA.y+o.a*o.wA.y}}getMetric(){switch(this.m_count){case 0:case 1:return 0;case 2:return T(this.m_v1.w,this.m_v2.w);case 3:return S(v(ft,this.m_v2.w,this.m_v1.w),v(Bt,this.m_v3.w,this.m_v1.w));default:return 0}}solve(){switch(this.m_count){case 1:break;case 2:this.solve2();break;case 3:this.solve3()}}solve2(){const t=this.m_v1.w,e=this.m_v2.w;v(gt,e,t);const s=-P(t,gt);if(s<=0)return this.m_v1.a=1,void(this.m_count=1);const i=P(e,gt);if(i<=0)return this.m_v2.a=1,this.m_count=1,void this.m_v1.set(this.m_v2);const o=1/(i+s);this.m_v1.a=i*o,this.m_v2.a=s*o,this.m_count=2}solve3(){const t=this.m_v1.w,e=this.m_v2.w,s=this.m_v3.w;v(gt,e,t);const i=P(t,gt),o=P(e,gt),n=-i;v(vt,s,t);const r=P(t,vt),m=P(s,vt),h=-r;v(bt,s,e);const a=P(e,bt),c=P(s,bt),l=-a,_=S(gt,vt),u=_*S(e,s),d=_*S(s,t),y=_*S(t,e);if(n<=0&&h<=0)return this.m_v1.a=1,void(this.m_count=1);if(o>0&&n>0&&y<=0){const t=1/(o+n);return this.m_v1.a=o*t,this.m_v2.a=n*t,void(this.m_count=2)}if(m>0&&h>0&&d<=0){const t=1/(m+h);return this.m_v1.a=m*t,this.m_v3.a=h*t,this.m_count=2,void this.m_v2.set(this.m_v3)}if(o<=0&&l<=0)return this.m_v2.a=1,this.m_count=1,void this.m_v1.set(this.m_v2);if(m<=0&&c<=0)return this.m_v3.a=1,this.m_count=1,void this.m_v1.set(this.m_v3);if(c>0&&l>0&&u<=0){const t=1/(c+l);return this.m_v2.a=c*t,this.m_v3.a=l*t,this.m_count=2,void this.m_v1.set(this.m_v3)}const p=1/(u+d+y);this.m_v1.a=u*p,this.m_v2.a=d*p,this.m_v3.a=y*p,this.m_count=3}}const Ft=new Tt,Lt=new wt,qt=new Ct,kt=new Vt,Nt=function(t,e,i,o,n,r){return Lt.recycle(),Lt.proxyA.set(t,e),Lt.proxyB.set(i,o),N(Lt.transformA,n),N(Lt.transformB,r),Lt.useRadii=!0,kt.recycle(),qt.recycle(),Mt(kt,qt,Lt),kt.distance<10*s.EPSILON};Mt.testOverlap=Nt,Mt.Input=wt,Mt.Output=Vt,Mt.Proxy=It,Mt.Cache=Ct;class Dt{constructor(){this.proxyA=new It,this.proxyB=new It,this.transformA=W.identity(),this.transformB=W.identity(),this.translationB=i.zero()}recycle(){this.proxyA.recycle(),this.proxyB.recycle(),this.transformA.setIdentity(),this.transformB.setIdentity(),p(this.translationB)}}class Ot{constructor(){this.point=i.zero(),this.normal=i.zero(),this.lambda=1,this.iterations=0}}const jt=function(t,e){t.iterations=0,t.lambda=1,t.normal.setZero(),t.point.setZero();const o=e.proxyA,n=e.proxyB,m=s.max(o.m_radius,r.polygonRadius),h=m+s.max(n.m_radius,r.polygonRadius),a=e.transformA,c=e.transformB,l=e.translationB,_=i.zero();let u=0;const d=new Tt;d.m_count=0;const y=d.m_v;let p=o.getSupport(E.mulTVec2(a.q,i.neg(l))),x=W.mulVec2(a,o.getVertex(p)),A=n.getSupport(E.mulTVec2(c.q,l)),g=W.mulVec2(c,n.getVertex(A));const v=i.sub(x,g),b=s.max(r.polygonRadius,h-r.polygonRadius),f=.5*r.linearSlop;let B=0;for(;B<20&&v.length()-b>f;){t.iterations+=1,p=o.getSupport(E.mulTVec2(a.q,i.neg(v))),x=W.mulVec2(a,o.getVertex(p)),A=n.getSupport(E.mulTVec2(c.q,v)),g=W.mulVec2(c,n.getVertex(A));const e=i.sub(x,g);v.normalize();const s=i.dot(v,e),r=i.dot(v,l);if(s-b>u*r){if(r<=0)return!1;if(u=(s-b)/r,u>1)return!1;_.setMul(-1,v),d.m_count=0}const m=y[d.m_count];switch(m.indexA=A,m.wA=i.combine(1,g,u,l),m.indexB=p,m.wB=x,m.w=i.sub(m.wB,m.wA),m.a=1,d.m_count+=1,d.m_count){case 1:break;case 2:d.solve2();break;case 3:d.solve3()}if(3==d.m_count)return!1;v.setVec2(d.getClosestPoint()),++B}if(0==B)return!1;const w=i.zero(),V=i.zero();return d.getWitnessPoints(V,w),v.lengthSquared()>0&&(_.setMul(-1,v),_.normalize()),t.point=i.combine(1,w,m,_),t.normal=_,t.lambda=u,t.iterations=B,!0};class Rt{constructor(){this.proxyA=new It,this.proxyB=new It,this.sweepA=new Y,this.sweepB=new Y}recycle(){this.proxyA.recycle(),this.proxyB.recycle(),this.sweepA.recycle(),this.sweepB.recycle(),this.tMax=-1}}var Et;t.TOIOutputState=void 0,(Et=t.TOIOutputState||(t.TOIOutputState={}))[Et.e_unset=-1]="e_unset",Et[Et.e_unknown=0]="e_unknown",Et[Et.e_failed=1]="e_failed",Et[Et.e_overlapped=2]="e_overlapped",Et[Et.e_touching=3]="e_touching",Et[Et.e_separated=4]="e_separated";class Jt{constructor(){this.state=t.TOIOutputState.e_unset,this.t=-1}recycle(){this.state=t.TOIOutputState.e_unset,this.t=-1}}dt.toiTime=0,dt.toiMaxTime=0,dt.toiCalls=0,dt.toiIters=0,dt.toiMaxIters=0,dt.toiRootIters=0,dt.toiMaxRootIters=0;const Yt=new wt,Wt=new Vt,Ht=new Ct,Zt=k(0,0,0),Kt=k(0,0,0),Ut=u(0,0),Xt=u(0,0),Gt=u(0,0),Qt=u(0,0),$t=u(0,0),te=u(0,0),ee=u(0,0),se=u(0,0),ie=function(e,i){const o=yt();++dt.toiCalls,e.state=t.TOIOutputState.e_unknown,e.t=i.tMax;const n=i.proxyA,m=i.proxyB,h=i.sweepA,a=i.sweepB;h.normalize(),a.normalize();const c=i.tMax,l=n.m_radius+m.m_radius,_=s.max(r.linearSlop,l-3*r.linearSlop),u=.25*r.linearSlop;let d=0;const y=r.maxTOIIterations;let p=0;for(Ht.recycle(),Yt.proxyA.setVertices(n.m_vertices,n.m_count,n.m_radius),Yt.proxyB.setVertices(m.m_vertices,m.m_count,m.m_radius),Yt.useRadii=!1;;){if(h.getTransform(Zt,d),a.getTransform(Kt,d),N(Yt.transformA,Zt),N(Yt.transformB,Kt),Mt(Wt,Ht,Yt),Wt.distance<=0){e.state=t.TOIOutputState.e_overlapped,e.t=0;break}if(Wt.distance<_+u){e.state=t.TOIOutputState.e_touching,e.t=d;break}ne.initialize(Ht,n,h,m,a,d);let i=!1,o=c,l=0;for(;;){let n=ne.findMinSeparation(o);if(n>_+u){e.state=t.TOIOutputState.e_separated,e.t=c,i=!0;break}if(n>_-u){d=o;break}let m=ne.evaluate(d);if(m<_-u){e.state=t.TOIOutputState.e_failed,e.t=d,i=!0;break}if(m<=_+u){e.state=t.TOIOutputState.e_touching,e.t=d,i=!0;break}let h=0,a=d,y=o;for(;;){let t;t=1&h?a+(_-m)*(y-a)/(n-m):.5*(a+y),++h,++dt.toiRootIters;const e=ne.evaluate(t);if(s.abs(e-_)<u){o=t;break}if(e>_?(a=t,m=e):(y=t,n=e),50===h)break}if(dt.toiMaxRootIters=s.max(dt.toiMaxRootIters,h),++l,l===r.maxPolygonVertices)break}if(++p,++dt.toiIters,i)break;if(p===y){e.state=t.TOIOutputState.e_failed,e.t=d;break}}dt.toiMaxIters=s.max(dt.toiMaxIters,p);const x=pt(o);dt.toiMaxTime=s.max(dt.toiMaxTime,x),dt.toiTime+=x,ne.recycle()};var oe;!function(t){t[t.e_unset=-1]="e_unset",t[t.e_points=1]="e_points",t[t.e_faceA=2]="e_faceA",t[t.e_faceB=3]="e_faceB"}(oe||(oe={}));const ne=new class{constructor(){this.m_proxyA=null,this.m_proxyB=null,this.m_sweepA=null,this.m_sweepB=null,this.m_type=oe.e_unset,this.m_localPoint=u(0,0),this.m_axis=u(0,0),this.indexA=-1,this.indexB=-1}recycle(){this.m_proxyA=null,this.m_proxyB=null,this.m_sweepA=null,this.m_sweepB=null,this.m_type=oe.e_unset,p(this.m_localPoint),p(this.m_axis),this.indexA=-1,this.indexB=-1}initialize(t,e,s,i,o,n){const r=t.count;if(this.m_proxyA=e,this.m_proxyB=i,this.m_sweepA=s,this.m_sweepB=o,this.m_sweepA.getTransform(Zt,n),this.m_sweepB.getTransform(Kt,n),1===r){this.m_type=oe.e_points;const e=this.m_proxyA.getVertex(t.indexA[0]),s=this.m_proxyB.getVertex(t.indexB[0]);D(Xt,Zt,e),D(Gt,Kt,s),v(this.m_axis,Gt,Xt);return function(t){const e=Math.sqrt(t.x*t.x+t.y*t.y);if(0!==e){const s=1/e;t.x*=s,t.y*=s}return e}(this.m_axis)}if(t.indexA[0]===t.indexA[1]){this.m_type=oe.e_faceB;const s=i.getVertex(t.indexB[0]),o=i.getVertex(t.indexB[1]);M(this.m_axis,v(Ut,o,s),1),C(this.m_axis),L(Qt,Kt.q,this.m_axis),V(this.m_localPoint,.5,s,.5,o),D(Gt,Kt,this.m_localPoint);const n=e.getVertex(t.indexA[0]);let r=P(W.mulVec2(Zt,n),Qt)-P(Gt,Qt);return r<0&&(x(this.m_axis),r=-r),r}{this.m_type=oe.e_faceA;const e=this.m_proxyA.getVertex(t.indexA[0]),s=this.m_proxyA.getVertex(t.indexA[1]);M(this.m_axis,v(Ut,s,e),1),C(this.m_axis),L(Qt,Zt.q,this.m_axis),V(this.m_localPoint,.5,e,.5,s),D(Xt,Zt,this.m_localPoint);const i=this.m_proxyB.getVertex(t.indexB[0]);D(Gt,Kt,i);let o=P(Gt,Qt)-P(Xt,Qt);return o<0&&(x(this.m_axis),o=-o),o}}compute(t,e){switch(this.m_sweepA.getTransform(Zt,e),this.m_sweepB.getTransform(Kt,e),this.m_type){case oe.e_points:t&&(q($t,Zt.q,this.m_axis),q(te,Kt.q,f(Ut,-1,this.m_axis)),this.indexA=this.m_proxyA.getSupport($t),this.indexB=this.m_proxyB.getSupport(te)),y(ee,this.m_proxyA.getVertex(this.indexA)),y(se,this.m_proxyB.getVertex(this.indexB)),D(Xt,Zt,ee),D(Gt,Kt,se);return P(Gt,this.m_axis)-P(Xt,this.m_axis);case oe.e_faceA:L(Qt,Zt.q,this.m_axis),D(Xt,Zt,this.m_localPoint),t&&(q(te,Kt.q,f(Ut,-1,Qt)),this.indexA=-1,this.indexB=this.m_proxyB.getSupport(te)),y(se,this.m_proxyB.getVertex(this.indexB)),D(Gt,Kt,se);return P(Gt,Qt)-P(Xt,Qt);case oe.e_faceB:L(Qt,Kt.q,this.m_axis),D(Gt,Kt,this.m_localPoint),t&&(q($t,Zt.q,f(Ut,-1,Qt)),this.indexB=-1,this.indexA=this.m_proxyA.getSupport($t)),y(ee,this.m_proxyA.getVertex(this.indexA)),D(Xt,Zt,ee);return P(Xt,Qt)-P(Gt,Qt);default:return t&&(this.indexA=-1,this.indexB=-1),0}}findMinSeparation(t){return this.compute(!0,t)}evaluate(t){return this.compute(!1,t)}};ie.Input=Rt,ie.Output=Jt;class re{constructor(){this.dt=0,this.inv_dt=0,this.velocityIterations=0,this.positionIterations=0,this.warmStarting=!1,this.blockSolve=!0,this.inv_dt0=0,this.dtRatio=1}reset(t){this.dt>0&&(this.inv_dt0=this.inv_dt),this.dt=t,this.inv_dt=0==t?0:1/t,this.dtRatio=t*this.inv_dt0}}const me=new re,he=u(0,0),ae=u(0,0),ce=u(0,0),le=new Rt,_e=new Jt,ue=new Y,de=new Y,ye=new Y;class pe{constructor(t){this.contact=t,this.normals=[],this.tangents=[]}recycle(){this.normals.length=0,this.tangents.length=0}get normalImpulses(){const t=this.contact,e=this.normals;e.length=0;for(let s=0;s<t.v_points.length;++s)e.push(t.v_points[s].normalImpulse);return e}get tangentImpulses(){const t=this.contact,e=this.tangents;e.length=0;for(let s=0;s<t.v_points.length;++s)e.push(t.v_points[s].tangentImpulse);return e}}class xe{constructor(t){this.m_world=t,this.m_stack=[],this.m_bodies=[],this.m_contacts=[],this.m_joints=[]}clear(){this.m_stack.length=0,this.m_bodies.length=0,this.m_contacts.length=0,this.m_joints.length=0}addBody(t){this.m_bodies.push(t)}addContact(t){this.m_contacts.push(t)}addJoint(t){this.m_joints.push(t)}solveWorld(t){const e=this.m_world;for(let t=e.m_bodyList;t;t=t.m_next)t.m_islandFlag=!1;for(let t=e.m_contactList;t;t=t.m_next)t.m_islandFlag=!1;for(let t=e.m_jointList;t;t=t.m_next)t.m_islandFlag=!1;const s=this.m_stack;for(let i=e.m_bodyList;i;i=i.m_next)if(!i.m_islandFlag&&0!=i.isAwake()&&0!=i.isActive()&&!i.isStatic()){for(this.clear(),s.push(i),i.m_islandFlag=!0;s.length>0;){const t=s.pop();if(this.addBody(t),t.m_awakeFlag=!0,!t.isStatic()){for(let e=t.m_contactList;e;e=e.next){const t=e.contact;if(t.m_islandFlag)continue;if(0==t.isEnabled()||0==t.isTouching())continue;const i=t.m_fixtureA.m_isSensor,o=t.m_fixtureB.m_isSensor;if(i||o)continue;this.addContact(t),t.m_islandFlag=!0;const n=e.other;n.m_islandFlag||(s.push(n),n.m_islandFlag=!0)}for(let e=t.m_jointList;e;e=e.next){if(1==e.joint.m_islandFlag)continue;const t=e.other;0!=t.isActive()&&(this.addJoint(e.joint),e.joint.m_islandFlag=!0,t.m_islandFlag||(s.push(t),t.m_islandFlag=!0))}}}this.solveIsland(t);for(let t=0;t<this.m_bodies.length;++t){const e=this.m_bodies[t];e.isStatic()&&(e.m_islandFlag=!1)}}}solveIsland(t){const e=this.m_world,i=e.m_gravity,o=e.m_allowSleep,n=t.dt;for(let t=0;t<this.m_bodies.length;++t){const e=this.m_bodies[t];y(he,e.m_sweep.c);const s=e.m_sweep.a;y(ae,e.m_linearVelocity);let o=e.m_angularVelocity;y(e.m_sweep.c0,e.m_sweep.c),e.m_sweep.a0=e.m_sweep.a,e.isDynamic()&&(B(ae,n*e.m_gravityScale,i),B(ae,n*e.m_invMass,e.m_force),o+=n*e.m_invI*e.m_torque,f(ae,1/(1+n*e.m_linearDamping),ae),o*=1/(1+n*e.m_angularDamping)),y(e.c_position.c,he),e.c_position.a=s,y(e.c_velocity.v,ae),e.c_velocity.w=o}for(let e=0;e<this.m_contacts.length;++e){this.m_contacts[e].initConstraint(t)}for(let e=0;e<this.m_contacts.length;++e){this.m_contacts[e].initVelocityConstraint(t)}if(t.warmStarting)for(let e=0;e<this.m_contacts.length;++e){this.m_contacts[e].warmStartConstraint(t)}for(let e=0;e<this.m_joints.length;++e){this.m_joints[e].initVelocityConstraints(t)}for(let e=0;e<t.velocityIterations;++e){for(let e=0;e<this.m_joints.length;++e){this.m_joints[e].solveVelocityConstraints(t)}for(let e=0;e<this.m_contacts.length;++e){this.m_contacts[e].solveVelocityConstraint(t)}}for(let e=0;e<this.m_contacts.length;++e){this.m_contacts[e].storeConstraintImpulses(t)}for(let t=0;t<this.m_bodies.length;++t){const e=this.m_bodies[t];y(he,e.c_position.c);let i=e.c_position.a;y(ae,e.c_velocity.v);let o=e.c_velocity.w;f(ce,n,ae);const m=z(ce);if(m>r.maxTranslationSquared){const t=r.maxTranslation/s.sqrt(m);b(ae,t)}const h=n*o;if(h*h>r.maxRotationSquared){o*=r.maxRotation/s.abs(h)}B(he,n,ae),i+=n*o,y(e.c_position.c,he),e.c_position.a=i,y(e.c_velocity.v,ae),e.c_velocity.w=o}let m=!1;for(let e=0;e<t.positionIterations;++e){let e=0;for(let i=0;i<this.m_contacts.length;++i){const o=this.m_contacts[i].solvePositionConstraint(t);e=s.min(e,o)}const i=e>=-3*r.linearSlop;let o=!0;for(let e=0;e<this.m_joints.length;++e){const s=this.m_joints[e].solvePositionConstraints(t);o=o&&s}if(i&&o){m=!0;break}}for(let t=0;t<this.m_bodies.length;++t){const e=this.m_bodies[t];y(e.m_sweep.c,e.c_position.c),e.m_sweep.a=e.c_position.a,y(e.m_linearVelocity,e.c_velocity.v),e.m_angularVelocity=e.c_velocity.w,e.synchronizeTransform()}if(this.postSolveIsland(),o){let t=1/0;const e=r.linearSleepToleranceSqr,i=r.angularSleepToleranceSqr;for(let o=0;o<this.m_bodies.length;++o){const r=this.m_bodies[o];r.isStatic()||(0==r.m_autoSleepFlag||r.m_angularVelocity*r.m_angularVelocity>i||z(r.m_linearVelocity)>e?(r.m_sleepTime=0,t=0):(r.m_sleepTime+=n,t=s.min(t,r.m_sleepTime)))}if(t>=r.timeToSleep&&m)for(let t=0;t<this.m_bodies.length;++t){this.m_bodies[t].setAwake(!1)}}}solveWorldTOI(e){const i=this.m_world;if(i.m_stepComplete){for(let t=i.m_bodyList;t;t=t.m_next)t.m_islandFlag=!1,t.m_sweep.alpha0=0;for(let t=i.m_contactList;t;t=t.m_next)t.m_toiFlag=!1,t.m_islandFlag=!1,t.m_toiCount=0,t.m_toi=1}for(;;){let o=null,n=1;for(let e=i.m_contactList;e;e=e.m_next){if(0==e.isEnabled())continue;if(e.m_toiCount>r.maxSubSteps)continue;let i=1;if(e.m_toiFlag)i=e.m_toi;else{const o=e.getFixtureA(),n=e.getFixtureB();if(o.isSensor()||n.isSensor())continue;const r=o.getBody(),m=n.getBody(),h=r.isAwake()&&!r.isStatic(),a=m.isAwake()&&!m.isStatic();if(0==h&&0==a)continue;const c=r.isBullet()||!r.isDynamic(),l=m.isBullet()||!m.isDynamic();if(0==c&&0==l)continue;let _=r.m_sweep.alpha0;r.m_sweep.alpha0<m.m_sweep.alpha0?(_=m.m_sweep.alpha0,r.m_sweep.advance(_)):m.m_sweep.alpha0<r.m_sweep.alpha0&&(_=r.m_sweep.alpha0,m.m_sweep.advance(_));const u=e.getChildIndexA(),d=e.getChildIndexB();r.m_sweep,m.m_sweep,le.proxyA.set(o.getShape(),u),le.proxyB.set(n.getShape(),d),le.sweepA.set(r.m_sweep),le.sweepB.set(m.m_sweep),le.tMax=1,ie(_e,le);const y=_e.t;i=_e.state==t.TOIOutputState.e_touching?s.min(_+(1-_)*y,1):1,e.m_toi=i,e.m_toiFlag=!0}i<n&&(o=e,n=i)}if(null==o||1-10*s.EPSILON<n){i.m_stepComplete=!0;break}const m=o.getFixtureA(),h=o.getFixtureB(),a=m.getBody(),c=h.getBody();if(de.set(a.m_sweep),ye.set(c.m_sweep),a.advance(n),c.advance(n),o.update(i),o.m_toiFlag=!1,++o.m_toiCount,0==o.isEnabled()||0==o.isTouching()){o.setEnabled(!1),a.m_sweep.set(de),c.m_sweep.set(ye),a.synchronizeTransform(),c.synchronizeTransform();continue}a.setAwake(!0),c.setAwake(!0),this.clear(),this.addBody(a),this.addBody(c),this.addContact(o),a.m_islandFlag=!0,c.m_islandFlag=!0,o.m_islandFlag=!0;const l=[a,c];for(let t=0;t<l.length;++t){const e=l[t];if(e.isDynamic())for(let t=e.m_contactList;t;t=t.next){const s=t.contact;if(s.m_islandFlag)continue;const o=t.other;if(o.isDynamic()&&!e.isBullet()&&!o.isBullet())continue;const r=s.m_fixtureA.m_isSensor,m=s.m_fixtureB.m_isSensor;r||m||(ue.set(o.m_sweep),0==o.m_islandFlag&&o.advance(n),s.update(i),0!=s.isEnabled()&&0!=s.isTouching()?(s.m_islandFlag=!0,this.addContact(s),o.m_islandFlag||(o.m_islandFlag=!0,o.isStatic()||o.setAwake(!0),this.addBody(o))):(o.m_sweep.set(ue),o.synchronizeTransform()))}}me.reset((1-n)*e.dt),me.dtRatio=1,me.positionIterations=20,me.velocityIterations=e.velocityIterations,me.warmStarting=!1,this.solveIslandTOI(me,a,c);for(let t=0;t<this.m_bodies.length;++t){const e=this.m_bodies[t];if(e.m_islandFlag=!1,e.isDynamic()){e.synchronizeFixtures();for(let t=e.m_contactList;t;t=t.next)t.contact.m_toiFlag=!1,t.contact.m_islandFlag=!1}}if(i.findNewContacts(),i.m_subStepping){i.m_stepComplete=!1;break}}}solveIslandTOI(t,e,i){for(let t=0;t<this.m_bodies.length;++t){const e=this.m_bodies[t];y(e.c_position.c,e.m_sweep.c),e.c_position.a=e.m_sweep.a,y(e.c_velocity.v,e.m_linearVelocity),e.c_velocity.w=e.m_angularVelocity}for(let e=0;e<this.m_contacts.length;++e){this.m_contacts[e].initConstraint(t)}for(let o=0;o<t.positionIterations;++o){let o=0;for(let n=0;n<this.m_contacts.length;++n){const r=this.m_contacts[n].solvePositionConstraintTOI(t,e,i);o=s.min(o,r)}if(o>=-1.5*r.linearSlop)break}y(e.m_sweep.c0,e.c_position.c),e.m_sweep.a0=e.c_position.a,y(i.m_sweep.c0,i.c_position.c),i.m_sweep.a0=i.c_position.a;for(let e=0;e<this.m_contacts.length;++e){this.m_contacts[e].initVelocityConstraint(t)}for(let e=0;e<t.velocityIterations;++e)for(let e=0;e<this.m_contacts.length;++e){this.m_contacts[e].solveVelocityConstraint(t)}const o=t.dt;for(let t=0;t<this.m_bodies.length;++t){const e=this.m_bodies[t];y(he,e.c_position.c);let i=e.c_position.a;y(ae,e.c_velocity.v);let n=e.c_velocity.w;f(ce,o,ae);const m=z(ce);if(m>r.maxTranslationSquared){const t=r.maxTranslation/s.sqrt(m);b(ae,t)}const h=o*n;if(h*h>r.maxRotationSquared){n*=r.maxRotation/s.abs(h)}B(he,o,ae),i+=o*n,y(e.c_position.c,he),e.c_position.a=i,y(e.c_velocity.v,ae),e.c_velocity.w=n,y(e.m_sweep.c,he),e.m_sweep.a=i,y(e.m_linearVelocity,ae),e.m_angularVelocity=n,e.synchronizeTransform()}this.postSolveIsland()}postSolveIsland(){for(let t=0;t<this.m_contacts.length;++t){const e=this.m_contacts[t];this.m_world.postSolve(e,e.m_impulse)}}}xe.TimeStep=re;class Ae{constructor(t,e,s,o){"object"==typeof t&&null!==t?(this.ex=i.clone(t),this.ey=i.clone(e)):"number"==typeof t?(this.ex=i.neo(t,s),this.ey=i.neo(e,o)):(this.ex=i.zero(),this.ey=i.zero())}toString(){return JSON.stringify(this)}static isValid(t){return null!=t&&(i.isValid(t.ex)&&i.isValid(t.ey))}static assert(t){}set(t,e,s,i){"number"==typeof t&&"number"==typeof e&&"number"==typeof s&&"number"==typeof i?(this.ex.setNum(t,s),this.ey.setNum(e,i)):"object"==typeof t&&"object"==typeof e?(this.ex.setVec2(t),this.ey.setVec2(e)):"object"==typeof t&&(this.ex.setVec2(t.ex),this.ey.setVec2(t.ey))}setIdentity(){this.ex.x=1,this.ey.x=0,this.ex.y=0,this.ey.y=1}setZero(){this.ex.x=0,this.ey.x=0,this.ex.y=0,this.ey.y=0}getInverse(){const t=this.ex.x,e=this.ey.x,s=this.ex.y,i=this.ey.y;let o=t*i-e*s;0!==o&&(o=1/o);const n=new Ae;return n.ex.x=o*i,n.ey.x=-o*e,n.ex.y=-o*s,n.ey.y=o*t,n}solve(t){const e=this.ex.x,s=this.ey.x,o=this.ex.y,n=this.ey.y;let r=e*n-s*o;0!==r&&(r=1/r);const m=i.zero();return m.x=r*(n*t.x-s*t.y),m.y=r*(e*t.y-o*t.x),m}static mul(t,e){if(e&&"x"in e&&"y"in e){const s=t.ex.x*e.x+t.ey.x*e.y,o=t.ex.y*e.x+t.ey.y*e.y;return i.neo(s,o)}if(e&&"ex"in e&&"ey"in e){const s=t.ex.x*e.ex.x+t.ey.x*e.ex.y,i=t.ex.x*e.ey.x+t.ey.x*e.ey.y,o=t.ex.y*e.ex.x+t.ey.y*e.ex.y,n=t.ex.y*e.ey.x+t.ey.y*e.ey.y;return new Ae(s,i,o,n)}}static mulVec2(t,e){const s=t.ex.x*e.x+t.ey.x*e.y,o=t.ex.y*e.x+t.ey.y*e.y;return i.neo(s,o)}static mulMat22(t,e){const s=t.ex.x*e.ex.x+t.ey.x*e.ex.y,i=t.ex.x*e.ey.x+t.ey.x*e.ey.y,o=t.ex.y*e.ex.x+t.ey.y*e.ex.y,n=t.ex.y*e.ey.x+t.ey.y*e.ey.y;return new Ae(s,i,o,n)}static mulT(t,e){if(e&&"x"in e&&"y"in e)return i.neo(i.dot(e,t.ex),i.dot(e,t.ey));if(e&&"ex"in e&&"ey"in e){const s=i.neo(i.dot(t.ex,e.ex),i.dot(t.ey,e.ex)),o=i.neo(i.dot(t.ex,e.ey),i.dot(t.ey,e.ey));return new Ae(s,o)}}static mulTVec2(t,e){return i.neo(i.dot(e,t.ex),i.dot(e,t.ey))}static mulTMat22(t,e){const s=i.neo(i.dot(t.ex,e.ex),i.dot(t.ey,e.ex)),o=i.neo(i.dot(t.ex,e.ey),i.dot(t.ey,e.ey));return new Ae(s,o)}static abs(t){return new Ae(i.abs(t.ex),i.abs(t.ey))}static add(t,e){return new Ae(i.add(t.ex,e.ex),i.add(t.ey,e.ey))}}const ge=u(0,0),ve=u(0,0),be=u(0,0),fe=u(0,0),Be=u(0,0),we=u(0,0),Ve=u(0,0),Ce=u(0,0);var Me,Ie,Se;t.ManifoldType=void 0,(Me=t.ManifoldType||(t.ManifoldType={}))[Me.e_unset=-1]="e_unset",Me[Me.e_circles=0]="e_circles",Me[Me.e_faceA=1]="e_faceA",Me[Me.e_faceB=2]="e_faceB",t.ContactFeatureType=void 0,(Ie=t.ContactFeatureType||(t.ContactFeatureType={}))[Ie.e_unset=-1]="e_unset",Ie[Ie.e_vertex=0]="e_vertex",Ie[Ie.e_face=1]="e_face",t.PointState=void 0,(Se=t.PointState||(t.PointState={}))[Se.nullState=0]="nullState",Se[Se.addState=1]="addState",Se[Se.persistState=2]="persistState",Se[Se.removeState=3]="removeState";class Pe{constructor(){this.v=u(0,0),this.id=new Fe}set(t){y(this.v,t.v),this.id.set(t.id)}recycle(){p(this.v),this.id.recycle()}}class ze{constructor(){this.localNormal=u(0,0),this.localPoint=u(0,0),this.points=[new Te,new Te],this.pointCount=0}set(t){this.type=t.type,y(this.localNormal,t.localNormal),y(this.localPoint,t.localPoint),this.pointCount=t.pointCount,this.points[0].set(t.points[0]),this.points[1].set(t.points[1])}recycle(){this.type=t.ManifoldType.e_unset,p(this.localNormal),p(this.localPoint),this.pointCount=0,this.points[0].recycle(),this.points[1].recycle()}getWorldManifold(e,i,o,n,r){if(0==this.pointCount)return e;(e=e||new Le).pointCount=this.pointCount;const m=e.normal,h=e.points,a=e.separations;switch(this.type){case t.ManifoldType.e_circles:{d(m,1,0);const t=this.points[0];D(ge,i,this.localPoint),D(ve,n,t.localPoint),v(we,ve,ge);const e=z(we);if(e>s.EPSILON*s.EPSILON){f(m,1/s.sqrt(e),we)}V(fe,1,ge,o,m),V(Be,1,ve,-r,m),V(h[0],.5,fe,.5,Be),a[0]=P(v(be,Be,fe),m);break}case t.ManifoldType.e_faceA:L(m,i.q,this.localNormal),D(Ve,i,this.localPoint);for(let t=0;t<this.pointCount;++t){const e=this.points[t];D(Ce,n,e.localPoint),V(fe,1,Ce,o-P(v(be,Ce,Ve),m),m),V(Be,1,Ce,-r,m),V(h[t],.5,fe,.5,Be),a[t]=P(v(be,Be,fe),m)}break;case t.ManifoldType.e_faceB:L(m,n.q,this.localNormal),D(Ve,n,this.localPoint);for(let t=0;t<this.pointCount;++t){const e=this.points[t];D(Ce,i,e.localPoint),V(Be,1,Ce,r-P(v(be,Ce,Ve),m),m),V(fe,1,Ce,-o,m),V(h[t],.5,fe,.5,Be),a[t]=P(v(be,fe,Be),m)}x(m)}return e}}ze.clipSegmentToLine=ke,ze.ClipVertex=Pe,ze.getPointStates=qe,ze.PointState=t.PointState;class Te{constructor(){this.localPoint=u(0,0),this.normalImpulse=0,this.tangentImpulse=0,this.id=new Fe}set(t){y(this.localPoint,t.localPoint),this.normalImpulse=t.normalImpulse,this.tangentImpulse=t.tangentImpulse,this.id.set(t.id)}recycle(){p(this.localPoint),this.normalImpulse=0,this.tangentImpulse=0,this.id.recycle()}}class Fe{constructor(){this.key=-1,this.indexA=-1,this.indexB=-1,this.typeA=t.ContactFeatureType.e_unset,this.typeB=t.ContactFeatureType.e_unset}setFeatures(t,e,s,i){this.indexA=t,this.indexB=s,this.typeA=e,this.typeB=i,this.key=this.indexA+4*this.indexB+16*this.typeA+64*this.typeB}set(t){this.indexA=t.indexA,this.indexB=t.indexB,this.typeA=t.typeA,this.typeB=t.typeB,this.key=this.indexA+4*this.indexB+16*this.typeA+64*this.typeB}swapFeatures(){const t=this.indexA,e=this.indexB,s=this.typeA,i=this.typeB;this.indexA=e,this.indexB=t,this.typeA=i,this.typeB=s,this.key=this.indexA+4*this.indexB+16*this.typeA+64*this.typeB}recycle(){this.indexA=0,this.indexB=0,this.typeA=t.ContactFeatureType.e_unset,this.typeB=t.ContactFeatureType.e_unset,this.key=-1}}class Le{constructor(){this.normal=u(0,0),this.points=[u(0,0),u(0,0)],this.separations=[0,0],this.pointCount=0}recycle(){p(this.normal),p(this.points[0]),p(this.points[1]),this.separations[0]=0,this.separations[1]=0,this.pointCount=0}}function qe(e,s,i,o){for(let s=0;s<i.pointCount;++s){const n=i.points[s].id;e[s]=t.PointState.removeState;for(let i=0;i<o.pointCount;++i)if(o.points[i].id.key===n.key){e[s]=t.PointState.persistState;break}}for(let e=0;e<o.pointCount;++e){const n=o.points[e].id;s[e]=t.PointState.addState;for(let o=0;o<i.pointCount;++o)if(i.points[o].id.key===n.key){s[e]=t.PointState.persistState;break}}}function ke(e,s,i,o,n){let r=0;const m=P(i,s[0].v)-o,h=P(i,s[1].v)-o;if(m<=0&&e[r++].set(s[0]),h<=0&&e[r++].set(s[1]),m*h<0){const i=m/(m-h);V(e[r].v,1-i,s[0].v,i,s[1].v),e[r].id.setFeatures(n,t.ContactFeatureType.e_vertex,s[0].id.indexB,t.ContactFeatureType.e_face),++r}return r}const Ne=new m({create:()=>new xs,release(t){t.recycle()}}),De=new ze,Oe=new Le;class je{constructor(t){this.prev=null,this.next=null,this.other=null,this.contact=t}recycle(){this.prev=null,this.next=null,this.other=null}}function Re(t,e){return s.sqrt(t*e)}function Ee(t,e){return t>e?t:e}const Je=[];class Ye{constructor(){this.rA=u(0,0),this.rB=u(0,0),this.normalImpulse=0,this.tangentImpulse=0,this.normalMass=0,this.tangentMass=0,this.velocityBias=0}recycle(){p(this.rA),p(this.rB),this.normalImpulse=0,this.tangentImpulse=0,this.normalMass=0,this.tangentMass=0,this.velocityBias=0}}const We=u(0,0),He=u(0,0),Ze=u(0,0),Ke=u(0,0),Ue=u(0,0),Xe=k(0,0,0),Ge=k(0,0,0),Qe=u(0,0),$e=u(0,0),ts=u(0,0),es=u(0,0),ss=u(0,0),is=u(0,0),os=u(0,0),ns=u(0,0),rs=u(0,0),ms=u(0,0),hs=u(0,0),as=u(0,0),cs=u(0,0),ls=u(0,0),_s=u(0,0),us=u(0,0),ds=u(0,0),ys=u(0,0),ps=u(0,0);class xs{constructor(){this.m_nodeA=new je(this),this.m_nodeB=new je(this),this.m_fixtureA=null,this.m_fixtureB=null,this.m_indexA=-1,this.m_indexB=-1,this.m_evaluateFcn=null,this.m_manifold=new ze,this.m_prev=null,this.m_next=null,this.m_toi=1,this.m_toiCount=0,this.m_toiFlag=!1,this.m_friction=0,this.m_restitution=0,this.m_tangentSpeed=0,this.m_enabledFlag=!0,this.m_islandFlag=!1,this.m_touchingFlag=!1,this.m_filterFlag=!1,this.m_bulletHitFlag=!1,this.m_impulse=new pe(this),this.v_points=[new Ye,new Ye],this.v_normal=u(0,0),this.v_normalMass=new Ae,this.v_K=new Ae,this.v_pointCount=0,this.v_tangentSpeed=0,this.v_friction=0,this.v_restitution=0,this.v_invMassA=0,this.v_invMassB=0,this.v_invIA=0,this.v_invIB=0,this.p_localPoints=[u(0,0),u(0,0)],this.p_localNormal=u(0,0),this.p_localPoint=u(0,0),this.p_localCenterA=u(0,0),this.p_localCenterB=u(0,0),this.p_type=t.ManifoldType.e_unset,this.p_radiusA=0,this.p_radiusB=0,this.p_pointCount=0,this.p_invMassA=0,this.p_invMassB=0,this.p_invIA=0,this.p_invIB=0}initialize(t,e,s,i,o){this.m_fixtureA=t,this.m_fixtureB=s,this.m_indexA=e,this.m_indexB=i,this.m_evaluateFcn=o,this.m_friction=Re(this.m_fixtureA.m_friction,this.m_fixtureB.m_friction),this.m_restitution=Ee(this.m_fixtureA.m_restitution,this.m_fixtureB.m_restitution)}recycle(){this.m_nodeA.recycle(),this.m_nodeB.recycle(),this.m_fixtureA=null,this.m_fixtureB=null,this.m_indexA=-1,this.m_indexB=-1,this.m_evaluateFcn=null,this.m_manifold.recycle(),this.m_prev=null,this.m_next=null,this.m_toi=1,this.m_toiCount=0,this.m_toiFlag=!1,this.m_friction=0,this.m_restitution=0,this.m_tangentSpeed=0,this.m_enabledFlag=!0,this.m_islandFlag=!1,this.m_touchingFlag=!1,this.m_filterFlag=!1,this.m_bulletHitFlag=!1,this.m_impulse.recycle();for(const t of this.v_points)t.recycle();p(this.v_normal),this.v_normalMass.setZero(),this.v_K.setZero(),this.v_pointCount=0,this.v_tangentSpeed=0,this.v_friction=0,this.v_restitution=0,this.v_invMassA=0,this.v_invMassB=0,this.v_invIA=0,this.v_invIB=0;for(const t of this.p_localPoints)p(t);p(this.p_localNormal),p(this.p_localPoint),p(this.p_localCenterA),p(this.p_localCenterB),this.p_type=t.ManifoldType.e_unset,this.p_radiusA=0,this.p_radiusB=0,this.p_pointCount=0,this.p_invMassA=0,this.p_invMassB=0,this.p_invIA=0,this.p_invIB=0}initConstraint(t){const e=this.m_fixtureA,s=this.m_fixtureB;if(null===e||null===s)return;const i=e.m_body,o=s.m_body;if(null===i||null===o)return;const n=e.m_shape,m=s.m_shape;if(null===n||null===m)return;const h=this.m_manifold,a=h.pointCount;this.v_invMassA=i.m_invMass,this.v_invMassB=o.m_invMass,this.v_invIA=i.m_invI,this.v_invIB=o.m_invI,this.v_friction=this.m_friction,this.v_restitution=this.m_restitution,this.v_tangentSpeed=this.m_tangentSpeed,this.v_pointCount=a,this.v_K.setZero(),this.v_normalMass.setZero(),this.p_invMassA=i.m_invMass,this.p_invMassB=o.m_invMass,this.p_invIA=i.m_invI,this.p_invIB=o.m_invI,y(this.p_localCenterA,i.m_sweep.localCenter),y(this.p_localCenterB,o.m_sweep.localCenter),this.p_radiusA=n.m_radius,this.p_radiusB=m.m_radius,this.p_type=h.type,y(this.p_localNormal,h.localNormal),y(this.p_localPoint,h.localPoint),this.p_pointCount=a;for(let t=0;t<r.maxManifoldPoints;++t)this.v_points[t].recycle(),p(this.p_localPoints[t]);for(let e=0;e<a;++e){const s=h.points[e],i=this.v_points[e];t.warmStarting&&(i.normalImpulse=t.dtRatio*s.normalImpulse,i.tangentImpulse=t.dtRatio*s.tangentImpulse),y(this.p_localPoints[e],s.localPoint)}}getManifold(){return this.m_manifold}getWorldManifold(t){const e=this.m_fixtureA,s=this.m_fixtureB;if(null===e||null===s)return;const i=e.m_body,o=s.m_body;if(null===i||null===o)return;const n=e.m_shape,r=s.m_shape;return null!==n&&null!==r?this.m_manifold.getWorldManifold(t,i.getTransform(),n.m_radius,o.getTransform(),r.m_radius):void 0}setEnabled(t){this.m_enabledFlag=!!t}isEnabled(){return this.m_enabledFlag}isTouching(){return this.m_touchingFlag}getNext(){return this.m_next}getFixtureA(){return this.m_fixtureA}getFixtureB(){return this.m_fixtureB}getChildIndexA(){return this.m_indexA}getChildIndexB(){return this.m_indexB}flagForFiltering(){this.m_filterFlag=!0}setFriction(t){this.m_friction=t}getFriction(){return this.m_friction}resetFriction(){const t=this.m_fixtureA,e=this.m_fixtureB;null!==t&&null!==e&&(this.m_friction=Re(t.m_friction,e.m_friction))}setRestitution(t){this.m_restitution=t}getRestitution(){return this.m_restitution}resetRestitution(){const t=this.m_fixtureA,e=this.m_fixtureB;null!==t&&null!==e&&(this.m_restitution=Ee(t.m_restitution,e.m_restitution))}setTangentSpeed(t){this.m_tangentSpeed=t}getTangentSpeed(){return this.m_tangentSpeed}evaluate(t,e,s){const i=this.m_fixtureA,o=this.m_fixtureB;null!==i&&null!==o&&this.m_evaluateFcn(t,e,i,this.m_indexA,s,o,this.m_indexB)}update(t){const e=this.m_fixtureA,s=this.m_fixtureB;if(null===e||null===s)return;const i=e.m_body,o=s.m_body;if(null===i||null===o)return;const n=e.m_shape,r=s.m_shape;if(null===n||null===r)return;this.m_enabledFlag=!0;let m=!1;const h=this.m_touchingFlag,a=e.m_isSensor,c=s.m_isSensor,l=a||c,_=i.m_xf,u=o.m_xf;if(l)m=Nt(n,this.m_indexA,r,this.m_indexB,_,u),this.m_manifold.pointCount=0;else{De.recycle(),De.set(this.m_manifold),this.m_manifold.recycle(),this.evaluate(this.m_manifold,_,u),m=this.m_manifold.pointCount>0;for(let t=0;t<this.m_manifold.pointCount;++t){const e=this.m_manifold.points[t];e.normalImpulse=0,e.tangentImpulse=0;for(let t=0;t<De.pointCount;++t){const s=De.points[t];if(s.id.key===e.id.key){e.normalImpulse=s.normalImpulse,e.tangentImpulse=s.tangentImpulse;break}}}m!==h&&(i.setAwake(!0),o.setAwake(!0))}this.m_touchingFlag=m;const d="object"==typeof t&&null!==t;!h&&m&&d&&t.beginContact(this),h&&!m&&d&&t.endContact(this),!l&&m&&d&&De&&t.preSolve(this,De)}solvePositionConstraint(t){return this._solvePositionConstraint(t,null,null)}solvePositionConstraintTOI(t,e,s){return this._solvePositionConstraint(t,e,s)}_solvePositionConstraint(e,i,o){const n=null!==i&&null!==o;let m=0;const h=this.m_fixtureA,a=this.m_fixtureB;if(null===h||null===a)return m;const c=h.m_body,l=a.m_body;if(null===c||null===l)return m;c.c_velocity,l.c_velocity;const _=c.c_position,u=l.c_position,d=this.p_localCenterA,p=this.p_localCenterB;let A=0,g=0;n&&c!==i&&c!==o||(A=this.p_invMassA,g=this.p_invIA);let b=0,M=0;n&&l!==i&&l!==o||(b=this.p_invMassB,M=this.p_invIB),y(We,_.c);let I=_.a;y(Ze,u.c);let z=u.a;for(let e=0;e<this.p_pointCount;++e){let i;switch(K(Xe,d,We,I),K(Ge,p,Ze,z),this.p_type){case t.ManifoldType.e_circles:D(Qe,Xe,this.p_localPoint),D($e,Ge,this.p_localPoints[0]),v(ns,$e,Qe),C(ns),V(rs,.5,Qe,.5,$e),i=P($e,ns)-P(Qe,ns)-this.p_radiusA-this.p_radiusB;break;case t.ManifoldType.e_faceA:L(ns,Xe.q,this.p_localNormal),D(es,Xe,this.p_localPoint),D(ts,Ge,this.p_localPoints[e]),i=P(ts,ns)-P(es,ns)-this.p_radiusA-this.p_radiusB,y(rs,ts);break;case t.ManifoldType.e_faceB:L(ns,Ge.q,this.p_localNormal),D(es,Ge,this.p_localPoint),D(ts,Xe,this.p_localPoints[e]),i=P(ts,ns)-P(es,ns)-this.p_radiusA-this.p_radiusB,y(rs,ts),x(ns);break;default:return m}v(ss,rs,We),v(is,rs,Ze),m=s.min(m,i);const o=n?r.toiBaugarte:r.baumgarte,h=r.linearSlop,a=r.maxLinearCorrection,c=s.clamp(o*(i+h),-a,0),l=S(ss,ns),_=S(is,ns),u=A+b+g*l*l+M*_*_;f(os,u>0?-c/u:0,ns),w(We,A,os),I-=g*S(ss,os),B(Ze,b,os),z+=M*S(is,os)}return y(_.c,We),_.a=I,y(u.c,Ze),u.a=z,m}initVelocityConstraint(t){const e=this.m_fixtureA,s=this.m_fixtureB;if(null===e||null===s)return;const i=e.m_body,o=s.m_body;if(null===i||null===o)return;const n=i.c_velocity,m=o.c_velocity,h=i.c_position,a=o.c_position,c=this.p_radiusA,l=this.p_radiusB,_=this.m_manifold,u=this.v_invMassA,d=this.v_invMassB,p=this.v_invIA,x=this.v_invIB,A=this.p_localCenterA,g=this.p_localCenterB;y(We,h.c);const b=h.a;y(He,n.v);const f=n.w;y(Ze,a.c);const B=a.a;y(Ke,m.v);const w=m.w;K(Xe,A,We,b),K(Ge,g,Ze,B),Oe.recycle(),_.getWorldManifold(Oe,Xe,c,Ge,l),y(this.v_normal,Oe.normal);for(let t=0;t<this.v_pointCount;++t){const e=this.v_points[t],s=Oe.points[t];v(e.rA,s,We),v(e.rB,s,Ze);const i=S(e.rA,this.v_normal),o=S(e.rB,this.v_normal),n=u+d+p*i*i+x*o*o;e.normalMass=n>0?1/n:0,M(Ue,this.v_normal,1);const m=S(e.rA,Ue),h=S(e.rB,Ue),a=u+d+p*m*m+x*h*h;e.tangentMass=a>0?1/a:0,e.velocityBias=0;let c=0;c+=P(this.v_normal,Ke),c+=P(this.v_normal,I(ps,w,e.rB)),c-=P(this.v_normal,He),c-=P(this.v_normal,I(ps,f,e.rA)),c<-r.velocityThreshold&&(e.velocityBias=-this.v_restitution*c)}if(2==this.v_pointCount&&t.blockSolve){const t=this.v_points[0],e=this.v_points[1],s=S(t.rA,this.v_normal),i=S(t.rB,this.v_normal),o=S(e.rA,this.v_normal),n=S(e.rB,this.v_normal),r=u+d+p*s*s+x*i*i,m=u+d+p*o*o+x*n*n,h=u+d+p*s*o+x*i*n;if(r*r<1e3*(r*m-h*h)){this.v_K.ex.setNum(r,h),this.v_K.ey.setNum(h,m);const t=this.v_K.ex.x,e=this.v_K.ey.x,s=this.v_K.ex.y,i=this.v_K.ey.y;let o=t*i-e*s;0!==o&&(o=1/o),this.v_normalMass.ex.x=o*i,this.v_normalMass.ey.x=-o*e,this.v_normalMass.ex.y=-o*s,this.v_normalMass.ey.y=o*t}else this.v_pointCount=1}y(h.c,We),h.a=b,y(n.v,He),n.w=f,y(a.c,Ze),a.a=B,y(m.v,Ke),m.w=w}warmStartConstraint(t){const e=this.m_fixtureA,s=this.m_fixtureB;if(null===e||null===s)return;const i=e.m_body,o=s.m_body;if(null===i||null===o)return;const n=i.c_velocity,r=o.c_velocity;i.c_position,o.c_position;const m=this.v_invMassA,h=this.v_invIA,a=this.v_invMassB,c=this.v_invIB;y(He,n.v);let l=n.w;y(Ke,r.v);let _=r.w;y(ns,this.v_normal),M(Ue,ns,1);for(let t=0;t<this.v_pointCount;++t){const e=this.v_points[t];V(os,e.normalImpulse,ns,e.tangentImpulse,Ue),l-=h*S(e.rA,os),w(He,m,os),_+=c*S(e.rB,os),B(Ke,a,os)}y(n.v,He),n.w=l,y(r.v,Ke),r.w=_}storeConstraintImpulses(t){const e=this.m_manifold;for(let t=0;t<this.v_pointCount;++t)e.points[t].normalImpulse=this.v_points[t].normalImpulse,e.points[t].tangentImpulse=this.v_points[t].tangentImpulse}solveVelocityConstraint(t){const e=this.m_fixtureA,i=this.m_fixtureB;if(null===e||null===i)return;const o=e.m_body,n=i.m_body;if(null===o||null===n)return;const r=o.c_velocity;o.c_position;const m=n.c_velocity;n.c_position;const h=this.v_invMassA,a=this.v_invIA,c=this.v_invMassB,l=this.v_invIB;y(He,r.v);let _=r.w;y(Ke,m.v);let u=m.w;y(ns,this.v_normal),M(Ue,ns,1);const x=this.v_friction;for(let t=0;t<this.v_pointCount;++t){const e=this.v_points[t];p(ms),A(ms,Ke),A(ms,I(ps,u,e.rB)),g(ms,He),g(ms,I(ps,_,e.rA));const i=P(ms,Ue)-this.v_tangentSpeed;let o=e.tangentMass*-i;const n=x*e.normalImpulse,r=s.clamp(e.tangentImpulse+o,-n,n);o=r-e.tangentImpulse,e.tangentImpulse=r,f(os,o,Ue),w(He,h,os),_-=a*S(e.rA,os),B(Ke,c,os),u+=l*S(e.rB,os)}if(1==this.v_pointCount||0==t.blockSolve)for(let t=0;t<this.v_pointCount;++t){const e=this.v_points[t];p(ms),A(ms,Ke),A(ms,I(ps,u,e.rB)),g(ms,He),g(ms,I(ps,_,e.rA));const i=P(ms,ns);let o=-e.normalMass*(i-e.velocityBias);const n=s.max(e.normalImpulse+o,0);o=n-e.normalImpulse,e.normalImpulse=n,f(os,o,ns),w(He,h,os),_-=a*S(e.rA,os),B(Ke,c,os),u+=l*S(e.rB,os)}else{const t=this.v_points[0],e=this.v_points[1];d(ls,t.normalImpulse,e.normalImpulse),p(hs),A(hs,Ke),A(hs,I(ps,u,t.rB)),g(hs,He),g(hs,I(ps,_,t.rA)),p(as),A(as,Ke),A(as,I(ps,u,e.rB)),g(as,He),g(as,I(ps,_,e.rA));let s=P(hs,ns),i=P(as,ns);for(d(cs,s-t.velocityBias,i-e.velocityBias),cs.x-=this.v_K.ex.x*ls.x+this.v_K.ey.x*ls.y,cs.y-=this.v_K.ex.y*ls.x+this.v_K.ey.y*ls.y;;){if(p(_s),_s.x=-(this.v_normalMass.ex.x*cs.x+this.v_normalMass.ey.x*cs.y),_s.y=-(this.v_normalMass.ex.y*cs.x+this.v_normalMass.ey.y*cs.y),_s.x>=0&&_s.y>=0){v(us,_s,ls),f(ds,us.x,ns),f(ys,us.y,ns),w(He,h,ds),w(He,h,ys),_-=a*(S(t.rA,ds)+S(e.rA,ys)),B(Ke,c,ds),B(Ke,c,ys),u+=l*(S(t.rB,ds)+S(e.rB,ys)),t.normalImpulse=_s.x,e.normalImpulse=_s.y;break}if(_s.x=-t.normalMass*cs.x,_s.y=0,s=0,i=this.v_K.ex.y*_s.x+cs.y,_s.x>=0&&i>=0){v(us,_s,ls),f(ds,us.x,ns),f(ys,us.y,ns),w(He,h,ds),w(He,h,ys),_-=a*(S(t.rA,ds)+S(e.rA,ys)),B(Ke,c,ds),B(Ke,c,ys),u+=l*(S(t.rB,ds)+S(e.rB,ys)),t.normalImpulse=_s.x,e.normalImpulse=_s.y;break}if(_s.x=0,_s.y=-e.normalMass*cs.y,s=this.v_K.ey.x*_s.y+cs.x,i=0,_s.y>=0&&s>=0){v(us,_s,ls),f(ds,us.x,ns),f(ys,us.y,ns),w(He,h,ds),w(He,h,ys),_-=a*(S(t.rA,ds)+S(e.rA,ys)),B(Ke,c,ds),B(Ke,c,ys),u+=l*(S(t.rB,ds)+S(e.rB,ys)),t.normalImpulse=_s.x,e.normalImpulse=_s.y;break}if(_s.x=0,_s.y=0,s=cs.x,i=cs.y,s>=0&&i>=0){v(us,_s,ls),f(ds,us.x,ns),f(ys,us.y,ns),w(He,h,ds),w(He,h,ys),_-=a*(S(t.rA,ds)+S(e.rA,ys)),B(Ke,c,ds),B(Ke,c,ys),u+=l*(S(t.rB,ds)+S(e.rB,ys)),t.normalImpulse=_s.x,e.normalImpulse=_s.y;break}break}}y(r.v,He),r.w=_,y(m.v,Ke),m.w=u}static addType(t,e,s){Je[t]=Je[t]||{},Je[t][e]=s}static create(t,e,s,i){const o=t.m_shape.m_type,n=s.m_shape.m_type,r=Ne.allocate();let m;if(m=Je[o]&&Je[o][n])r.initialize(t,e,s,i,m);else{if(!(m=Je[n]&&Je[n][o]))return null;r.initialize(s,i,t,e,m)}t=r.m_fixtureA,s=r.m_fixtureB,e=r.getChildIndexA(),i=r.getChildIndexB();const h=t.m_body,a=s.m_body;return r.m_nodeA.contact=r,r.m_nodeA.other=a,r.m_nodeA.prev=null,r.m_nodeA.next=h.m_contactList,null!=h.m_contactList&&(h.m_contactList.prev=r.m_nodeA),h.m_contactList=r.m_nodeA,r.m_nodeB.contact=r,r.m_nodeB.other=h,r.m_nodeB.prev=null,r.m_nodeB.next=a.m_contactList,null!=a.m_contactList&&(a.m_contactList.prev=r.m_nodeB),a.m_contactList=r.m_nodeB,0==t.isSensor()&&0==s.isSensor()&&(h.setAwake(!0),a.setAwake(!0)),r}static destroy(t,e){const s=t.m_fixtureA,i=t.m_fixtureB;if(null===s||null===i)return;const o=s.m_body,n=i.m_body;null!==o&&null!==n&&(t.isTouching()&&e.endContact(t),t.m_nodeA.prev&&(t.m_nodeA.prev.next=t.m_nodeA.next),t.m_nodeA.next&&(t.m_nodeA.next.prev=t.m_nodeA.prev),t.m_nodeA==o.m_contactList&&(o.m_contactList=t.m_nodeA.next),t.m_nodeB.prev&&(t.m_nodeB.prev.next=t.m_nodeB.next),t.m_nodeB.next&&(t.m_nodeB.next.prev=t.m_nodeB.prev),t.m_nodeB==n.m_contactList&&(n.m_contactList=t.m_nodeB.next),t.m_manifold.pointCount>0&&!s.m_isSensor&&!i.m_isSensor&&(o.setAwake(!0),n.setAwake(!0)),Ne.release(t))}}const As={gravity:i.zero(),allowSleep:!0,warmStarting:!0,continuousPhysics:!0,subStepping:!1,blockSolve:!0,velocityIterations:8,positionIterations:3};class gs{constructor(t){this.s_step=new re,t&&i.isValid(t)&&(t={gravity:t}),t=e(t,As),this.m_solver=new xe(this),this.m_broadPhase=new _,this.m_contactList=null,this.m_contactCount=0,this.m_bodyList=null,this.m_bodyCount=0,this.m_jointList=null,this.m_jointCount=0,this.m_stepComplete=!0,this.m_allowSleep=t.allowSleep,this.m_gravity=i.clone(t.gravity),this.m_clearForces=!0,this.m_newFixture=!1,this.m_locked=!1,this.m_warmStarting=t.warmStarting,this.m_continuousPhysics=t.continuousPhysics,this.m_subStepping=t.subStepping,this.m_blockSolve=t.blockSolve,this.m_velocityIterations=t.velocityIterations,this.m_positionIterations=t.positionIterations,this.m_t=0}_serialize(){const t=[],e=[];for(let e=this.getBodyList();e;e=e.getNext())t.push(e);for(let t=this.getJointList();t;t=t.getNext())"function"==typeof t._serialize&&e.push(t);return{gravity:this.m_gravity,bodies:t,joints:e}}static _deserialize(t,e,s){if(!t)return new gs;const i=new gs(t.gravity);if(t.bodies)for(let e=t.bodies.length-1;e>=0;e-=1)i._addBody(s(lt,t.bodies[e],i));if(t.joints)for(let e=t.joints.length-1;e>=0;e--)i.createJoint(s(ut,t.joints[e],i));return i}getBodyList(){return this.m_bodyList}getJointList(){return this.m_jointList}getContactList(){return this.m_contactList}getBodyCount(){return this.m_bodyCount}getJointCount(){return this.m_jointCount}getContactCount(){return this.m_contactCount}setGravity(t){this.m_gravity=t}getGravity(){return this.m_gravity}isLocked(){return this.m_locked}setAllowSleeping(t){if(t!=this.m_allowSleep&&(this.m_allowSleep=t,0==this.m_allowSleep))for(let t=this.m_bodyList;t;t=t.m_next)t.setAwake(!0)}getAllowSleeping(){return this.m_allowSleep}setWarmStarting(t){this.m_warmStarting=t}getWarmStarting(){return this.m_warmStarting}setContinuousPhysics(t){this.m_continuousPhysics=t}getContinuousPhysics(){return this.m_continuousPhysics}setSubStepping(t){this.m_subStepping=t}getSubStepping(){return this.m_subStepping}setAutoClearForces(t){this.m_clearForces=t}getAutoClearForces(){return this.m_clearForces}clearForces(){for(let t=this.m_bodyList;t;t=t.getNext())t.m_force.setZero(),t.m_torque=0}queryAABB(t,e){const s=this.m_broadPhase;this.m_broadPhase.query(t,(function(t){const i=s.getUserData(t);return e(i.fixture)}))}rayCast(t,e,s){const o=this.m_broadPhase;this.m_broadPhase.rayCast({maxFraction:1,p1:t,p2:e},(function(t,e){const n=o.getUserData(e),r=n.fixture,m=n.childIndex,h={};if(r.rayCast(h,t,m)){const e=h.fraction,o=i.add(i.mulNumVec2(1-e,t.p1),i.mulNumVec2(e,t.p2));return s(r,o,h.normal,e)}return t.maxFraction}))}getProxyCount(){return this.m_broadPhase.getProxyCount()}getTreeHeight(){return this.m_broadPhase.getTreeHeight()}getTreeBalance(){return this.m_broadPhase.getTreeBalance()}getTreeQuality(){return this.m_broadPhase.getTreeQuality()}shiftOrigin(t){if(!this.m_locked){for(let e=this.m_bodyList;e;e=e.m_next)e.m_xf.p.sub(t),e.m_sweep.c0.sub(t),e.m_sweep.c.sub(t);for(let e=this.m_jointList;e;e=e.m_next)e.shiftOrigin(t);this.m_broadPhase.shiftOrigin(t)}}_addBody(t){this.isLocked()||(t.m_prev=null,t.m_next=this.m_bodyList,this.m_bodyList&&(this.m_bodyList.m_prev=t),this.m_bodyList=t,++this.m_bodyCount)}createBody(t,e){if(this.isLocked())return null;let s={};t&&(i.isValid(t)?s={position:t,angle:e}:"object"==typeof t&&(s=t));const o=new lt(this,s);return this._addBody(o),o}createDynamicBody(t,e){let s={};return t&&(i.isValid(t)?s={position:t,angle:e}:"object"==typeof t&&(s=t)),s.type="dynamic",this.createBody(s)}createKinematicBody(t,e){let s={};return t&&(i.isValid(t)?s={position:t,angle:e}:"object"==typeof t&&(s=t)),s.type="kinematic",this.createBody(s)}destroyBody(t){if(this.isLocked())return;if(t.m_destroyed)return!1;let e=t.m_jointList;for(;e;){const s=e;e=e.next,this.publish("remove-joint",s.joint),this.destroyJoint(s.joint),t.m_jointList=e}t.m_jointList=null;let s=t.m_contactList;for(;s;){const e=s;s=s.next,this.destroyContact(e.contact),t.m_contactList=s}t.m_contactList=null;let i=t.m_fixtureList;for(;i;){const e=i;i=i.m_next,this.publish("remove-fixture",e),e.destroyProxies(this.m_broadPhase),t.m_fixtureList=i}return t.m_fixtureList=null,t.m_prev&&(t.m_prev.m_next=t.m_next),t.m_next&&(t.m_next.m_prev=t.m_prev),t==this.m_bodyList&&(this.m_bodyList=t.m_next),t.m_destroyed=!0,--this.m_bodyCount,this.publish("remove-body",t),!0}createJoint(t){if(this.isLocked())return null;if(t.m_prev=null,t.m_next=this.m_jointList,this.m_jointList&&(this.m_jointList.m_prev=t),this.m_jointList=t,++this.m_jointCount,t.m_edgeA.joint=t,t.m_edgeA.other=t.m_bodyB,t.m_edgeA.prev=null,t.m_edgeA.next=t.m_bodyA.m_jointList,t.m_bodyA.m_jointList&&(t.m_bodyA.m_jointList.prev=t.m_edgeA),t.m_bodyA.m_jointList=t.m_edgeA,t.m_edgeB.joint=t,t.m_edgeB.other=t.m_bodyA,t.m_edgeB.prev=null,t.m_edgeB.next=t.m_bodyB.m_jointList,t.m_bodyB.m_jointList&&(t.m_bodyB.m_jointList.prev=t.m_edgeB),t.m_bodyB.m_jointList=t.m_edgeB,0==t.m_collideConnected)for(let e=t.m_bodyB.getContactList();e;e=e.next)e.other==t.m_bodyA&&e.contact.flagForFiltering();return t}destroyJoint(t){if(this.isLocked())return;t.m_prev&&(t.m_prev.m_next=t.m_next),t.m_next&&(t.m_next.m_prev=t.m_prev),t==this.m_jointList&&(this.m_jointList=t.m_next);const e=t.m_bodyA,s=t.m_bodyB;if(e.setAwake(!0),s.setAwake(!0),t.m_edgeA.prev&&(t.m_edgeA.prev.next=t.m_edgeA.next),t.m_edgeA.next&&(t.m_edgeA.next.prev=t.m_edgeA.prev),t.m_edgeA==e.m_jointList&&(e.m_jointList=t.m_edgeA.next),t.m_edgeA.prev=null,t.m_edgeA.next=null,t.m_edgeB.prev&&(t.m_edgeB.prev.next=t.m_edgeB.next),t.m_edgeB.next&&(t.m_edgeB.next.prev=t.m_edgeB.prev),t.m_edgeB==s.m_jointList&&(s.m_jointList=t.m_edgeB.next),t.m_edgeB.prev=null,t.m_edgeB.next=null,--this.m_jointCount,0==t.m_collideConnected){let t=s.getContactList();for(;t;)t.other==e&&t.contact.flagForFiltering(),t=t.next}this.publish("remove-joint",t)}step(t,e,s){if(this.publish("pre-step",t),(0|e)!==e&&(e=0),e=e||this.m_velocityIterations,s=s||this.m_positionIterations,this.m_newFixture&&(this.findNewContacts(),this.m_newFixture=!1),this.m_locked=!0,this.s_step.reset(t),this.s_step.velocityIterations=e,this.s_step.positionIterations=s,this.s_step.warmStarting=this.m_warmStarting,this.s_step.blockSolve=this.m_blockSolve,this.updateContacts(),this.m_stepComplete&&t>0){this.m_solver.solveWorld(this.s_step);for(let t=this.m_bodyList;t;t=t.getNext())0!=t.m_islandFlag&&(t.isStatic()||t.synchronizeFixtures());this.findNewContacts()}this.m_continuousPhysics&&t>0&&this.m_solver.solveWorldTOI(this.s_step),this.m_clearForces&&this.clearForces(),this.m_locked=!1,this.publish("post-step",t)}findNewContacts(){this.m_broadPhase.updatePairs(((t,e)=>this.createContact(t,e)))}createContact(t,e){const s=t.fixture,i=e.fixture,o=t.childIndex,n=e.childIndex,r=s.getBody(),m=i.getBody();if(r==m)return;let h=m.getContactList();for(;h;){if(h.other==r){const t=h.contact.getFixtureA(),e=h.contact.getFixtureB(),r=h.contact.getChildIndexA(),m=h.contact.getChildIndexB();if(t==s&&e==i&&r==o&&m==n)return;if(t==i&&e==s&&r==n&&m==o)return}h=h.next}if(0==m.shouldCollide(r))return;if(0==i.shouldCollide(s))return;const a=xs.create(s,o,i,n);null!=a&&(a.m_prev=null,null!=this.m_contactList&&(a.m_next=this.m_contactList,this.m_contactList.m_prev=a),this.m_contactList=a,++this.m_contactCount)}updateContacts(){let t,e=this.m_contactList;for(;t=e;){e=t.getNext();const s=t.getFixtureA(),i=t.getFixtureB(),o=t.getChildIndexA(),n=t.getChildIndexB(),r=s.getBody(),m=i.getBody();if(t.m_filterFlag){if(0==m.shouldCollide(r)){this.destroyContact(t);continue}if(0==i.shouldCollide(s)){this.destroyContact(t);continue}t.m_filterFlag=!1}const h=r.isAwake()&&!r.isStatic(),a=m.isAwake()&&!m.isStatic();if(0==h&&0==a)continue;const c=s.m_proxies[o].proxyId,l=i.m_proxies[n].proxyId;0!=this.m_broadPhase.testOverlap(c,l)?t.update(this):this.destroyContact(t)}}destroyContact(t){t.m_prev&&(t.m_prev.m_next=t.m_next),t.m_next&&(t.m_next.m_prev=t.m_prev),t==this.m_contactList&&(this.m_contactList=t.m_next),xs.destroy(t,this),--this.m_contactCount}on(t,e){return"string"!=typeof t||"function"!=typeof e||(this._listeners||(this._listeners={}),this._listeners[t]||(this._listeners[t]=[]),this._listeners[t].push(e)),this}off(t,e){if("string"!=typeof t||"function"!=typeof e)return this;const s=this._listeners&&this._listeners[t];if(!s||!s.length)return this;const i=s.indexOf(e);return i>=0&&s.splice(i,1),this}publish(t,e,s,i){const o=this._listeners&&this._listeners[t];if(!o||!o.length)return 0;for(let t=0;t<o.length;t++)o[t].call(this,e,s,i);return o.length}beginContact(t){this.publish("begin-contact",t)}endContact(t){this.publish("end-contact",t)}preSolve(t,e){this.publish("pre-solve",t,e)}postSolve(t,e){this.publish("post-solve",t,e)}}class vs{constructor(t,e,s){void 0===t?(this.x=0,this.y=0,this.z=0):"object"==typeof t?(this.x=t.x,this.y=t.y,this.z=t.z):(this.x=t,this.y=e,this.z=s)}_serialize(){return{x:this.x,y:this.y,z:this.z}}static _deserialize(t){const e=Object.create(vs.prototype);return e.x=t.x,e.y=t.y,e.z=t.z,e}static neo(t,e,s){const i=Object.create(vs.prototype);return i.x=t,i.y=e,i.z=s,i}static zero(){const t=Object.create(vs.prototype);return t.x=0,t.y=0,t.z=0,t}static clone(t){return vs.neo(t.x,t.y,t.z)}toString(){return JSON.stringify(this)}static isValid(t){return null!=t&&(s.isFinite(t.x)&&s.isFinite(t.y)&&s.isFinite(t.z))}static assert(t){}setZero(){return this.x=0,this.y=0,this.z=0,this}set(t,e,s){return this.x=t,this.y=e,this.z=s,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}mul(t){return this.x*=t,this.y*=t,this.z*=t,this}static areEqual(t,e){return t===e||"object"==typeof t&&null!==t&&"object"==typeof e&&null!==e&&t.x===e.x&&t.y===e.y&&t.z===e.z}static dot(t,e){return t.x*e.x+t.y*e.y+t.z*e.z}static cross(t,e){return new vs(t.y*e.z-t.z*e.y,t.z*e.x-t.x*e.z,t.x*e.y-t.y*e.x)}static add(t,e){return new vs(t.x+e.x,t.y+e.y,t.z+e.z)}static sub(t,e){return new vs(t.x-e.x,t.y-e.y,t.z-e.z)}static mul(t,e){return new vs(e*t.x,e*t.y,e*t.z)}neg(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}static neg(t){return new vs(-t.x,-t.y,-t.z)}}const bs=u(0,0),fs=u(0,0);class Bs extends U{constructor(t,e){super(),this.m_type=Bs.TYPE,this.m_radius=r.polygonRadius,this.m_vertex1=t?i.clone(t):i.zero(),this.m_vertex2=e?i.clone(e):i.zero(),this.m_vertex0=i.zero(),this.m_vertex3=i.zero(),this.m_hasVertex0=!1,this.m_hasVertex3=!1}_serialize(){return{type:this.m_type,vertex1:this.m_vertex1,vertex2:this.m_vertex2,vertex0:this.m_vertex0,vertex3:this.m_vertex3,hasVertex0:this.m_hasVertex0,hasVertex3:this.m_hasVertex3}}static _deserialize(t){const e=new Bs(t.vertex1,t.vertex2);return e.m_hasVertex0&&e.setPrevVertex(t.vertex0),e.m_hasVertex3&&e.setNextVertex(t.vertex3),e}_reset(){}getRadius(){return this.m_radius}getType(){return this.m_type}setNext(t){return this.setNextVertex(t)}setNextVertex(t){return t?(this.m_vertex3.setVec2(t),this.m_hasVertex3=!0):(this.m_vertex3.setZero(),this.m_hasVertex3=!1),this}getNextVertex(){return this.m_vertex3}setPrev(t){return this.setPrevVertex(t)}setPrevVertex(t){return t?(this.m_vertex0.setVec2(t),this.m_hasVertex0=!0):(this.m_vertex0.setZero(),this.m_hasVertex0=!1),this}getPrevVertex(){return this.m_vertex0}_set(t,e){return this.m_vertex1.setVec2(t),this.m_vertex2.setVec2(e),this.m_hasVertex0=!1,this.m_hasVertex3=!1,this}_clone(){const t=new Bs;return t.m_type=this.m_type,t.m_radius=this.m_radius,t.m_vertex1.setVec2(this.m_vertex1),t.m_vertex2.setVec2(this.m_vertex2),t.m_vertex0.setVec2(this.m_vertex0),t.m_vertex3.setVec2(this.m_vertex3),t.m_hasVertex0=this.m_hasVertex0,t.m_hasVertex3=this.m_hasVertex3,t}getChildCount(){return 1}testPoint(t,e){return!1}rayCast(t,e,s,o){const n=E.mulTVec2(s.q,i.sub(e.p1,s.p)),r=E.mulTVec2(s.q,i.sub(e.p2,s.p)),m=i.sub(r,n),h=this.m_vertex1,a=this.m_vertex2,c=i.sub(a,h),l=i.neo(c.y,-c.x);l.normalize();const _=i.dot(l,i.sub(h,n)),u=i.dot(l,m);if(0==u)return!1;const d=_/u;if(d<0||e.maxFraction<d)return!1;const y=i.add(n,i.mulNumVec2(d,m)),p=i.sub(a,h),x=i.dot(p,p);if(0==x)return!1;const A=i.dot(i.sub(y,h),p)/x;return!(A<0||1<A)&&(t.fraction=d,t.normal=_>0?E.mulVec2(s.q,l).neg():E.mulVec2(s.q,l),!0)}computeAABB(t,e,s){D(bs,e,this.m_vertex1),D(fs,e,this.m_vertex2),o.combinePoints(t,bs,fs),o.extend(t,this.m_radius)}computeMass(t,e){t.mass=0,V(t.center,.5,this.m_vertex1,.5,this.m_vertex2),t.I=0}computeDistanceProxy(t){t.m_vertices[0]=this.m_vertex1,t.m_vertices[1]=this.m_vertex2,t.m_vertices.length=2,t.m_count=2,t.m_radius=this.m_radius}}Bs.TYPE="edge";const ws=Bs,Vs=u(0,0),Cs=u(0,0);class Ms extends U{constructor(t,e){super(),this.m_type=Ms.TYPE,this.m_radius=r.polygonRadius,this.m_vertices=[],this.m_count=0,this.m_prevVertex=null,this.m_nextVertex=null,this.m_hasPrevVertex=!1,this.m_hasNextVertex=!1,this.m_isLoop=!!e,t&&t.length&&(e?this._createLoop(t):this._createChain(t))}_serialize(){const t={type:this.m_type,vertices:this.m_vertices,isLoop:this.m_isLoop,hasPrevVertex:this.m_hasPrevVertex,hasNextVertex:this.m_hasNextVertex,prevVertex:null,nextVertex:null};return this.m_prevVertex&&(t.prevVertex=this.m_prevVertex),this.m_nextVertex&&(t.nextVertex=this.m_nextVertex),t}static _deserialize(t,e,s){const o=[];if(t.vertices)for(let e=0;e<t.vertices.length;e++)o.push(s(i,t.vertices[e]));const n=new Ms(o,t.isLoop);return t.prevVertex&&n.setPrevVertex(t.prevVertex),t.nextVertex&&n.setNextVertex(t.nextVertex),n}getType(){return this.m_type}getRadius(){return this.m_radius}_createLoop(t){if(!(t.length<3)){for(let e=1;e<t.length;++e)t[e-1],t[e];this.m_vertices=[],this.m_count=t.length+1;for(let e=0;e<t.length;++e)this.m_vertices[e]=i.clone(t[e]);return this.m_vertices[t.length]=i.clone(t[0]),this.m_prevVertex=this.m_vertices[this.m_count-2],this.m_nextVertex=this.m_vertices[1],this.m_hasPrevVertex=!0,this.m_hasNextVertex=!0,this}}_createChain(t){for(let e=1;e<t.length;++e)t[e-1],t[e];this.m_count=t.length;for(let e=0;e<t.length;++e)this.m_vertices[e]=i.clone(t[e]);return this.m_hasPrevVertex=!1,this.m_hasNextVertex=!1,this.m_prevVertex=null,this.m_nextVertex=null,this}_reset(){this.m_isLoop?this._createLoop(this.m_vertices):this._createChain(this.m_vertices)}setPrevVertex(t){this.m_prevVertex=t,this.m_hasPrevVertex=!0}getPrevVertex(){return this.m_prevVertex}setNextVertex(t){this.m_nextVertex=t,this.m_hasNextVertex=!0}getNextVertex(){return this.m_nextVertex}_clone(){const t=new Ms;return t._createChain(this.m_vertices),t.m_type=this.m_type,t.m_radius=this.m_radius,t.m_prevVertex=this.m_prevVertex,t.m_nextVertex=this.m_nextVertex,t.m_hasPrevVertex=this.m_hasPrevVertex,t.m_hasNextVertex=this.m_hasNextVertex,t}getChildCount(){return this.m_count-1}getChildEdge(t,e){t.m_type=Bs.TYPE,t.m_radius=this.m_radius,t.m_vertex1=this.m_vertices[e],t.m_vertex2=this.m_vertices[e+1],e>0?(t.m_vertex0=this.m_vertices[e-1],t.m_hasVertex0=!0):(t.m_vertex0=this.m_prevVertex,t.m_hasVertex0=this.m_hasPrevVertex),e<this.m_count-2?(t.m_vertex3=this.m_vertices[e+2],t.m_hasVertex3=!0):(t.m_vertex3=this.m_nextVertex,t.m_hasVertex3=this.m_hasNextVertex)}getVertex(t){return t<this.m_count?this.m_vertices[t]:this.m_vertices[0]}isLoop(){return this.m_isLoop}testPoint(t,e){return!1}rayCast(t,e,s,i){return new Bs(this.getVertex(i),this.getVertex(i+1)).rayCast(t,e,s,0)}computeAABB(t,e,s){D(Vs,e,this.getVertex(s)),D(Cs,e,this.getVertex(s+1)),o.combinePoints(t,Vs,Cs)}computeMass(t,e){t.mass=0,p(t.center),t.I=0}computeDistanceProxy(t,e){t.m_vertices[0]=this.getVertex(e),t.m_vertices[1]=this.getVertex(e+1),t.m_count=2,t.m_radius=this.m_radius}}Ms.TYPE="chain";const Is=Ms,Ss=u(0,0),Ps=u(0,0),zs=u(0,0),Ts=u(0,0),Fs=u(0,0),Ls=u(0,0);class qs extends U{constructor(t){super(),this.m_type=qs.TYPE,this.m_radius=r.polygonRadius,this.m_centroid=i.zero(),this.m_vertices=[],this.m_normals=[],this.m_count=0,t&&t.length&&this._set(t)}_serialize(){return{type:this.m_type,vertices:this.m_vertices}}static _deserialize(t,e,s){const o=[];if(t.vertices)for(let e=0;e<t.vertices.length;e++)o.push(s(i,t.vertices[e]));return new qs(o)}getType(){return this.m_type}getRadius(){return this.m_radius}_clone(){const t=new qs;t.m_type=this.m_type,t.m_radius=this.m_radius,t.m_count=this.m_count,t.m_centroid.setVec2(this.m_centroid);for(let e=0;e<this.m_count;e++)t.m_vertices.push(this.m_vertices[e].clone());for(let e=0;e<this.m_normals.length;e++)t.m_normals.push(this.m_normals[e].clone());return t}getChildCount(){return 1}_reset(){this._set(this.m_vertices)}_set(t){if(t.length<3)return void this._setAsBox(1,1);let e=s.min(t.length,r.maxPolygonVertices);const o=[];for(let s=0;s<e;++s){const e=t[s];let n=!0;for(let t=0;t<o.length;++t)if(i.distanceSquared(e,o[t])<.25*r.linearSlopSquared){n=!1;break}n&&o.push(i.clone(e))}if(e=o.length,e<3)return void this._setAsBox(1,1);let n=0,m=o[0].x;for(let t=1;t<e;++t){const e=o[t].x;(e>m||e===m&&o[t].y<o[n].y)&&(n=t,m=e)}const h=[];let a=0,c=n;for(;;){h[a]=c;let t=0;for(let s=1;s<e;++s){if(t===c){t=s;continue}const e=i.sub(o[t],o[h[a]]),n=i.sub(o[s],o[h[a]]),r=i.crossVec2Vec2(e,n);r<0&&(t=s),0===r&&n.lengthSquared()>e.lengthSquared()&&(t=s)}if(++a,c=t,t===n)break}if(a<3)this._setAsBox(1,1);else{this.m_count=a,this.m_vertices=[];for(let t=0;t<a;++t)this.m_vertices[t]=o[h[t]];for(let t=0;t<a;++t){const e=t,s=t+1<a?t+1:0,o=i.sub(this.m_vertices[s],this.m_vertices[e]);this.m_normals[t]=i.crossVec2Num(o,1),this.m_normals[t].normalize()}this.m_centroid=function(t,e){const s=i.zero();let o=0;const n=i.zero(),r=1/3;for(let m=0;m<e;++m){const h=n,a=t[m],c=m+1<e?t[m+1]:t[0],l=i.sub(a,h),_=i.sub(c,h),u=.5*i.crossVec2Vec2(l,_);o+=u,s.addMul(u*r,h),s.addMul(u*r,a),s.addMul(u*r,c)}return s.mul(1/o),s}(this.m_vertices,a)}}_setAsBox(t,e,s,o){if(this.m_vertices[0]=i.neo(t,-e),this.m_vertices[1]=i.neo(t,e),this.m_vertices[2]=i.neo(-t,e),this.m_vertices[3]=i.neo(-t,-e),this.m_normals[0]=i.neo(1,0),this.m_normals[1]=i.neo(0,1),this.m_normals[2]=i.neo(-1,0),this.m_normals[3]=i.neo(0,-1),this.m_count=4,s&&i.isValid(s)){o=o||0,y(this.m_centroid,s);const t=W.identity();t.p.setVec2(s),t.q.setAngle(o);for(let e=0;e<this.m_count;++e)this.m_vertices[e]=W.mulVec2(t,this.m_vertices[e]),this.m_normals[e]=E.mulVec2(t.q,this.m_normals[e])}}testPoint(t,e){const s=O(Ss,t,e);for(let t=0;t<this.m_count;++t){if(P(this.m_normals[t],s)-P(this.m_normals[t],this.m_vertices[t])>0)return!1}return!0}rayCast(t,e,s,o){const n=E.mulTVec2(s.q,i.sub(e.p1,s.p)),r=E.mulTVec2(s.q,i.sub(e.p2,s.p)),m=i.sub(r,n);let h=0,a=e.maxFraction,c=-1;for(let t=0;t<this.m_count;++t){const e=i.dot(this.m_normals[t],i.sub(this.m_vertices[t],n)),s=i.dot(this.m_normals[t],m);if(0==s){if(e<0)return!1}else s<0&&e<h*s?(h=e/s,c=t):s>0&&e<a*s&&(a=e/s);if(a<h)return!1}return c>=0&&(t.fraction=h,t.normal=E.mulVec2(s.q,this.m_normals[c]),!0)}computeAABB(t,e,i){let o=1/0,n=1/0,r=-1/0,m=-1/0;for(let t=0;t<this.m_count;++t){const i=D(Ss,e,this.m_vertices[t]);o=s.min(o,i.x),r=s.max(r,i.x),n=s.min(n,i.y),m=s.max(m,i.y)}d(t.lowerBound,o-this.m_radius,n-this.m_radius),d(t.upperBound,r+this.m_radius,m+this.m_radius)}computeMass(t,e){p(Fs);let s=0,i=0;p(Ls);for(let t=0;t<this.m_count;++t)A(Ls,this.m_vertices[t]);f(Ls,1/this.m_count,Ls);const o=1/3;for(let t=0;t<this.m_count;++t){v(zs,this.m_vertices[t],Ls),t+1<this.m_count?v(Ts,this.m_vertices[t+1],Ls):v(Ts,this.m_vertices[0],Ls);const e=S(zs,Ts),n=.5*e;s+=n,V(Fs,1,Fs,n*o,zs),V(Fs,1,Fs,n*o,Ts);const r=zs.x,m=zs.y,h=Ts.x,a=Ts.y;i+=.25*o*e*(r*r+h*r+h*h+(m*m+a*m+a*a))}t.mass=e*s,f(Fs,1/s,Fs),function(t,e,s){t.x=e.x+s.x,t.y=e.x+s.y}(t.center,Fs,Ls),t.I=e*i,t.I+=t.mass*(P(t.center,t.center)-P(Fs,Fs))}validate(){for(let t=0;t<this.m_count;++t){const e=t,s=t<this.m_count-1?e+1:0,i=this.m_vertices[e];v(Ps,this.m_vertices[s],i);for(let t=0;t<this.m_count;++t){if(t==e||t==s)continue;if(S(Ps,v(Ss,this.m_vertices[t],i))<0)return!1}}return!0}computeDistanceProxy(t){for(let e=0;e<this.m_count;++e)t.m_vertices[e]=this.m_vertices[e];t.m_vertices.length=this.m_count,t.m_count=this.m_count,t.m_radius=this.m_radius}}qs.TYPE="polygon";const ks=qs;class Ns extends qs{constructor(t,e,s,i){super(),this._setAsBox(t,e,s,i)}}Ns.TYPE="polygon";const Ds=Ns,Os=u(0,0);class js extends U{constructor(t,e){super(),this.m_type=js.TYPE,this.m_p=i.zero(),this.m_radius=1,"object"==typeof t&&i.isValid(t)?(this.m_p.setVec2(t),"number"==typeof e&&(this.m_radius=e)):"number"==typeof t&&(this.m_radius=t)}_serialize(){return{type:this.m_type,p:this.m_p,radius:this.m_radius}}static _deserialize(t){return new js(t.p,t.radius)}_reset(){}getType(){return this.m_type}getRadius(){return this.m_radius}getCenter(){return this.m_p}_clone(){const t=new js;return t.m_type=this.m_type,t.m_radius=this.m_radius,t.m_p=this.m_p.clone(),t}getChildCount(){return 1}testPoint(t,e){return F(e,D(Os,t,this.m_p))<=this.m_radius*this.m_radius}rayCast(t,e,o,n){const r=i.add(o.p,E.mulVec2(o.q,this.m_p)),m=i.sub(e.p1,r),h=i.dot(m,m)-this.m_radius*this.m_radius,a=i.sub(e.p2,e.p1),c=i.dot(m,a),l=i.dot(a,a),_=c*c-l*h;if(_<0||l<s.EPSILON)return!1;let u=-(c+s.sqrt(_));return 0<=u&&u<=e.maxFraction*l&&(u/=l,t.fraction=u,t.normal=i.add(m,i.mulNumVec2(u,a)),t.normal.normalize(),!0)}computeAABB(t,e,s){const i=D(Os,e,this.m_p);d(t.lowerBound,i.x-this.m_radius,i.y-this.m_radius),d(t.upperBound,i.x+this.m_radius,i.y+this.m_radius)}computeMass(t,e){t.mass=e*s.PI*this.m_radius*this.m_radius,y(t.center,this.m_p),t.I=t.mass*(.5*this.m_radius*this.m_radius+z(this.m_p))}computeDistanceProxy(t){t.m_vertices[0]=this.m_p,t.m_vertices.length=1,t.m_count=1,t.m_radius=this.m_radius}}js.TYPE="circle";const Rs=js,Es={frequencyHz:0,dampingRatio:0};class Js extends ut{constructor(t,o,n,r,m){if(n&&r&&"m_type"in r&&"x"in n&&"y"in n){const t=n;n=r,r=t}super(t=e(t,Es),o,n),o=this.m_bodyA,n=this.m_bodyB,this.m_type=Js.TYPE,this.m_localAnchorA=i.clone(r?o.getLocalPoint(r):t.localAnchorA||i.zero()),this.m_localAnchorB=i.clone(m?n.getLocalPoint(m):t.localAnchorB||i.zero()),this.m_length=s.isFinite(t.length)?t.length:i.distance(o.getWorldPoint(this.m_localAnchorA),n.getWorldPoint(this.m_localAnchorB)),this.m_frequencyHz=t.frequencyHz,this.m_dampingRatio=t.dampingRatio,this.m_impulse=0,this.m_gamma=0,this.m_bias=0}_serialize(){return{type:this.m_type,bodyA:this.m_bodyA,bodyB:this.m_bodyB,collideConnected:this.m_collideConnected,frequencyHz:this.m_frequencyHz,dampingRatio:this.m_dampingRatio,localAnchorA:this.m_localAnchorA,localAnchorB:this.m_localAnchorB,length:this.m_length,impulse:this.m_impulse,gamma:this.m_gamma,bias:this.m_bias}}static _deserialize(t,e,s){(t=Object.assign({},t)).bodyA=s(lt,t.bodyA,e),t.bodyB=s(lt,t.bodyB,e);return new Js(t)}_setAnchors(t){t.anchorA?this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(t.anchorA)):t.localAnchorA&&this.m_localAnchorA.setVec2(t.localAnchorA),t.anchorB?this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(t.anchorB)):t.localAnchorB&&this.m_localAnchorB.setVec2(t.localAnchorB),t.length>0?this.m_length=+t.length:t.length<0||(t.anchorA||t.anchorA||t.anchorA||t.anchorA)&&(this.m_length=i.distance(this.m_bodyA.getWorldPoint(this.m_localAnchorA),this.m_bodyB.getWorldPoint(this.m_localAnchorB)))}getLocalAnchorA(){return this.m_localAnchorA}getLocalAnchorB(){return this.m_localAnchorB}setLength(t){this.m_length=t}getLength(){return this.m_length}setFrequency(t){this.m_frequencyHz=t}getFrequency(){return this.m_frequencyHz}setDampingRatio(t){this.m_dampingRatio=t}getDampingRatio(){return this.m_dampingRatio}getAnchorA(){return this.m_bodyA.getWorldPoint(this.m_localAnchorA)}getAnchorB(){return this.m_bodyB.getWorldPoint(this.m_localAnchorB)}getReactionForce(t){return i.mulNumVec2(this.m_impulse,this.m_u).mul(t)}getReactionTorque(t){return 0}initVelocityConstraints(t){this.m_localCenterA=this.m_bodyA.m_sweep.localCenter,this.m_localCenterB=this.m_bodyB.m_sweep.localCenter,this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=this.m_bodyA.c_position.c,o=this.m_bodyA.c_position.a,n=this.m_bodyA.c_velocity.v;let m=this.m_bodyA.c_velocity.w;const h=this.m_bodyB.c_position.c,a=this.m_bodyB.c_position.a,c=this.m_bodyB.c_velocity.v;let l=this.m_bodyB.c_velocity.w;const _=E.neo(o),u=E.neo(a);this.m_rA=E.mulVec2(_,i.sub(this.m_localAnchorA,this.m_localCenterA)),this.m_rB=E.mulVec2(u,i.sub(this.m_localAnchorB,this.m_localCenterB)),this.m_u=i.sub(i.add(h,this.m_rB),i.add(e,this.m_rA));const d=this.m_u.length();d>r.linearSlop?this.m_u.mul(1/d):this.m_u.setNum(0,0);const y=i.crossVec2Vec2(this.m_rA,this.m_u),p=i.crossVec2Vec2(this.m_rB,this.m_u);let x=this.m_invMassA+this.m_invIA*y*y+this.m_invMassB+this.m_invIB*p*p;if(this.m_mass=0!=x?1/x:0,this.m_frequencyHz>0){const e=d-this.m_length,i=2*s.PI*this.m_frequencyHz,o=2*this.m_mass*this.m_dampingRatio*i,n=this.m_mass*i*i,r=t.dt;this.m_gamma=r*(o+r*n),this.m_gamma=0!=this.m_gamma?1/this.m_gamma:0,this.m_bias=e*r*n*this.m_gamma,x+=this.m_gamma,this.m_mass=0!=x?1/x:0}else this.m_gamma=0,this.m_bias=0;if(t.warmStarting){this.m_impulse*=t.dtRatio;const e=i.mulNumVec2(this.m_impulse,this.m_u);n.subMul(this.m_invMassA,e),m-=this.m_invIA*i.crossVec2Vec2(this.m_rA,e),c.addMul(this.m_invMassB,e),l+=this.m_invIB*i.crossVec2Vec2(this.m_rB,e)}else this.m_impulse=0;this.m_bodyA.c_velocity.v.setVec2(n),this.m_bodyA.c_velocity.w=m,this.m_bodyB.c_velocity.v.setVec2(c),this.m_bodyB.c_velocity.w=l}solveVelocityConstraints(t){const e=this.m_bodyA.c_velocity.v;let s=this.m_bodyA.c_velocity.w;const o=this.m_bodyB.c_velocity.v;let n=this.m_bodyB.c_velocity.w;const r=i.add(e,i.crossNumVec2(s,this.m_rA)),m=i.add(o,i.crossNumVec2(n,this.m_rB)),h=i.dot(this.m_u,m)-i.dot(this.m_u,r),a=-this.m_mass*(h+this.m_bias+this.m_gamma*this.m_impulse);this.m_impulse+=a;const c=i.mulNumVec2(a,this.m_u);e.subMul(this.m_invMassA,c),s-=this.m_invIA*i.crossVec2Vec2(this.m_rA,c),o.addMul(this.m_invMassB,c),n+=this.m_invIB*i.crossVec2Vec2(this.m_rB,c),this.m_bodyA.c_velocity.v.setVec2(e),this.m_bodyA.c_velocity.w=s,this.m_bodyB.c_velocity.v.setVec2(o),this.m_bodyB.c_velocity.w=n}solvePositionConstraints(t){if(this.m_frequencyHz>0)return!0;const e=this.m_bodyA.c_position.c;let o=this.m_bodyA.c_position.a;const n=this.m_bodyB.c_position.c;let m=this.m_bodyB.c_position.a;const h=E.neo(o),a=E.neo(m),c=E.mulSub(h,this.m_localAnchorA,this.m_localCenterA),l=E.mulSub(a,this.m_localAnchorB,this.m_localCenterB),_=i.sub(i.add(n,l),i.add(e,c));let u=_.normalize()-this.m_length;u=s.clamp(u,-r.maxLinearCorrection,r.maxLinearCorrection);const d=-this.m_mass*u,y=i.mulNumVec2(d,_);return e.subMul(this.m_invMassA,y),o-=this.m_invIA*i.crossVec2Vec2(c,y),n.addMul(this.m_invMassB,y),m+=this.m_invIB*i.crossVec2Vec2(l,y),this.m_bodyA.c_position.c.setVec2(e),this.m_bodyA.c_position.a=o,this.m_bodyB.c_position.c.setVec2(n),this.m_bodyB.c_position.a=m,s.abs(u)<r.linearSlop}}Js.TYPE="distance-joint";const Ys={maxForce:0,maxTorque:0};class Ws extends ut{constructor(t,s,o,n){super(t=e(t,Ys),s,o),s=this.m_bodyA,o=this.m_bodyB,this.m_type=Ws.TYPE,this.m_localAnchorA=i.clone(n?s.getLocalPoint(n):t.localAnchorA||i.zero()),this.m_localAnchorB=i.clone(n?o.getLocalPoint(n):t.localAnchorB||i.zero()),this.m_linearImpulse=i.zero(),this.m_angularImpulse=0,this.m_maxForce=t.maxForce,this.m_maxTorque=t.maxTorque}_serialize(){return{type:this.m_type,bodyA:this.m_bodyA,bodyB:this.m_bodyB,collideConnected:this.m_collideConnected,maxForce:this.m_maxForce,maxTorque:this.m_maxTorque,localAnchorA:this.m_localAnchorA,localAnchorB:this.m_localAnchorB}}static _deserialize(t,e,s){(t=Object.assign({},t)).bodyA=s(lt,t.bodyA,e),t.bodyB=s(lt,t.bodyB,e);return new Ws(t)}_setAnchors(t){t.anchorA?this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(t.anchorA)):t.localAnchorA&&this.m_localAnchorA.setVec2(t.localAnchorA),t.anchorB?this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(t.anchorB)):t.localAnchorB&&this.m_localAnchorB.setVec2(t.localAnchorB)}getLocalAnchorA(){return this.m_localAnchorA}getLocalAnchorB(){return this.m_localAnchorB}setMaxForce(t){this.m_maxForce=t}getMaxForce(){return this.m_maxForce}setMaxTorque(t){this.m_maxTorque=t}getMaxTorque(){return this.m_maxTorque}getAnchorA(){return this.m_bodyA.getWorldPoint(this.m_localAnchorA)}getAnchorB(){return this.m_bodyB.getWorldPoint(this.m_localAnchorB)}getReactionForce(t){return i.mulNumVec2(t,this.m_linearImpulse)}getReactionTorque(t){return t*this.m_angularImpulse}initVelocityConstraints(t){this.m_localCenterA=this.m_bodyA.m_sweep.localCenter,this.m_localCenterB=this.m_bodyB.m_sweep.localCenter,this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=this.m_bodyA.c_position.a,s=this.m_bodyA.c_velocity.v;let o=this.m_bodyA.c_velocity.w;const n=this.m_bodyB.c_position.a,r=this.m_bodyB.c_velocity.v;let m=this.m_bodyB.c_velocity.w;const h=E.neo(e),a=E.neo(n);this.m_rA=E.mulVec2(h,i.sub(this.m_localAnchorA,this.m_localCenterA)),this.m_rB=E.mulVec2(a,i.sub(this.m_localAnchorB,this.m_localCenterB));const c=this.m_invMassA,l=this.m_invMassB,_=this.m_invIA,u=this.m_invIB,d=new Ae;if(d.ex.x=c+l+_*this.m_rA.y*this.m_rA.y+u*this.m_rB.y*this.m_rB.y,d.ex.y=-_*this.m_rA.x*this.m_rA.y-u*this.m_rB.x*this.m_rB.y,d.ey.x=d.ex.y,d.ey.y=c+l+_*this.m_rA.x*this.m_rA.x+u*this.m_rB.x*this.m_rB.x,this.m_linearMass=d.getInverse(),this.m_angularMass=_+u,this.m_angularMass>0&&(this.m_angularMass=1/this.m_angularMass),t.warmStarting){this.m_linearImpulse.mul(t.dtRatio),this.m_angularImpulse*=t.dtRatio;const e=i.neo(this.m_linearImpulse.x,this.m_linearImpulse.y);s.subMul(c,e),o-=_*(i.crossVec2Vec2(this.m_rA,e)+this.m_angularImpulse),r.addMul(l,e),m+=u*(i.crossVec2Vec2(this.m_rB,e)+this.m_angularImpulse)}else this.m_linearImpulse.setZero(),this.m_angularImpulse=0;this.m_bodyA.c_velocity.v=s,this.m_bodyA.c_velocity.w=o,this.m_bodyB.c_velocity.v=r,this.m_bodyB.c_velocity.w=m}solveVelocityConstraints(t){const e=this.m_bodyA.c_velocity.v;let o=this.m_bodyA.c_velocity.w;const n=this.m_bodyB.c_velocity.v;let r=this.m_bodyB.c_velocity.w;const m=this.m_invMassA,h=this.m_invMassB,a=this.m_invIA,c=this.m_invIB,l=t.dt;{const t=r-o;let e=-this.m_angularMass*t;const i=this.m_angularImpulse,n=l*this.m_maxTorque;this.m_angularImpulse=s.clamp(this.m_angularImpulse+e,-n,n),e=this.m_angularImpulse-i,o-=a*e,r+=c*e}{const t=i.sub(i.add(n,i.crossNumVec2(r,this.m_rB)),i.add(e,i.crossNumVec2(o,this.m_rA)));let s=i.neg(Ae.mulVec2(this.m_linearMass,t));const _=this.m_linearImpulse;this.m_linearImpulse.add(s);const u=l*this.m_maxForce;this.m_linearImpulse.lengthSquared()>u*u&&(this.m_linearImpulse.normalize(),this.m_linearImpulse.mul(u)),s=i.sub(this.m_linearImpulse,_),e.subMul(m,s),o-=a*i.crossVec2Vec2(this.m_rA,s),n.addMul(h,s),r+=c*i.crossVec2Vec2(this.m_rB,s)}this.m_bodyA.c_velocity.v=e,this.m_bodyA.c_velocity.w=o,this.m_bodyB.c_velocity.v=n,this.m_bodyB.c_velocity.w=r}solvePositionConstraints(t){return!0}}Ws.TYPE="friction-joint";class Hs{constructor(t,e,s){"object"==typeof t&&null!==t?(this.ex=vs.clone(t),this.ey=vs.clone(e),this.ez=vs.clone(s)):(this.ex=vs.zero(),this.ey=vs.zero(),this.ez=vs.zero())}toString(){return JSON.stringify(this)}static isValid(t){return null!=t&&(vs.isValid(t.ex)&&vs.isValid(t.ey)&&vs.isValid(t.ez))}static assert(t){}setZero(){return this.ex.setZero(),this.ey.setZero(),this.ez.setZero(),this}solve33(t){let e=this.ey.y*this.ez.z-this.ey.z*this.ez.y,s=this.ey.z*this.ez.x-this.ey.x*this.ez.z,i=this.ey.x*this.ez.y-this.ey.y*this.ez.x,o=this.ex.x*e+this.ex.y*s+this.ex.z*i;0!==o&&(o=1/o);const n=new vs;return e=this.ey.y*this.ez.z-this.ey.z*this.ez.y,s=this.ey.z*this.ez.x-this.ey.x*this.ez.z,i=this.ey.x*this.ez.y-this.ey.y*this.ez.x,n.x=o*(t.x*e+t.y*s+t.z*i),e=t.y*this.ez.z-t.z*this.ez.y,s=t.z*this.ez.x-t.x*this.ez.z,i=t.x*this.ez.y-t.y*this.ez.x,n.y=o*(this.ex.x*e+this.ex.y*s+this.ex.z*i),e=this.ey.y*t.z-this.ey.z*t.y,s=this.ey.z*t.x-this.ey.x*t.z,i=this.ey.x*t.y-this.ey.y*t.x,n.z=o*(this.ex.x*e+this.ex.y*s+this.ex.z*i),n}solve22(t){const e=this.ex.x,s=this.ey.x,o=this.ex.y,n=this.ey.y;let r=e*n-s*o;0!==r&&(r=1/r);const m=i.zero();return m.x=r*(n*t.x-s*t.y),m.y=r*(e*t.y-o*t.x),m}getInverse22(t){const e=this.ex.x,s=this.ey.x,i=this.ex.y,o=this.ey.y;let n=e*o-s*i;0!==n&&(n=1/n),t.ex.x=n*o,t.ey.x=-n*s,t.ex.z=0,t.ex.y=-n*i,t.ey.y=n*e,t.ey.z=0,t.ez.x=0,t.ez.y=0,t.ez.z=0}getSymInverse33(t){let e=vs.dot(this.ex,vs.cross(this.ey,this.ez));0!==e&&(e=1/e);const s=this.ex.x,i=this.ey.x,o=this.ez.x,n=this.ey.y,r=this.ez.y,m=this.ez.z;t.ex.x=e*(n*m-r*r),t.ex.y=e*(o*r-i*m),t.ex.z=e*(i*r-o*n),t.ey.x=t.ex.y,t.ey.y=e*(s*m-o*o),t.ey.z=e*(o*i-s*r),t.ez.x=t.ex.z,t.ez.y=t.ey.z,t.ez.z=e*(s*n-i*i)}static mul(t,e){if(e&&"z"in e&&"y"in e&&"x"in e){const s=t.ex.x*e.x+t.ey.x*e.y+t.ez.x*e.z,i=t.ex.y*e.x+t.ey.y*e.y+t.ez.y*e.z,o=t.ex.z*e.x+t.ey.z*e.y+t.ez.z*e.z;return new vs(s,i,o)}if(e&&"y"in e&&"x"in e){const s=t.ex.x*e.x+t.ey.x*e.y,o=t.ex.y*e.x+t.ey.y*e.y;return i.neo(s,o)}}static mulVec3(t,e){const s=t.ex.x*e.x+t.ey.x*e.y+t.ez.x*e.z,i=t.ex.y*e.x+t.ey.y*e.y+t.ez.y*e.z,o=t.ex.z*e.x+t.ey.z*e.y+t.ez.z*e.z;return new vs(s,i,o)}static mulVec2(t,e){const s=t.ex.x*e.x+t.ey.x*e.y,o=t.ex.y*e.x+t.ey.y*e.y;return i.neo(s,o)}static add(t,e){return new Hs(vs.add(t.ex,e.ex),vs.add(t.ey,e.ey),vs.add(t.ez,e.ez))}}const Zs={lowerAngle:0,upperAngle:0,maxMotorTorque:0,motorSpeed:0,enableLimit:!1,enableMotor:!1};class Ks extends ut{constructor(t,o,n,r){super(t=e(t,Zs),o,n),this.m_mass=new Hs,this.m_limitState=0,o=this.m_bodyA,n=this.m_bodyB,this.m_type=Ks.TYPE,this.m_localAnchorA=i.clone(r?o.getLocalPoint(r):t.localAnchorA||i.zero()),this.m_localAnchorB=i.clone(r?n.getLocalPoint(r):t.localAnchorB||i.zero()),this.m_referenceAngle=s.isFinite(t.referenceAngle)?t.referenceAngle:n.getAngle()-o.getAngle(),this.m_impulse=new vs,this.m_motorImpulse=0,this.m_lowerAngle=t.lowerAngle,this.m_upperAngle=t.upperAngle,this.m_maxMotorTorque=t.maxMotorTorque,this.m_motorSpeed=t.motorSpeed,this.m_enableLimit=t.enableLimit,this.m_enableMotor=t.enableMotor}_serialize(){return{type:this.m_type,bodyA:this.m_bodyA,bodyB:this.m_bodyB,collideConnected:this.m_collideConnected,lowerAngle:this.m_lowerAngle,upperAngle:this.m_upperAngle,maxMotorTorque:this.m_maxMotorTorque,motorSpeed:this.m_motorSpeed,enableLimit:this.m_enableLimit,enableMotor:this.m_enableMotor,localAnchorA:this.m_localAnchorA,localAnchorB:this.m_localAnchorB,referenceAngle:this.m_referenceAngle}}static _deserialize(t,e,s){(t=Object.assign({},t)).bodyA=s(lt,t.bodyA,e),t.bodyB=s(lt,t.bodyB,e);return new Ks(t)}_setAnchors(t){t.anchorA?this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(t.anchorA)):t.localAnchorA&&this.m_localAnchorA.setVec2(t.localAnchorA),t.anchorB?this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(t.anchorB)):t.localAnchorB&&this.m_localAnchorB.setVec2(t.localAnchorB)}getLocalAnchorA(){return this.m_localAnchorA}getLocalAnchorB(){return this.m_localAnchorB}getReferenceAngle(){return this.m_referenceAngle}getJointAngle(){const t=this.m_bodyA;return this.m_bodyB.m_sweep.a-t.m_sweep.a-this.m_referenceAngle}getJointSpeed(){const t=this.m_bodyA;return this.m_bodyB.m_angularVelocity-t.m_angularVelocity}isMotorEnabled(){return this.m_enableMotor}enableMotor(t){t!=this.m_enableMotor&&(this.m_bodyA.setAwake(!0),this.m_bodyB.setAwake(!0),this.m_enableMotor=t)}getMotorTorque(t){return t*this.m_motorImpulse}setMotorSpeed(t){t!=this.m_motorSpeed&&(this.m_bodyA.setAwake(!0),this.m_bodyB.setAwake(!0),this.m_motorSpeed=t)}getMotorSpeed(){return this.m_motorSpeed}setMaxMotorTorque(t){t!=this.m_maxMotorTorque&&(this.m_bodyA.setAwake(!0),this.m_bodyB.setAwake(!0),this.m_maxMotorTorque=t)}getMaxMotorTorque(){return this.m_maxMotorTorque}isLimitEnabled(){return this.m_enableLimit}enableLimit(t){t!=this.m_enableLimit&&(this.m_bodyA.setAwake(!0),this.m_bodyB.setAwake(!0),this.m_enableLimit=t,this.m_impulse.z=0)}getLowerLimit(){return this.m_lowerAngle}getUpperLimit(){return this.m_upperAngle}setLimits(t,e){t==this.m_lowerAngle&&e==this.m_upperAngle||(this.m_bodyA.setAwake(!0),this.m_bodyB.setAwake(!0),this.m_impulse.z=0,this.m_lowerAngle=t,this.m_upperAngle=e)}getAnchorA(){return this.m_bodyA.getWorldPoint(this.m_localAnchorA)}getAnchorB(){return this.m_bodyB.getWorldPoint(this.m_localAnchorB)}getReactionForce(t){return i.neo(this.m_impulse.x,this.m_impulse.y).mul(t)}getReactionTorque(t){return t*this.m_impulse.z}initVelocityConstraints(t){this.m_localCenterA=this.m_bodyA.m_sweep.localCenter,this.m_localCenterB=this.m_bodyB.m_sweep.localCenter,this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=this.m_bodyA.c_position.a,o=this.m_bodyA.c_velocity.v;let n=this.m_bodyA.c_velocity.w;const m=this.m_bodyB.c_position.a,h=this.m_bodyB.c_velocity.v;let a=this.m_bodyB.c_velocity.w;const c=E.neo(e),l=E.neo(m);this.m_rA=E.mulVec2(c,i.sub(this.m_localAnchorA,this.m_localCenterA)),this.m_rB=E.mulVec2(l,i.sub(this.m_localAnchorB,this.m_localCenterB));const _=this.m_invMassA,u=this.m_invMassB,d=this.m_invIA,y=this.m_invIB,p=d+y===0;if(this.m_mass.ex.x=_+u+this.m_rA.y*this.m_rA.y*d+this.m_rB.y*this.m_rB.y*y,this.m_mass.ey.x=-this.m_rA.y*this.m_rA.x*d-this.m_rB.y*this.m_rB.x*y,this.m_mass.ez.x=-this.m_rA.y*d-this.m_rB.y*y,this.m_mass.ex.y=this.m_mass.ey.x,this.m_mass.ey.y=_+u+this.m_rA.x*this.m_rA.x*d+this.m_rB.x*this.m_rB.x*y,this.m_mass.ez.y=this.m_rA.x*d+this.m_rB.x*y,this.m_mass.ex.z=this.m_mass.ez.x,this.m_mass.ey.z=this.m_mass.ez.y,this.m_mass.ez.z=d+y,this.m_motorMass=d+y,this.m_motorMass>0&&(this.m_motorMass=1/this.m_motorMass),(0==this.m_enableMotor||p)&&(this.m_motorImpulse=0),this.m_enableLimit&&0==p){const t=m-e-this.m_referenceAngle;s.abs(this.m_upperAngle-this.m_lowerAngle)<2*r.angularSlop?this.m_limitState=3:t<=this.m_lowerAngle?(1!=this.m_limitState&&(this.m_impulse.z=0),this.m_limitState=1):t>=this.m_upperAngle?(2!=this.m_limitState&&(this.m_impulse.z=0),this.m_limitState=2):(this.m_limitState=0,this.m_impulse.z=0)}else this.m_limitState=0;if(t.warmStarting){this.m_impulse.mul(t.dtRatio),this.m_motorImpulse*=t.dtRatio;const e=i.neo(this.m_impulse.x,this.m_impulse.y);o.subMul(_,e),n-=d*(i.crossVec2Vec2(this.m_rA,e)+this.m_motorImpulse+this.m_impulse.z),h.addMul(u,e),a+=y*(i.crossVec2Vec2(this.m_rB,e)+this.m_motorImpulse+this.m_impulse.z)}else this.m_impulse.setZero(),this.m_motorImpulse=0;this.m_bodyA.c_velocity.v=o,this.m_bodyA.c_velocity.w=n,this.m_bodyB.c_velocity.v=h,this.m_bodyB.c_velocity.w=a}solveVelocityConstraints(t){const e=this.m_bodyA.c_velocity.v;let o=this.m_bodyA.c_velocity.w;const n=this.m_bodyB.c_velocity.v;let r=this.m_bodyB.c_velocity.w;const m=this.m_invMassA,h=this.m_invMassB,a=this.m_invIA,c=this.m_invIB,l=a+c===0;if(this.m_enableMotor&&3!=this.m_limitState&&0==l){const e=r-o-this.m_motorSpeed;let i=-this.m_motorMass*e;const n=this.m_motorImpulse,m=t.dt*this.m_maxMotorTorque;this.m_motorImpulse=s.clamp(this.m_motorImpulse+i,-m,m),i=this.m_motorImpulse-n,o-=a*i,r+=c*i}if(this.m_enableLimit&&0!=this.m_limitState&&0==l){const t=i.zero();t.addCombine(1,n,1,i.crossNumVec2(r,this.m_rB)),t.subCombine(1,e,1,i.crossNumVec2(o,this.m_rA));const s=r-o,l=new vs(t.x,t.y,s),_=vs.neg(this.m_mass.solve33(l));if(3==this.m_limitState)this.m_impulse.add(_);else if(1==this.m_limitState){if(this.m_impulse.z+_.z<0){const e=i.combine(-1,t,this.m_impulse.z,i.neo(this.m_mass.ez.x,this.m_mass.ez.y)),s=this.m_mass.solve22(e);_.x=s.x,_.y=s.y,_.z=-this.m_impulse.z,this.m_impulse.x+=s.x,this.m_impulse.y+=s.y,this.m_impulse.z=0}else this.m_impulse.add(_)}else if(2==this.m_limitState){if(this.m_impulse.z+_.z>0){const e=i.combine(-1,t,this.m_impulse.z,i.neo(this.m_mass.ez.x,this.m_mass.ez.y)),s=this.m_mass.solve22(e);_.x=s.x,_.y=s.y,_.z=-this.m_impulse.z,this.m_impulse.x+=s.x,this.m_impulse.y+=s.y,this.m_impulse.z=0}else this.m_impulse.add(_)}const u=i.neo(_.x,_.y);e.subMul(m,u),o-=a*(i.crossVec2Vec2(this.m_rA,u)+_.z),n.addMul(h,u),r+=c*(i.crossVec2Vec2(this.m_rB,u)+_.z)}else{const t=i.zero();t.addCombine(1,n,1,i.crossNumVec2(r,this.m_rB)),t.subCombine(1,e,1,i.crossNumVec2(o,this.m_rA));const s=this.m_mass.solve22(i.neg(t));this.m_impulse.x+=s.x,this.m_impulse.y+=s.y,e.subMul(m,s),o-=a*i.crossVec2Vec2(this.m_rA,s),n.addMul(h,s),r+=c*i.crossVec2Vec2(this.m_rB,s)}this.m_bodyA.c_velocity.v=e,this.m_bodyA.c_velocity.w=o,this.m_bodyB.c_velocity.v=n,this.m_bodyB.c_velocity.w=r}solvePositionConstraints(t){const e=this.m_bodyA.c_position.c;let o=this.m_bodyA.c_position.a;const n=this.m_bodyB.c_position.c;let m=this.m_bodyB.c_position.a;const h=E.neo(o),a=E.neo(m);let c=0,l=0;const _=this.m_invIA+this.m_invIB==0;if(this.m_enableLimit&&0!=this.m_limitState&&0==_){const t=m-o-this.m_referenceAngle;let e=0;if(3==this.m_limitState){const i=s.clamp(t-this.m_lowerAngle,-r.maxAngularCorrection,r.maxAngularCorrection);e=-this.m_motorMass*i,c=s.abs(i)}else if(1==this.m_limitState){let i=t-this.m_lowerAngle;c=-i,i=s.clamp(i+r.angularSlop,-r.maxAngularCorrection,0),e=-this.m_motorMass*i}else if(2==this.m_limitState){let i=t-this.m_upperAngle;c=i,i=s.clamp(i-r.angularSlop,0,r.maxAngularCorrection),e=-this.m_motorMass*i}o-=this.m_invIA*e,m+=this.m_invIB*e}{h.setAngle(o),a.setAngle(m);const t=E.mulVec2(h,i.sub(this.m_localAnchorA,this.m_localCenterA)),s=E.mulVec2(a,i.sub(this.m_localAnchorB,this.m_localCenterB)),r=i.zero();r.addCombine(1,n,1,s),r.subCombine(1,e,1,t),l=r.length();const c=this.m_invMassA,_=this.m_invMassB,u=this.m_invIA,d=this.m_invIB,y=new Ae;y.ex.x=c+_+u*t.y*t.y+d*s.y*s.y,y.ex.y=-u*t.x*t.y-d*s.x*s.y,y.ey.x=y.ex.y,y.ey.y=c+_+u*t.x*t.x+d*s.x*s.x;const p=i.neg(y.solve(r));e.subMul(c,p),o-=u*i.crossVec2Vec2(t,p),n.addMul(_,p),m+=d*i.crossVec2Vec2(s,p)}return this.m_bodyA.c_position.c.setVec2(e),this.m_bodyA.c_position.a=o,this.m_bodyB.c_position.c.setVec2(n),this.m_bodyB.c_position.a=m,l<=r.linearSlop&&c<=r.angularSlop}}Ks.TYPE="revolute-joint";const Us={enableLimit:!1,lowerTranslation:0,upperTranslation:0,enableMotor:!1,maxMotorForce:0,motorSpeed:0};class Xs extends ut{constructor(t,o,n,r,m){super(t=e(t,Us),o,n),o=this.m_bodyA,n=this.m_bodyB,this.m_type=Xs.TYPE,this.m_localAnchorA=i.clone(r?o.getLocalPoint(r):t.localAnchorA||i.zero()),this.m_localAnchorB=i.clone(r?n.getLocalPoint(r):t.localAnchorB||i.zero()),this.m_localXAxisA=i.clone(m?o.getLocalVector(m):t.localAxisA||i.neo(1,0)),this.m_localXAxisA.normalize(),this.m_localYAxisA=i.crossNumVec2(1,this.m_localXAxisA),this.m_referenceAngle=s.isFinite(t.referenceAngle)?t.referenceAngle:n.getAngle()-o.getAngle(),this.m_impulse=new vs,this.m_motorMass=0,this.m_motorImpulse=0,this.m_lowerTranslation=t.lowerTranslation,this.m_upperTranslation=t.upperTranslation,this.m_maxMotorForce=t.maxMotorForce,this.m_motorSpeed=t.motorSpeed,this.m_enableLimit=t.enableLimit,this.m_enableMotor=t.enableMotor,this.m_limitState=0,this.m_axis=i.zero(),this.m_perp=i.zero(),this.m_K=new Hs}_serialize(){return{type:this.m_type,bodyA:this.m_bodyA,bodyB:this.m_bodyB,collideConnected:this.m_collideConnected,lowerTranslation:this.m_lowerTranslation,upperTranslation:this.m_upperTranslation,maxMotorForce:this.m_maxMotorForce,motorSpeed:this.m_motorSpeed,enableLimit:this.m_enableLimit,enableMotor:this.m_enableMotor,localAnchorA:this.m_localAnchorA,localAnchorB:this.m_localAnchorB,localAxisA:this.m_localXAxisA,referenceAngle:this.m_referenceAngle}}static _deserialize(t,e,s){(t=Object.assign({},t)).bodyA=s(lt,t.bodyA,e),t.bodyB=s(lt,t.bodyB,e),t.localAxisA=i.clone(t.localAxisA);return new Xs(t)}_setAnchors(t){t.anchorA?this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(t.anchorA)):t.localAnchorA&&this.m_localAnchorA.setVec2(t.localAnchorA),t.anchorB?this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(t.anchorB)):t.localAnchorB&&this.m_localAnchorB.setVec2(t.localAnchorB),t.localAxisA&&(this.m_localXAxisA.setVec2(t.localAxisA),this.m_localYAxisA.setVec2(i.crossNumVec2(1,t.localAxisA)))}getLocalAnchorA(){return this.m_localAnchorA}getLocalAnchorB(){return this.m_localAnchorB}getLocalAxisA(){return this.m_localXAxisA}getReferenceAngle(){return this.m_referenceAngle}getJointTranslation(){const t=this.m_bodyA.getWorldPoint(this.m_localAnchorA),e=this.m_bodyB.getWorldPoint(this.m_localAnchorB),s=i.sub(e,t),o=this.m_bodyA.getWorldVector(this.m_localXAxisA);return i.dot(s,o)}getJointSpeed(){const t=this.m_bodyA,e=this.m_bodyB,s=E.mulVec2(t.m_xf.q,i.sub(this.m_localAnchorA,t.m_sweep.localCenter)),o=E.mulVec2(e.m_xf.q,i.sub(this.m_localAnchorB,e.m_sweep.localCenter)),n=i.add(t.m_sweep.c,s),r=i.add(e.m_sweep.c,o),m=i.sub(r,n),h=E.mulVec2(t.m_xf.q,this.m_localXAxisA),a=t.m_linearVelocity,c=e.m_linearVelocity,l=t.m_angularVelocity,_=e.m_angularVelocity;return i.dot(m,i.crossNumVec2(l,h))+i.dot(h,i.sub(i.addCrossNumVec2(c,_,o),i.addCrossNumVec2(a,l,s)))}isLimitEnabled(){return this.m_enableLimit}enableLimit(t){t!=this.m_enableLimit&&(this.m_bodyA.setAwake(!0),this.m_bodyB.setAwake(!0),this.m_enableLimit=t,this.m_impulse.z=0)}getLowerLimit(){return this.m_lowerTranslation}getUpperLimit(){return this.m_upperTranslation}setLimits(t,e){t==this.m_lowerTranslation&&e==this.m_upperTranslation||(this.m_bodyA.setAwake(!0),this.m_bodyB.setAwake(!0),this.m_lowerTranslation=t,this.m_upperTranslation=e,this.m_impulse.z=0)}isMotorEnabled(){return this.m_enableMotor}enableMotor(t){t!=this.m_enableMotor&&(this.m_bodyA.setAwake(!0),this.m_bodyB.setAwake(!0),this.m_enableMotor=t)}setMotorSpeed(t){t!=this.m_motorSpeed&&(this.m_bodyA.setAwake(!0),this.m_bodyB.setAwake(!0),this.m_motorSpeed=t)}setMaxMotorForce(t){t!=this.m_maxMotorForce&&(this.m_bodyA.setAwake(!0),this.m_bodyB.setAwake(!0),this.m_maxMotorForce=t)}getMaxMotorForce(){return this.m_maxMotorForce}getMotorSpeed(){return this.m_motorSpeed}getMotorForce(t){return t*this.m_motorImpulse}getAnchorA(){return this.m_bodyA.getWorldPoint(this.m_localAnchorA)}getAnchorB(){return this.m_bodyB.getWorldPoint(this.m_localAnchorB)}getReactionForce(t){return i.combine(this.m_impulse.x,this.m_perp,this.m_motorImpulse+this.m_impulse.z,this.m_axis).mul(t)}getReactionTorque(t){return t*this.m_impulse.y}initVelocityConstraints(t){this.m_localCenterA=this.m_bodyA.m_sweep.localCenter,this.m_localCenterB=this.m_bodyB.m_sweep.localCenter,this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=this.m_bodyA.c_position.c,o=this.m_bodyA.c_position.a,n=this.m_bodyA.c_velocity.v;let m=this.m_bodyA.c_velocity.w;const h=this.m_bodyB.c_position.c,a=this.m_bodyB.c_position.a,c=this.m_bodyB.c_velocity.v;let l=this.m_bodyB.c_velocity.w;const _=E.neo(o),u=E.neo(a),d=E.mulVec2(_,i.sub(this.m_localAnchorA,this.m_localCenterA)),y=E.mulVec2(u,i.sub(this.m_localAnchorB,this.m_localCenterB)),p=i.zero();p.addCombine(1,h,1,y),p.subCombine(1,e,1,d);const x=this.m_invMassA,A=this.m_invMassB,g=this.m_invIA,v=this.m_invIB;this.m_axis=E.mulVec2(_,this.m_localXAxisA),this.m_a1=i.crossVec2Vec2(i.add(p,d),this.m_axis),this.m_a2=i.crossVec2Vec2(y,this.m_axis),this.m_motorMass=x+A+g*this.m_a1*this.m_a1+v*this.m_a2*this.m_a2,this.m_motorMass>0&&(this.m_motorMass=1/this.m_motorMass);{this.m_perp=E.mulVec2(_,this.m_localYAxisA),this.m_s1=i.crossVec2Vec2(i.add(p,d),this.m_perp),this.m_s2=i.crossVec2Vec2(y,this.m_perp),i.crossVec2Vec2(d,this.m_perp);const t=x+A+g*this.m_s1*this.m_s1+v*this.m_s2*this.m_s2,e=g*this.m_s1+v*this.m_s2,s=g*this.m_s1*this.m_a1+v*this.m_s2*this.m_a2;let o=g+v;0==o&&(o=1);const n=g*this.m_a1+v*this.m_a2,r=x+A+g*this.m_a1*this.m_a1+v*this.m_a2*this.m_a2;this.m_K.ex.set(t,e,s),this.m_K.ey.set(e,o,n),this.m_K.ez.set(s,n,r)}if(this.m_enableLimit){const t=i.dot(this.m_axis,p);s.abs(this.m_upperTranslation-this.m_lowerTranslation)<2*r.linearSlop?this.m_limitState=3:t<=this.m_lowerTranslation?1!=this.m_limitState&&(this.m_limitState=1,this.m_impulse.z=0):t>=this.m_upperTranslation?2!=this.m_limitState&&(this.m_limitState=2,this.m_impulse.z=0):(this.m_limitState=0,this.m_impulse.z=0)}else this.m_limitState=0,this.m_impulse.z=0;if(0==this.m_enableMotor&&(this.m_motorImpulse=0),t.warmStarting){this.m_impulse.mul(t.dtRatio),this.m_motorImpulse*=t.dtRatio;const e=i.combine(this.m_impulse.x,this.m_perp,this.m_motorImpulse+this.m_impulse.z,this.m_axis),s=this.m_impulse.x*this.m_s1+this.m_impulse.y+(this.m_motorImpulse+this.m_impulse.z)*this.m_a1,o=this.m_impulse.x*this.m_s2+this.m_impulse.y+(this.m_motorImpulse+this.m_impulse.z)*this.m_a2;n.subMul(x,e),m-=g*s,c.addMul(A,e),l+=v*o}else this.m_impulse.setZero(),this.m_motorImpulse=0;this.m_bodyA.c_velocity.v.setVec2(n),this.m_bodyA.c_velocity.w=m,this.m_bodyB.c_velocity.v.setVec2(c),this.m_bodyB.c_velocity.w=l}solveVelocityConstraints(t){const e=this.m_bodyA.c_velocity.v;let o=this.m_bodyA.c_velocity.w;const n=this.m_bodyB.c_velocity.v;let r=this.m_bodyB.c_velocity.w;const m=this.m_invMassA,h=this.m_invMassB,a=this.m_invIA,c=this.m_invIB;if(this.m_enableMotor&&3!=this.m_limitState){const l=i.dot(this.m_axis,i.sub(n,e))+this.m_a2*r-this.m_a1*o;let _=this.m_motorMass*(this.m_motorSpeed-l);const u=this.m_motorImpulse,d=t.dt*this.m_maxMotorForce;this.m_motorImpulse=s.clamp(this.m_motorImpulse+_,-d,d),_=this.m_motorImpulse-u;const y=i.mulNumVec2(_,this.m_axis),p=_*this.m_a1,x=_*this.m_a2;e.subMul(m,y),o-=a*p,n.addMul(h,y),r+=c*x}const l=i.zero();if(l.x+=i.dot(this.m_perp,n)+this.m_s2*r,l.x-=i.dot(this.m_perp,e)+this.m_s1*o,l.y=r-o,this.m_enableLimit&&0!=this.m_limitState){let t=0;t+=i.dot(this.m_axis,n)+this.m_a2*r,t-=i.dot(this.m_axis,e)+this.m_a1*o;const _=new vs(l.x,l.y,t),u=vs.clone(this.m_impulse);let d=this.m_K.solve33(vs.neg(_));this.m_impulse.add(d),1==this.m_limitState?this.m_impulse.z=s.max(this.m_impulse.z,0):2==this.m_limitState&&(this.m_impulse.z=s.min(this.m_impulse.z,0));const y=i.combine(-1,l,-(this.m_impulse.z-u.z),i.neo(this.m_K.ez.x,this.m_K.ez.y)),p=i.add(this.m_K.solve22(y),i.neo(u.x,u.y));this.m_impulse.x=p.x,this.m_impulse.y=p.y,d=vs.sub(this.m_impulse,u);const x=i.combine(d.x,this.m_perp,d.z,this.m_axis),A=d.x*this.m_s1+d.y+d.z*this.m_a1,g=d.x*this.m_s2+d.y+d.z*this.m_a2;e.subMul(m,x),o-=a*A,n.addMul(h,x),r+=c*g}else{const t=this.m_K.solve22(i.neg(l));this.m_impulse.x+=t.x,this.m_impulse.y+=t.y;const s=i.mulNumVec2(t.x,this.m_perp),_=t.x*this.m_s1+t.y,u=t.x*this.m_s2+t.y;e.subMul(m,s),o-=a*_,n.addMul(h,s),r+=c*u}this.m_bodyA.c_velocity.v=e,this.m_bodyA.c_velocity.w=o,this.m_bodyB.c_velocity.v=n,this.m_bodyB.c_velocity.w=r}solvePositionConstraints(t){const e=this.m_bodyA.c_position.c;let o=this.m_bodyA.c_position.a;const n=this.m_bodyB.c_position.c;let m=this.m_bodyB.c_position.a;const h=E.neo(o),a=E.neo(m),c=this.m_invMassA,l=this.m_invMassB,_=this.m_invIA,u=this.m_invIB,d=E.mulVec2(h,i.sub(this.m_localAnchorA,this.m_localCenterA)),y=E.mulVec2(a,i.sub(this.m_localAnchorB,this.m_localCenterB)),p=i.sub(i.add(n,y),i.add(e,d)),x=E.mulVec2(h,this.m_localXAxisA),A=i.crossVec2Vec2(i.add(p,d),x),g=i.crossVec2Vec2(y,x),v=E.mulVec2(h,this.m_localYAxisA),b=i.crossVec2Vec2(i.add(p,d),v),f=i.crossVec2Vec2(y,v);let B=new vs;const w=i.zero();w.x=i.dot(v,p),w.y=m-o-this.m_referenceAngle;let V=s.abs(w.x);const C=s.abs(w.y),M=r.linearSlop,I=r.maxLinearCorrection;let S=!1,P=0;if(this.m_enableLimit){const t=i.dot(x,p);s.abs(this.m_upperTranslation-this.m_lowerTranslation)<2*M?(P=s.clamp(t,-I,I),V=s.max(V,s.abs(t)),S=!0):t<=this.m_lowerTranslation?(P=s.clamp(t-this.m_lowerTranslation+M,-I,0),V=s.max(V,this.m_lowerTranslation-t),S=!0):t>=this.m_upperTranslation&&(P=s.clamp(t-this.m_upperTranslation-M,0,I),V=s.max(V,t-this.m_upperTranslation),S=!0)}if(S){const t=c+l+_*b*b+u*f*f,e=_*b+u*f,s=_*b*A+u*f*g;let i=_+u;0==i&&(i=1);const o=_*A+u*g,n=c+l+_*A*A+u*g*g,r=new Hs;r.ex.set(t,e,s),r.ey.set(e,i,o),r.ez.set(s,o,n);const m=new vs;m.x=w.x,m.y=w.y,m.z=P,B=r.solve33(vs.neg(m))}else{const t=c+l+_*b*b+u*f*f,e=_*b+u*f;let s=_+u;0==s&&(s=1);const o=new Ae;o.ex.setNum(t,e),o.ey.setNum(e,s);const n=o.solve(i.neg(w));B.x=n.x,B.y=n.y,B.z=0}const z=i.combine(B.x,v,B.z,x),T=B.x*b+B.y+B.z*A,F=B.x*f+B.y+B.z*g;return e.subMul(c,z),o-=_*T,n.addMul(l,z),m+=u*F,this.m_bodyA.c_position.c=e,this.m_bodyA.c_position.a=o,this.m_bodyB.c_position.c=n,this.m_bodyB.c_position.a=m,V<=r.linearSlop&&C<=r.angularSlop}}Xs.TYPE="prismatic-joint";const Gs={ratio:1};class Qs extends ut{constructor(t,o,n,r,m,h){let a,c;super(t=e(t,Gs),o,n),o=this.m_bodyA,n=this.m_bodyB,this.m_type=Qs.TYPE,this.m_joint1=r||t.joint1,this.m_joint2=m||t.joint2,this.m_ratio=s.isFinite(h)?h:t.ratio,this.m_type1=this.m_joint1.getType(),this.m_type2=this.m_joint2.getType(),this.m_bodyC=this.m_joint1.getBodyA(),this.m_bodyA=this.m_joint1.getBodyB();const l=this.m_bodyA.m_xf,_=this.m_bodyA.m_sweep.a,u=this.m_bodyC.m_xf,d=this.m_bodyC.m_sweep.a;if(this.m_type1===Ks.TYPE){const t=this.m_joint1;this.m_localAnchorC=t.m_localAnchorA,this.m_localAnchorA=t.m_localAnchorB,this.m_referenceAngleA=t.m_referenceAngle,this.m_localAxisC=i.zero(),a=_-d-this.m_referenceAngleA}else{const t=this.m_joint1;this.m_localAnchorC=t.m_localAnchorA,this.m_localAnchorA=t.m_localAnchorB,this.m_referenceAngleA=t.m_referenceAngle,this.m_localAxisC=t.m_localXAxisA;const e=this.m_localAnchorC,s=E.mulTVec2(u.q,i.add(E.mulVec2(l.q,this.m_localAnchorA),i.sub(l.p,u.p)));a=i.dot(s,this.m_localAxisC)-i.dot(e,this.m_localAxisC)}this.m_bodyD=this.m_joint2.getBodyA(),this.m_bodyB=this.m_joint2.getBodyB();const y=this.m_bodyB.m_xf,p=this.m_bodyB.m_sweep.a,x=this.m_bodyD.m_xf,A=this.m_bodyD.m_sweep.a;if(this.m_type2===Ks.TYPE){const t=this.m_joint2;this.m_localAnchorD=t.m_localAnchorA,this.m_localAnchorB=t.m_localAnchorB,this.m_referenceAngleB=t.m_referenceAngle,this.m_localAxisD=i.zero(),c=p-A-this.m_referenceAngleB}else{const t=this.m_joint2;this.m_localAnchorD=t.m_localAnchorA,this.m_localAnchorB=t.m_localAnchorB,this.m_referenceAngleB=t.m_referenceAngle,this.m_localAxisD=t.m_localXAxisA;const e=this.m_localAnchorD,s=E.mulTVec2(x.q,i.add(E.mulVec2(y.q,this.m_localAnchorB),i.sub(y.p,x.p)));c=i.dot(s,this.m_localAxisD)-i.dot(e,this.m_localAxisD)}this.m_constant=a+this.m_ratio*c,this.m_impulse=0}_serialize(){return{type:this.m_type,bodyA:this.m_bodyA,bodyB:this.m_bodyB,collideConnected:this.m_collideConnected,joint1:this.m_joint1,joint2:this.m_joint2,ratio:this.m_ratio}}static _deserialize(t,e,s){(t=Object.assign({},t)).bodyA=s(lt,t.bodyA,e),t.bodyB=s(lt,t.bodyB,e),t.joint1=s(ut,t.joint1,e),t.joint2=s(ut,t.joint2,e);return new Qs(t)}getJoint1(){return this.m_joint1}getJoint2(){return this.m_joint2}setRatio(t){this.m_ratio=t}getRatio(){return this.m_ratio}getAnchorA(){return this.m_bodyA.getWorldPoint(this.m_localAnchorA)}getAnchorB(){return this.m_bodyB.getWorldPoint(this.m_localAnchorB)}getReactionForce(t){return i.mulNumVec2(this.m_impulse,this.m_JvAC).mul(t)}getReactionTorque(t){return t*(this.m_impulse*this.m_JwA)}initVelocityConstraints(t){this.m_lcA=this.m_bodyA.m_sweep.localCenter,this.m_lcB=this.m_bodyB.m_sweep.localCenter,this.m_lcC=this.m_bodyC.m_sweep.localCenter,this.m_lcD=this.m_bodyD.m_sweep.localCenter,this.m_mA=this.m_bodyA.m_invMass,this.m_mB=this.m_bodyB.m_invMass,this.m_mC=this.m_bodyC.m_invMass,this.m_mD=this.m_bodyD.m_invMass,this.m_iA=this.m_bodyA.m_invI,this.m_iB=this.m_bodyB.m_invI,this.m_iC=this.m_bodyC.m_invI,this.m_iD=this.m_bodyD.m_invI;const e=this.m_bodyA.c_position.a,s=this.m_bodyA.c_velocity.v;let o=this.m_bodyA.c_velocity.w;const n=this.m_bodyB.c_position.a,r=this.m_bodyB.c_velocity.v;let m=this.m_bodyB.c_velocity.w;const h=this.m_bodyC.c_position.a,a=this.m_bodyC.c_velocity.v;let c=this.m_bodyC.c_velocity.w;const l=this.m_bodyD.c_position.a,_=this.m_bodyD.c_velocity.v;let u=this.m_bodyD.c_velocity.w;const d=E.neo(e),y=E.neo(n),p=E.neo(h),x=E.neo(l);if(this.m_mass=0,this.m_type1==Ks.TYPE)this.m_JvAC=i.zero(),this.m_JwA=1,this.m_JwC=1,this.m_mass+=this.m_iA+this.m_iC;else{const t=E.mulVec2(p,this.m_localAxisC),e=E.mulSub(p,this.m_localAnchorC,this.m_lcC),s=E.mulSub(d,this.m_localAnchorA,this.m_lcA);this.m_JvAC=t,this.m_JwC=i.crossVec2Vec2(e,t),this.m_JwA=i.crossVec2Vec2(s,t),this.m_mass+=this.m_mC+this.m_mA+this.m_iC*this.m_JwC*this.m_JwC+this.m_iA*this.m_JwA*this.m_JwA}if(this.m_type2==Ks.TYPE)this.m_JvBD=i.zero(),this.m_JwB=this.m_ratio,this.m_JwD=this.m_ratio,this.m_mass+=this.m_ratio*this.m_ratio*(this.m_iB+this.m_iD);else{const t=E.mulVec2(x,this.m_localAxisD),e=E.mulSub(x,this.m_localAnchorD,this.m_lcD),s=E.mulSub(y,this.m_localAnchorB,this.m_lcB);this.m_JvBD=i.mulNumVec2(this.m_ratio,t),this.m_JwD=this.m_ratio*i.crossVec2Vec2(e,t),this.m_JwB=this.m_ratio*i.crossVec2Vec2(s,t),this.m_mass+=this.m_ratio*this.m_ratio*(this.m_mD+this.m_mB)+this.m_iD*this.m_JwD*this.m_JwD+this.m_iB*this.m_JwB*this.m_JwB}this.m_mass=this.m_mass>0?1/this.m_mass:0,t.warmStarting?(s.addMul(this.m_mA*this.m_impulse,this.m_JvAC),o+=this.m_iA*this.m_impulse*this.m_JwA,r.addMul(this.m_mB*this.m_impulse,this.m_JvBD),m+=this.m_iB*this.m_impulse*this.m_JwB,a.subMul(this.m_mC*this.m_impulse,this.m_JvAC),c-=this.m_iC*this.m_impulse*this.m_JwC,_.subMul(this.m_mD*this.m_impulse,this.m_JvBD),u-=this.m_iD*this.m_impulse*this.m_JwD):this.m_impulse=0,this.m_bodyA.c_velocity.v.setVec2(s),this.m_bodyA.c_velocity.w=o,this.m_bodyB.c_velocity.v.setVec2(r),this.m_bodyB.c_velocity.w=m,this.m_bodyC.c_velocity.v.setVec2(a),this.m_bodyC.c_velocity.w=c,this.m_bodyD.c_velocity.v.setVec2(_),this.m_bodyD.c_velocity.w=u}solveVelocityConstraints(t){const e=this.m_bodyA.c_velocity.v;let s=this.m_bodyA.c_velocity.w;const o=this.m_bodyB.c_velocity.v;let n=this.m_bodyB.c_velocity.w;const r=this.m_bodyC.c_velocity.v;let m=this.m_bodyC.c_velocity.w;const h=this.m_bodyD.c_velocity.v;let a=this.m_bodyD.c_velocity.w,c=i.dot(this.m_JvAC,e)-i.dot(this.m_JvAC,r)+i.dot(this.m_JvBD,o)-i.dot(this.m_JvBD,h);c+=this.m_JwA*s-this.m_JwC*m+(this.m_JwB*n-this.m_JwD*a);const l=-this.m_mass*c;this.m_impulse+=l,e.addMul(this.m_mA*l,this.m_JvAC),s+=this.m_iA*l*this.m_JwA,o.addMul(this.m_mB*l,this.m_JvBD),n+=this.m_iB*l*this.m_JwB,r.subMul(this.m_mC*l,this.m_JvAC),m-=this.m_iC*l*this.m_JwC,h.subMul(this.m_mD*l,this.m_JvBD),a-=this.m_iD*l*this.m_JwD,this.m_bodyA.c_velocity.v.setVec2(e),this.m_bodyA.c_velocity.w=s,this.m_bodyB.c_velocity.v.setVec2(o),this.m_bodyB.c_velocity.w=n,this.m_bodyC.c_velocity.v.setVec2(r),this.m_bodyC.c_velocity.w=m,this.m_bodyD.c_velocity.v.setVec2(h),this.m_bodyD.c_velocity.w=a}solvePositionConstraints(t){const e=this.m_bodyA.c_position.c;let s=this.m_bodyA.c_position.a;const o=this.m_bodyB.c_position.c;let n=this.m_bodyB.c_position.a;const m=this.m_bodyC.c_position.c;let h=this.m_bodyC.c_position.a;const a=this.m_bodyD.c_position.c;let c=this.m_bodyD.c_position.a;const l=E.neo(s),_=E.neo(n),u=E.neo(h),d=E.neo(c);let y,p,x,A,g,v,b,f,B=0;if(this.m_type1==Ks.TYPE)x=i.zero(),g=1,b=1,B+=this.m_iA+this.m_iC,y=s-h-this.m_referenceAngleA;else{const t=E.mulVec2(u,this.m_localAxisC),s=E.mulSub(u,this.m_localAnchorC,this.m_lcC),o=E.mulSub(l,this.m_localAnchorA,this.m_lcA);x=t,b=i.crossVec2Vec2(s,t),g=i.crossVec2Vec2(o,t),B+=this.m_mC+this.m_mA+this.m_iC*b*b+this.m_iA*g*g;const n=i.sub(this.m_localAnchorC,this.m_lcC),r=E.mulTVec2(u,i.add(o,i.sub(e,m)));y=i.dot(i.sub(r,n),this.m_localAxisC)}if(this.m_type2==Ks.TYPE)A=i.zero(),v=this.m_ratio,f=this.m_ratio,B+=this.m_ratio*this.m_ratio*(this.m_iB+this.m_iD),p=n-c-this.m_referenceAngleB;else{const t=E.mulVec2(d,this.m_localAxisD),e=E.mulSub(d,this.m_localAnchorD,this.m_lcD),s=E.mulSub(_,this.m_localAnchorB,this.m_lcB);A=i.mulNumVec2(this.m_ratio,t),f=this.m_ratio*i.crossVec2Vec2(e,t),v=this.m_ratio*i.crossVec2Vec2(s,t),B+=this.m_ratio*this.m_ratio*(this.m_mD+this.m_mB)+this.m_iD*f*f+this.m_iB*v*v;const n=i.sub(this.m_localAnchorD,this.m_lcD),r=E.mulTVec2(d,i.add(s,i.sub(o,a)));p=i.dot(r,this.m_localAxisD)-i.dot(n,this.m_localAxisD)}const w=y+this.m_ratio*p-this.m_constant;let V=0;return B>0&&(V=-w/B),e.addMul(this.m_mA*V,x),s+=this.m_iA*V*g,o.addMul(this.m_mB*V,A),n+=this.m_iB*V*v,m.subMul(this.m_mC*V,x),h-=this.m_iC*V*b,a.subMul(this.m_mD*V,A),c-=this.m_iD*V*f,this.m_bodyA.c_position.c.setVec2(e),this.m_bodyA.c_position.a=s,this.m_bodyB.c_position.c.setVec2(o),this.m_bodyB.c_position.a=n,this.m_bodyC.c_position.c.setVec2(m),this.m_bodyC.c_position.a=h,this.m_bodyD.c_position.c.setVec2(a),this.m_bodyD.c_position.a=c,0<r.linearSlop}}Qs.TYPE="gear-joint";const $s={maxForce:1,maxTorque:1,correctionFactor:.3};class ti extends ut{constructor(t,o,n){super(t=e(t,$s),o,n),o=this.m_bodyA,n=this.m_bodyB,this.m_type=ti.TYPE,this.m_linearOffset=s.isFinite(t.linearOffset)?t.linearOffset:o.getLocalPoint(n.getPosition()),this.m_angularOffset=s.isFinite(t.angularOffset)?t.angularOffset:n.getAngle()-o.getAngle(),this.m_linearImpulse=i.zero(),this.m_angularImpulse=0,this.m_maxForce=t.maxForce,this.m_maxTorque=t.maxTorque,this.m_correctionFactor=t.correctionFactor}_serialize(){return{type:this.m_type,bodyA:this.m_bodyA,bodyB:this.m_bodyB,collideConnected:this.m_collideConnected,maxForce:this.m_maxForce,maxTorque:this.m_maxTorque,correctionFactor:this.m_correctionFactor,linearOffset:this.m_linearOffset,angularOffset:this.m_angularOffset}}static _deserialize(t,e,s){(t=Object.assign({},t)).bodyA=s(lt,t.bodyA,e),t.bodyB=s(lt,t.bodyB,e);return new ti(t)}_setAnchors(t){}setMaxForce(t){this.m_maxForce=t}getMaxForce(){return this.m_maxForce}setMaxTorque(t){this.m_maxTorque=t}getMaxTorque(){return this.m_maxTorque}setCorrectionFactor(t){this.m_correctionFactor=t}getCorrectionFactor(){return this.m_correctionFactor}setLinearOffset(t){t.x==this.m_linearOffset.x&&t.y==this.m_linearOffset.y||(this.m_bodyA.setAwake(!0),this.m_bodyB.setAwake(!0),this.m_linearOffset=t)}getLinearOffset(){return this.m_linearOffset}setAngularOffset(t){t!=this.m_angularOffset&&(this.m_bodyA.setAwake(!0),this.m_bodyB.setAwake(!0),this.m_angularOffset=t)}getAngularOffset(){return this.m_angularOffset}getAnchorA(){return this.m_bodyA.getPosition()}getAnchorB(){return this.m_bodyB.getPosition()}getReactionForce(t){return i.mulNumVec2(t,this.m_linearImpulse)}getReactionTorque(t){return t*this.m_angularImpulse}initVelocityConstraints(t){this.m_localCenterA=this.m_bodyA.m_sweep.localCenter,this.m_localCenterB=this.m_bodyB.m_sweep.localCenter,this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=this.m_bodyA.c_position.c,s=this.m_bodyA.c_position.a,o=this.m_bodyA.c_velocity.v;let n=this.m_bodyA.c_velocity.w;const r=this.m_bodyB.c_position.c,m=this.m_bodyB.c_position.a,h=this.m_bodyB.c_velocity.v;let a=this.m_bodyB.c_velocity.w;const c=E.neo(s),l=E.neo(m);this.m_rA=E.mulVec2(c,i.sub(this.m_linearOffset,this.m_localCenterA)),this.m_rB=E.mulVec2(l,i.neg(this.m_localCenterB));const _=this.m_invMassA,u=this.m_invMassB,d=this.m_invIA,y=this.m_invIB,p=new Ae;if(p.ex.x=_+u+d*this.m_rA.y*this.m_rA.y+y*this.m_rB.y*this.m_rB.y,p.ex.y=-d*this.m_rA.x*this.m_rA.y-y*this.m_rB.x*this.m_rB.y,p.ey.x=p.ex.y,p.ey.y=_+u+d*this.m_rA.x*this.m_rA.x+y*this.m_rB.x*this.m_rB.x,this.m_linearMass=p.getInverse(),this.m_angularMass=d+y,this.m_angularMass>0&&(this.m_angularMass=1/this.m_angularMass),this.m_linearError=i.zero(),this.m_linearError.addCombine(1,r,1,this.m_rB),this.m_linearError.subCombine(1,e,1,this.m_rA),this.m_angularError=m-s-this.m_angularOffset,t.warmStarting){this.m_linearImpulse.mul(t.dtRatio),this.m_angularImpulse*=t.dtRatio;const e=i.neo(this.m_linearImpulse.x,this.m_linearImpulse.y);o.subMul(_,e),n-=d*(i.crossVec2Vec2(this.m_rA,e)+this.m_angularImpulse),h.addMul(u,e),a+=y*(i.crossVec2Vec2(this.m_rB,e)+this.m_angularImpulse)}else this.m_linearImpulse.setZero(),this.m_angularImpulse=0;this.m_bodyA.c_velocity.v=o,this.m_bodyA.c_velocity.w=n,this.m_bodyB.c_velocity.v=h,this.m_bodyB.c_velocity.w=a}solveVelocityConstraints(t){const e=this.m_bodyA.c_velocity.v;let o=this.m_bodyA.c_velocity.w;const n=this.m_bodyB.c_velocity.v;let r=this.m_bodyB.c_velocity.w;const m=this.m_invMassA,h=this.m_invMassB,a=this.m_invIA,c=this.m_invIB,l=t.dt,_=t.inv_dt;{const t=r-o+_*this.m_correctionFactor*this.m_angularError;let e=-this.m_angularMass*t;const i=this.m_angularImpulse,n=l*this.m_maxTorque;this.m_angularImpulse=s.clamp(this.m_angularImpulse+e,-n,n),e=this.m_angularImpulse-i,o-=a*e,r+=c*e}{const t=i.zero();t.addCombine(1,n,1,i.crossNumVec2(r,this.m_rB)),t.subCombine(1,e,1,i.crossNumVec2(o,this.m_rA)),t.addMul(_*this.m_correctionFactor,this.m_linearError);let s=i.neg(Ae.mulVec2(this.m_linearMass,t));const u=i.clone(this.m_linearImpulse);this.m_linearImpulse.add(s);const d=l*this.m_maxForce;this.m_linearImpulse.clamp(d),s=i.sub(this.m_linearImpulse,u),e.subMul(m,s),o-=a*i.crossVec2Vec2(this.m_rA,s),n.addMul(h,s),r+=c*i.crossVec2Vec2(this.m_rB,s)}this.m_bodyA.c_velocity.v=e,this.m_bodyA.c_velocity.w=o,this.m_bodyB.c_velocity.v=n,this.m_bodyB.c_velocity.w=r}solvePositionConstraints(t){return!0}}ti.TYPE="motor-joint";const ei={maxForce:0,frequencyHz:5,dampingRatio:.7};class si extends ut{constructor(t,s,o,n){super(t=e(t,ei),s,o),s=this.m_bodyA,o=this.m_bodyB,this.m_type=si.TYPE,i.isValid(n)?this.m_targetA=i.clone(n):i.isValid(t.target)?this.m_targetA=i.clone(t.target):this.m_targetA=i.zero(),this.m_localAnchorB=W.mulTVec2(o.getTransform(),this.m_targetA),this.m_maxForce=t.maxForce,this.m_impulse=i.zero(),this.m_frequencyHz=t.frequencyHz,this.m_dampingRatio=t.dampingRatio,this.m_beta=0,this.m_gamma=0,this.m_rB=i.zero(),this.m_localCenterB=i.zero(),this.m_invMassB=0,this.m_invIB=0,this.m_mass=new Ae,this.m_C=i.zero()}_serialize(){return{type:this.m_type,bodyA:this.m_bodyA,bodyB:this.m_bodyB,collideConnected:this.m_collideConnected,target:this.m_targetA,maxForce:this.m_maxForce,frequencyHz:this.m_frequencyHz,dampingRatio:this.m_dampingRatio,_localAnchorB:this.m_localAnchorB}}static _deserialize(t,e,s){(t=Object.assign({},t)).bodyA=s(lt,t.bodyA,e),t.bodyB=s(lt,t.bodyB,e),t.target=i.clone(t.target);const o=new si(t);return t._localAnchorB&&(o.m_localAnchorB=t._localAnchorB),o}setTarget(t){i.areEqual(t,this.m_targetA)||(this.m_bodyB.setAwake(!0),this.m_targetA=i.clone(t))}getTarget(){return this.m_targetA}setMaxForce(t){this.m_maxForce=t}getMaxForce(){return this.m_maxForce}setFrequency(t){this.m_frequencyHz=t}getFrequency(){return this.m_frequencyHz}setDampingRatio(t){this.m_dampingRatio=t}getDampingRatio(){return this.m_dampingRatio}getAnchorA(){return i.clone(this.m_targetA)}getAnchorB(){return this.m_bodyB.getWorldPoint(this.m_localAnchorB)}getReactionForce(t){return i.mulNumVec2(t,this.m_impulse)}getReactionTorque(t){return 0*t}shiftOrigin(t){this.m_targetA.sub(t)}initVelocityConstraints(t){this.m_localCenterB=this.m_bodyB.m_sweep.localCenter,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIB=this.m_bodyB.m_invI;const e=this.m_bodyB.c_position,o=this.m_bodyB.c_velocity,n=e.c,r=e.a,m=o.v;let h=o.w;const a=E.neo(r),c=this.m_bodyB.getMass(),l=2*s.PI*this.m_frequencyHz,_=2*c*this.m_dampingRatio*l,u=c*(l*l),d=t.dt;this.m_gamma=d*(_+d*u),0!=this.m_gamma&&(this.m_gamma=1/this.m_gamma),this.m_beta=d*u*this.m_gamma,this.m_rB=E.mulVec2(a,i.sub(this.m_localAnchorB,this.m_localCenterB));const y=new Ae;y.ex.x=this.m_invMassB+this.m_invIB*this.m_rB.y*this.m_rB.y+this.m_gamma,y.ex.y=-this.m_invIB*this.m_rB.x*this.m_rB.y,y.ey.x=y.ex.y,y.ey.y=this.m_invMassB+this.m_invIB*this.m_rB.x*this.m_rB.x+this.m_gamma,this.m_mass=y.getInverse(),this.m_C.setVec2(n),this.m_C.addCombine(1,this.m_rB,-1,this.m_targetA),this.m_C.mul(this.m_beta),h*=.98,t.warmStarting?(this.m_impulse.mul(t.dtRatio),m.addMul(this.m_invMassB,this.m_impulse),h+=this.m_invIB*i.crossVec2Vec2(this.m_rB,this.m_impulse)):this.m_impulse.setZero(),o.v.setVec2(m),o.w=h}solveVelocityConstraints(t){const e=this.m_bodyB.c_velocity,s=i.clone(e.v);let o=e.w;const n=i.crossNumVec2(o,this.m_rB);n.add(s),n.addCombine(1,this.m_C,this.m_gamma,this.m_impulse),n.neg();let r=Ae.mulVec2(this.m_mass,n);const m=i.clone(this.m_impulse);this.m_impulse.add(r);const h=t.dt*this.m_maxForce;this.m_impulse.clamp(h),r=i.sub(this.m_impulse,m),s.addMul(this.m_invMassB,r),o+=this.m_invIB*i.crossVec2Vec2(this.m_rB,r),e.v.setVec2(s),e.w=o}solvePositionConstraints(t){return!0}}si.TYPE="mouse-joint";const ii={collideConnected:!0};class oi extends ut{constructor(t,o,n,r,m,h,a,c){super(t=e(t,ii),o,n),o=this.m_bodyA,n=this.m_bodyB,this.m_type=oi.TYPE,this.m_groundAnchorA=r||(t.groundAnchorA||i.neo(-1,1)),this.m_groundAnchorB=m||(t.groundAnchorB||i.neo(1,1)),this.m_localAnchorA=h?o.getLocalPoint(h):t.localAnchorA||i.neo(-1,0),this.m_localAnchorB=a?n.getLocalPoint(a):t.localAnchorB||i.neo(1,0),this.m_lengthA=s.isFinite(t.lengthA)?t.lengthA:i.distance(h,r),this.m_lengthB=s.isFinite(t.lengthB)?t.lengthB:i.distance(a,m),this.m_ratio=s.isFinite(c)?c:t.ratio,this.m_constant=this.m_lengthA+this.m_ratio*this.m_lengthB,this.m_impulse=0}_serialize(){return{type:this.m_type,bodyA:this.m_bodyA,bodyB:this.m_bodyB,collideConnected:this.m_collideConnected,groundAnchorA:this.m_groundAnchorA,groundAnchorB:this.m_groundAnchorB,localAnchorA:this.m_localAnchorA,localAnchorB:this.m_localAnchorB,lengthA:this.m_lengthA,lengthB:this.m_lengthB,ratio:this.m_ratio}}static _deserialize(t,e,s){(t=Object.assign({},t)).bodyA=s(lt,t.bodyA,e),t.bodyB=s(lt,t.bodyB,e);return new oi(t)}getGroundAnchorA(){return this.m_groundAnchorA}getGroundAnchorB(){return this.m_groundAnchorB}getLengthA(){return this.m_lengthA}getLengthB(){return this.m_lengthB}getRatio(){return this.m_ratio}getCurrentLengthA(){const t=this.m_bodyA.getWorldPoint(this.m_localAnchorA),e=this.m_groundAnchorA;return i.distance(t,e)}getCurrentLengthB(){const t=this.m_bodyB.getWorldPoint(this.m_localAnchorB),e=this.m_groundAnchorB;return i.distance(t,e)}shiftOrigin(t){this.m_groundAnchorA.sub(t),this.m_groundAnchorB.sub(t)}getAnchorA(){return this.m_bodyA.getWorldPoint(this.m_localAnchorA)}getAnchorB(){return this.m_bodyB.getWorldPoint(this.m_localAnchorB)}getReactionForce(t){return i.mulNumVec2(this.m_impulse,this.m_uB).mul(t)}getReactionTorque(t){return 0}initVelocityConstraints(t){this.m_localCenterA=this.m_bodyA.m_sweep.localCenter,this.m_localCenterB=this.m_bodyB.m_sweep.localCenter,this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=this.m_bodyA.c_position.c,s=this.m_bodyA.c_position.a,o=this.m_bodyA.c_velocity.v;let n=this.m_bodyA.c_velocity.w;const m=this.m_bodyB.c_position.c,h=this.m_bodyB.c_position.a,a=this.m_bodyB.c_velocity.v;let c=this.m_bodyB.c_velocity.w;const l=E.neo(s),_=E.neo(h);this.m_rA=E.mulVec2(l,i.sub(this.m_localAnchorA,this.m_localCenterA)),this.m_rB=E.mulVec2(_,i.sub(this.m_localAnchorB,this.m_localCenterB)),this.m_uA=i.sub(i.add(e,this.m_rA),this.m_groundAnchorA),this.m_uB=i.sub(i.add(m,this.m_rB),this.m_groundAnchorB);const u=this.m_uA.length(),d=this.m_uB.length();u>10*r.linearSlop?this.m_uA.mul(1/u):this.m_uA.setZero(),d>10*r.linearSlop?this.m_uB.mul(1/d):this.m_uB.setZero();const y=i.crossVec2Vec2(this.m_rA,this.m_uA),p=i.crossVec2Vec2(this.m_rB,this.m_uB),x=this.m_invMassA+this.m_invIA*y*y,A=this.m_invMassB+this.m_invIB*p*p;if(this.m_mass=x+this.m_ratio*this.m_ratio*A,this.m_mass>0&&(this.m_mass=1/this.m_mass),t.warmStarting){this.m_impulse*=t.dtRatio;const e=i.mulNumVec2(-this.m_impulse,this.m_uA),s=i.mulNumVec2(-this.m_ratio*this.m_impulse,this.m_uB);o.addMul(this.m_invMassA,e),n+=this.m_invIA*i.crossVec2Vec2(this.m_rA,e),a.addMul(this.m_invMassB,s),c+=this.m_invIB*i.crossVec2Vec2(this.m_rB,s)}else this.m_impulse=0;this.m_bodyA.c_velocity.v=o,this.m_bodyA.c_velocity.w=n,this.m_bodyB.c_velocity.v=a,this.m_bodyB.c_velocity.w=c}solveVelocityConstraints(t){const e=this.m_bodyA.c_velocity.v;let s=this.m_bodyA.c_velocity.w;const o=this.m_bodyB.c_velocity.v;let n=this.m_bodyB.c_velocity.w;const r=i.add(e,i.crossNumVec2(s,this.m_rA)),m=i.add(o,i.crossNumVec2(n,this.m_rB)),h=-i.dot(this.m_uA,r)-this.m_ratio*i.dot(this.m_uB,m),a=-this.m_mass*h;this.m_impulse+=a;const c=i.mulNumVec2(-a,this.m_uA),l=i.mulNumVec2(-this.m_ratio*a,this.m_uB);e.addMul(this.m_invMassA,c),s+=this.m_invIA*i.crossVec2Vec2(this.m_rA,c),o.addMul(this.m_invMassB,l),n+=this.m_invIB*i.crossVec2Vec2(this.m_rB,l),this.m_bodyA.c_velocity.v=e,this.m_bodyA.c_velocity.w=s,this.m_bodyB.c_velocity.v=o,this.m_bodyB.c_velocity.w=n}solvePositionConstraints(t){const e=this.m_bodyA.c_position.c;let o=this.m_bodyA.c_position.a;const n=this.m_bodyB.c_position.c;let m=this.m_bodyB.c_position.a;const h=E.neo(o),a=E.neo(m),c=E.mulVec2(h,i.sub(this.m_localAnchorA,this.m_localCenterA)),l=E.mulVec2(a,i.sub(this.m_localAnchorB,this.m_localCenterB)),_=i.sub(i.add(e,this.m_rA),this.m_groundAnchorA),u=i.sub(i.add(n,this.m_rB),this.m_groundAnchorB),d=_.length(),y=u.length();d>10*r.linearSlop?_.mul(1/d):_.setZero(),y>10*r.linearSlop?u.mul(1/y):u.setZero();const p=i.crossVec2Vec2(c,_),x=i.crossVec2Vec2(l,u),A=this.m_invMassA+this.m_invIA*p*p,g=this.m_invMassB+this.m_invIB*x*x;let v=A+this.m_ratio*this.m_ratio*g;v>0&&(v=1/v);const b=this.m_constant-d-this.m_ratio*y,f=s.abs(b),B=-v*b,w=i.mulNumVec2(-B,_),V=i.mulNumVec2(-this.m_ratio*B,u);return e.addMul(this.m_invMassA,w),o+=this.m_invIA*i.crossVec2Vec2(c,w),n.addMul(this.m_invMassB,V),m+=this.m_invIB*i.crossVec2Vec2(l,V),this.m_bodyA.c_position.c=e,this.m_bodyA.c_position.a=o,this.m_bodyB.c_position.c=n,this.m_bodyB.c_position.a=m,f<r.linearSlop}}oi.TYPE="pulley-joint";const ni={maxLength:0};class ri extends ut{constructor(t,s,o,n){super(t=e(t,ni),s,o),s=this.m_bodyA,o=this.m_bodyB,this.m_type=ri.TYPE,this.m_localAnchorA=n?s.getLocalPoint(n):t.localAnchorA||i.neo(-1,0),this.m_localAnchorB=n?o.getLocalPoint(n):t.localAnchorB||i.neo(1,0),this.m_maxLength=t.maxLength,this.m_mass=0,this.m_impulse=0,this.m_length=0,this.m_state=0}_serialize(){return{type:this.m_type,bodyA:this.m_bodyA,bodyB:this.m_bodyB,collideConnected:this.m_collideConnected,localAnchorA:this.m_localAnchorA,localAnchorB:this.m_localAnchorB,maxLength:this.m_maxLength}}static _deserialize(t,e,s){(t=Object.assign({},t)).bodyA=s(lt,t.bodyA,e),t.bodyB=s(lt,t.bodyB,e);return new ri(t)}getLocalAnchorA(){return this.m_localAnchorA}getLocalAnchorB(){return this.m_localAnchorB}setMaxLength(t){this.m_maxLength=t}getMaxLength(){return this.m_maxLength}getLimitState(){return this.m_state}getAnchorA(){return this.m_bodyA.getWorldPoint(this.m_localAnchorA)}getAnchorB(){return this.m_bodyB.getWorldPoint(this.m_localAnchorB)}getReactionForce(t){return i.mulNumVec2(this.m_impulse,this.m_u).mul(t)}getReactionTorque(t){return 0}initVelocityConstraints(t){this.m_localCenterA=this.m_bodyA.m_sweep.localCenter,this.m_localCenterB=this.m_bodyB.m_sweep.localCenter,this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=this.m_bodyA.c_position.c,s=this.m_bodyA.c_position.a,o=this.m_bodyA.c_velocity.v;let n=this.m_bodyA.c_velocity.w;const m=this.m_bodyB.c_position.c,h=this.m_bodyB.c_position.a,a=this.m_bodyB.c_velocity.v;let c=this.m_bodyB.c_velocity.w;const l=E.neo(s),_=E.neo(h);this.m_rA=E.mulSub(l,this.m_localAnchorA,this.m_localCenterA),this.m_rB=E.mulSub(_,this.m_localAnchorB,this.m_localCenterB),this.m_u=i.zero(),this.m_u.addCombine(1,m,1,this.m_rB),this.m_u.subCombine(1,e,1,this.m_rA),this.m_length=this.m_u.length();const u=this.m_length-this.m_maxLength;if(this.m_state=u>0?2:0,!(this.m_length>r.linearSlop))return this.m_u.setZero(),this.m_mass=0,void(this.m_impulse=0);this.m_u.mul(1/this.m_length);const d=i.crossVec2Vec2(this.m_rA,this.m_u),y=i.crossVec2Vec2(this.m_rB,this.m_u),p=this.m_invMassA+this.m_invIA*d*d+this.m_invMassB+this.m_invIB*y*y;if(this.m_mass=0!=p?1/p:0,t.warmStarting){this.m_impulse*=t.dtRatio;const e=i.mulNumVec2(this.m_impulse,this.m_u);o.subMul(this.m_invMassA,e),n-=this.m_invIA*i.crossVec2Vec2(this.m_rA,e),a.addMul(this.m_invMassB,e),c+=this.m_invIB*i.crossVec2Vec2(this.m_rB,e)}else this.m_impulse=0;this.m_bodyA.c_velocity.v.setVec2(o),this.m_bodyA.c_velocity.w=n,this.m_bodyB.c_velocity.v.setVec2(a),this.m_bodyB.c_velocity.w=c}solveVelocityConstraints(t){const e=this.m_bodyA.c_velocity.v;let o=this.m_bodyA.c_velocity.w;const n=this.m_bodyB.c_velocity.v;let r=this.m_bodyB.c_velocity.w;const m=i.addCrossNumVec2(e,o,this.m_rA),h=i.addCrossNumVec2(n,r,this.m_rB),a=this.m_length-this.m_maxLength;let c=i.dot(this.m_u,i.sub(h,m));a<0&&(c+=t.inv_dt*a);let l=-this.m_mass*c;const _=this.m_impulse;this.m_impulse=s.min(0,this.m_impulse+l),l=this.m_impulse-_;const u=i.mulNumVec2(l,this.m_u);e.subMul(this.m_invMassA,u),o-=this.m_invIA*i.crossVec2Vec2(this.m_rA,u),n.addMul(this.m_invMassB,u),r+=this.m_invIB*i.crossVec2Vec2(this.m_rB,u),this.m_bodyA.c_velocity.v=e,this.m_bodyA.c_velocity.w=o,this.m_bodyB.c_velocity.v=n,this.m_bodyB.c_velocity.w=r}solvePositionConstraints(t){const e=this.m_bodyA.c_position.c;let o=this.m_bodyA.c_position.a;const n=this.m_bodyB.c_position.c;let m=this.m_bodyB.c_position.a;const h=E.neo(o),a=E.neo(m),c=E.mulSub(h,this.m_localAnchorA,this.m_localCenterA),l=E.mulSub(a,this.m_localAnchorB,this.m_localCenterB),_=i.zero();_.addCombine(1,n,1,l),_.subCombine(1,e,1,c);const u=_.normalize();let d=u-this.m_maxLength;d=s.clamp(d,0,r.maxLinearCorrection);const y=-this.m_mass*d,p=i.mulNumVec2(y,_);return e.subMul(this.m_invMassA,p),o-=this.m_invIA*i.crossVec2Vec2(c,p),n.addMul(this.m_invMassB,p),m+=this.m_invIB*i.crossVec2Vec2(l,p),this.m_bodyA.c_position.c.setVec2(e),this.m_bodyA.c_position.a=o,this.m_bodyB.c_position.c.setVec2(n),this.m_bodyB.c_position.a=m,u-this.m_maxLength<r.linearSlop}}ri.TYPE="rope-joint";const mi={frequencyHz:0,dampingRatio:0};class hi extends ut{constructor(t,o,n,r){super(t=e(t,mi),o,n),o=this.m_bodyA,n=this.m_bodyB,this.m_type=hi.TYPE,this.m_localAnchorA=i.clone(r?o.getLocalPoint(r):t.localAnchorA||i.zero()),this.m_localAnchorB=i.clone(r?n.getLocalPoint(r):t.localAnchorB||i.zero()),this.m_referenceAngle=s.isFinite(t.referenceAngle)?t.referenceAngle:n.getAngle()-o.getAngle(),this.m_frequencyHz=t.frequencyHz,this.m_dampingRatio=t.dampingRatio,this.m_impulse=new vs,this.m_bias=0,this.m_gamma=0,this.m_rA,this.m_rB,this.m_localCenterA,this.m_localCenterB,this.m_invMassA,this.m_invMassB,this.m_invIA,this.m_invIB,this.m_mass=new Hs}_serialize(){return{type:this.m_type,bodyA:this.m_bodyA,bodyB:this.m_bodyB,collideConnected:this.m_collideConnected,frequencyHz:this.m_frequencyHz,dampingRatio:this.m_dampingRatio,localAnchorA:this.m_localAnchorA,localAnchorB:this.m_localAnchorB,referenceAngle:this.m_referenceAngle}}static _deserialize(t,e,s){(t=Object.assign({},t)).bodyA=s(lt,t.bodyA,e),t.bodyB=s(lt,t.bodyB,e);return new hi(t)}_setAnchors(t){t.anchorA?this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(t.anchorA)):t.localAnchorA&&this.m_localAnchorA.setVec2(t.localAnchorA),t.anchorB?this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(t.anchorB)):t.localAnchorB&&this.m_localAnchorB.setVec2(t.localAnchorB)}getLocalAnchorA(){return this.m_localAnchorA}getLocalAnchorB(){return this.m_localAnchorB}getReferenceAngle(){return this.m_referenceAngle}setFrequency(t){this.m_frequencyHz=t}getFrequency(){return this.m_frequencyHz}setDampingRatio(t){this.m_dampingRatio=t}getDampingRatio(){return this.m_dampingRatio}getAnchorA(){return this.m_bodyA.getWorldPoint(this.m_localAnchorA)}getAnchorB(){return this.m_bodyB.getWorldPoint(this.m_localAnchorB)}getReactionForce(t){return i.neo(this.m_impulse.x,this.m_impulse.y).mul(t)}getReactionTorque(t){return t*this.m_impulse.z}initVelocityConstraints(t){this.m_localCenterA=this.m_bodyA.m_sweep.localCenter,this.m_localCenterB=this.m_bodyB.m_sweep.localCenter,this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=this.m_bodyA.c_position.a,o=this.m_bodyA.c_velocity.v;let n=this.m_bodyA.c_velocity.w;const r=this.m_bodyB.c_position.a,m=this.m_bodyB.c_velocity.v;let h=this.m_bodyB.c_velocity.w;const a=E.neo(e),c=E.neo(r);this.m_rA=E.mulVec2(a,i.sub(this.m_localAnchorA,this.m_localCenterA)),this.m_rB=E.mulVec2(c,i.sub(this.m_localAnchorB,this.m_localCenterB));const l=this.m_invMassA,_=this.m_invMassB,u=this.m_invIA,d=this.m_invIB,y=new Hs;if(y.ex.x=l+_+this.m_rA.y*this.m_rA.y*u+this.m_rB.y*this.m_rB.y*d,y.ey.x=-this.m_rA.y*this.m_rA.x*u-this.m_rB.y*this.m_rB.x*d,y.ez.x=-this.m_rA.y*u-this.m_rB.y*d,y.ex.y=y.ey.x,y.ey.y=l+_+this.m_rA.x*this.m_rA.x*u+this.m_rB.x*this.m_rB.x*d,y.ez.y=this.m_rA.x*u+this.m_rB.x*d,y.ex.z=y.ez.x,y.ey.z=y.ez.y,y.ez.z=u+d,this.m_frequencyHz>0){y.getInverse22(this.m_mass);let i=u+d;const o=i>0?1/i:0,n=r-e-this.m_referenceAngle,m=2*s.PI*this.m_frequencyHz,h=2*o*this.m_dampingRatio*m,a=o*m*m,c=t.dt;this.m_gamma=c*(h+c*a),this.m_gamma=0!=this.m_gamma?1/this.m_gamma:0,this.m_bias=n*c*a*this.m_gamma,i+=this.m_gamma,this.m_mass.ez.z=0!=i?1/i:0}else 0==y.ez.z?(y.getInverse22(this.m_mass),this.m_gamma=0,this.m_bias=0):(y.getSymInverse33(this.m_mass),this.m_gamma=0,this.m_bias=0);if(t.warmStarting){this.m_impulse.mul(t.dtRatio);const e=i.neo(this.m_impulse.x,this.m_impulse.y);o.subMul(l,e),n-=u*(i.crossVec2Vec2(this.m_rA,e)+this.m_impulse.z),m.addMul(_,e),h+=d*(i.crossVec2Vec2(this.m_rB,e)+this.m_impulse.z)}else this.m_impulse.setZero();this.m_bodyA.c_velocity.v=o,this.m_bodyA.c_velocity.w=n,this.m_bodyB.c_velocity.v=m,this.m_bodyB.c_velocity.w=h}solveVelocityConstraints(t){const e=this.m_bodyA.c_velocity.v;let s=this.m_bodyA.c_velocity.w;const o=this.m_bodyB.c_velocity.v;let n=this.m_bodyB.c_velocity.w;const r=this.m_invMassA,m=this.m_invMassB,h=this.m_invIA,a=this.m_invIB;if(this.m_frequencyHz>0){const t=n-s,c=-this.m_mass.ez.z*(t+this.m_bias+this.m_gamma*this.m_impulse.z);this.m_impulse.z+=c,s-=h*c,n+=a*c;const l=i.zero();l.addCombine(1,o,1,i.crossNumVec2(n,this.m_rB)),l.subCombine(1,e,1,i.crossNumVec2(s,this.m_rA));const _=i.neg(Hs.mulVec2(this.m_mass,l));this.m_impulse.x+=_.x,this.m_impulse.y+=_.y;const u=i.clone(_);e.subMul(r,u),s-=h*i.crossVec2Vec2(this.m_rA,u),o.addMul(m,u),n+=a*i.crossVec2Vec2(this.m_rB,u)}else{const t=i.zero();t.addCombine(1,o,1,i.crossNumVec2(n,this.m_rB)),t.subCombine(1,e,1,i.crossNumVec2(s,this.m_rA));const c=n-s,l=new vs(t.x,t.y,c),_=vs.neg(Hs.mulVec3(this.m_mass,l));this.m_impulse.add(_);const u=i.neo(_.x,_.y);e.subMul(r,u),s-=h*(i.crossVec2Vec2(this.m_rA,u)+_.z),o.addMul(m,u),n+=a*(i.crossVec2Vec2(this.m_rB,u)+_.z)}this.m_bodyA.c_velocity.v=e,this.m_bodyA.c_velocity.w=s,this.m_bodyB.c_velocity.v=o,this.m_bodyB.c_velocity.w=n}solvePositionConstraints(t){const e=this.m_bodyA.c_position.c;let o=this.m_bodyA.c_position.a;const n=this.m_bodyB.c_position.c;let m=this.m_bodyB.c_position.a;const h=E.neo(o),a=E.neo(m),c=this.m_invMassA,l=this.m_invMassB,_=this.m_invIA,u=this.m_invIB,d=E.mulVec2(h,i.sub(this.m_localAnchorA,this.m_localCenterA)),y=E.mulVec2(a,i.sub(this.m_localAnchorB,this.m_localCenterB));let p,x;const A=new Hs;if(A.ex.x=c+l+d.y*d.y*_+y.y*y.y*u,A.ey.x=-d.y*d.x*_-y.y*y.x*u,A.ez.x=-d.y*_-y.y*u,A.ex.y=A.ey.x,A.ey.y=c+l+d.x*d.x*_+y.x*y.x*u,A.ez.y=d.x*_+y.x*u,A.ex.z=A.ez.x,A.ey.z=A.ez.y,A.ez.z=_+u,this.m_frequencyHz>0){const t=i.zero();t.addCombine(1,n,1,y),t.subCombine(1,e,1,d),p=t.length(),x=0;const s=i.neg(A.solve22(t));e.subMul(c,s),o-=_*i.crossVec2Vec2(d,s),n.addMul(l,s),m+=u*i.crossVec2Vec2(y,s)}else{const t=i.zero();t.addCombine(1,n,1,y),t.subCombine(1,e,1,d);const r=m-o-this.m_referenceAngle;p=t.length(),x=s.abs(r);const h=new vs(t.x,t.y,r);let a=new vs;if(A.ez.z>0)a=vs.neg(A.solve33(h));else{const e=i.neg(A.solve22(t));a.set(e.x,e.y,0)}const g=i.neo(a.x,a.y);e.subMul(c,g),o-=_*(i.crossVec2Vec2(d,g)+a.z),n.addMul(l,g),m+=u*(i.crossVec2Vec2(y,g)+a.z)}return this.m_bodyA.c_position.c=e,this.m_bodyA.c_position.a=o,this.m_bodyB.c_position.c=n,this.m_bodyB.c_position.a=m,p<=r.linearSlop&&x<=r.angularSlop}}hi.TYPE="weld-joint";const ai={enableMotor:!1,maxMotorTorque:0,motorSpeed:0,frequencyHz:2,dampingRatio:.7};class ci extends ut{constructor(t,s,o,n,r){super(t=e(t,ai),s,o),this.m_ax=i.zero(),this.m_ay=i.zero(),s=this.m_bodyA,o=this.m_bodyB,this.m_type=ci.TYPE,this.m_localAnchorA=i.clone(n?s.getLocalPoint(n):t.localAnchorA||i.zero()),this.m_localAnchorB=i.clone(n?o.getLocalPoint(n):t.localAnchorB||i.zero()),this.m_localXAxisA=i.clone(r?s.getLocalVector(r):t.localAxisA||t.localAxis||i.neo(1,0)),this.m_localYAxisA=i.crossNumVec2(1,this.m_localXAxisA),this.m_mass=0,this.m_impulse=0,this.m_motorMass=0,this.m_motorImpulse=0,this.m_springMass=0,this.m_springImpulse=0,this.m_maxMotorTorque=t.maxMotorTorque,this.m_motorSpeed=t.motorSpeed,this.m_enableMotor=t.enableMotor,this.m_frequencyHz=t.frequencyHz,this.m_dampingRatio=t.dampingRatio,this.m_bias=0,this.m_gamma=0}_serialize(){return{type:this.m_type,bodyA:this.m_bodyA,bodyB:this.m_bodyB,collideConnected:this.m_collideConnected,enableMotor:this.m_enableMotor,maxMotorTorque:this.m_maxMotorTorque,motorSpeed:this.m_motorSpeed,frequencyHz:this.m_frequencyHz,dampingRatio:this.m_dampingRatio,localAnchorA:this.m_localAnchorA,localAnchorB:this.m_localAnchorB,localAxisA:this.m_localXAxisA}}static _deserialize(t,e,s){(t=Object.assign({},t)).bodyA=s(lt,t.bodyA,e),t.bodyB=s(lt,t.bodyB,e);return new ci(t)}_setAnchors(t){t.anchorA?this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(t.anchorA)):t.localAnchorA&&this.m_localAnchorA.setVec2(t.localAnchorA),t.anchorB?this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(t.anchorB)):t.localAnchorB&&this.m_localAnchorB.setVec2(t.localAnchorB),t.localAxisA&&(this.m_localXAxisA.setVec2(t.localAxisA),this.m_localYAxisA.setVec2(i.crossNumVec2(1,t.localAxisA)))}getLocalAnchorA(){return this.m_localAnchorA}getLocalAnchorB(){return this.m_localAnchorB}getLocalAxisA(){return this.m_localXAxisA}getJointTranslation(){const t=this.m_bodyA,e=this.m_bodyB,s=t.getWorldPoint(this.m_localAnchorA),o=e.getWorldPoint(this.m_localAnchorB),n=i.sub(o,s),r=t.getWorldVector(this.m_localXAxisA);return i.dot(n,r)}getJointSpeed(){const t=this.m_bodyA.m_angularVelocity;return this.m_bodyB.m_angularVelocity-t}isMotorEnabled(){return this.m_enableMotor}enableMotor(t){t!=this.m_enableMotor&&(this.m_bodyA.setAwake(!0),this.m_bodyB.setAwake(!0),this.m_enableMotor=t)}setMotorSpeed(t){t!=this.m_motorSpeed&&(this.m_bodyA.setAwake(!0),this.m_bodyB.setAwake(!0),this.m_motorSpeed=t)}getMotorSpeed(){return this.m_motorSpeed}setMaxMotorTorque(t){t!=this.m_maxMotorTorque&&(this.m_bodyA.setAwake(!0),this.m_bodyB.setAwake(!0),this.m_maxMotorTorque=t)}getMaxMotorTorque(){return this.m_maxMotorTorque}getMotorTorque(t){return t*this.m_motorImpulse}setSpringFrequencyHz(t){this.m_frequencyHz=t}getSpringFrequencyHz(){return this.m_frequencyHz}setSpringDampingRatio(t){this.m_dampingRatio=t}getSpringDampingRatio(){return this.m_dampingRatio}getAnchorA(){return this.m_bodyA.getWorldPoint(this.m_localAnchorA)}getAnchorB(){return this.m_bodyB.getWorldPoint(this.m_localAnchorB)}getReactionForce(t){return i.combine(this.m_impulse,this.m_ay,this.m_springImpulse,this.m_ax).mul(t)}getReactionTorque(t){return t*this.m_motorImpulse}initVelocityConstraints(t){this.m_localCenterA=this.m_bodyA.m_sweep.localCenter,this.m_localCenterB=this.m_bodyB.m_sweep.localCenter,this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=this.m_invMassA,o=this.m_invMassB,n=this.m_invIA,r=this.m_invIB,m=this.m_bodyA.c_position.c,h=this.m_bodyA.c_position.a,a=this.m_bodyA.c_velocity.v;let c=this.m_bodyA.c_velocity.w;const l=this.m_bodyB.c_position.c,_=this.m_bodyB.c_position.a,u=this.m_bodyB.c_velocity.v;let d=this.m_bodyB.c_velocity.w;const y=E.neo(h),p=E.neo(_),x=E.mulVec2(y,i.sub(this.m_localAnchorA,this.m_localCenterA)),A=E.mulVec2(p,i.sub(this.m_localAnchorB,this.m_localCenterB)),g=i.zero();if(g.addCombine(1,l,1,A),g.subCombine(1,m,1,x),this.m_ay=E.mulVec2(y,this.m_localYAxisA),this.m_sAy=i.crossVec2Vec2(i.add(g,x),this.m_ay),this.m_sBy=i.crossVec2Vec2(A,this.m_ay),this.m_mass=e+o+n*this.m_sAy*this.m_sAy+r*this.m_sBy*this.m_sBy,this.m_mass>0&&(this.m_mass=1/this.m_mass),this.m_springMass=0,this.m_bias=0,this.m_gamma=0,this.m_frequencyHz>0){this.m_ax=E.mulVec2(y,this.m_localXAxisA),this.m_sAx=i.crossVec2Vec2(i.add(g,x),this.m_ax),this.m_sBx=i.crossVec2Vec2(A,this.m_ax);const m=e+o+n*this.m_sAx*this.m_sAx+r*this.m_sBx*this.m_sBx;if(m>0){this.m_springMass=1/m;const e=i.dot(g,this.m_ax),o=2*s.PI*this.m_frequencyHz,n=2*this.m_springMass*this.m_dampingRatio*o,r=this.m_springMass*o*o,h=t.dt;this.m_gamma=h*(n+h*r),this.m_gamma>0&&(this.m_gamma=1/this.m_gamma),this.m_bias=e*h*r*this.m_gamma,this.m_springMass=m+this.m_gamma,this.m_springMass>0&&(this.m_springMass=1/this.m_springMass)}}else this.m_springImpulse=0;if(this.m_enableMotor?(this.m_motorMass=n+r,this.m_motorMass>0&&(this.m_motorMass=1/this.m_motorMass)):(this.m_motorMass=0,this.m_motorImpulse=0),t.warmStarting){this.m_impulse*=t.dtRatio,this.m_springImpulse*=t.dtRatio,this.m_motorImpulse*=t.dtRatio;const e=i.combine(this.m_impulse,this.m_ay,this.m_springImpulse,this.m_ax),s=this.m_impulse*this.m_sAy+this.m_springImpulse*this.m_sAx+this.m_motorImpulse,o=this.m_impulse*this.m_sBy+this.m_springImpulse*this.m_sBx+this.m_motorImpulse;a.subMul(this.m_invMassA,e),c-=this.m_invIA*s,u.addMul(this.m_invMassB,e),d+=this.m_invIB*o}else this.m_impulse=0,this.m_springImpulse=0,this.m_motorImpulse=0;this.m_bodyA.c_velocity.v.setVec2(a),this.m_bodyA.c_velocity.w=c,this.m_bodyB.c_velocity.v.setVec2(u),this.m_bodyB.c_velocity.w=d}solveVelocityConstraints(t){const e=this.m_invMassA,o=this.m_invMassB,n=this.m_invIA,r=this.m_invIB,m=this.m_bodyA.c_velocity.v;let h=this.m_bodyA.c_velocity.w;const a=this.m_bodyB.c_velocity.v;let c=this.m_bodyB.c_velocity.w;{const t=i.dot(this.m_ax,a)-i.dot(this.m_ax,m)+this.m_sBx*c-this.m_sAx*h,s=-this.m_springMass*(t+this.m_bias+this.m_gamma*this.m_springImpulse);this.m_springImpulse+=s;const l=i.mulNumVec2(s,this.m_ax),_=s*this.m_sAx,u=s*this.m_sBx;m.subMul(e,l),h-=n*_,a.addMul(o,l),c+=r*u}{const e=c-h-this.m_motorSpeed;let i=-this.m_motorMass*e;const o=this.m_motorImpulse,m=t.dt*this.m_maxMotorTorque;this.m_motorImpulse=s.clamp(this.m_motorImpulse+i,-m,m),i=this.m_motorImpulse-o,h-=n*i,c+=r*i}{const t=i.dot(this.m_ay,a)-i.dot(this.m_ay,m)+this.m_sBy*c-this.m_sAy*h,s=-this.m_mass*t;this.m_impulse+=s;const l=i.mulNumVec2(s,this.m_ay),_=s*this.m_sAy,u=s*this.m_sBy;m.subMul(e,l),h-=n*_,a.addMul(o,l),c+=r*u}this.m_bodyA.c_velocity.v.setVec2(m),this.m_bodyA.c_velocity.w=h,this.m_bodyB.c_velocity.v.setVec2(a),this.m_bodyB.c_velocity.w=c}solvePositionConstraints(t){const e=this.m_bodyA.c_position.c;let o=this.m_bodyA.c_position.a;const n=this.m_bodyB.c_position.c;let m=this.m_bodyB.c_position.a;const h=E.neo(o),a=E.neo(m),c=E.mulVec2(h,i.sub(this.m_localAnchorA,this.m_localCenterA)),l=E.mulVec2(a,i.sub(this.m_localAnchorB,this.m_localCenterB)),_=i.zero();_.addCombine(1,n,1,l),_.subCombine(1,e,1,c);const u=E.mulVec2(h,this.m_localYAxisA),d=i.crossVec2Vec2(i.add(_,c),u),y=i.crossVec2Vec2(l,u),p=i.dot(_,u),x=this.m_invMassA+this.m_invMassB+this.m_invIA*this.m_sAy*this.m_sAy+this.m_invIB*this.m_sBy*this.m_sBy;let A;A=0!=x?-p/x:0;const g=i.mulNumVec2(A,u),v=A*d,b=A*y;return e.subMul(this.m_invMassA,g),o-=this.m_invIA*v,n.addMul(this.m_invMassB,g),m+=this.m_invIB*b,this.m_bodyA.c_position.c.setVec2(e),this.m_bodyA.c_position.a=o,this.m_bodyB.c_position.c.setVec2(n),this.m_bodyB.c_position.a=m,s.abs(p)<=r.linearSlop}}ci.TYPE="wheel-joint";let li=0;function _i(t){const e=(t=t||{}).rootClass||gs,s=t.preSerialize||function(t){return t},o=t.postSerialize||function(t,e){return t},n=t.preDeserialize||function(t){return t},r=t.postDeserialize||function(t,e){return t},m={World:gs,Body:lt,Joint:ut,Fixture:et,Shape:U},h=Object.assign({Vec2:i,Vec3:vs},m),a={[lt.STATIC]:lt,[lt.DYNAMIC]:lt,[lt.KINEMATIC]:lt,[Ms.TYPE]:Ms,[Ns.TYPE]:Ns,[Bs.TYPE]:Bs,[qs.TYPE]:qs,[js.TYPE]:js,[Js.TYPE]:Js,[Ws.TYPE]:Ws,[Qs.TYPE]:Qs,[ti.TYPE]:ti,[si.TYPE]:si,[Xs.TYPE]:Xs,[oi.TYPE]:oi,[Ks.TYPE]:Ks,[ri.TYPE]:ri,[hi.TYPE]:hi,[ci.TYPE]:ci};this.toJson=function(t){const e=[],i=[t],n={};function r(t,s){if(t.__sid=t.__sid||++li,!n[t.__sid]){i.push(t);const o={refIndex:e.length+i.length,refType:s};n[t.__sid]=o}return n[t.__sid]}function h(t,e){if("object"!=typeof t||null===t)return t;if("function"==typeof t._serialize){if(t!==e)for(const e in m)if(t instanceof m[e])return r(t,e);t=function(t){let e=(t=s(t))._serialize();return e=o(e,t),e}(t)}if(Array.isArray(t)){const e=[];for(let s=0;s<t.length;s++)e[s]=h(t[s]);t=e}else{const e={};for(const s in t)t.hasOwnProperty(s)&&(e[s]=h(t[s]));t=e}return t}for(;i.length;){const t=i.shift(),s=h(t,t);e.push(s)}return e},this.fromJson=function(t){const s={};function i(t,e,s){const i=function(t,e){return e&&e._deserialize||(e=a[t.type]),e&&e._deserialize}(e,t);if(!i)return;let m=i(e=n(e),s,o);return m=r(m,e),m}function o(e,o,n){if(!o.refIndex)return e&&e._deserialize&&i(e,o,n);e=h[o.refType]||e;const r=o.refIndex;if(!s[r]){const o=i(e,t[r],n);s[r]=o}return s[r]}return e._deserialize(t[0],null,o)}}const ui=new _i;_i.toJson=ui.toJson,_i.fromJson=ui.fromJson,xs.addType(js.TYPE,js.TYPE,(function(t,e,s,i,o,n,r){pi(t,s.getShape(),e,n.getShape(),o)}));const di=u(0,0),yi=u(0,0),pi=function(e,s,i,o,n){e.pointCount=0,D(di,i,s.m_p),D(yi,n,o.m_p);const r=F(yi,di),m=s.m_radius+o.m_radius;r>m*m||(e.type=t.ManifoldType.e_circles,y(e.localPoint,s.m_p),p(e.localNormal),e.pointCount=1,y(e.points[0].localPoint,o.m_p),e.points[0].id.setFeatures(0,t.ContactFeatureType.e_vertex,0,t.ContactFeatureType.e_vertex))};xs.addType(Bs.TYPE,js.TYPE,(function(t,e,s,i,o,n,r){const m=s.getShape(),h=n.getShape();Bi(t,m,e,h,o)})),xs.addType(Ms.TYPE,js.TYPE,(function(t,e,s,i,o,n,r){const m=s.getShape(),h=new Bs;m.getChildEdge(h,i);const a=h,c=n.getShape();Bi(t,a,e,c,o)}));const xi=u(0,0),Ai=u(0,0),gi=u(0,0),vi=u(0,0),bi=u(0,0),fi=u(0,0),Bi=function(e,s,i,o,n){e.pointCount=0,j(vi,n,i,o.m_p);const r=s.m_vertex1,m=s.m_vertex2;v(xi,m,r);const h=P(xi,m)-P(xi,vi),a=P(xi,vi)-P(xi,r),c=s.m_radius+o.m_radius;if(a<=0){y(bi,r);if(F(vi,r)>c*c)return;if(s.m_hasVertex0){const t=s.m_vertex0,e=r;v(Ai,e,t);if(P(Ai,e)-P(Ai,vi)>0)return}return e.type=t.ManifoldType.e_circles,p(e.localNormal),y(e.localPoint,bi),e.pointCount=1,y(e.points[0].localPoint,o.m_p),void e.points[0].id.setFeatures(0,t.ContactFeatureType.e_vertex,0,t.ContactFeatureType.e_vertex)}if(h<=0){y(bi,m);if(F(vi,bi)>c*c)return;if(s.m_hasVertex3){const t=s.m_vertex3,e=m;v(gi,t,e);if(P(gi,vi)-P(gi,e)>0)return}return e.type=t.ManifoldType.e_circles,p(e.localNormal),y(e.localPoint,bi),e.pointCount=1,y(e.points[0].localPoint,o.m_p),void e.points[0].id.setFeatures(1,t.ContactFeatureType.e_vertex,0,t.ContactFeatureType.e_vertex)}const l=z(xi);V(bi,h/l,r,a/l,m);F(vi,bi)>c*c||(I(fi,1,xi),P(fi,vi)-P(fi,r)<0&&x(fi),C(fi),e.type=t.ManifoldType.e_faceA,y(e.localNormal,fi),y(e.localPoint,r),e.pointCount=1,y(e.points[0].localPoint,o.m_p),e.points[0].id.setFeatures(0,t.ContactFeatureType.e_face,0,t.ContactFeatureType.e_vertex))},wi=[new Pe,new Pe],Vi=[new Pe,new Pe],Ci=[new Pe,new Pe],Mi=u(0,0),Ii=u(0,0),Si=u(0,0),Pi=k(0,0,0),zi=u(0,0),Ti=u(0,0),Fi=u(0,0),Li=u(0,0),qi=u(0,0),ki=u(0,0),Ni=u(0,0),Di=u(0,0);function Oi(t,e,s,i,o){const n=t.m_count,r=s.m_count,m=t.m_normals,h=t.m_vertices,a=s.m_vertices;R(Pi,i,e);let c=0,l=-1/0;for(let t=0;t<n;++t){L(Si,Pi.q,m[t]),D(Ii,Pi,h[t]);let e=1/0;for(let t=0;t<r;++t){const s=P(Si,a[t])-P(Si,Ii);s<e&&(e=s)}e>l&&(l=e,c=t)}o.maxSeparation=l,o.bestIndex=c}xs.addType(qs.TYPE,qs.TYPE,(function(t,e,s,i,o,n,r){Ri(t,s.getShape(),e,n.getShape(),o)}));const ji={maxSeparation:0,bestIndex:0},Ri=function(e,s,i,o,n){e.pointCount=0;const m=s.m_radius+o.m_radius;Oi(s,i,o,n,ji);const h=ji.bestIndex,a=ji.maxSeparation;if(a>m)return;Oi(o,n,s,i,ji);const c=ji.maxSeparation;if(c>m)return;let l,_,u,p,x,A;c>a+.1*r.linearSlop?(l=o,_=s,u=n,p=i,x=ji.bestIndex,e.type=t.ManifoldType.e_faceB,A=!0):(l=s,_=o,u=i,p=n,x=h,e.type=t.ManifoldType.e_faceA,A=!1),wi[0].recycle(),wi[1].recycle(),function(e,s,i,o,n,r){const m=s.m_normals,h=n.m_count,a=n.m_vertices,c=n.m_normals;!function(t,e,s,i){const o=e.c*i.x+e.s*i.y,n=-e.s*i.x+e.c*i.y,r=s.c*o-s.s*n,m=s.s*o+s.c*n;t.x=r,t.y=m}(Di,r.q,i.q,m[o]);let l=0,_=1/0;for(let t=0;t<h;++t){const e=P(Di,c[t]);e<_&&(_=e,l=t)}const u=l,d=u+1<h?u+1:0;D(e[0].v,r,a[u]),e[0].id.setFeatures(o,t.ContactFeatureType.e_face,u,t.ContactFeatureType.e_vertex),D(e[1].v,r,a[d]),e[1].id.setFeatures(o,t.ContactFeatureType.e_face,d,t.ContactFeatureType.e_vertex)}(wi,l,u,x,_,p);const g=l.m_count,b=l.m_vertices,f=x,B=x+1<g?x+1:0;y(zi,b[f]),y(Ti,b[B]),v(Fi,Ti,zi),C(Fi),M(Li,Fi,1),V(qi,.5,zi,.5,Ti),L(ki,u.q,Fi),M(Ni,ki,1),D(zi,u,zi),D(Ti,u,Ti);const w=P(Ni,zi),I=-P(ki,zi)+m,S=P(ki,Ti)+m;Vi[0].recycle(),Vi[1].recycle(),Ci[0].recycle(),Ci[1].recycle(),d(Mi,-ki.x,-ki.y);if(ke(Vi,wi,Mi,I,f)<2)return;d(Mi,ki.x,ki.y);if(ke(Ci,Vi,Mi,S,B)<2)return;y(e.localNormal,Li),y(e.localPoint,qi);let z=0;for(let t=0;t<Ci.length;++t){if(P(Ni,Ci[t].v)-w<=m){const s=e.points[z];O(s.localPoint,p,Ci[t].v),s.id.set(Ci[t].id),A&&s.id.swapFeatures(),++z}}e.pointCount=z};xs.addType(qs.TYPE,js.TYPE,(function(t,e,s,i,o,n,r){Yi(t,s.getShape(),e,n.getShape(),o)}));const Ei=u(0,0),Ji=u(0,0),Yi=function(e,i,o,n,r){e.pointCount=0,j(Ei,r,o,n.m_p);let m=0,h=-1/0;const a=i.m_radius+n.m_radius,c=i.m_count,l=i.m_vertices,_=i.m_normals;for(let t=0;t<c;++t){const e=P(_[t],Ei)-P(_[t],l[t]);if(e>a)return;e>h&&(h=e,m=t)}const u=m,d=u+1<c?u+1:0,p=l[u],x=l[d];if(h<s.EPSILON)return e.pointCount=1,e.type=t.ManifoldType.e_faceA,y(e.localNormal,_[m]),V(e.localPoint,.5,p,.5,x),y(e.points[0].localPoint,n.m_p),void e.points[0].id.setFeatures(0,t.ContactFeatureType.e_vertex,0,t.ContactFeatureType.e_vertex);const A=P(Ei,x)-P(Ei,p)-P(p,x)+P(p,p),g=P(Ei,p)-P(Ei,x)-P(x,p)+P(x,x);if(A<=0){if(F(Ei,p)>a*a)return;e.pointCount=1,e.type=t.ManifoldType.e_faceA,v(e.localNormal,Ei,p),C(e.localNormal),y(e.localPoint,p),y(e.points[0].localPoint,n.m_p),e.points[0].id.setFeatures(0,t.ContactFeatureType.e_vertex,0,t.ContactFeatureType.e_vertex)}else if(g<=0){if(F(Ei,x)>a*a)return;e.pointCount=1,e.type=t.ManifoldType.e_faceA,v(e.localNormal,Ei,x),C(e.localNormal),y(e.localPoint,x),y(e.points[0].localPoint,n.m_p),e.points[0].id.setFeatures(0,t.ContactFeatureType.e_vertex,0,t.ContactFeatureType.e_vertex)}else{V(Ji,.5,p,.5,x);if(P(Ei,_[u])-P(Ji,_[u])>a)return;e.pointCount=1,e.type=t.ManifoldType.e_faceA,y(e.localNormal,_[u]),y(e.localPoint,Ji),y(e.points[0].localPoint,n.m_p),e.points[0].id.setFeatures(0,t.ContactFeatureType.e_vertex,0,t.ContactFeatureType.e_vertex)}};xs.addType(Bs.TYPE,qs.TYPE,(function(t,e,s,i,o,n,r){po(t,s.getShape(),e,n.getShape(),o)})),xs.addType(Ms.TYPE,qs.TYPE,(function(t,e,s,i,o,n,r){s.getShape().getChildEdge(Wi,i),po(t,Wi,e,n.getShape(),o)}));const Wi=new Bs;var Hi,Zi;!function(t){t[t.e_unknown=-1]="e_unknown",t[t.e_edgeA=1]="e_edgeA",t[t.e_edgeB=2]="e_edgeB"}(Hi||(Hi={})),function(t){t[t.e_isolated=0]="e_isolated",t[t.e_concave=1]="e_concave",t[t.e_convex=2]="e_convex"}(Zi||(Zi={}));class Ki{}const Ui=[new Pe,new Pe],Xi=[new Pe,new Pe],Gi=[new Pe,new Pe],Qi=new Ki,$i=new Ki,to=new class{constructor(){this.vertices=[],this.normals=[],this.count=0;for(let t=0;t<r.maxPolygonVertices;t++)this.vertices.push(u(0,0)),this.normals.push(u(0,0))}},eo=new class{constructor(){this.v1=u(0,0),this.v2=u(0,0),this.normal=u(0,0),this.sideNormal1=u(0,0),this.sideNormal2=u(0,0)}recycle(){p(this.v1),p(this.v2),p(this.normal),p(this.sideNormal1),p(this.sideNormal2)}},so=u(0,0),io=u(0,0),oo=u(0,0),no=u(0,0),ro=k(0,0,0),mo=u(0,0),ho=u(0,0),ao=u(0,0),co=u(0,0),lo=u(0,0),_o=u(0,0),uo=u(0,0),yo=u(0,0),po=function(e,s,o,n,m){R(ro,o,m),D(so,ro,n.m_centroid);const h=s.m_vertex0,a=s.m_vertex1,c=s.m_vertex2,l=s.m_vertex3,_=s.m_hasVertex0,u=s.m_hasVertex3;v(oo,c,a),C(oo),d(ao,oo.y,-oo.x);const x=P(ao,so)-P(ao,a);let A,g=0,b=0,B=!1,w=!1;p(ho),p(co),_&&(v(io,a,h),C(io),d(ho,io.y,-io.x),B=S(io,oo)>=0,g=i.dot(ho,so)-i.dot(ho,h)),u&&(v(no,l,c),C(no),d(co,no.y,-no.x),w=i.crossVec2Vec2(oo,no)>0,b=i.dot(co,so)-i.dot(co,c)),p(mo),p(lo),p(_o),_&&u?B&&w?(A=g>=0||x>=0||b>=0,A?(y(mo,ao),y(lo,ho),y(_o,co)):(f(mo,-1,ao),f(lo,-1,ao),f(_o,-1,ao))):B?(A=g>=0||x>=0&&b>=0,A?(y(mo,ao),y(lo,ho),y(_o,ao)):(f(mo,-1,ao),f(lo,-1,co),f(_o,-1,ao))):w?(A=b>=0||g>=0&&x>=0,A?(y(mo,ao),y(lo,ao),y(_o,co)):(f(mo,-1,ao),f(lo,-1,ao),f(_o,-1,ho))):(A=g>=0&&x>=0&&b>=0,A?(y(mo,ao),y(lo,ao),y(_o,ao)):(f(mo,-1,ao),f(lo,-1,co),f(_o,-1,ho))):_?B?(A=g>=0||x>=0,A?(y(mo,ao),y(lo,ho),f(_o,-1,ao)):(f(mo,-1,ao),y(lo,ao),f(_o,-1,ao))):(A=g>=0&&x>=0,A?(y(mo,ao),y(lo,ao),f(_o,-1,ao)):(f(mo,-1,ao),y(lo,ao),f(_o,-1,ho))):u?w?(A=x>=0||b>=0,A?(y(mo,ao),f(lo,-1,ao),y(_o,co)):(f(mo,-1,ao),f(lo,-1,ao),y(_o,ao))):(A=x>=0&&b>=0,A?(y(mo,ao),f(lo,-1,ao),y(_o,ao)):(f(mo,-1,ao),f(lo,-1,co),y(_o,ao))):(A=x>=0,A?(y(mo,ao),f(lo,-1,ao),f(_o,-1,ao)):(f(mo,-1,ao),y(lo,ao),y(_o,ao))),to.count=n.m_count;for(let t=0;t<n.m_count;++t)D(to.vertices[t],ro,n.m_vertices[t]),L(to.normals[t],ro.q,n.m_normals[t]);const V=n.m_radius+s.m_radius;e.pointCount=0,Qi.type=Hi.e_edgeA,Qi.index=A?0:1,Qi.separation=1/0;for(let t=0;t<to.count;++t){const e=to.vertices[t],s=P(mo,e)-P(mo,a);s<Qi.separation&&(Qi.separation=s)}if(Qi.type==Hi.e_unknown)return;if(Qi.separation>V)return;$i.type=Hi.e_unknown,$i.index=-1,$i.separation=-1/0,d(uo,-mo.y,mo.x);for(let t=0;t<to.count;++t){f(yo,-1,to.normals[t]);const e=P(yo,to.vertices[t])-P(yo,a),s=P(yo,to.vertices[t])-P(yo,c),i=Math.min(e,s);if(i>V){$i.type=Hi.e_edgeB,$i.index=t,$i.separation=i;break}if(P(yo,uo)>=0){if(P(yo,mo)-P(_o,mo)<-r.angularSlop)continue}else if(P(yo,mo)-P(lo,mo)<-r.angularSlop)continue;i>$i.separation&&($i.type=Hi.e_edgeB,$i.index=t,$i.separation=i)}if($i.type!=Hi.e_unknown&&$i.separation>V)return;let M;if(M=$i.type==Hi.e_unknown?Qi:$i.separation>.98*Qi.separation+.001?$i:Qi,Gi[0].recycle(),Gi[1].recycle(),M.type==Hi.e_edgeA){e.type=t.ManifoldType.e_faceA;let s=0,i=P(mo,to.normals[0]);for(let t=1;t<to.count;++t){const e=P(mo,to.normals[t]);e<i&&(i=e,s=t)}const o=s,n=o+1<to.count?o+1:0;y(Gi[0].v,to.vertices[o]),Gi[0].id.setFeatures(0,t.ContactFeatureType.e_face,o,t.ContactFeatureType.e_vertex),y(Gi[1].v,to.vertices[n]),Gi[1].id.setFeatures(0,t.ContactFeatureType.e_face,n,t.ContactFeatureType.e_vertex),A?(eo.i1=0,eo.i2=1,y(eo.v1,a),y(eo.v2,c),y(eo.normal,ao)):(eo.i1=1,eo.i2=0,y(eo.v1,c),y(eo.v2,a),f(eo.normal,-1,ao))}else e.type=t.ManifoldType.e_faceB,y(Gi[0].v,a),Gi[0].id.setFeatures(0,t.ContactFeatureType.e_vertex,M.index,t.ContactFeatureType.e_face),y(Gi[1].v,c),Gi[1].id.setFeatures(0,t.ContactFeatureType.e_vertex,M.index,t.ContactFeatureType.e_face),eo.i1=M.index,eo.i2=eo.i1+1<to.count?eo.i1+1:0,y(eo.v1,to.vertices[eo.i1]),y(eo.v2,to.vertices[eo.i2]),y(eo.normal,to.normals[eo.i1]);d(eo.sideNormal1,eo.normal.y,-eo.normal.x),d(eo.sideNormal2,-eo.sideNormal1.x,-eo.sideNormal1.y),eo.sideOffset1=P(eo.sideNormal1,eo.v1),eo.sideOffset2=P(eo.sideNormal2,eo.v2),Ui[0].recycle(),Ui[1].recycle(),Xi[0].recycle(),Xi[1].recycle();if(ke(Ui,Gi,eo.sideNormal1,eo.sideOffset1,eo.i1)<r.maxManifoldPoints)return;if(ke(Xi,Ui,eo.sideNormal2,eo.sideOffset2,eo.i2)<r.maxManifoldPoints)return;M.type==Hi.e_edgeA?(y(e.localNormal,eo.normal),y(e.localPoint,eo.v1)):(y(e.localNormal,n.m_normals[eo.i1]),y(e.localPoint,n.m_vertices[eo.i1]));let I=0;for(let t=0;t<r.maxManifoldPoints;++t){if(P(eo.normal,Xi[t].v)-P(eo.normal,eo.v1)<=V){const s=e.points[I];M.type==Hi.e_edgeA?(O(s.localPoint,ro,Xi[t].v),s.id.set(Xi[t].id)):(y(s.localPoint,Xi[t].v),s.id.set(Xi[t].id),s.id.swapFeatures()),++I}}e.pointCount=I},xo=s,Ao={CollidePolygons:Ri,Settings:r,Sweep:Y,Manifold:ze,Distance:Mt,TimeOfImpact:ie,DynamicTree:c,stats:dt};var go=Object.freeze({__proto__:null,Math:xo,internal:Ao,Serializer:_i,math:s,Vec2:i,Vec3:vs,Mat22:Ae,Mat33:Hs,Transform:W,Rot:E,AABB:o,Shape:U,FixtureProxy:tt,Fixture:et,MassData:ct,Body:lt,ContactEdge:je,mixFriction:Re,mixRestitution:Ee,VelocityConstraintPoint:Ye,Contact:xs,JointEdge:_t,Joint:ut,World:gs,CircleShape:js,Circle:Rs,EdgeShape:Bs,Edge:ws,PolygonShape:qs,Polygon:ks,ChainShape:Ms,Chain:Is,BoxShape:Ns,Box:Ds,CollideCircles:pi,CollideEdgeCircle:Bi,CollidePolygons:Ri,CollidePolygonCircle:Yi,CollideEdgePolygon:po,DistanceJoint:Js,FrictionJoint:Ws,GearJoint:Qs,MotorJoint:ti,MouseJoint:si,PrismaticJoint:Xs,PulleyJoint:oi,RevoluteJoint:Ks,RopeJoint:ri,WeldJoint:hi,WheelJoint:ci,Settings:n,SettingsInternal:r,Sweep:Y,get ManifoldType(){return t.ManifoldType},get ContactFeatureType(){return t.ContactFeatureType},get PointState(){return t.PointState},ClipVertex:Pe,Manifold:ze,ManifoldPoint:Te,ContactID:Fe,WorldManifold:Le,getPointStates:qe,clipSegmentToLine:ke,DistanceInput:wt,DistanceOutput:Vt,SimplexCache:Ct,Distance:Mt,DistanceProxy:It,testOverlap:Nt,ShapeCastInput:Dt,ShapeCastOutput:Ot,ShapeCast:jt,TOIInput:Rt,get TOIOutputState(){return t.TOIOutputState},TOIOutput:Jt,TimeOfImpact:ie,TreeNode:h,DynamicTree:c,stats:dt});t.AABB=o,t.Body=lt,t.Box=Ds,t.BoxShape=Ns,t.Chain=Is,t.ChainShape=Ms,t.Circle=Rs,t.CircleShape=js,t.ClipVertex=Pe,t.CollideCircles=pi,t.CollideEdgeCircle=Bi,t.CollideEdgePolygon=po,t.CollidePolygonCircle=Yi,t.CollidePolygons=Ri,t.Contact=xs,t.ContactEdge=je,t.ContactID=Fe,t.Distance=Mt,t.DistanceInput=wt,t.DistanceJoint=Js,t.DistanceOutput=Vt,t.DistanceProxy=It,t.DynamicTree=c,t.Edge=ws,t.EdgeShape=Bs,t.Fixture=et,t.FixtureProxy=tt,t.FrictionJoint=Ws,t.GearJoint=Qs,t.Joint=ut,t.JointEdge=_t,t.Manifold=ze,t.ManifoldPoint=Te,t.MassData=ct,t.Mat22=Ae,t.Mat33=Hs,t.Math=xo,t.MotorJoint=ti,t.MouseJoint=si,t.Polygon=ks,t.PolygonShape=qs,t.PrismaticJoint=Xs,t.PulleyJoint=oi,t.RevoluteJoint=Ks,t.RopeJoint=ri,t.Rot=E,t.Serializer=_i,t.Settings=n,t.SettingsInternal=r,t.Shape=U,t.ShapeCast=jt,t.ShapeCastInput=Dt,t.ShapeCastOutput=Ot,t.SimplexCache=Ct,t.Sweep=Y,t.TOIInput=Rt,t.TOIOutput=Jt,t.TimeOfImpact=ie,t.Transform=W,t.TreeNode=h,t.Vec2=i,t.Vec3=vs,t.VelocityConstraintPoint=Ye,t.WeldJoint=hi,t.WheelJoint=ci,t.World=gs,t.WorldManifold=Le,t.clipSegmentToLine=ke,t.default=go,t.getPointStates=qe,t.internal=Ao,t.math=s,t.mixFriction=Re,t.mixRestitution=Ee,t.stats=dt,t.testOverlap=Nt,Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=planck.min.js.map
