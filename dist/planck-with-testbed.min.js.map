{"version":3,"file":"planck-with-testbed.min.js","sources":["../node_modules/stage-js/dist/stage.js","../src/util/options.ts","../src/common/Math.ts","../src/common/Vec2.ts","../src/collision/AABB.ts","../src/Settings.ts","../src/util/Pool.ts","../src/collision/DynamicTree.ts","../src/collision/BroadPhase.ts","../src/common/Matrix.ts","../src/common/Rot.ts","../src/common/Sweep.ts","../src/common/Transform.ts","../src/dynamics/Velocity.ts","../src/dynamics/Position.ts","../src/collision/Shape.ts","../src/dynamics/Fixture.ts","../src/dynamics/Body.ts","../src/dynamics/Joint.ts","../src/util/stats.ts","../src/util/Timer.ts","../src/collision/Distance.ts","../src/collision/TimeOfImpact.ts","../src/dynamics/Solver.ts","../src/common/Mat22.ts","../src/collision/Manifold.ts","../src/dynamics/Contact.ts","../src/dynamics/World.ts","../src/common/Vec3.ts","../src/collision/shape/EdgeShape.ts","../src/collision/shape/ChainShape.ts","../src/collision/shape/PolygonShape.ts","../src/collision/shape/BoxShape.ts","../src/collision/shape/CircleShape.ts","../src/dynamics/joint/DistanceJoint.ts","../src/dynamics/joint/FrictionJoint.ts","../src/common/Mat33.ts","../src/dynamics/joint/RevoluteJoint.ts","../src/dynamics/joint/PrismaticJoint.ts","../src/dynamics/joint/GearJoint.ts","../src/dynamics/joint/MotorJoint.ts","../src/dynamics/joint/MouseJoint.ts","../src/dynamics/joint/PulleyJoint.ts","../src/dynamics/joint/RopeJoint.ts","../src/dynamics/joint/WeldJoint.ts","../src/dynamics/joint/WheelJoint.ts","../src/serializer/index.ts","../src/collision/shape/CollideCircle.ts","../src/collision/shape/CollideEdgeCircle.ts","../src/collision/shape/CollidePolygon.ts","../src/collision/shape/CollideCirclePolygon.ts","../src/collision/shape/CollideEdgePolygon.ts","../src/index.ts","../testbed/index.ts"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst stats = {\n  create: 0,\n  tick: 0,\n  node: 0,\n  draw: 0,\n  fps: 0\n};\nclass Matrix {\n  constructor(a, b, c, d, e, f) {\n    this.reset(a, b, c, d, e, f);\n  }\n  toString() {\n    return \"[\" + this.a + \", \" + this.b + \", \" + this.c + \", \" + this.d + \", \" + this.e + \", \" + this.f + \"]\";\n  }\n  clone() {\n    return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);\n  }\n  reset(a, b, c, d, e, f) {\n    this._dirty = true;\n    if (typeof a === \"object\") {\n      this.a = a.a, this.d = a.d;\n      this.b = a.b, this.c = a.c;\n      this.e = a.e, this.f = a.f;\n    } else {\n      this.a = a || 1, this.d = d || 1;\n      this.b = b || 0, this.c = c || 0;\n      this.e = e || 0, this.f = f || 0;\n    }\n    return this;\n  }\n  identity() {\n    this._dirty = true;\n    this.a = 1;\n    this.b = 0;\n    this.c = 0;\n    this.d = 1;\n    this.e = 0;\n    this.f = 0;\n    return this;\n  }\n  rotate(angle) {\n    if (!angle) {\n      return this;\n    }\n    this._dirty = true;\n    var u = angle ? Math.cos(angle) : 1;\n    var v = angle ? Math.sin(angle) : 0;\n    var a = u * this.a - v * this.b;\n    var b = u * this.b + v * this.a;\n    var c = u * this.c - v * this.d;\n    var d = u * this.d + v * this.c;\n    var e = u * this.e - v * this.f;\n    var f = u * this.f + v * this.e;\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.d = d;\n    this.e = e;\n    this.f = f;\n    return this;\n  }\n  translate(x, y) {\n    if (!x && !y) {\n      return this;\n    }\n    this._dirty = true;\n    this.e += x;\n    this.f += y;\n    return this;\n  }\n  scale(x, y) {\n    if (!(x - 1) && !(y - 1)) {\n      return this;\n    }\n    this._dirty = true;\n    this.a *= x;\n    this.b *= y;\n    this.c *= x;\n    this.d *= y;\n    this.e *= x;\n    this.f *= y;\n    return this;\n  }\n  skew(x, y) {\n    if (!x && !y) {\n      return this;\n    }\n    this._dirty = true;\n    var a = this.a + this.b * x;\n    var b = this.b + this.a * y;\n    var c = this.c + this.d * x;\n    var d = this.d + this.c * y;\n    var e = this.e + this.f * x;\n    var f = this.f + this.e * y;\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.d = d;\n    this.e = e;\n    this.f = f;\n    return this;\n  }\n  concat(m) {\n    this._dirty = true;\n    var n = this;\n    var a = n.a * m.a + n.b * m.c;\n    var b = n.b * m.d + n.a * m.b;\n    var c = n.c * m.a + n.d * m.c;\n    var d = n.d * m.d + n.c * m.b;\n    var e = n.e * m.a + m.e + n.f * m.c;\n    var f = n.f * m.d + m.f + n.e * m.b;\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.d = d;\n    this.e = e;\n    this.f = f;\n    return this;\n  }\n  inverse() {\n    if (this._dirty) {\n      this._dirty = false;\n      this.inverted = this.inverted || new Matrix();\n      var z = this.a * this.d - this.b * this.c;\n      this.inverted.a = this.d / z;\n      this.inverted.b = -this.b / z;\n      this.inverted.c = -this.c / z;\n      this.inverted.d = this.a / z;\n      this.inverted.e = (this.c * this.f - this.e * this.d) / z;\n      this.inverted.f = (this.e * this.b - this.a * this.f) / z;\n    }\n    return this.inverted;\n  }\n  map(p, q) {\n    q = q || {};\n    q.x = this.a * p.x + this.c * p.y + this.e;\n    q.y = this.b * p.x + this.d * p.y + this.f;\n    return q;\n  }\n  mapX(x, y) {\n    if (typeof x === \"object\")\n      y = x.y, x = x.x;\n    return this.a * x + this.c * y + this.e;\n  }\n  mapY(x, y) {\n    if (typeof x === \"object\")\n      y = x.y, x = x.x;\n    return this.b * x + this.d * y + this.f;\n  }\n}\nvar iid$1 = 0;\nfunction Pin(owner) {\n  this._owner = owner;\n  this._parent = null;\n  this._relativeMatrix = new Matrix();\n  this._absoluteMatrix = new Matrix();\n  this.reset();\n}\nPin.prototype.reset = function() {\n  this._textureAlpha = 1;\n  this._alpha = 1;\n  this._width = 0;\n  this._height = 0;\n  this._scaleX = 1;\n  this._scaleY = 1;\n  this._skewX = 0;\n  this._skewY = 0;\n  this._rotation = 0;\n  this._pivoted = false;\n  this._pivotX = null;\n  this._pivotY = null;\n  this._handled = false;\n  this._handleX = 0;\n  this._handleY = 0;\n  this._aligned = false;\n  this._alignX = 0;\n  this._alignY = 0;\n  this._offsetX = 0;\n  this._offsetY = 0;\n  this._boxX = 0;\n  this._boxY = 0;\n  this._boxWidth = this._width;\n  this._boxHeight = this._height;\n  this._ts_translate = ++iid$1;\n  this._ts_transform = ++iid$1;\n  this._ts_matrix = ++iid$1;\n};\nPin.prototype._update = function() {\n  this._parent = this._owner._parent && this._owner._parent._pin;\n  if (this._handled && this._mo_handle != this._ts_transform) {\n    this._mo_handle = this._ts_transform;\n    this._ts_translate = ++iid$1;\n  }\n  if (this._aligned && this._parent && this._mo_align != this._parent._ts_transform) {\n    this._mo_align = this._parent._ts_transform;\n    this._ts_translate = ++iid$1;\n  }\n  return this;\n};\nPin.prototype.toString = function() {\n  return this._owner + \" (\" + (this._parent ? this._parent._owner : null) + \")\";\n};\nPin.prototype.absoluteMatrix = function() {\n  this._update();\n  var ts = Math.max(\n    this._ts_transform,\n    this._ts_translate,\n    this._parent ? this._parent._ts_matrix : 0\n  );\n  if (this._mo_abs == ts) {\n    return this._absoluteMatrix;\n  }\n  this._mo_abs = ts;\n  var abs2 = this._absoluteMatrix;\n  abs2.reset(this.relativeMatrix());\n  this._parent && abs2.concat(this._parent._absoluteMatrix);\n  this._ts_matrix = ++iid$1;\n  return abs2;\n};\nPin.prototype.relativeMatrix = function() {\n  this._update();\n  var ts = Math.max(\n    this._ts_transform,\n    this._ts_translate,\n    this._parent ? this._parent._ts_transform : 0\n  );\n  if (this._mo_rel == ts) {\n    return this._relativeMatrix;\n  }\n  this._mo_rel = ts;\n  var rel2 = this._relativeMatrix;\n  rel2.identity();\n  if (this._pivoted) {\n    rel2.translate(-this._pivotX * this._width, -this._pivotY * this._height);\n  }\n  rel2.scale(this._scaleX, this._scaleY);\n  rel2.skew(this._skewX, this._skewY);\n  rel2.rotate(this._rotation);\n  if (this._pivoted) {\n    rel2.translate(this._pivotX * this._width, this._pivotY * this._height);\n  }\n  if (this._pivoted) {\n    this._boxX = 0;\n    this._boxY = 0;\n    this._boxWidth = this._width;\n    this._boxHeight = this._height;\n  } else {\n    var p, q;\n    if (rel2.a > 0 && rel2.c > 0 || rel2.a < 0 && rel2.c < 0) {\n      p = 0, q = rel2.a * this._width + rel2.c * this._height;\n    } else {\n      p = rel2.a * this._width, q = rel2.c * this._height;\n    }\n    if (p > q) {\n      this._boxX = q;\n      this._boxWidth = p - q;\n    } else {\n      this._boxX = p;\n      this._boxWidth = q - p;\n    }\n    if (rel2.b > 0 && rel2.d > 0 || rel2.b < 0 && rel2.d < 0) {\n      p = 0, q = rel2.b * this._width + rel2.d * this._height;\n    } else {\n      p = rel2.b * this._width, q = rel2.d * this._height;\n    }\n    if (p > q) {\n      this._boxY = q;\n      this._boxHeight = p - q;\n    } else {\n      this._boxY = p;\n      this._boxHeight = q - p;\n    }\n  }\n  this._x = this._offsetX;\n  this._y = this._offsetY;\n  this._x -= this._boxX + this._handleX * this._boxWidth;\n  this._y -= this._boxY + this._handleY * this._boxHeight;\n  if (this._aligned && this._parent) {\n    this._parent.relativeMatrix();\n    this._x += this._alignX * this._parent._width;\n    this._y += this._alignY * this._parent._height;\n  }\n  rel2.translate(this._x, this._y);\n  return this._relativeMatrix;\n};\nPin.prototype.get = function(key) {\n  if (typeof getters[key] === \"function\") {\n    return getters[key](this);\n  }\n};\nPin.prototype.set = function(a, b) {\n  if (typeof a === \"string\") {\n    if (typeof setters[a] === \"function\" && typeof b !== \"undefined\") {\n      setters[a](this, b);\n    }\n  } else if (typeof a === \"object\") {\n    for (b in a) {\n      if (typeof setters[b] === \"function\" && typeof a[b] !== \"undefined\") {\n        setters[b](this, a[b], a);\n      }\n    }\n  }\n  if (this._owner) {\n    this._owner._ts_pin = ++iid$1;\n    this._owner.touch();\n  }\n  return this;\n};\nvar getters = {\n  alpha: function(pin) {\n    return pin._alpha;\n  },\n  textureAlpha: function(pin) {\n    return pin._textureAlpha;\n  },\n  width: function(pin) {\n    return pin._width;\n  },\n  height: function(pin) {\n    return pin._height;\n  },\n  boxWidth: function(pin) {\n    return pin._boxWidth;\n  },\n  boxHeight: function(pin) {\n    return pin._boxHeight;\n  },\n  // scale : function(pin) {\n  // },\n  scaleX: function(pin) {\n    return pin._scaleX;\n  },\n  scaleY: function(pin) {\n    return pin._scaleY;\n  },\n  // skew : function(pin) {\n  // },\n  skewX: function(pin) {\n    return pin._skewX;\n  },\n  skewY: function(pin) {\n    return pin._skewY;\n  },\n  rotation: function(pin) {\n    return pin._rotation;\n  },\n  // pivot : function(pin) {\n  // },\n  pivotX: function(pin) {\n    return pin._pivotX;\n  },\n  pivotY: function(pin) {\n    return pin._pivotY;\n  },\n  // offset : function(pin) {\n  // },\n  offsetX: function(pin) {\n    return pin._offsetX;\n  },\n  offsetY: function(pin) {\n    return pin._offsetY;\n  },\n  // align : function(pin) {\n  // },\n  alignX: function(pin) {\n    return pin._alignX;\n  },\n  alignY: function(pin) {\n    return pin._alignY;\n  },\n  // handle : function(pin) {\n  // },\n  handleX: function(pin) {\n    return pin._handleX;\n  },\n  handleY: function(pin) {\n    return pin._handleY;\n  }\n};\nvar setters = {\n  alpha: function(pin, value) {\n    pin._alpha = value;\n  },\n  textureAlpha: function(pin, value) {\n    pin._textureAlpha = value;\n  },\n  width: function(pin, value) {\n    pin._width_ = value;\n    pin._width = value;\n    pin._ts_transform = ++iid$1;\n  },\n  height: function(pin, value) {\n    pin._height_ = value;\n    pin._height = value;\n    pin._ts_transform = ++iid$1;\n  },\n  scale: function(pin, value) {\n    pin._scaleX = value;\n    pin._scaleY = value;\n    pin._ts_transform = ++iid$1;\n  },\n  scaleX: function(pin, value) {\n    pin._scaleX = value;\n    pin._ts_transform = ++iid$1;\n  },\n  scaleY: function(pin, value) {\n    pin._scaleY = value;\n    pin._ts_transform = ++iid$1;\n  },\n  skew: function(pin, value) {\n    pin._skewX = value;\n    pin._skewY = value;\n    pin._ts_transform = ++iid$1;\n  },\n  skewX: function(pin, value) {\n    pin._skewX = value;\n    pin._ts_transform = ++iid$1;\n  },\n  skewY: function(pin, value) {\n    pin._skewY = value;\n    pin._ts_transform = ++iid$1;\n  },\n  rotation: function(pin, value) {\n    pin._rotation = value;\n    pin._ts_transform = ++iid$1;\n  },\n  pivot: function(pin, value) {\n    pin._pivotX = value;\n    pin._pivotY = value;\n    pin._pivoted = true;\n    pin._ts_transform = ++iid$1;\n  },\n  pivotX: function(pin, value) {\n    pin._pivotX = value;\n    pin._pivoted = true;\n    pin._ts_transform = ++iid$1;\n  },\n  pivotY: function(pin, value) {\n    pin._pivotY = value;\n    pin._pivoted = true;\n    pin._ts_transform = ++iid$1;\n  },\n  offset: function(pin, value) {\n    pin._offsetX = value;\n    pin._offsetY = value;\n    pin._ts_translate = ++iid$1;\n  },\n  offsetX: function(pin, value) {\n    pin._offsetX = value;\n    pin._ts_translate = ++iid$1;\n  },\n  offsetY: function(pin, value) {\n    pin._offsetY = value;\n    pin._ts_translate = ++iid$1;\n  },\n  align: function(pin, value) {\n    this.alignX(pin, value);\n    this.alignY(pin, value);\n  },\n  alignX: function(pin, value) {\n    pin._alignX = value;\n    pin._aligned = true;\n    pin._ts_translate = ++iid$1;\n    this.handleX(pin, value);\n  },\n  alignY: function(pin, value) {\n    pin._alignY = value;\n    pin._aligned = true;\n    pin._ts_translate = ++iid$1;\n    this.handleY(pin, value);\n  },\n  handle: function(pin, value) {\n    this.handleX(pin, value);\n    this.handleY(pin, value);\n  },\n  handleX: function(pin, value) {\n    pin._handleX = value;\n    pin._handled = true;\n    pin._ts_translate = ++iid$1;\n  },\n  handleY: function(pin, value) {\n    pin._handleY = value;\n    pin._handled = true;\n    pin._ts_translate = ++iid$1;\n  },\n  resizeMode: function(pin, value, all) {\n    if (all) {\n      if (value == \"in\") {\n        value = \"in-pad\";\n      } else if (value == \"out\") {\n        value = \"out-crop\";\n      }\n      scaleTo(pin, all.resizeWidth, all.resizeHeight, value);\n    }\n  },\n  resizeWidth: function(pin, value, all) {\n    if (!all || !all.resizeMode) {\n      scaleTo(pin, value, null);\n    }\n  },\n  resizeHeight: function(pin, value, all) {\n    if (!all || !all.resizeMode) {\n      scaleTo(pin, null, value);\n    }\n  },\n  scaleMode: function(pin, value, all) {\n    if (all) {\n      scaleTo(pin, all.scaleWidth, all.scaleHeight, value);\n    }\n  },\n  scaleWidth: function(pin, value, all) {\n    if (!all || !all.scaleMode) {\n      scaleTo(pin, value, null);\n    }\n  },\n  scaleHeight: function(pin, value, all) {\n    if (!all || !all.scaleMode) {\n      scaleTo(pin, null, value);\n    }\n  },\n  matrix: function(pin, value) {\n    this.scaleX(pin, value.a);\n    this.skewX(pin, value.c / value.d);\n    this.skewY(pin, value.b / value.a);\n    this.scaleY(pin, value.d);\n    this.offsetX(pin, value.e);\n    this.offsetY(pin, value.f);\n    this.rotation(pin, 0);\n  }\n};\nPin.prototype.scaleTo = function(width, height, mode) {\n  scaleTo(this, width, height, mode);\n};\nfunction scaleTo(pin, width, height, mode) {\n  var w = typeof width === \"number\";\n  var h = typeof height === \"number\";\n  var m = typeof mode === \"string\";\n  pin._ts_transform = ++iid$1;\n  if (w) {\n    pin._scaleX = width / pin._width_;\n    pin._width = pin._width_;\n  }\n  if (h) {\n    pin._scaleY = height / pin._height_;\n    pin._height = pin._height_;\n  }\n  if (w && h && m) {\n    if (mode == \"out\" || mode == \"out-crop\") {\n      pin._scaleX = pin._scaleY = Math.max(pin._scaleX, pin._scaleY);\n    } else if (mode == \"in\" || mode == \"in-pad\") {\n      pin._scaleX = pin._scaleY = Math.min(pin._scaleX, pin._scaleY);\n    }\n    if (mode == \"out-crop\" || mode == \"in-pad\") {\n      pin._width = width / pin._scaleX;\n      pin._height = height / pin._scaleY;\n    }\n  }\n}\nPin._add_shortcuts = function(prototype) {\n  prototype.size = function(w, h) {\n    this.pin(\"width\", w);\n    this.pin(\"height\", h);\n    return this;\n  };\n  prototype.width = function(w) {\n    if (typeof w === \"undefined\") {\n      return this.pin(\"width\");\n    }\n    this.pin(\"width\", w);\n    return this;\n  };\n  prototype.height = function(h) {\n    if (typeof h === \"undefined\") {\n      return this.pin(\"height\");\n    }\n    this.pin(\"height\", h);\n    return this;\n  };\n  prototype.offset = function(a, b) {\n    if (typeof a === \"object\")\n      b = a.y, a = a.x;\n    this.pin(\"offsetX\", a);\n    this.pin(\"offsetY\", b);\n    return this;\n  };\n  prototype.rotate = function(a) {\n    this.pin(\"rotation\", a);\n    return this;\n  };\n  prototype.skew = function(a, b) {\n    if (typeof a === \"object\")\n      b = a.y, a = a.x;\n    else if (typeof b === \"undefined\")\n      b = a;\n    this.pin(\"skewX\", a);\n    this.pin(\"skewY\", b);\n    return this;\n  };\n  prototype.scale = function(a, b) {\n    if (typeof a === \"object\")\n      b = a.y, a = a.x;\n    else if (typeof b === \"undefined\")\n      b = a;\n    this.pin(\"scaleX\", a);\n    this.pin(\"scaleY\", b);\n    return this;\n  };\n  prototype.alpha = function(a, ta) {\n    this.pin(\"alpha\", a);\n    if (typeof ta !== \"undefined\") {\n      this.pin(\"textureAlpha\", ta);\n    }\n    return this;\n  };\n};\nvar iid = 0;\nstats.create = 0;\nfunction assertType(obj) {\n  if (obj && obj instanceof Node) {\n    return obj;\n  }\n  throw \"Invalid node: \" + obj;\n}\nconst create = function() {\n  return new Node();\n};\nfunction Node() {\n  stats.create++;\n  this._pin = new Pin(this);\n}\nNode.prototype.matrix = function(relative) {\n  if (relative === true) {\n    return this._pin.relativeMatrix();\n  }\n  return this._pin.absoluteMatrix();\n};\nNode.prototype.pin = function(a, b) {\n  if (typeof a === \"object\") {\n    this._pin.set(a);\n    return this;\n  } else if (typeof a === \"string\") {\n    if (typeof b === \"undefined\") {\n      return this._pin.get(a);\n    } else {\n      this._pin.set(a, b);\n      return this;\n    }\n  } else if (typeof a === \"undefined\") {\n    return this._pin;\n  }\n};\nNode.prototype.scaleTo = function(a, b, c) {\n  if (typeof a === \"object\")\n    c = b, b = a.y, a = a.x;\n  this._pin.scaleTo(a, b, c);\n  return this;\n};\nPin._add_shortcuts(Node.prototype);\nNode.prototype._label = \"\";\nNode.prototype._visible = true;\nNode.prototype._parent = null;\nNode.prototype._next = null;\nNode.prototype._prev = null;\nNode.prototype._first = null;\nNode.prototype._last = null;\nNode.prototype._attrs = null;\nNode.prototype._flags = null;\nNode.prototype.toString = function() {\n  return \"[\" + this._label + \"]\";\n};\nNode.prototype.id = function(id) {\n  return this.label(id);\n};\nNode.prototype.label = function(label) {\n  if (typeof label === \"undefined\") {\n    return this._label;\n  }\n  this._label = label;\n  return this;\n};\nNode.prototype.attr = function(name, value) {\n  if (typeof value === \"undefined\") {\n    return this._attrs !== null ? this._attrs[name] : void 0;\n  }\n  (this._attrs !== null ? this._attrs : this._attrs = {})[name] = value;\n  return this;\n};\nNode.prototype.visible = function(visible) {\n  if (typeof visible === \"undefined\") {\n    return this._visible;\n  }\n  this._visible = visible;\n  this._parent && (this._parent._ts_children = ++iid);\n  this._ts_pin = ++iid;\n  this.touch();\n  return this;\n};\nNode.prototype.hide = function() {\n  return this.visible(false);\n};\nNode.prototype.show = function() {\n  return this.visible(true);\n};\nNode.prototype.parent = function() {\n  return this._parent;\n};\nNode.prototype.next = function(visible) {\n  var next = this._next;\n  while (next && visible && !next._visible) {\n    next = next._next;\n  }\n  return next;\n};\nNode.prototype.prev = function(visible) {\n  var prev = this._prev;\n  while (prev && visible && !prev._visible) {\n    prev = prev._prev;\n  }\n  return prev;\n};\nNode.prototype.first = function(visible) {\n  var next = this._first;\n  while (next && visible && !next._visible) {\n    next = next._next;\n  }\n  return next;\n};\nNode.prototype.last = function(visible) {\n  var prev = this._last;\n  while (prev && visible && !prev._visible) {\n    prev = prev._prev;\n  }\n  return prev;\n};\nNode.prototype.visit = function(visitor, data) {\n  var reverse = visitor.reverse;\n  var visible = visitor.visible;\n  if (visitor.start && visitor.start(this, data)) {\n    return;\n  }\n  var child, next = reverse ? this.last(visible) : this.first(visible);\n  while (child = next) {\n    next = reverse ? child.prev(visible) : child.next(visible);\n    if (child.visit(visitor, data)) {\n      return true;\n    }\n  }\n  return visitor.end && visitor.end(this, data);\n};\nNode.prototype.append = function(child, more) {\n  if (Array.isArray(child))\n    for (var i = 0; i < child.length; i++)\n      append(this, child[i]);\n  else if (typeof more !== \"undefined\")\n    for (var i = 0; i < arguments.length; i++)\n      append(this, arguments[i]);\n  else if (typeof child !== \"undefined\")\n    append(this, child);\n  return this;\n};\nNode.prototype.prepend = function(child, more) {\n  if (Array.isArray(child))\n    for (var i = child.length - 1; i >= 0; i--)\n      prepend(this, child[i]);\n  else if (typeof more !== \"undefined\")\n    for (var i = arguments.length - 1; i >= 0; i--)\n      prepend(this, arguments[i]);\n  else if (typeof child !== \"undefined\")\n    prepend(this, child);\n  return this;\n};\nNode.prototype.appendTo = function(parent) {\n  append(parent, this);\n  return this;\n};\nNode.prototype.prependTo = function(parent) {\n  prepend(parent, this);\n  return this;\n};\nNode.prototype.insertNext = function(sibling, more) {\n  if (Array.isArray(sibling))\n    for (var i = 0; i < sibling.length; i++)\n      insertAfter(sibling[i], this);\n  else if (typeof more !== \"undefined\")\n    for (var i = 0; i < arguments.length; i++)\n      insertAfter(arguments[i], this);\n  else if (typeof sibling !== \"undefined\")\n    insertAfter(sibling, this);\n  return this;\n};\nNode.prototype.insertPrev = function(sibling, more) {\n  if (Array.isArray(sibling))\n    for (var i = sibling.length - 1; i >= 0; i--)\n      insertBefore(sibling[i], this);\n  else if (typeof more !== \"undefined\")\n    for (var i = arguments.length - 1; i >= 0; i--)\n      insertBefore(arguments[i], this);\n  else if (typeof sibling !== \"undefined\")\n    insertBefore(sibling, this);\n  return this;\n};\nNode.prototype.insertAfter = function(prev) {\n  insertAfter(this, prev);\n  return this;\n};\nNode.prototype.insertBefore = function(next) {\n  insertBefore(this, next);\n  return this;\n};\nfunction append(parent, child) {\n  assertType(child);\n  assertType(parent);\n  child.remove();\n  if (parent._last) {\n    parent._last._next = child;\n    child._prev = parent._last;\n  }\n  child._parent = parent;\n  parent._last = child;\n  if (!parent._first) {\n    parent._first = child;\n  }\n  child._parent._flag(child, true);\n  child._ts_parent = ++iid;\n  parent._ts_children = ++iid;\n  parent.touch();\n}\nfunction prepend(parent, child) {\n  assertType(child);\n  assertType(parent);\n  child.remove();\n  if (parent._first) {\n    parent._first._prev = child;\n    child._next = parent._first;\n  }\n  child._parent = parent;\n  parent._first = child;\n  if (!parent._last) {\n    parent._last = child;\n  }\n  child._parent._flag(child, true);\n  child._ts_parent = ++iid;\n  parent._ts_children = ++iid;\n  parent.touch();\n}\nfunction insertBefore(self, next) {\n  assertType(self);\n  assertType(next);\n  self.remove();\n  var parent = next._parent;\n  var prev = next._prev;\n  next._prev = self;\n  prev && (prev._next = self) || parent && (parent._first = self);\n  self._parent = parent;\n  self._prev = prev;\n  self._next = next;\n  self._parent._flag(self, true);\n  self._ts_parent = ++iid;\n  self.touch();\n}\nfunction insertAfter(self, prev) {\n  assertType(self);\n  assertType(prev);\n  self.remove();\n  var parent = prev._parent;\n  var next = prev._next;\n  prev._next = self;\n  next && (next._prev = self) || parent && (parent._last = self);\n  self._parent = parent;\n  self._prev = prev;\n  self._next = next;\n  self._parent._flag(self, true);\n  self._ts_parent = ++iid;\n  self.touch();\n}\nNode.prototype.remove = function(child, more) {\n  if (typeof child !== \"undefined\") {\n    if (Array.isArray(child)) {\n      for (var i = 0; i < child.length; i++)\n        assertType(child[i]).remove();\n    } else if (typeof more !== \"undefined\") {\n      for (var i = 0; i < arguments.length; i++)\n        assertType(arguments[i]).remove();\n    } else {\n      assertType(child).remove();\n    }\n    return this;\n  }\n  if (this._prev) {\n    this._prev._next = this._next;\n  }\n  if (this._next) {\n    this._next._prev = this._prev;\n  }\n  if (this._parent) {\n    if (this._parent._first === this) {\n      this._parent._first = this._next;\n    }\n    if (this._parent._last === this) {\n      this._parent._last = this._prev;\n    }\n    this._parent._flag(this, false);\n    this._parent._ts_children = ++iid;\n    this._parent.touch();\n  }\n  this._prev = this._next = this._parent = null;\n  this._ts_parent = ++iid;\n  return this;\n};\nNode.prototype.empty = function() {\n  var child, next = this._first;\n  while (child = next) {\n    next = child._next;\n    child._prev = child._next = child._parent = null;\n    this._flag(child, false);\n  }\n  this._first = this._last = null;\n  this._ts_children = ++iid;\n  this.touch();\n  return this;\n};\nNode.prototype._ts_touch = null;\nNode.prototype.touch = function() {\n  this._ts_touch = ++iid;\n  this._parent && this._parent.touch();\n  return this;\n};\nNode.prototype._flag = function(obj, name) {\n  if (typeof name === \"undefined\") {\n    return this._flags !== null && this._flags[obj] || 0;\n  }\n  if (typeof obj === \"string\") {\n    if (name) {\n      this._flags = this._flags || {};\n      if (!this._flags[obj] && this._parent) {\n        this._parent._flag(obj, true);\n      }\n      this._flags[obj] = (this._flags[obj] || 0) + 1;\n    } else if (this._flags && this._flags[obj] > 0) {\n      if (this._flags[obj] == 1 && this._parent) {\n        this._parent._flag(obj, false);\n      }\n      this._flags[obj] = this._flags[obj] - 1;\n    }\n  }\n  if (typeof obj === \"object\") {\n    if (obj._flags) {\n      for (var type in obj._flags) {\n        if (obj._flags[type] > 0) {\n          this._flag(type, name);\n        }\n      }\n    }\n  }\n  return this;\n};\nNode.prototype.hitTest = function(hit) {\n  var width = this._pin._width;\n  var height = this._pin._height;\n  return hit.x >= 0 && hit.x <= width && hit.y >= 0 && hit.y <= height;\n};\nNode.prototype._textures = null;\nNode.prototype._alpha = 1;\nNode.prototype.render = function(context) {\n  if (!this._visible) {\n    return;\n  }\n  stats.node++;\n  var m = this.matrix();\n  context.setTransform(m.a, m.b, m.c, m.d, m.e, m.f);\n  this._alpha = this._pin._alpha * (this._parent ? this._parent._alpha : 1);\n  var alpha = this._pin._textureAlpha * this._alpha;\n  if (context.globalAlpha != alpha) {\n    context.globalAlpha = alpha;\n  }\n  if (this._textures !== null) {\n    for (var i = 0, n = this._textures.length; i < n; i++) {\n      this._textures[i].draw(context);\n    }\n  }\n  if (context.globalAlpha != this._alpha) {\n    context.globalAlpha = this._alpha;\n  }\n  var child, next = this._first;\n  while (child = next) {\n    next = child._next;\n    child.render(context);\n  }\n};\nNode.prototype._tickBefore = null;\nNode.prototype._tickAfter = null;\nNode.prototype.MAX_ELAPSE = Infinity;\nNode.prototype._tick = function(elapsed, now, last) {\n  if (!this._visible) {\n    return;\n  }\n  if (elapsed > this.MAX_ELAPSE) {\n    elapsed = this.MAX_ELAPSE;\n  }\n  var ticked = false;\n  if (this._tickBefore !== null) {\n    for (var i = 0; i < this._tickBefore.length; i++) {\n      stats.tick++;\n      var tickFn = this._tickBefore[i];\n      ticked = tickFn.call(this, elapsed, now, last) === true || ticked;\n    }\n  }\n  var child, next = this._first;\n  while (child = next) {\n    next = child._next;\n    if (child._flag(\"_tick\")) {\n      ticked = child._tick(elapsed, now, last) === true ? true : ticked;\n    }\n  }\n  if (this._tickAfter !== null) {\n    for (var i = 0; i < this._tickAfter.length; i++) {\n      stats.tick++;\n      var tickFn = this._tickAfter[i];\n      ticked = tickFn.call(this, elapsed, now, last) === true || ticked;\n    }\n  }\n  return ticked;\n};\nNode.prototype.tick = function(ticker, before) {\n  if (typeof ticker !== \"function\") {\n    return;\n  }\n  if (before) {\n    if (this._tickBefore === null) {\n      this._tickBefore = [];\n    }\n    this._tickBefore.push(ticker);\n  } else {\n    if (this._tickAfter === null) {\n      this._tickAfter = [];\n    }\n    this._tickAfter.push(ticker);\n  }\n  this._flag(\"_tick\", this._tickAfter !== null && this._tickAfter.length > 0 || this._tickBefore !== null && this._tickBefore.length > 0);\n};\nNode.prototype.untick = function(ticker) {\n  if (typeof ticker !== \"function\") {\n    return;\n  }\n  var i;\n  if (this._tickBefore !== null && (i = this._tickBefore.indexOf(ticker)) >= 0) {\n    this._tickBefore.splice(i, 1);\n  }\n  if (this._tickAfter !== null && (i = this._tickAfter.indexOf(ticker)) >= 0) {\n    this._tickAfter.splice(i, 1);\n  }\n};\nNode.prototype.timeout = function(fn, time) {\n  this.setTimeout(fn, time);\n};\nNode.prototype.setTimeout = function(fn, time) {\n  function timer(t) {\n    if ((time -= t) < 0) {\n      this.untick(timer);\n      fn.call(this);\n    } else {\n      return true;\n    }\n  }\n  this.tick(timer);\n  return timer;\n};\nNode.prototype.clearTimeout = function(timer) {\n  this.untick(timer);\n};\nNode.prototype._listeners = null;\nNode.prototype._event_callback = function(name, on) {\n  this._flag(name, on);\n};\nNode.prototype.on = function(types, listener) {\n  if (!types || !types.length || typeof listener !== \"function\") {\n    return this;\n  }\n  if (this._listeners === null) {\n    this._listeners = {};\n  }\n  var isarray = typeof types !== \"string\" && typeof types.join === \"function\";\n  if (types = (isarray ? types.join(\" \") : types).match(/\\S+/g)) {\n    for (var i = 0; i < types.length; i++) {\n      var type = types[i];\n      this._listeners[type] = this._listeners[type] || [];\n      this._listeners[type].push(listener);\n      if (typeof this._event_callback === \"function\") {\n        this._event_callback(type, true);\n      }\n    }\n  }\n  return this;\n};\nNode.prototype.off = function(types, listener) {\n  if (!types || !types.length || typeof listener !== \"function\") {\n    return this;\n  }\n  if (this._listeners === null) {\n    return this;\n  }\n  var isarray = typeof types !== \"string\" && typeof types.join === \"function\";\n  if (types = (isarray ? types.join(\" \") : types).match(/\\S+/g)) {\n    for (var i = 0; i < types.length; i++) {\n      var type = types[i], all = this._listeners[type], index;\n      if (all && (index = all.indexOf(listener)) >= 0) {\n        all.splice(index, 1);\n        if (!all.length) {\n          delete this._listeners[type];\n        }\n        if (typeof this._event_callback === \"function\") {\n          this._event_callback(type, false);\n        }\n      }\n    }\n  }\n  return this;\n};\nNode.prototype.listeners = function(type) {\n  return this._listeners && this._listeners[type];\n};\nNode.prototype.publish = function(name, args) {\n  var listeners = this.listeners(name);\n  if (!listeners || !listeners.length) {\n    return 0;\n  }\n  for (var l = 0; l < listeners.length; l++) {\n    listeners[l].apply(this, args);\n  }\n  return listeners.length;\n};\nNode.prototype.trigger = function(name, args) {\n  this.publish(name, args);\n  return this;\n};\nvar native = Math;\nconst math = Object.create(Math);\nmath.random = function(min, max) {\n  if (typeof min === \"undefined\") {\n    max = 1, min = 0;\n  } else if (typeof max === \"undefined\") {\n    max = min, min = 0;\n  }\n  return min == max ? min : native.random() * (max - min) + min;\n};\nmath.wrap = function(num, min, max) {\n  if (typeof min === \"undefined\") {\n    max = 1, min = 0;\n  } else if (typeof max === \"undefined\") {\n    max = min, min = 0;\n  }\n  if (max > min) {\n    num = (num - min) % (max - min);\n    return num + (num < 0 ? max : min);\n  } else {\n    num = (num - max) % (min - max);\n    return num + (num <= 0 ? min : max);\n  }\n};\nmath.clamp = function(num, min, max) {\n  if (num < min) {\n    return min;\n  } else if (num > max) {\n    return max;\n  } else {\n    return num;\n  }\n};\nmath.length = function(x, y) {\n  return native.sqrt(x * x + y * y);\n};\nmath.rotate = math.wrap;\nmath.limit = math.clamp;\nconst isFn = function(value) {\n  var str = Object.prototype.toString.call(value);\n  return str === \"[object Function]\" || str === \"[object GeneratorFunction]\" || str === \"[object AsyncFunction]\";\n};\nconst isHash = function(value) {\n  return Object.prototype.toString.call(value) === \"[object Object]\" && value.constructor === Object;\n};\nclass Texture {\n  constructor(texture2, ratio) {\n    if (typeof texture2 === \"object\") {\n      this.src(texture2, ratio);\n    }\n  }\n  pipe() {\n    return new Texture(this);\n  }\n  /**\n   * Signatures: (texture), (x, y, w, h), (w, h)\n   */\n  src(x, y, w, h) {\n    if (typeof x === \"object\") {\n      var drawable = x, ratio = y || 1;\n      this._image = drawable;\n      this._sx = this._dx = 0;\n      this._sy = this._dy = 0;\n      this._sw = this._dw = drawable.width / ratio;\n      this._sh = this._dh = drawable.height / ratio;\n      this.width = drawable.width / ratio;\n      this.height = drawable.height / ratio;\n      this.ratio = ratio;\n    } else {\n      if (typeof w === \"undefined\") {\n        w = x, h = y;\n      } else {\n        this._sx = x, this._sy = y;\n      }\n      this._sw = this._dw = w;\n      this._sh = this._dh = h;\n      this.width = w;\n      this.height = h;\n    }\n    return this;\n  }\n  /**\n   * Signatures: (x, y, w, h), (x, y)\n   */\n  dest(x, y, w, h) {\n    this._dx = x, this._dy = y;\n    this._dx = x, this._dy = y;\n    if (typeof w !== \"undefined\") {\n      this._dw = w, this._dh = h;\n      this.width = w, this.height = h;\n    }\n    return this;\n  }\n  draw(context, x1, y1, x2, y2, x3, y3, x4, y4) {\n    var drawable = this._image;\n    if (drawable === null || typeof drawable !== \"object\") {\n      return;\n    }\n    var sx = this._sx, sy = this._sy;\n    var sw = this._sw, sh = this._sh;\n    var dx = this._dx, dy = this._dy;\n    var dw = this._dw, dh = this._dh;\n    if (typeof x3 !== \"undefined\") {\n      x1 = math.clamp(x1, 0, this._sw), x2 = math.clamp(x2, 0, this._sw - x1);\n      y1 = math.clamp(y1, 0, this._sh), y2 = math.clamp(y2, 0, this._sh - y1);\n      sx += x1, sy += y1, sw = x2, sh = y2;\n      dx = x3, dy = y3, dw = x4, dh = y4;\n    } else if (typeof x2 !== \"undefined\") {\n      dx = x1, dy = y1, dw = x2, dh = y2;\n    } else if (typeof x1 !== \"undefined\") {\n      dw = x1, dh = y1;\n    }\n    var ratio = this.ratio || 1;\n    sx *= ratio, sy *= ratio, sw *= ratio, sh *= ratio;\n    try {\n      if (typeof drawable.draw === \"function\") {\n        drawable.draw(context, sx, sy, sw, sh, dx, dy, dw, dh);\n      } else {\n        stats.draw++;\n        context.drawImage(drawable, sx, sy, sw, sh, dx, dy, dw, dh);\n      }\n    } catch (ex) {\n      if (!drawable._draw_failed) {\n        console.log(\"Unable to draw: \", drawable);\n        console.log(ex);\n        drawable._draw_failed = true;\n      }\n    }\n  }\n}\nvar NO_TEXTURE = new class extends Texture {\n  constructor() {\n    super();\n    __publicField(this, \"pipe\", function() {\n      return this;\n    });\n    __publicField(this, \"src\", function() {\n      return this;\n    });\n    __publicField(this, \"dest\", function() {\n      return this;\n    });\n    __publicField(this, \"draw\", function() {\n    });\n    this.x = this.y = this.width = this.height = 0;\n  }\n}();\nvar NO_SELECTION = new Selection(NO_TEXTURE);\nfunction preloadImage(src) {\n  console.log(\"Loading image: \" + src);\n  return new Promise(function(resolve, reject) {\n    const img = new Image();\n    img.onload = function() {\n      console.log(\"Image loaded: \" + src);\n      resolve(img);\n    };\n    img.onerror = function(error) {\n      console.log(\"Loading failed: \" + src);\n      reject(error);\n    };\n    img.src = src;\n  });\n}\nvar _atlases_map = {};\nvar _atlases_arr = [];\nconst atlas = async function(def) {\n  var atlas2 = isFn(def.draw) ? def : new Atlas(def);\n  if (def.name) {\n    _atlases_map[def.name] = atlas2;\n  }\n  _atlases_arr.push(atlas2);\n  deprecated(def, \"imagePath\");\n  deprecated(def, \"imageRatio\");\n  var url = def.imagePath;\n  var ratio = def.imageRatio || 1;\n  if (\"string\" === typeof def.image) {\n    url = def.image;\n  } else if (isHash(def.image)) {\n    url = def.image.src || def.image.url;\n    ratio = def.image.ratio || ratio;\n  }\n  if (url) {\n    const image2 = await preloadImage(url);\n    atlas2.src(image2, ratio);\n  }\n  return atlas2;\n};\nclass Atlas extends Texture {\n  constructor(def) {\n    super();\n    var atlas2 = this;\n    deprecated(def, \"filter\");\n    deprecated(def, \"cutouts\");\n    deprecated(def, \"sprites\");\n    deprecated(def, \"factory\");\n    var map = def.map || def.filter;\n    var ppu = def.ppu || def.ratio || 1;\n    var trim = def.trim || 0;\n    var textures = def.textures;\n    var factory = def.factory;\n    var cutouts = def.cutouts || def.sprites;\n    function make(def2) {\n      if (!def2 || isFn(def2.draw)) {\n        return def2;\n      }\n      def2 = Object.assign({}, def2);\n      if (isFn(map)) {\n        def2 = map(def2);\n      }\n      if (ppu != 1) {\n        def2.x *= ppu, def2.y *= ppu;\n        def2.width *= ppu, def2.height *= ppu;\n        def2.top *= ppu, def2.bottom *= ppu;\n        def2.left *= ppu, def2.right *= ppu;\n      }\n      if (trim != 0) {\n        def2.x += trim, def2.y += trim;\n        def2.width -= 2 * trim, def2.height -= 2 * trim;\n        def2.top -= trim, def2.bottom -= trim;\n        def2.left -= trim, def2.right -= trim;\n      }\n      var texture2 = atlas2.pipe();\n      texture2.top = def2.top, texture2.bottom = def2.bottom;\n      texture2.left = def2.left, texture2.right = def2.right;\n      texture2.src(def2.x, def2.y, def2.width, def2.height);\n      return texture2;\n    }\n    function find(query) {\n      if (textures) {\n        if (isFn(textures)) {\n          return textures(query);\n        } else if (isHash(textures)) {\n          return textures[query];\n        }\n      }\n      if (cutouts) {\n        var result = null, n = 0;\n        for (var i = 0; i < cutouts.length; i++) {\n          if (string.startsWith(cutouts[i].name, query)) {\n            if (n === 0) {\n              result = cutouts[i];\n            } else if (n === 1) {\n              result = [result, cutouts[i]];\n            } else {\n              result.push(cutouts[i]);\n            }\n            n++;\n          }\n        }\n        if (n === 0 && isFn(factory)) {\n          result = function(subquery) {\n            return factory(query + (subquery ? subquery : \"\"));\n          };\n        }\n        return result;\n      }\n    }\n    this.select = function(query) {\n      if (!query) {\n        return new Selection(this.pipe());\n      }\n      var found = find(query);\n      if (found) {\n        return new Selection(found, find, make);\n      }\n    };\n  }\n}\nfunction Selection(result, find, make) {\n  function link(result2, subquery) {\n    if (!result2) {\n      return NO_TEXTURE;\n    } else if (isFn(result2.draw)) {\n      return result2;\n    } else if (isHash(result2) && \"number\" === typeof result2.width && \"number\" === typeof result2.height && isFn(make)) {\n      return make(result2);\n    } else if (isHash(result2) && \"undefined\" !== typeof subquery) {\n      return link(result2[subquery]);\n    } else if (isFn(result2)) {\n      return link(result2(subquery));\n    } else if (Array.isArray(result2)) {\n      return link(result2[0]);\n    } else if (\"string\" === typeof result2 && isFn(find)) {\n      return link(find(result2));\n    }\n  }\n  this.one = function(subquery) {\n    return link(result, subquery);\n  };\n  this.array = function(arr) {\n    var array = Array.isArray(arr) ? arr : [];\n    if (Array.isArray(result)) {\n      for (var i = 0; i < result.length; i++) {\n        array[i] = link(result[i]);\n      }\n    } else {\n      array[0] = link(result);\n    }\n    return array;\n  };\n}\nconst texture = function(query) {\n  if (!(\"string\" === typeof query)) {\n    return new Selection(query);\n  }\n  var result = null, atlas2, i;\n  if ((i = query.indexOf(\":\")) > 0 && query.length > i + 1) {\n    atlas2 = _atlases_map[query.slice(0, i)];\n    result = atlas2 && atlas2.select(query.slice(i + 1));\n  }\n  if (!result && (atlas2 = _atlases_map[query])) {\n    result = atlas2.select();\n  }\n  for (i = 0; !result && i < _atlases_arr.length; i++) {\n    result = _atlases_arr[i].select(query);\n  }\n  if (!result) {\n    console.error(\"Texture not found: \" + query);\n    result = NO_SELECTION;\n  }\n  return result;\n};\nfunction deprecated(hash, name, msg) {\n  if (name in hash)\n    console.log(msg ? msg.replace(\"%name\", name) : \"'\" + name + \"' field of texture atlas is deprecated.\");\n}\nconst canvas = function(type, attributes, plotter) {\n  if (typeof type === \"string\") {\n    if (typeof attributes === \"object\")\n      ;\n    else {\n      if (typeof attributes === \"function\") {\n        plotter = attributes;\n      }\n      attributes = {};\n    }\n  } else {\n    if (typeof type === \"function\") {\n      plotter = type;\n    }\n    attributes = {};\n    type = \"2d\";\n  }\n  var canvas2 = document.createElement(\"canvas\");\n  var context = canvas2.getContext(type, attributes);\n  var texture2 = new Texture(canvas2);\n  texture2.context = function() {\n    return context;\n  };\n  texture2.size = function(width, height, ratio) {\n    ratio = ratio || 1;\n    canvas2.width = width * ratio;\n    canvas2.height = height * ratio;\n    this.src(canvas2, ratio);\n    return this;\n  };\n  texture2.canvas = function(fn) {\n    if (typeof fn === \"function\") {\n      fn.call(this, context);\n    } else if (typeof fn === \"undefined\" && typeof plotter === \"function\") {\n      plotter.call(this, context);\n    }\n    return this;\n  };\n  if (typeof plotter === \"function\") {\n    plotter.call(texture2, context);\n  }\n  return texture2;\n};\nlet M;\nfunction memoizeDraw(callback, memoKey = () => null) {\n  const PIXEL_RATIO = typeof window !== \"undefined\" ? window.devicePixelRatio || 1 : 1;\n  let lastRatio = 0;\n  let lastSelection = void 0;\n  let texture2 = Stage.canvas();\n  let sprite2 = Stage.sprite();\n  let first = true;\n  sprite2.tick(function() {\n    let m = this._parent.matrix();\n    if (first) {\n      first = false;\n      if (!(m = M)) {\n        return;\n      }\n    }\n    M = m;\n    let newRatio = Math.max(Math.abs(m.a), Math.abs(m.b));\n    let rationChange = lastRatio / newRatio;\n    if (lastRatio === 0 || rationChange > 1.25 || rationChange < 0.8) {\n      const newSelection = memoKey();\n      if (lastSelection !== newSelection) {\n        lastRatio = newRatio;\n        callback(2.5 * newRatio / PIXEL_RATIO, texture2, sprite2);\n        sprite2.texture(texture2);\n        sprite2.__timestamp = Date.now();\n      }\n    }\n  }, false);\n  return sprite2;\n}\nclass Mouse {\n  constructor() {\n    __publicField(this, \"x\", 0);\n    __publicField(this, \"y\", 0);\n    __publicField(this, \"ratio\", 1);\n    __publicField(this, \"stage\");\n    __publicField(this, \"elem\");\n    __publicField(this, \"clicklist\", []);\n    __publicField(this, \"cancellist\", []);\n    __publicField(this, \"handleStart\", (event) => {\n      event.preventDefault();\n      this.locate(event);\n      this.publish(event.type, event);\n      this.lookup(\"click\", this.clicklist);\n      this.lookup(\"mousecancel\", this.cancellist);\n    });\n    __publicField(this, \"handleMove\", (event) => {\n      event.preventDefault();\n      this.locate(event);\n      this.publish(event.type, event);\n    });\n    __publicField(this, \"handleEnd\", (event) => {\n      event.preventDefault();\n      this.publish(event.type, event);\n      if (this.clicklist.length) {\n        this.publish(\"click\", event, this.clicklist);\n      }\n      this.cancellist.length = 0;\n    });\n    __publicField(this, \"handleCancel\", (event) => {\n      if (this.cancellist.length) {\n        this.publish(\"mousecancel\", event, this.cancellist);\n      }\n      this.clicklist.length = 0;\n    });\n    __publicField(this, \"toString\", function() {\n      return (this.x | 0) + \"x\" + (this.y | 0);\n    });\n    __publicField(this, \"locate\", function(event) {\n      const elem = this.elem;\n      let x;\n      let y;\n      if (event.touches && event.touches.length) {\n        x = event.touches[0].clientX;\n        y = event.touches[0].clientY;\n      } else {\n        x = event.clientX;\n        y = event.clientY;\n      }\n      var rect = elem.getBoundingClientRect();\n      x -= rect.left;\n      y -= rect.top;\n      x -= elem.clientLeft | 0;\n      y -= elem.clientTop | 0;\n      this.x = x * this.ratio;\n      this.y = y * this.ratio;\n    });\n    __publicField(this, \"lookup\", function(type, collect) {\n      this.type = type;\n      this.root = this.stage;\n      this.event = null;\n      collect.length = 0;\n      this.collect = collect;\n      this.root.visit({\n        reverse: true,\n        visible: true,\n        start: this.visitStart,\n        end: this.visitEnd\n      }, this);\n    });\n    __publicField(this, \"publish\", function(type, event, targets) {\n      this.type = type;\n      this.root = this.stage;\n      this.event = event;\n      this.collect = false;\n      this.timeStamp = Date.now();\n      if (type !== \"mousemove\" && type !== \"touchmove\") {\n        console.log(this.type + \" \" + this);\n      }\n      if (targets) {\n        while (targets.length)\n          if (this.visitEnd(targets.shift()))\n            break;\n        targets.length = 0;\n      } else {\n        this.root.visit({\n          reverse: true,\n          visible: true,\n          start: this.visitStart,\n          end: this.visitEnd\n        }, this);\n      }\n    });\n    __publicField(this, \"visitStart\", (node) => {\n      return !node._flag(this.type);\n    });\n    __publicField(this, \"visitEnd\", (node) => {\n      rel.raw = this.event;\n      rel.type = this.type;\n      rel.timeStamp = this.timeStamp;\n      rel.abs.x = this.x;\n      rel.abs.y = this.y;\n      var listeners = node.listeners(this.type);\n      if (!listeners) {\n        return;\n      }\n      node.matrix().inverse().map(this, rel);\n      if (!(node === this.root || node.attr(\"spy\") || node.hitTest(rel))) {\n        return;\n      }\n      if (this.collect) {\n        this.collect.push(node);\n      }\n      if (this.event) {\n        var cancel = false;\n        for (var l = 0; l < listeners.length; l++) {\n          cancel = listeners[l].call(node, rel) ? true : cancel;\n        }\n        return cancel;\n      }\n    });\n  }\n  mount(stage, elem) {\n    this.stage = stage;\n    this.elem = elem;\n    this.ratio = stage.viewport().ratio || 1;\n    stage.on(\"viewport\", (size) => {\n      this.ratio = size.ratio ?? this.ratio;\n    });\n    elem.addEventListener(\"touchstart\", this.handleStart);\n    elem.addEventListener(\"touchend\", this.handleEnd);\n    elem.addEventListener(\"touchmove\", this.handleMove);\n    elem.addEventListener(\"touchcancel\", this.handleCancel);\n    elem.addEventListener(\"mousedown\", this.handleStart);\n    elem.addEventListener(\"mouseup\", this.handleEnd);\n    elem.addEventListener(\"mousemove\", this.handleMove);\n    document.addEventListener(\"mouseup\", this.handleCancel);\n    window.addEventListener(\"blur\", this.handleCancel);\n    return this;\n  }\n  unmount() {\n    const elem = this.elem;\n    elem.removeEventListener(\"touchstart\", this.handleStart);\n    elem.removeEventListener(\"touchend\", this.handleEnd);\n    elem.removeEventListener(\"touchmove\", this.handleMove);\n    elem.removeEventListener(\"touchcancel\", this.handleCancel);\n    elem.removeEventListener(\"mousedown\", this.handleStart);\n    elem.removeEventListener(\"mouseup\", this.handleEnd);\n    elem.removeEventListener(\"mousemove\", this.handleMove);\n    document.removeEventListener(\"mouseup\", this.handleCancel);\n    window.removeEventListener(\"blur\", this.handleCancel);\n    return this;\n  }\n}\n__publicField(Mouse, \"CLICK\", \"click\");\n__publicField(Mouse, \"START\", \"touchstart mousedown\");\n__publicField(Mouse, \"MOVE\", \"touchmove mousemove\");\n__publicField(Mouse, \"END\", \"touchend mouseup\");\n__publicField(Mouse, \"CANCEL\", \"touchcancel mousecancel\");\nvar rel = {}, abs = {};\ndefineValue(rel, \"clone\", function(obj) {\n  obj = obj || {}, obj.x = this.x, obj.y = this.y;\n  return obj;\n});\ndefineValue(rel, \"toString\", function() {\n  return (this.x | 0) + \"x\" + (this.y | 0) + \" (\" + this.abs + \")\";\n});\ndefineValue(rel, \"abs\", abs);\ndefineValue(abs, \"clone\", function(obj) {\n  obj = obj || {}, obj.x = this.x, obj.y = this.y;\n  return obj;\n});\ndefineValue(abs, \"toString\", function() {\n  return (this.x | 0) + \"x\" + (this.y | 0);\n});\nfunction defineValue(obj, name, value) {\n  Object.defineProperty(obj, name, {\n    value\n  });\n}\nfunction IDENTITY(x) {\n  return x;\n}\nvar _cache = {};\nvar _modes = {};\nvar _easings = {};\nclass Easing {\n  static get(token, fallback = IDENTITY) {\n    if (typeof token === \"function\") {\n      return token;\n    }\n    if (typeof token !== \"string\") {\n      return fallback;\n    }\n    var fn = _cache[token];\n    if (fn) {\n      return fn;\n    }\n    var match = /^(\\w+)(-(in|out|in-out|out-in))?(\\((.*)\\))?$/i.exec(token);\n    if (!match || !match.length) {\n      return fallback;\n    }\n    var easing = _easings[match[1]];\n    var mode = _modes[match[3]];\n    var params = match[5];\n    if (easing && easing.fn) {\n      fn = easing.fn;\n    } else if (easing && easing.fc) {\n      fn = easing.fc.apply(easing.fc, params && params.replace(/\\s+/, \"\").split(\",\"));\n    } else {\n      fn = fallback;\n    }\n    if (mode) {\n      fn = mode.fn(fn);\n    }\n    _cache[token] = fn;\n    return fn;\n  }\n  static add(data) {\n    var names = (data.name || data.mode).split(/\\s+/);\n    for (var i = 0; i < names.length; i++) {\n      var name = names[i];\n      if (name) {\n        (data.name ? _easings : _modes)[name] = data;\n      }\n    }\n  }\n}\nEasing.add({\n  mode: \"in\",\n  fn: function(f) {\n    return f;\n  }\n});\nEasing.add({\n  mode: \"out\",\n  fn: function(f) {\n    return function(t) {\n      return 1 - f(1 - t);\n    };\n  }\n});\nEasing.add({\n  mode: \"in-out\",\n  fn: function(f) {\n    return function(t) {\n      return t < 0.5 ? f(2 * t) / 2 : 1 - f(2 * (1 - t)) / 2;\n    };\n  }\n});\nEasing.add({\n  mode: \"out-in\",\n  fn: function(f) {\n    return function(t) {\n      return t < 0.5 ? 1 - f(2 * (1 - t)) / 2 : f(2 * t) / 2;\n    };\n  }\n});\nEasing.add({\n  name: \"linear\",\n  fn: function(t) {\n    return t;\n  }\n});\nEasing.add({\n  name: \"quad\",\n  fn: function(t) {\n    return t * t;\n  }\n});\nEasing.add({\n  name: \"cubic\",\n  fn: function(t) {\n    return t * t * t;\n  }\n});\nEasing.add({\n  name: \"quart\",\n  fn: function(t) {\n    return t * t * t * t;\n  }\n});\nEasing.add({\n  name: \"quint\",\n  fn: function(t) {\n    return t * t * t * t * t;\n  }\n});\nEasing.add({\n  name: \"sin sine\",\n  fn: function(t) {\n    return 1 - Math.cos(t * Math.PI / 2);\n  }\n});\nEasing.add({\n  name: \"exp expo\",\n  fn: function(t) {\n    return t == 0 ? 0 : Math.pow(2, 10 * (t - 1));\n  }\n});\nEasing.add({\n  name: \"circle circ\",\n  fn: function(t) {\n    return 1 - Math.sqrt(1 - t * t);\n  }\n});\nEasing.add({\n  name: \"bounce\",\n  fn: function(t) {\n    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;\n  }\n});\nEasing.add({\n  name: \"poly\",\n  fc: function(e) {\n    return function(t) {\n      return Math.pow(t, e);\n    };\n  }\n});\nEasing.add({\n  name: \"elastic\",\n  fc: function(a, p) {\n    p = p || 0.45;\n    a = a || 1;\n    var s = p / (2 * Math.PI) * Math.asin(1 / a);\n    return function(t) {\n      return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p);\n    };\n  }\n});\nEasing.add({\n  name: \"back\",\n  fc: function(s) {\n    s = typeof s !== \"undefined\" ? s : 1.70158;\n    return function(t) {\n      return t * t * ((s + 1) * t - s);\n    };\n  }\n});\nNode.prototype.tween = function(a, b, c) {\n  let options;\n  if (typeof a === \"object\" && a !== null) {\n    options = a;\n  } else if (typeof a === \"number\" && typeof b === \"number\") {\n    options = {\n      duration: a,\n      delay: b,\n      append: c\n    };\n  } else if (typeof a === \"number\") {\n    options = {\n      duration: a,\n      delay: 0,\n      append: b\n    };\n  } else {\n    options = {\n      duration: 400,\n      delay: 0,\n      append: a\n    };\n  }\n  if (!this._tweens) {\n    this._tweens = [];\n    var ticktime = 0;\n    this.tick(function(elapsed, now, last) {\n      if (!this._tweens.length) {\n        return false;\n      }\n      var ignore = ticktime != last;\n      ticktime = now;\n      if (ignore) {\n        return true;\n      }\n      var head = this._tweens[0];\n      var ended = head.tick(this, elapsed, now, last);\n      if (ended) {\n        if (head === this._tweens[0]) {\n          this._tweens.shift();\n        }\n        var next = head.finish();\n        if (next) {\n          this._tweens.unshift(next);\n        }\n      }\n      return true;\n    }, true);\n  }\n  this.touch();\n  if (!options.append) {\n    this._tweens.length = 0;\n  }\n  var tween = new Tween(this, options);\n  this._tweens.push(tween);\n  return tween;\n};\nclass Tween {\n  constructor(owner, options = {}) {\n    __publicField(this, \"_ending\", []);\n    this._end = {};\n    this._duration = options.duration || 400;\n    this._delay = options.delay || 0;\n    this._owner = owner;\n    this._time = 0;\n  }\n  // @internal\n  tick(node, elapsed, now, last) {\n    this._time += elapsed;\n    if (this._time < this._delay) {\n      return;\n    }\n    var time = this._time - this._delay;\n    if (!this._start) {\n      this._start = {};\n      for (var key in this._end) {\n        this._start[key] = this._owner.pin(key);\n      }\n    }\n    var p = Math.min(time / this._duration, 1);\n    var ended = p >= 1;\n    if (typeof this._easing == \"function\") {\n      p = this._easing(p);\n    }\n    var q = 1 - p;\n    for (var key in this._end) {\n      this._owner.pin(key, this._start[key] * q + this._end[key] * p);\n    }\n    return ended;\n  }\n  // @internal\n  finish() {\n    this._ending.forEach((callback) => {\n      try {\n        callback.call(this._owner);\n      } catch (e) {\n        console.error(e);\n      }\n    });\n    return this._next;\n  }\n  tween(duration, delay) {\n    return this._next = new Tween(this._owner, duration, delay);\n  }\n  duration(duration) {\n    this._duration = duration;\n    return this;\n  }\n  delay(delay) {\n    this._delay = delay;\n    return this;\n  }\n  ease(easing) {\n    this._easing = Easing.get(easing);\n    return this;\n  }\n  done(fn) {\n    this._ending.push(fn);\n    return this;\n  }\n  hide() {\n    this._ending.push(function() {\n      this.hide();\n    });\n    this._hide = true;\n    return this;\n  }\n  remove() {\n    this._ending.push(function() {\n      this.remove();\n    });\n    this._remove = true;\n    return this;\n  }\n  pin(a, b) {\n    if (typeof a === \"object\") {\n      for (var attr in a) {\n        pinning(this._owner, this._end, attr, a[attr]);\n      }\n    } else if (typeof b !== \"undefined\") {\n      pinning(this._owner, this._end, a, b);\n    }\n    return this;\n  }\n  /**\n   * @deprecated Use .done(fn) instead.\n   */\n  then(fn) {\n    this.done(fn);\n    return this;\n  }\n  /**\n   * @deprecated this doesn't do anything anymore, call tween on the node instead.\n   */\n  clear(forward) {\n    return this;\n  }\n}\nfunction pinning(node, map, key, value) {\n  if (typeof node.pin(key) === \"number\") {\n    map[key] = value;\n  } else if (typeof node.pin(key + \"X\") === \"number\" && typeof node.pin(key + \"Y\") === \"number\") {\n    map[key + \"X\"] = value;\n    map[key + \"Y\"] = value;\n  }\n}\nPin._add_shortcuts(Tween.prototype);\nconst _stages = [];\nconst pause = function() {\n  for (let i = _stages.length - 1; i >= 0; i--) {\n    _stages[i].pause();\n  }\n};\nconst resume = function() {\n  for (let i = _stages.length - 1; i >= 0; i--) {\n    _stages[i].resume();\n  }\n};\nconst mount = function(configs = {}) {\n  let root = new Root();\n  root.mount(configs);\n  root.mouse = new Mouse().mount(root, root.dom);\n  return root;\n};\nclass Root extends Node {\n  constructor() {\n    super();\n    __publicField(this, \"canvas\", null);\n    __publicField(this, \"dom\", null);\n    __publicField(this, \"context\", null);\n    __publicField(this, \"pixelWidth\", -1);\n    __publicField(this, \"pixelHeight\", -1);\n    __publicField(this, \"pixelRatio\", 1);\n    __publicField(this, \"drawingWidth\", 0);\n    __publicField(this, \"drawingHeight\", 0);\n    __publicField(this, \"mounted\", false);\n    __publicField(this, \"paused\", false);\n    __publicField(this, \"sleep\", false);\n    __publicField(this, \"mount\", (configs = {}) => {\n      if (typeof configs.canvas === \"string\") {\n        this.canvas = document.getElementById(configs.canvas);\n      } else if (configs.canvas instanceof HTMLCanvasElement) {\n        this.canvas = configs.canvas;\n      } else if (configs.canvas)\n        ;\n      if (!this.canvas) {\n        this.canvas = document.getElementById(\"cutjs\") || document.getElementById(\"stage\");\n      }\n      if (!this.canvas) {\n        console.log(\"Creating Canvas...\");\n        this.canvas = document.createElement(\"canvas\");\n        Object.assign(this.canvas.style, {\n          position: \"absolute\",\n          display: \"block\",\n          top: \"0\",\n          left: \"0\",\n          bottom: \"0\",\n          right: \"0\",\n          width: \"100%\",\n          height: \"100%\"\n        });\n        let body = document.body;\n        body.insertBefore(this.canvas, body.firstChild);\n      }\n      this.dom = this.canvas;\n      this.context = this.canvas.getContext(\"2d\");\n      this.devicePixelRatio = window.devicePixelRatio || 1;\n      this.backingStoreRatio = this.context.webkitBackingStorePixelRatio || this.context.mozBackingStorePixelRatio || this.context.msBackingStorePixelRatio || this.context.oBackingStorePixelRatio || this.context.backingStorePixelRatio || 1;\n      this.pixelRatio = this.devicePixelRatio / this.backingStoreRatio;\n      this.mounted = true;\n      _stages.push(this);\n      this.requestFrame(this.onFrame);\n    });\n    __publicField(this, \"frameRequested\", false);\n    __publicField(this, \"requestFrame\", () => {\n      if (!this.frameRequested) {\n        this.frameRequested = true;\n        requestAnimationFrame(this.onFrame);\n      }\n    });\n    __publicField(this, \"lastTime\", 0);\n    __publicField(this, \"_mo_touch\", null);\n    // monitor touch\n    __publicField(this, \"onFrame\", (now) => {\n      this.frameRequested = false;\n      if (!this.mounted) {\n        return;\n      }\n      this.requestFrame();\n      const newPixelWidth = this.canvas.clientWidth;\n      const newPixelHeight = this.canvas.clientHeight;\n      if (this.pixelWidth !== newPixelWidth || this.pixelHeight !== newPixelHeight) {\n        this.pixelWidth = newPixelWidth;\n        this.pixelHeight = newPixelHeight;\n        this.drawingWidth = newPixelWidth * this.pixelRatio;\n        this.drawingHeight = newPixelHeight * this.pixelRatio;\n        if (this.canvas.width !== this.drawingWidth || this.canvas.height !== this.drawingHeight) {\n          this.canvas.width = this.drawingWidth;\n          this.canvas.height = this.drawingHeight;\n          console.log(\"Resize: [\" + this.drawingWidth + \", \" + this.drawingHeight + \"] = \" + this.pixelRatio + \" x [\" + this.pixelWidth + \", \" + this.pixelHeight + \"]\");\n          this.viewport({\n            width: this.drawingWidth,\n            height: this.drawingHeight,\n            ratio: this.pixelRatio\n          });\n        }\n      }\n      let last = this.lastTime || now;\n      let elapsed = now - last;\n      if (!this.mounted || this.paused || this.sleep) {\n        return;\n      }\n      this.lastTime = now;\n      let tickRequest = this._tick(elapsed, now, last);\n      if (this._mo_touch != this._ts_touch) {\n        this._mo_touch = this._ts_touch;\n        this.sleep = false;\n        if (this.drawingWidth > 0 && this.drawingHeight > 0) {\n          this.context.setTransform(1, 0, 0, 1, 0, 0);\n          this.context.clearRect(0, 0, this.drawingWidth, this.drawingHeight);\n          this.render(this.context);\n        }\n      } else if (tickRequest) {\n        this.sleep = false;\n      } else {\n        this.sleep = true;\n      }\n      stats.fps = elapsed ? 1e3 / elapsed : 0;\n    });\n    this.label(\"Root\");\n  }\n  resume() {\n    if (this.sleep || this.paused) {\n      this.requestFrame();\n    }\n    this.paused = false;\n    this.sleep = false;\n    this.publish(\"resume\");\n    return this;\n  }\n  pause() {\n    if (!this.paused) {\n      this.publish(\"pause\");\n    }\n    this.paused = true;\n    return this;\n  }\n  touch() {\n    if (this.sleep || this.paused) {\n      this.requestFrame();\n    }\n    this.sleep = false;\n    return Node.prototype.touch();\n  }\n  unmount() {\n    var _a;\n    this.mounted = false;\n    let index = _stages.indexOf(this);\n    if (index >= 0) {\n      _stages.splice(index, 1);\n    }\n    (_a = this.mouse) == null ? void 0 : _a.unmount();\n    return this;\n  }\n  background(color) {\n    this.dom.style.backgroundColor = color;\n    return this;\n  }\n  /**\n   * Set/Get viewport.\n   * This is used along with viewbox to determine the scale and position of the viewbox within the viewport.\n   * Viewport is the size of the container, for example size of the canvas element.\n   * Viewbox is provided by the user, and is the ideal size of the content.\n   */\n  viewport(width, height, ratio) {\n    if (typeof width === \"undefined\") {\n      return Object.assign({}, this._viewport);\n    }\n    if (typeof width === \"object\") {\n      const options = width;\n      width = options.width;\n      height = options.height;\n      ratio = options.ratio;\n    }\n    this._viewport = {\n      width,\n      height,\n      ratio: ratio || 1\n    };\n    this.viewbox();\n    let data = Object.assign({}, this._viewport);\n    this.visit({\n      start: function(node) {\n        if (!node._flag(\"viewport\")) {\n          return true;\n        }\n        node.publish(\"viewport\", [data]);\n      }\n    });\n    return this;\n  }\n  /**\n   * Set viewbox.\n   * \n   * @param {mode} string - One of: 'in-pad' (like css object-fit: 'contain'), 'in', 'out-crop' (like css object-fit: 'cover'), 'out'\n   */\n  // TODO: static/fixed viewbox\n  // TODO: use css object-fit values\n  viewbox(width, height, mode) {\n    if (typeof width === \"number\" && typeof height === \"number\") {\n      this._viewbox = {\n        width,\n        height,\n        mode\n      };\n    } else if (typeof width === \"object\" && width !== null) {\n      this._viewbox = {\n        ...width\n      };\n    }\n    this.rescale();\n    return this;\n  }\n  camera(matrix) {\n    this._camera = matrix;\n    this.rescale();\n    return this;\n  }\n  rescale() {\n    let viewbox = this._viewbox;\n    let viewport = this._viewport;\n    let camera = this._camera;\n    if (viewport && viewbox) {\n      const viewportWidth = viewport.width;\n      const viewportHeight = viewport.height;\n      const viewboxMode = /^(in|out|in-pad|out-crop)$/.test(viewbox.mode) ? viewbox.mode : \"in-pad\";\n      const viewboxWidth = viewbox.width;\n      const viewboxHeight = viewbox.height;\n      this.pin({\n        width: viewboxWidth,\n        height: viewboxHeight\n      });\n      this.scaleTo(viewportWidth, viewportHeight, viewboxMode);\n      const viewboxX = viewbox.x || 0;\n      const viewboxY = viewbox.y || 0;\n      const cameraZoom = (camera == null ? void 0 : camera.a) || 1;\n      const cameraX = (camera == null ? void 0 : camera.e) || 0;\n      const cameraY = (camera == null ? void 0 : camera.f) || 0;\n      const scaleX = this.pin(\"scaleX\");\n      const scaleY = this.pin(\"scaleY\");\n      this.pin(\"scaleX\", scaleX * cameraZoom);\n      this.pin(\"scaleY\", scaleY * cameraZoom);\n      this.pin(\"offsetX\", cameraX - viewboxX * scaleX * cameraZoom);\n      this.pin(\"offsetY\", cameraY - viewboxY * scaleY * cameraZoom);\n    } else if (viewport) {\n      this.pin({\n        width: viewport.width,\n        height: viewport.height\n      });\n    }\n    return this;\n  }\n}\nconst sprite = function(frame) {\n  var sprite2 = new Sprite();\n  frame && sprite2.texture(frame);\n  return sprite2;\n};\nSprite._super = Node;\nSprite.prototype = Object.create(Sprite._super.prototype);\nfunction Sprite() {\n  Sprite._super.call(this);\n  this.label(\"Sprite\");\n  this._textures = [];\n  this._image = null;\n}\nSprite.prototype.texture = function(frame) {\n  this._image = texture(frame).one();\n  this.pin(\"width\", this._image ? this._image.width : 0);\n  this.pin(\"height\", this._image ? this._image.height : 0);\n  this._textures[0] = this._image.pipe();\n  this._textures.length = 1;\n  return this;\n};\nSprite.prototype.tile = function(inner) {\n  this._repeat(false, inner);\n  return this;\n};\nSprite.prototype.stretch = function(inner) {\n  this._repeat(true, inner);\n  return this;\n};\nSprite.prototype._repeat = function(stretch, inner) {\n  var self = this;\n  this.untick(this._repeatTicker);\n  this.tick(this._repeatTicker = function() {\n    if (this._mo_stretch == this._pin._ts_transform) {\n      return;\n    }\n    this._mo_stretch = this._pin._ts_transform;\n    var width = this.pin(\"width\");\n    var height = this.pin(\"height\");\n    this._textures.length = repeat(this._image, width, height, stretch, inner, insert);\n  });\n  function insert(i, sx, sy, sw, sh, dx, dy, dw, dh) {\n    var repeat2 = self._textures.length > i ? self._textures[i] : self._textures[i] = self._image.pipe();\n    repeat2.src(sx, sy, sw, sh);\n    repeat2.dest(dx, dy, dw, dh);\n  }\n};\nfunction repeat(img, owidth, oheight, stretch, inner, insert) {\n  var width = img.width;\n  var height = img.height;\n  var left = img.left;\n  var right = img.right;\n  var top = img.top;\n  var bottom = img.bottom;\n  left = typeof left === \"number\" && left === left ? left : 0;\n  right = typeof right === \"number\" && right === right ? right : 0;\n  top = typeof top === \"number\" && top === top ? top : 0;\n  bottom = typeof bottom === \"number\" && bottom === bottom ? bottom : 0;\n  width = width - left - right;\n  height = height - top - bottom;\n  if (!inner) {\n    owidth = Math.max(owidth - left - right, 0);\n    oheight = Math.max(oheight - top - bottom, 0);\n  }\n  var i = 0;\n  if (top > 0 && left > 0)\n    insert(i++, 0, 0, left, top, 0, 0, left, top);\n  if (bottom > 0 && left > 0)\n    insert(i++, 0, height + top, left, bottom, 0, oheight + top, left, bottom);\n  if (top > 0 && right > 0)\n    insert(i++, width + left, 0, right, top, owidth + left, 0, right, top);\n  if (bottom > 0 && right > 0)\n    insert(\n      i++,\n      width + left,\n      height + top,\n      right,\n      bottom,\n      owidth + left,\n      oheight + top,\n      right,\n      bottom\n    );\n  if (stretch) {\n    if (top > 0)\n      insert(i++, left, 0, width, top, left, 0, owidth, top);\n    if (bottom > 0)\n      insert(\n        i++,\n        left,\n        height + top,\n        width,\n        bottom,\n        left,\n        oheight + top,\n        owidth,\n        bottom\n      );\n    if (left > 0)\n      insert(i++, 0, top, left, height, 0, top, left, oheight);\n    if (right > 0)\n      insert(\n        i++,\n        width + left,\n        top,\n        right,\n        height,\n        owidth + left,\n        top,\n        right,\n        oheight\n      );\n    insert(i++, left, top, width, height, left, top, owidth, oheight);\n  } else {\n    var l = left, r = owidth, w;\n    while (r > 0) {\n      w = Math.min(width, r), r -= width;\n      var t = top, b = oheight, h;\n      while (b > 0) {\n        h = Math.min(height, b), b -= height;\n        insert(i++, left, top, w, h, l, t, w, h);\n        if (r <= 0) {\n          if (left)\n            insert(i++, 0, top, left, h, 0, t, left, h);\n          if (right)\n            insert(i++, width + left, top, right, h, l + w, t, right, h);\n        }\n        t += h;\n      }\n      if (top)\n        insert(i++, left, 0, w, top, l, 0, w, top);\n      if (bottom)\n        insert(i++, left, height + top, w, bottom, l, t, w, bottom);\n      l += w;\n    }\n  }\n  return i;\n}\nSprite.prototype.image = Sprite.prototype.texture;\nconst image = sprite;\nconst Image$1 = Sprite;\nconst anim = function(frames, fps) {\n  var anim2 = new Anim();\n  anim2.frames(frames).gotoFrame(0);\n  fps && anim2.fps(fps);\n  return anim2;\n};\nAnim._super = Node;\nAnim.prototype = Object.create(Anim._super.prototype);\nconst FPS = 15;\nfunction Anim() {\n  Anim._super.call(this);\n  this.label(\"Anim\");\n  this._textures = [];\n  this._fps = FPS;\n  this._ft = 1e3 / this._fps;\n  this._time = -1;\n  this._repeat = 0;\n  this._index = 0;\n  this._frames = [];\n  var lastTime = 0;\n  this.tick(function(t, now, last) {\n    if (this._time < 0 || this._frames.length <= 1) {\n      return;\n    }\n    var ignore = lastTime != last;\n    lastTime = now;\n    if (ignore) {\n      return true;\n    }\n    this._time += t;\n    if (this._time < this._ft) {\n      return true;\n    }\n    var n = this._time / this._ft | 0;\n    this._time -= n * this._ft;\n    this.moveFrame(n);\n    if (this._repeat > 0 && (this._repeat -= n) <= 0) {\n      this.stop();\n      this._callback && this._callback();\n      return false;\n    }\n    return true;\n  }, false);\n}\nAnim.prototype.fps = function(fps) {\n  if (typeof fps === \"undefined\") {\n    return this._fps;\n  }\n  this._fps = fps > 0 ? fps : FPS;\n  this._ft = 1e3 / this._fps;\n  return this;\n};\nAnim.prototype.setFrames = function(a, b, c) {\n  return this.frames(a, b, c);\n};\nAnim.prototype.frames = function(frames) {\n  this._index = 0;\n  this._frames = texture(frames).array();\n  this.touch();\n  return this;\n};\nAnim.prototype.length = function() {\n  return this._frames ? this._frames.length : 0;\n};\nAnim.prototype.gotoFrame = function(frame, resize) {\n  this._index = math.wrap(frame, this._frames.length) | 0;\n  resize = resize || !this._textures[0];\n  this._textures[0] = this._frames[this._index];\n  if (resize) {\n    this.pin(\"width\", this._textures[0].width);\n    this.pin(\"height\", this._textures[0].height);\n  }\n  this.touch();\n  return this;\n};\nAnim.prototype.moveFrame = function(move) {\n  return this.gotoFrame(this._index + move);\n};\nAnim.prototype.repeat = function(repeat2, callback) {\n  this._repeat = repeat2 * this._frames.length - 1;\n  this._callback = callback;\n  this.play();\n  return this;\n};\nAnim.prototype.play = function(frame) {\n  if (typeof frame !== \"undefined\") {\n    this.gotoFrame(frame);\n    this._time = 0;\n  } else if (this._time < 0) {\n    this._time = 0;\n  }\n  this.touch();\n  return this;\n};\nAnim.prototype.stop = function(frame) {\n  this._time = -1;\n  if (typeof frame !== \"undefined\") {\n    this.gotoFrame(frame);\n  }\n  return this;\n};\nconst string$1 = function(frames) {\n  return new Str().frames(frames);\n};\nStr._super = Node;\nStr.prototype = Object.create(Str._super.prototype);\nfunction Str() {\n  Str._super.call(this);\n  this.label(\"String\");\n  this._textures = [];\n}\nStr.prototype.setFont = function(a, b, c) {\n  return this.frames(a, b, c);\n};\nStr.prototype.frames = function(frames) {\n  this._textures = [];\n  if (typeof frames == \"string\") {\n    frames = texture(frames);\n    this._item = function(value) {\n      return frames.one(value);\n    };\n  } else if (typeof frames === \"object\") {\n    this._item = function(value) {\n      return frames[value];\n    };\n  } else if (typeof frames === \"function\") {\n    this._item = frames;\n  }\n  return this;\n};\nStr.prototype.setValue = function(a, b, c) {\n  return this.value(a, b, c);\n};\nStr.prototype.value = function(value) {\n  if (typeof value === \"undefined\") {\n    return this._value;\n  }\n  if (this._value === value) {\n    return this;\n  }\n  this._value = value;\n  if (value === null) {\n    value = \"\";\n  } else if (typeof value !== \"string\" && !Array.isArray(value)) {\n    value = value.toString();\n  }\n  this._spacing = this._spacing || 0;\n  var width = 0, height = 0;\n  for (var i = 0; i < value.length; i++) {\n    var texture2 = this._textures[i] = this._item(value[i]);\n    width += i > 0 ? this._spacing : 0;\n    texture2.dest(width, 0);\n    width = width + texture2.width;\n    height = Math.max(height, texture2.height);\n  }\n  this.pin(\"width\", width);\n  this.pin(\"height\", height);\n  this._textures.length = value.length;\n  return this;\n};\nconst row = function(align) {\n  return create().row(align).label(\"Row\");\n};\nNode.prototype.row = function(align) {\n  this.align(\"row\", align);\n  return this;\n};\nconst column = function(align) {\n  return create().column(align).label(\"Row\");\n};\nNode.prototype.column = function(align) {\n  this.align(\"column\", align);\n  return this;\n};\nNode.prototype.align = function(type, align) {\n  this._padding = this._padding || 0;\n  this._spacing = this._spacing || 0;\n  this.untick(this._layoutTiker);\n  this.tick(this._layoutTiker = function() {\n    if (this._mo_seq == this._ts_touch) {\n      return;\n    }\n    this._mo_seq = this._ts_touch;\n    var alignChildren = this._mo_seqAlign != this._ts_children;\n    this._mo_seqAlign = this._ts_children;\n    var width = 0, height = 0;\n    var child, next = this.first(true);\n    var first = true;\n    while (child = next) {\n      next = child.next(true);\n      child.matrix(true);\n      var w = child.pin(\"boxWidth\");\n      var h = child.pin(\"boxHeight\");\n      if (type == \"column\") {\n        !first && (height += this._spacing);\n        child.pin(\"offsetY\") != height && child.pin(\"offsetY\", height);\n        width = Math.max(width, w);\n        height = height + h;\n        alignChildren && child.pin(\"alignX\", align);\n      } else if (type == \"row\") {\n        !first && (width += this._spacing);\n        child.pin(\"offsetX\") != width && child.pin(\"offsetX\", width);\n        width = width + w;\n        height = Math.max(height, h);\n        alignChildren && child.pin(\"alignY\", align);\n      }\n      first = false;\n    }\n    width += 2 * this._padding;\n    height += 2 * this._padding;\n    this.pin(\"width\") != width && this.pin(\"width\", width);\n    this.pin(\"height\") != height && this.pin(\"height\", height);\n  });\n  return this;\n};\nconst box = function() {\n  return create().box().label(\"Box\");\n};\nNode.prototype.box = function() {\n  this._padding = this._padding || 0;\n  this.untick(this._layoutTiker);\n  this.tick(this._layoutTiker = function() {\n    if (this._mo_box == this._ts_touch) {\n      return;\n    }\n    this._mo_box = this._ts_touch;\n    var width = 0, height = 0;\n    var child, next = this.first(true);\n    while (child = next) {\n      next = child.next(true);\n      child.matrix(true);\n      var w = child.pin(\"boxWidth\");\n      var h = child.pin(\"boxHeight\");\n      width = Math.max(width, w);\n      height = Math.max(height, h);\n    }\n    width += 2 * this._padding;\n    height += 2 * this._padding;\n    this.pin(\"width\") != width && this.pin(\"width\", width);\n    this.pin(\"height\") != height && this.pin(\"height\", height);\n  });\n  return this;\n};\nconst layer = function() {\n  return create().layer().label(\"Layer\");\n};\nNode.prototype.layer = function() {\n  this.untick(this._layoutTiker);\n  this.tick(this._layoutTiker = function() {\n    var parent = this.parent();\n    if (parent) {\n      var width = parent.pin(\"width\");\n      if (this.pin(\"width\") != width) {\n        this.pin(\"width\", width);\n      }\n      var height = parent.pin(\"height\");\n      if (this.pin(\"height\") != height) {\n        this.pin(\"height\", height);\n      }\n    }\n  }, true);\n  return this;\n};\nNode.prototype.padding = function(pad) {\n  this._padding = pad;\n  return this;\n};\nNode.prototype.spacing = function(space) {\n  this._spacing = space;\n  return this;\n};\nconst Stage$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  Anim,\n  Atlas,\n  Image: Image$1,\n  Math: math,\n  Matrix,\n  Mouse,\n  Node,\n  Pin,\n  Root,\n  Sprite,\n  Str,\n  Texture,\n  Tween,\n  anim,\n  atlas,\n  box,\n  canvas,\n  column,\n  create,\n  image,\n  layer,\n  math,\n  memoizeDraw,\n  mount,\n  pause,\n  resume,\n  row,\n  sprite,\n  string: string$1,\n  texture\n}, Symbol.toStringTag, { value: \"Module\" }));\nexport {\n  Anim,\n  Atlas,\n  Image$1 as Image,\n  math as Math,\n  Matrix,\n  Mouse,\n  Node,\n  Pin,\n  Root,\n  Sprite,\n  Str,\n  Texture,\n  Tween,\n  anim,\n  atlas,\n  box,\n  canvas,\n  column,\n  create,\n  Stage$1 as default,\n  image,\n  layer,\n  math,\n  memoizeDraw,\n  mount,\n  pause,\n  resume,\n  row,\n  sprite,\n  string$1 as string,\n  texture\n};\n","export const options = function<T>(input: T, defaults: object): T {\n  if (input === null || typeof input === 'undefined') {\n    // tslint:disable-next-line:no-object-literal-type-assertion\n    input = {} as T;\n  }\n\n  const output = {...input};\n\n  // tslint:disable-next-line:no-for-in\n  for (const key in defaults) {\n    if (defaults.hasOwnProperty(key) && typeof input[key] === 'undefined') {\n      output[key] = defaults[key];\n    }\n  }\n\n  if (typeof Object.getOwnPropertySymbols === 'function') {\n    const symbols = Object.getOwnPropertySymbols(defaults);\n    for (let i = 0; i < symbols.length; i++) {\n      const symbol = symbols[i];\n      if (defaults.propertyIsEnumerable(symbol) && typeof input[symbol] === 'undefined') {\n        output[symbol] = defaults[symbol];\n      }\n    }\n  }\n\n  return output;\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\nexport const math = Object.assign(Object.create(Math) as typeof Math, {\n  EPSILON: 1e-9, // TODO\n\n  /**\n   * This function is used to ensure that a floating point number is not a NaN or\n   * infinity.\n   */\n  isFinite: function(x: unknown): boolean {\n    return (typeof x === 'number') && isFinite(x) && !isNaN(x);\n  },\n\n  assert: function(x: any): void {\n    _ASSERT && console.assert(!math.isFinite(x), 'Invalid Number!', x);\n  },\n\n  /**\n   * Next Largest Power of 2 Given a binary integer value x, the next largest\n   * power of 2 can be computed by a SWAR algorithm that recursively \"folds\" the\n   * upper bits into the lower bits. This process yields a bit vector with the\n   * same most significant 1 as x, but all 1's below it. Adding 1 to that value\n   * yields the next largest power of 2. For a 32-bit value:\n   */\n  nextPowerOfTwo: function(x: number): number {\n    // TODO\n    x |= (x >> 1);\n    x |= (x >> 2);\n    x |= (x >> 4);\n    x |= (x >> 8);\n    x |= (x >> 16);\n    return x + 1;\n  },\n\n  isPowerOfTwo: function(x: number): boolean {\n    return x > 0 && (x & (x - 1)) === 0;\n  },\n\n  mod: function(num: number, min?: number, max?: number): number {\n    if (typeof min === 'undefined') {\n      max = 1;\n      min = 0;\n    } else if (typeof max === 'undefined') {\n      max = min;\n      min = 0;\n    }\n    if (max > min) {\n      num = (num - min) % (max - min);\n      return num + (num < 0 ? max : min);\n    } else {\n      num = (num - max) % (min - max);\n      return num + (num <= 0 ? min : max);\n    }\n  },\n  /**\n   * Returns a min if num is less than min, and max if more than max, otherwise returns num.\n   */\n  clamp: function(num: number, min: number, max: number): number {\n    if (num < min) {\n      return min;\n    } else if (num > max) {\n      return max;\n    } else {\n      return num;\n    }\n  },\n  /**\n   * Returns a random number between min and max when two arguments are provided.\n   * If one arg is provided between 0 to max.\n   * If one arg is passed between 0 to 1.\n   */\n  random: function(min?: number, max?: number): number {\n    if (typeof min === 'undefined') {\n      max = 1;\n      min = 0;\n    } else if (typeof max === 'undefined') {\n      max = min;\n      min = 0;\n    }\n    return min === max ? min : Math.random() * (max - min) + min;\n  }\n});\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport * as matrix from './Matrix';\nimport { math as Math } from './Math';\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\nconst _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\nexport interface Vec2Value {\n  x: number;\n  y: number;\n}\n\nexport class Vec2 {\n  x: number;\n  y: number;\n\n  constructor(x: number, y: number);\n  constructor(obj: { x: number, y: number });\n  constructor();\n  // tslint:disable-next-line:typedef\n  constructor(x?, y?) {\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof Vec2)) {\n      return new Vec2(x, y);\n    }\n    if (typeof x === 'undefined') {\n      this.x = 0;\n      this.y = 0;\n    } else if (typeof x === 'object') {\n      this.x = x.x;\n      this.y = x.y;\n    } else {\n      this.x = x;\n      this.y = y;\n    }\n    _ASSERT && Vec2.assert(this);\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      x: this.x,\n      y: this.y\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any): Vec2 {\n    const obj = Object.create(Vec2.prototype);\n    obj.x = data.x;\n    obj.y = data.y;\n    return obj;\n  }\n\n  static zero(): Vec2 {\n    const obj = Object.create(Vec2.prototype);\n    obj.x = 0;\n    obj.y = 0;\n    return obj;\n  }\n\n  /** @internal */\n  static neo(x: number, y: number): Vec2 {\n    const obj = Object.create(Vec2.prototype);\n    obj.x = x;\n    obj.y = y;\n    return obj;\n  }\n\n  static clone(v: Vec2Value): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    return Vec2.neo(v.x, v.y);\n  }\n\n  /** @internal */\n  toString(): string {\n    return JSON.stringify(this);\n  }\n\n  /**\n   * Does this vector contain finite coordinates?\n   */\n  static isValid(obj: any): boolean {\n    if (obj === null || typeof obj === 'undefined') {\n      return false;\n    }\n    return Math.isFinite(obj.x) && Math.isFinite(obj.y);\n  }\n\n  static assert(o: any): void {\n    _ASSERT && console.assert(!Vec2.isValid(o), 'Invalid Vec2!', o);\n  }\n\n  clone(): Vec2 {\n    return Vec2.clone(this);\n  }\n\n  /**\n   * Set this vector to all zeros.\n   *\n   * @returns this\n   */\n  setZero(): Vec2 {\n    this.x = 0.0;\n    this.y = 0.0;\n    return this;\n  }\n\n  set(x: number, y: number): Vec2;\n  set(value: Vec2Value): Vec2;\n  /**\n   * Set this vector to some specified coordinates.\n   *\n   * @returns this\n   */\n  // tslint:disable-next-line:typedef\n  set(x, y?) {\n    if (typeof x === 'object') {\n      _ASSERT && Vec2.assert(x);\n      this.x = x.x;\n      this.y = x.y;\n    } else {\n      _ASSERT && Math.assert(x);\n      _ASSERT && Math.assert(y);\n      this.x = x;\n      this.y = y;\n    }\n    return this;\n  }\n\n  /**\n   * Set this vector to some specified coordinates.\n   *\n   * @returns this\n   */\n   setNum(x: number, y: number) {\n    _ASSERT && Math.assert(x);\n    _ASSERT && Math.assert(y);\n    this.x = x;\n    this.y = y;\n\n    return this;\n  }\n\n  /**\n   * Set this vector to some specified coordinates.\n   *\n   * @returns this\n   */\n  setVec2(value: Vec2Value) {\n    _ASSERT && Vec2.assert(value);\n    this.x = value.x;\n    this.y = value.y;\n\n    return this;\n  }\n\n  /**\n   * @internal\n   * @deprecated Use setCombine or setMul\n   */\n  wSet(a: number, v: Vec2Value, b?: number, w?: Vec2Value): Vec2 {\n    if (typeof b !== 'undefined' || typeof w !== 'undefined') {\n      return this.setCombine(a, v, b, w);\n    } else {\n      return this.setMul(a, v);\n    }\n  }\n\n  /**\n   * Set linear combination of v and w: `a * v + b * w`\n   */\n  setCombine(a: number, v: Vec2Value, b: number, w: Vec2Value): Vec2 {\n    _ASSERT && Math.assert(a);\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Math.assert(b);\n    _ASSERT && Vec2.assert(w);\n    const x = a * v.x + b * w.x;\n    const y = a * v.y + b * w.y;\n\n    // `this` may be `w`\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n\n  setMul(a: number, v: Vec2Value): Vec2 {\n    _ASSERT && Math.assert(a);\n    _ASSERT && Vec2.assert(v);\n    const x = a * v.x;\n    const y = a * v.y;\n\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n\n  /**\n   * Add a vector to this vector.\n   *\n   * @returns this\n   */\n  add(w: Vec2Value): Vec2 {\n    _ASSERT && Vec2.assert(w);\n    this.x += w.x;\n    this.y += w.y;\n    return this;\n  }\n\n  /**\n   * @internal\n   * @deprecated Use addCombine or addMul\n   */\n  wAdd(a: number, v: Vec2Value, b?: number, w?: Vec2Value): Vec2 {\n    if (typeof b !== 'undefined' || typeof w !== 'undefined') {\n      return this.addCombine(a, v, b, w);\n    } else {\n      return this.addMul(a, v);\n    }\n  }\n\n  /**\n   * Add linear combination of v and w: `a * v + b * w`\n   */\n  addCombine(a: number, v: Vec2Value, b: number, w: Vec2Value): Vec2 {\n    _ASSERT && Math.assert(a);\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Math.assert(b);\n    _ASSERT && Vec2.assert(w);\n\n    const x = a * v.x + b * w.x;\n    const y = a * v.y + b * w.y;\n\n    // `this` may be `w`\n    this.x += x;\n    this.y += y;\n    return this;\n  }\n\n  addMul(a: number, v: Vec2Value): Vec2 {\n    _ASSERT && Math.assert(a);\n    _ASSERT && Vec2.assert(v);\n    const x = a * v.x;\n    const y = a * v.y;\n\n    this.x += x;\n    this.y += y;\n    return this;\n  }\n\n  /**\n   * @deprecated Use subCombine or subMul\n   */\n  wSub(a: number, v: Vec2Value, b?: number, w?: Vec2Value): Vec2 {\n    if (typeof b !== 'undefined' || typeof w !== 'undefined') {\n      return this.subCombine(a, v, b, w);\n    } else {\n      return this.subMul(a, v);\n    }}\n\n  /**\n   * Subtract linear combination of v and w: `a * v + b * w`\n   */\n  subCombine(a: number, v: Vec2Value, b: number, w: Vec2Value): Vec2 {\n    _ASSERT && Math.assert(a);\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Math.assert(b);\n    _ASSERT && Vec2.assert(w);\n    const x = a * v.x + b * w.x;\n    const y = a * v.y + b * w.y;\n\n    // `this` may be `w`\n    this.x -= x;\n    this.y -= y;\n    return this;\n  }\n\n  subMul(a: number, v: Vec2Value): Vec2 {\n    _ASSERT && Math.assert(a);\n    _ASSERT && Vec2.assert(v);\n    const x = a * v.x;\n    const y = a * v.y;\n\n    this.x -= x;\n    this.y -= y;\n    return this;\n  }\n\n  /**\n   * Subtract a vector from this vector\n   *\n   * @returns this\n   */\n  sub(w: Vec2Value): Vec2 {\n    _ASSERT && Vec2.assert(w);\n    this.x -= w.x;\n    this.y -= w.y;\n    return this;\n  }\n\n  /**\n   * Multiply this vector by a scalar.\n   *\n   * @returns this\n   */\n  mul(m: number): Vec2 {\n    _ASSERT && Math.assert(m);\n    this.x *= m;\n    this.y *= m;\n    return this;\n  }\n\n  /**\n   * Get the length of this vector (the norm).\n   *\n   * For performance, use this instead of lengthSquared (if possible).\n   */\n  length(): number {\n    return Vec2.lengthOf(this);\n  }\n\n  /**\n   * Get the length squared.\n   */\n  lengthSquared(): number {\n    return Vec2.lengthSquared(this);\n  }\n\n  /**\n   * Convert this vector into a unit vector.\n   *\n   * @returns old length\n   */\n  normalize(): number {\n    const length = this.length();\n    if (length < Math.EPSILON) {\n      return 0.0;\n    }\n    const invLength = 1.0 / length;\n    this.x *= invLength;\n    this.y *= invLength;\n    return length;\n  }\n\n  /**\n   * Get the length of this vector (the norm).\n   *\n   * For performance, use this instead of lengthSquared (if possible).\n   */\n  static lengthOf(v: Vec2Value): number {\n    _ASSERT && Vec2.assert(v);\n    return Math.sqrt(v.x * v.x + v.y * v.y);\n  }\n\n  /**\n   * Get the length squared.\n   */\n  static lengthSquared(v: Vec2Value): number {\n    _ASSERT && Vec2.assert(v);\n    return v.x * v.x + v.y * v.y;\n  }\n\n  static distance(v: Vec2Value, w: Vec2Value): number {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    const dx = v.x - w.x;\n    const dy = v.y - w.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  static distanceSquared(v: Vec2Value, w: Vec2Value): number {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    const dx = v.x - w.x;\n    const dy = v.y - w.y;\n    return dx * dx + dy * dy;\n  }\n\n  static areEqual(v: Vec2Value, w: Vec2Value): boolean {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return v === w || typeof w === 'object' && w !== null && v.x === w.x && v.y === w.y;\n  }\n\n  /**\n   * Get the skew vector such that dot(skew_vec, other) == cross(vec, other)\n   */\n  static skew(v: Vec2Value): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    return Vec2.neo(-v.y, v.x);\n  }\n\n  /**\n   * Perform the dot product on two vectors.\n   */\n  static dot(v: Vec2Value, w: Vec2Value): number {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return v.x * w.x + v.y * w.y;\n  }\n\n  static cross(v: Vec2Value, w: Vec2Value): number;\n  static cross(v: Vec2Value, w: number): Vec2;\n  static cross(v: number, w: Vec2Value): Vec2;\n  /**\n   * Perform the cross product on two vectors. In 2D this produces a scalar.\n   *\n   * Perform the cross product on a vector and a scalar. In 2D this produces a\n   * vector.\n   */\n  // tslint:disable-next-line:typedef\n  static cross(v, w) {\n    if (typeof w === 'number') {\n      _ASSERT && Vec2.assert(v);\n      _ASSERT && Math.assert(w);\n      return Vec2.neo(w * v.y, -w * v.x);\n\n    } else if (typeof v === 'number') {\n      _ASSERT && Math.assert(v);\n      _ASSERT && Vec2.assert(w);\n      return Vec2.neo(-v * w.y, v * w.x);\n\n    } else {\n      _ASSERT && Vec2.assert(v);\n      _ASSERT && Vec2.assert(w);\n      return v.x * w.y - v.y * w.x;\n    }\n  }\n\n  /**\n   * Perform the cross product on two vectors. In 2D this produces a scalar.\n   */\n  static crossVec2Vec2(v: Vec2Value, w: Vec2Value): number {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return v.x * w.y - v.y * w.x;\n  }\n\n  /**\n   * Perform the cross product on a vector and a scalar. In 2D this produces a\n   * vector.\n   */\n  static crossVec2Num(v: Vec2Value, w: number): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Math.assert(w);\n    return Vec2.neo(w * v.y, -w * v.x);\n  }\n\n  /**\n   * Perform the cross product on a vector and a scalar. In 2D this produces a\n   * vector.\n   */\n  static crossNumVec2(v: number, w: Vec2Value): Vec2 {\n    _ASSERT && Math.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return Vec2.neo(-v * w.y, v * w.x);\n  }\n\n  static addCross(a: Vec2Value, v: Vec2Value, w: number): Vec2;\n  static addCross(a: Vec2Value, v: number, w: Vec2Value): Vec2;\n  /**\n   * Returns `a + (v x w)`\n   */\n  // tslint:disable-next-line:typedef\n  static addCross(a, v, w) {\n    if (typeof w === 'number') {\n      _ASSERT && Vec2.assert(v);\n      _ASSERT && Math.assert(w);\n      return Vec2.neo(w * v.y + a.x, -w * v.x + a.y);\n\n    } else if (typeof v === 'number') {\n      _ASSERT && Math.assert(v);\n      _ASSERT && Vec2.assert(w);\n      return Vec2.neo(-v * w.y + a.x, v * w.x + a.y);\n    }\n\n    _ASSERT && console.assert(false);\n  }\n\n  /**\n   * Returns `a + (v x w)`\n   */\n  static addCrossVec2Num(a: Vec2Value, v: Vec2Value, w: number): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Math.assert(w);\n    return Vec2.neo(w * v.y + a.x, -w * v.x + a.y);\n  }\n\n  /**\n   * Returns `a + (v x w)`\n   */\n  static addCrossNumVec2(a: Vec2Value, v: number, w: Vec2Value): Vec2 {\n    _ASSERT && Math.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return Vec2.neo(-v * w.y + a.x, v * w.x + a.y);\n  }\n\n  static add(v: Vec2Value, w: Vec2Value): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return Vec2.neo(v.x + w.x, v.y + w.y);\n  }\n\n  /** @internal @deprecated */\n  static wAdd(a: number, v: Vec2, b: number, w: Vec2): Vec2 {\n    if (typeof b !== 'undefined' || typeof w !== 'undefined') {\n      return Vec2.combine(a, v, b, w);\n    } else {\n      return Vec2.mulNumVec2(a, v);\n    }\n  }\n\n  static combine(a: number, v: Vec2, b: number, w: Vec2): Vec2 {\n    return Vec2.zero().setCombine(a, v, b, w);\n  }\n\n  static sub(v: Vec2Value, w: Vec2Value): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return Vec2.neo(v.x - w.x, v.y - w.y);\n  }\n\n  static mul(a: Vec2Value, b: number): Vec2;\n  static mul(a: number, b: Vec2Value): Vec2;\n  // tslint:disable-next-line:typedef\n  static mul(a, b) {\n    if (typeof a === 'object') {\n      _ASSERT && Vec2.assert(a);\n      _ASSERT && Math.assert(b);\n      return Vec2.neo(a.x * b, a.y * b);\n\n    } else if (typeof b === 'object') {\n      _ASSERT && Math.assert(a);\n      _ASSERT && Vec2.assert(b);\n      return Vec2.neo(a * b.x, a * b.y);\n    }\n  }\n\n  static mulVec2Num(a: Vec2Value, b: number): Vec2 {\n    _ASSERT && Vec2.assert(a);\n    _ASSERT && Math.assert(b);\n    return Vec2.neo(a.x * b, a.y * b);\n  }\n\n  static mulNumVec2(a: number, b: Vec2Value): Vec2 {\n    _ASSERT && Math.assert(a);\n    _ASSERT && Vec2.assert(b);\n    return Vec2.neo(a * b.x, a * b.y);\n  }\n\n  neg(): Vec2 {\n    this.x = -this.x;\n    this.y = -this.y;\n    return this;\n  }\n\n  static neg(v: Vec2Value): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    return Vec2.neo(-v.x, -v.y);\n  }\n\n  static abs(v: Vec2Value): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    return Vec2.neo(Math.abs(v.x), Math.abs(v.y));\n  }\n\n  static mid(v: Vec2Value, w: Vec2Value): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return Vec2.neo((v.x + w.x) * 0.5, (v.y + w.y) * 0.5);\n  }\n\n  static upper(v: Vec2Value, w: Vec2Value): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return Vec2.neo(Math.max(v.x, w.x), Math.max(v.y, w.y));\n  }\n\n  static lower(v: Vec2Value, w: Vec2Value): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return Vec2.neo(Math.min(v.x, w.x), Math.min(v.y, w.y));\n  }\n\n  clamp(max: number): Vec2 {\n    const lengthSqr = this.x * this.x + this.y * this.y;\n    if (lengthSqr > max * max) {\n      const scale = max / Math.sqrt(lengthSqr);\n      this.x *= scale;\n      this.y *= scale;\n    }\n    return this;\n  }\n\n  static clamp(v: Vec2Value, max: number): Vec2 {\n    const r = Vec2.neo(v.x, v.y);\n    r.clamp(max);\n    return r;\n  }\n\n  /**  @internal @deprecated */\n  // tslint:disable-next-line:typedef\n  static scaleFn(x: number, y: number) {\n    return function(v: Vec2): Vec2 {\n      return Vec2.neo(v.x * x, v.y * y);\n    };\n  }\n\n  /**  @internal @deprecated */\n  // tslint:disable-next-line:typedef\n  static translateFn(x: number, y: number) {\n    return function(v: Vec2): Vec2 {\n      return Vec2.neo(v.x + x, v.y + y);\n    };\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport * as matrix from '../common/Matrix';\nimport { math as Math } from '../common/Math';\nimport { Vec2, Vec2Value } from '../common/Vec2';\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\nconst _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\n/**\n * Ray-cast input data. The ray extends from `p1` to `p1 + maxFraction * (p2 - p1)`.\n */\nexport interface RayCastInput {\n  p1: Vec2;\n  p2: Vec2;\n  maxFraction: number;\n}\n\nexport type RayCastCallback = (subInput: RayCastInput, id: number) => number;\n\n/**\n * Ray-cast output data. The ray hits at `p1 + fraction * (p2 - p1)`,\n * where `p1` and `p2` come from RayCastInput.\n */\nexport interface RayCastOutput {\n  normal: Vec2;\n  fraction: number;\n}\n\nexport interface AABBValue {\n  lowerBound: Vec2Value;\n  upperBound: Vec2Value;\n}\n\nexport class AABB {\n  lowerBound: Vec2;\n  upperBound: Vec2;\n\n  constructor(lower?: Vec2Value, upper?: Vec2Value) {\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof AABB)) {\n      return new AABB(lower, upper);\n    }\n\n    this.lowerBound = Vec2.zero();\n    this.upperBound = Vec2.zero();\n\n    if (typeof lower === 'object') {\n      this.lowerBound.setVec2(lower);\n    }\n    if (typeof upper === 'object') {\n      this.upperBound.setVec2(upper);\n    } else if (typeof lower === 'object') {\n      this.upperBound.setVec2(lower);\n    }\n  }\n\n  /**\n   * Verify that the bounds are sorted.\n   */\n  isValid(): boolean {\n    return AABB.isValid(this);\n  }\n\n  static isValid(obj: any): boolean {\n    if (obj === null || typeof obj === 'undefined') {\n      return false;\n    }\n    return Vec2.isValid(obj.lowerBound) && Vec2.isValid(obj.upperBound) && Vec2.sub(obj.upperBound, obj.lowerBound).lengthSquared() >= 0;\n  }\n\n  static assert(o: any): void {\n    _ASSERT && console.assert(!AABB.isValid(o), 'Invalid AABB!', o);\n  }\n\n  /**\n   * Get the center of the AABB.\n   */\n  getCenter(): Vec2 {\n    return Vec2.neo((this.lowerBound.x + this.upperBound.x) * 0.5, (this.lowerBound.y + this.upperBound.y) * 0.5);\n  }\n\n  /**\n   * Get the extents of the AABB (half-widths).\n   */\n  getExtents(): Vec2 {\n    return Vec2.neo((this.upperBound.x - this.lowerBound.x) * 0.5, (this.upperBound.y - this.lowerBound.y) * 0.5);\n  }\n\n  /**\n   * Get the perimeter length.\n   */\n  getPerimeter(): number {\n    return 2.0 * (this.upperBound.x - this.lowerBound.x + this.upperBound.y - this.lowerBound.y);\n  }\n\n  /**\n   * Combine one or two AABB into this one.\n   */\n  combine(a: AABB, b?: AABB): void {\n    b = b || this;\n\n    const lowerA = a.lowerBound;\n    const upperA = a.upperBound;\n    const lowerB = b.lowerBound;\n    const upperB = b.upperBound;\n\n    const lowerX = Math.min(lowerA.x, lowerB.x);\n    const lowerY = Math.min(lowerA.y, lowerB.y);\n    const upperX = Math.max(upperB.x, upperA.x);\n    const upperY = Math.max(upperB.y, upperA.y);\n\n    this.lowerBound.setNum(lowerX, lowerY);\n    this.upperBound.setNum(upperX, upperY);\n  }\n\n  combinePoints(a: Vec2Value, b: Vec2Value): void {\n    this.lowerBound.setNum(Math.min(a.x, b.x), Math.min(a.y, b.y));\n    this.upperBound.setNum(Math.max(a.x, b.x), Math.max(a.y, b.y));\n  }\n\n  set(aabb: AABB): void {\n    this.lowerBound.setNum(aabb.lowerBound.x, aabb.lowerBound.y);\n    this.upperBound.setNum(aabb.upperBound.x, aabb.upperBound.y);\n  }\n\n  contains(aabb: AABB): boolean {\n    let result = true;\n    result = result && this.lowerBound.x <= aabb.lowerBound.x;\n    result = result && this.lowerBound.y <= aabb.lowerBound.y;\n    result = result && aabb.upperBound.x <= this.upperBound.x;\n    result = result && aabb.upperBound.y <= this.upperBound.y;\n    return result;\n  }\n\n  extend(value: number): AABB {\n    AABB.extend(this, value);\n    return this;\n  }\n\n  static extend(out: AABBValue, value: number): AABBValue {\n    out.lowerBound.x -= value;\n    out.lowerBound.y -= value;\n    out.upperBound.x += value;\n    out.upperBound.y += value;\n    return out;\n  }\n\n  static testOverlap(a: AABB, b: AABB): boolean {\n    const d1x = b.lowerBound.x - a.upperBound.x;\n    const d2x = a.lowerBound.x - b.upperBound.x;\n\n    const d1y = b.lowerBound.y - a.upperBound.y;\n    const d2y = a.lowerBound.y - b.upperBound.y;\n\n    if (d1x > 0 || d1y > 0 || d2x > 0 || d2y > 0) {\n      return false;\n    }\n    return true;\n  }\n\n  static areEqual(a: AABB, b: AABB): boolean {\n    return Vec2.areEqual(a.lowerBound, b.lowerBound) && Vec2.areEqual(a.upperBound, b.upperBound);\n  }\n\n  static diff(a: AABB, b: AABB): number {\n    const wD = Math.max(0, Math.min(a.upperBound.x, b.upperBound.x) - Math.max(b.lowerBound.x, a.lowerBound.x));\n    const hD = Math.max(0, Math.min(a.upperBound.y, b.upperBound.y) - Math.max(b.lowerBound.y, a.lowerBound.y));\n\n    const wA = a.upperBound.x - a.lowerBound.x;\n    const hA = a.upperBound.y - a.lowerBound.y;\n\n    const wB = b.upperBound.x - b.lowerBound.x;\n    const hB = b.upperBound.y - b.lowerBound.y;\n\n    return wA * hA + wB * hB - wD * hD;\n  }\n\n  rayCast(output: RayCastOutput, input: RayCastInput): boolean {\n    // From Real-time Collision Detection, p179.\n\n    let tmin = -Infinity;\n    let tmax = Infinity;\n\n    const p = input.p1;\n    const d = Vec2.sub(input.p2, input.p1);\n    const absD = Vec2.abs(d);\n\n    const normal = Vec2.zero();\n\n    for (let f: 'x' | 'y' = 'x'; f !== null; f = (f === 'x' ? 'y' : null)) {\n      if (absD.x < Math.EPSILON) {\n        // Parallel.\n        if (p[f] < this.lowerBound[f] || this.upperBound[f] < p[f]) {\n          return false;\n        }\n      } else {\n        const inv_d = 1.0 / d[f];\n        let t1 = (this.lowerBound[f] - p[f]) * inv_d;\n        let t2 = (this.upperBound[f] - p[f]) * inv_d;\n\n        // Sign of the normal vector.\n        let s = -1.0;\n\n        if (t1 > t2) {\n          const temp = t1;\n          t1 = t2;\n          t2 = temp;\n          s = 1.0;\n        }\n\n        // Push the min up\n        if (t1 > tmin) {\n          normal.setZero();\n          normal[f] = s;\n          tmin = t1;\n        }\n\n        // Pull the max down\n        tmax = Math.min(tmax, t2);\n\n        if (tmin > tmax) {\n          return false;\n        }\n      }\n    }\n\n    // Does the ray start inside the box?\n    // Does the ray intersect beyond the max fraction?\n    if (tmin < 0.0 || input.maxFraction < tmin) {\n      return false;\n    }\n\n    // Intersection.\n    output.fraction = tmin;\n    output.normal = normal;\n    return true;\n  }\n\n  /** @internal */\n  toString(): string {\n    return JSON.stringify(this);\n  }\n\n  static combinePoints(out: AABBValue, a: Vec2Value, b: Vec2Value): AABBValue {\n    out.lowerBound.x = Math.min(a.x, b.x);\n    out.lowerBound.y = Math.min(a.y, b.y);\n    out.upperBound.x = Math.max(a.x, b.x);\n    out.upperBound.y = Math.max(a.y, b.y);\n    return out;\n  }\n\n  static combinedPerimeter(a: AABBValue, b: AABBValue) {\n    const lx = Math.min(a.lowerBound.x, b.lowerBound.x);\n    const ly = Math.min(a.lowerBound.y, b.lowerBound.y);\n    const ux = Math.max(a.upperBound.x, b.upperBound.x);\n    const uy = Math.max(a.upperBound.y, b.upperBound.y);\n    return 2.0 * (ux - lx + uy - ly);  \n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n/**\n * Tuning constants based on meters-kilograms-seconds (MKS) units.\n */\nexport class Settings {\n  /**\n   * You can use this to change the length scale used by your game.\n   * \n   * For example for inches you could use 39.4.\n   */\n  static lengthUnitsPerMeter = 1.0;\n  \n  // Collision\n  /**\n   * The maximum number of contact points between two convex shapes. Do not change\n   * this value.\n   */\n  static maxManifoldPoints: number = 2;\n\n  /**\n   * The maximum number of vertices on a convex polygon. You cannot increase this\n   * too much because BlockAllocator has a maximum object size.\n   */\n  static maxPolygonVertices: number = 12;\n\n  /**\n   * This is used to fatten AABBs in the dynamic tree. This allows proxies to move\n   * by a small amount without triggering a tree adjustment. This is in meters.\n   */\n  static aabbExtension: number = 0.1;\n\n  /**\n   * This is used to fatten AABBs in the dynamic tree. This is used to predict the\n   * future position based on the current displacement. This is a dimensionless\n   * multiplier.\n   */\n  static aabbMultiplier: number = 2.0;\n\n  /**\n   * A small length used as a collision and constraint tolerance. Usually it is\n   * chosen to be numerically significant, but visually insignificant.\n   */\n  static linearSlop: number = 0.005;\n\n  /**\n   * A small angle used as a collision and constraint tolerance. Usually it is\n   * chosen to be numerically significant, but visually insignificant.\n   */\n  static angularSlop: number = (2.0 / 180.0 * Math.PI);\n\n  /**\n   * The radius of the polygon/edge shape skin. This should not be modified.\n   * Making this smaller means polygons will have an insufficient buffer for\n   * continuous collision. Making it larger may create artifacts for vertex\n   * collision.\n   */\n  static get polygonRadius(): number { return 2.0 * Settings.linearSlop; }\n\n  /**\n   * Maximum number of sub-steps per contact in continuous physics simulation.\n   */\n  static maxSubSteps: number = 8;\n\n// Dynamics\n\n  /**\n   * Maximum number of contacts to be handled to solve a TOI impact.\n   */\n  static maxTOIContacts: number = 32;\n\n  /**\n   * Maximum iterations to solve a TOI.\n   */\n  static maxTOIIterations: number = 20;\n\n  /**\n   * Maximum iterations to find Distance.\n   */\n  static maxDistnceIterations: number = 20;\n\n  /**\n   * A velocity threshold for elastic collisions. Any collision with a relative\n   * linear velocity below this threshold will be treated as inelastic.\n   */\n  static velocityThreshold: number = 1.0;\n\n  /**\n   * The maximum linear position correction used when solving constraints. This\n   * helps to prevent overshoot.\n   */\n  static maxLinearCorrection: number = 0.2;\n\n  /**\n   * The maximum angular position correction used when solving constraints. This\n   * helps to prevent overshoot.\n   */\n  static maxAngularCorrection: number = (8.0 / 180.0 * Math.PI);\n\n  /**\n   * The maximum linear velocity of a body. This limit is very large and is used\n   * to prevent numerical problems. You shouldn't need to adjust Settings.\n   */\n  static maxTranslation: number = 2.0;\n\n  /**\n   * The maximum angular velocity of a body. This limit is very large and is used\n   * to prevent numerical problems. You shouldn't need to adjust Settings.\n   */\n  static maxRotation: number = (0.5 * Math.PI);\n\n  /**\n   * This scale factor controls how fast overlap is resolved. Ideally this would\n   * be 1 so that overlap is removed in one time step. However using values close\n   * to 1 often lead to overshoot.\n   */\n  static baumgarte: number = 0.2;\n  static toiBaugarte: number = 0.75;\n\n  // Sleep\n\n  /**\n   * The time that a body must be still before it will go to sleep.\n   */\n  static timeToSleep: number = 0.5;\n\n  /**\n   * A body cannot sleep if its linear velocity is above this tolerance.\n   */\n  static linearSleepTolerance: number = 0.01;\n\n  /**\n   * A body cannot sleep if its angular velocity is above this tolerance.\n   */\n  static angularSleepTolerance: number = (2.0 / 180.0 * Math.PI);\n}\n\n/** @internal */\nexport class SettingsInternal {\n  static get maxManifoldPoints() {\n    return Settings.maxManifoldPoints;\n  }\n  static get maxPolygonVertices() {\n    return Settings.maxPolygonVertices;\n  }\n  static get aabbExtension() {\n    return Settings.aabbExtension * Settings.lengthUnitsPerMeter;\n  }\n  static get aabbMultiplier() {\n    return Settings.aabbMultiplier;\n  }\n  static get linearSlop() {\n    return Settings.linearSlop * Settings.lengthUnitsPerMeter;\n  }\n  static get linearSlopSquared() {\n    return Settings.linearSlop * Settings.lengthUnitsPerMeter * Settings.linearSlop * Settings.lengthUnitsPerMeter;\n  }\n  static get angularSlop() {\n    return Settings.angularSlop;\n  }\n  static get polygonRadius() {\n    return 2.0 * Settings.linearSlop;\n  }\n  static get maxSubSteps() {\n    return Settings.maxSubSteps;\n  }\n  static get maxTOIContacts() {\n    return Settings.maxTOIContacts;\n  }\n  static get maxTOIIterations() {\n    return Settings.maxTOIIterations;\n  }\n  static get maxDistnceIterations() {\n    return Settings.maxDistnceIterations;\n  }\n  static get velocityThreshold() {\n    return Settings.velocityThreshold * Settings.lengthUnitsPerMeter;\n  }\n  static get maxLinearCorrection() {\n    return Settings.maxLinearCorrection * Settings.lengthUnitsPerMeter;\n  }\n  static get maxAngularCorrection() {\n    return Settings.maxAngularCorrection;\n  }\n  static get maxTranslation() {\n    return Settings.maxTranslation * Settings.lengthUnitsPerMeter;\n  }\n  static get maxTranslationSquared() {\n    return Settings.maxTranslation * Settings.lengthUnitsPerMeter * Settings.maxTranslation * Settings.lengthUnitsPerMeter;\n  }\n  static get maxRotation() {\n    return Settings.maxRotation;\n  }\n  static get maxRotationSquared() {\n    return Settings.maxRotation * Settings.maxRotation;\n  }\n  static get baumgarte() {\n    return Settings.baumgarte;\n  }\n  static get toiBaugarte() {\n    return Settings.toiBaugarte;\n  }\n  static get timeToSleep() {\n    return Settings.timeToSleep;\n  }\n  static get linearSleepTolerance() {\n    return Settings.linearSleepTolerance * Settings.lengthUnitsPerMeter;\n  }\n  static get linearSleepToleranceSqr() {\n    return Settings.linearSleepTolerance * Settings.lengthUnitsPerMeter * Settings.linearSleepTolerance * Settings.lengthUnitsPerMeter;\n  }\n  static get angularSleepTolerance() {\n    return Settings.angularSleepTolerance;\n  }\n  static get angularSleepToleranceSqr() {\n    return Settings.angularSleepTolerance * Settings.angularSleepTolerance;\n  }\n}\n","/*\n * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js\n *\n * This software is provided 'as-is', without any express or implied\n * warranty.  In no event will the authors be held liable for any damages\n * arising from the use of this software.\n * Permission is granted to anyone to use this software for any purpose,\n * including commercial applications, and to alter it and redistribute it\n * freely, subject to the following restrictions:\n * 1. The origin of this software must not be misrepresented; you must not\n * claim that you wrote the original software. If you use this software\n * in a product, an acknowledgment in the product documentation would be\n * appreciated but is not required.\n * 2. Altered source versions must be plainly marked as such, and must not be\n * misrepresented as being the original software.\n * 3. This notice may not be removed or altered from any source distribution.\n */\n\nexport interface PoolOptions<T> {\n  max?: number,\n  create?: () => T,\n  /** Called when an object is being re-allocated. */\n  allocate?: (item: T) => void,\n  /** Called when an object is returned to pool. */\n  release?: (item: T) => void,\n  /** Called when an object is returned to the pool but will be disposed from pool. */\n  dispose?: (item: T) => T,\n}\n\nexport class Pool<T> {\n  _list: T[] = [];\n  _max: number = Infinity;\n\n  _createFn: () => T;\n  _hasCreateFn: boolean = false;\n  _createCount: number = 0;\n\n  _allocateFn: (item: T) => void;\n  _hasAllocateFn: boolean = false;\n  _allocateCount: number = 0;\n\n  _releaseFn: (item: T) => void;\n  _hasReleaseFn: boolean = false;\n  _releaseCount: number = 0;\n\n  _disposeFn: (item: T) => T;\n  _hasDisposeFn: boolean = false;\n  _disposeCount: number = 0;\n\n  constructor(opts: PoolOptions<T>) {\n    this._list = [];\n    this._max = opts.max || this._max;\n\n    this._createFn = opts.create;\n    this._hasCreateFn = typeof this._createFn === 'function';\n    this._allocateFn = opts.allocate;\n    this._hasAllocateFn = typeof this._allocateFn === 'function';\n    this._releaseFn = opts.release;\n    this._hasReleaseFn = typeof this._releaseFn === 'function';\n    this._disposeFn = opts.dispose;\n    this._hasDisposeFn = typeof this._disposeFn === 'function';\n  }\n\n  max(n?: number): number | Pool<T> {\n    if (typeof n === 'number') {\n      this._max = n;\n      return this;\n    }\n    return this._max;\n  }\n\n  size(): number {\n    return this._list.length;\n  }\n\n  allocate(): T {\n    let item: T;\n    if (this._list.length > 0) {\n      item = this._list.shift();\n    } else {\n      this._createCount++;\n      if (this._hasCreateFn) {\n        item = this._createFn();\n      } else {\n        // tslint:disable-next-line:no-object-literal-type-assertion\n        item = {} as T;\n      }\n    }\n    this._allocateCount++;\n    if (this._hasAllocateFn) {\n      this._allocateFn(item);\n    }\n    return item;\n  }\n\n  release(item: T): void {\n    if (this._list.length < this._max) {\n      this._releaseCount++;\n      if (this._hasReleaseFn) {\n        this._releaseFn(item);\n      }\n      this._list.push(item);\n    } else {\n      this._disposeCount++;\n      if (this._hasDisposeFn) {\n        item = this._disposeFn(item);\n      }\n    }\n  }\n\n  /** @internal */\n  toString(): string {\n    return \" +\" + this._createCount + \" >\" + this._allocateCount + \" <\" + this._releaseCount + \" -\"\n      + this._disposeCount + \" =\" + this._list.length + \"/\" + this._max;\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { SettingsInternal as Settings } from '../Settings';\nimport { Pool } from '../util/Pool';\nimport { Vec2, Vec2Value } from '../common/Vec2';\nimport { AABB, RayCastCallback, RayCastInput } from './AABB';\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nexport type DynamicTreeQueryCallback = (nodeId: number) => boolean;\n\n/**\n * A node in the dynamic tree. The client does not interact with this directly.\n */\nexport class TreeNode<T> {\n  id: number;\n  /** Enlarged AABB */\n  aabb: AABB = new AABB();\n  userData: T = null;\n  parent: TreeNode<T> = null;\n  child1: TreeNode<T> = null;\n  child2: TreeNode<T> = null;\n  /** 0: leaf, -1: free node */\n  height: number = -1;\n\n  constructor(id?: number) {\n    this.id = id;\n  }\n\n  /** @internal */\n  toString(): string {\n    return this.id + \": \" + this.userData;\n  }\n\n  isLeaf(): boolean {\n    return this.child1 == null;\n  }\n}\n\nconst poolTreeNode = new Pool<TreeNode<any>>({\n  create(): TreeNode<any> {\n    return new TreeNode();\n  },\n  release(node: TreeNode<any>) {\n    node.userData = null;\n    node.parent = null;\n    node.child1 = null;\n    node.child2 = null;\n    node.height = -1;\n    node.id = undefined;\n  }\n});\n\n/**\n * A dynamic AABB tree broad-phase, inspired by Nathanael Presson's btDbvt. A\n * dynamic tree arranges data in a binary tree to accelerate queries such as\n * volume queries and ray casts. Leafs are proxies with an AABB. In the tree we\n * expand the proxy AABB by `aabbExtension` so that the proxy AABB is bigger\n * than the client object. This allows the client object to move by small\n * amounts without triggering a tree update.\n *\n * Nodes are pooled and relocatable, so we use node indices rather than\n * pointers.\n */\nexport class DynamicTree<T> {\n  m_root: TreeNode<T>;\n  m_lastProxyId: number;\n  m_nodes: {\n    [id: number]: TreeNode<T>\n  };\n\n  constructor() {\n    this.m_root = null;\n    this.m_nodes = {};\n    this.m_lastProxyId = 0;\n  }\n\n  /**\n   * Get proxy user data.\n   *\n   * @return the proxy user data or 0 if the id is invalid.\n   */\n  getUserData(id: number): T {\n    const node = this.m_nodes[id];\n    _ASSERT && console.assert(!!node);\n    return node.userData;\n  }\n\n  /**\n   * Get the fat AABB for a node id.\n   *\n   * @return the proxy user data or 0 if the id is invalid.\n   */\n  getFatAABB(id: number): AABB {\n    const node = this.m_nodes[id];\n    _ASSERT && console.assert(!!node);\n    return node.aabb;\n  }\n\n  allocateNode(): TreeNode<T> {\n    const node = poolTreeNode.allocate();\n    node.id = ++this.m_lastProxyId;\n    this.m_nodes[node.id] = node;\n    return node;\n  }\n\n  freeNode(node: TreeNode<T>): void {\n    // tslint:disable-next-line:no-dynamic-delete\n    delete this.m_nodes[node.id];\n    poolTreeNode.release(node);\n  }\n\n  /**\n   * Create a proxy in the tree as a leaf node. We return the index of the node\n   * instead of a pointer so that we can grow the node pool.\n   *\n   * Create a proxy. Provide a tight fitting AABB and a userData pointer.\n   */\n  createProxy(aabb: AABB, userData: T): number {\n    _ASSERT && console.assert(AABB.isValid(aabb));\n\n    const node = this.allocateNode();\n\n    node.aabb.set(aabb);\n\n    // Fatten the aabb.\n    AABB.extend(node.aabb, Settings.aabbExtension);\n\n    node.userData = userData;\n    node.height = 0;\n\n    this.insertLeaf(node);\n\n    return node.id;\n  }\n\n  /**\n   * Destroy a proxy. This asserts if the id is invalid.\n   */\n  destroyProxy(id: number): void {\n    const node = this.m_nodes[id];\n\n    _ASSERT && console.assert(!!node);\n    _ASSERT && console.assert(node.isLeaf());\n\n    this.removeLeaf(node);\n    this.freeNode(node);\n  }\n\n  /**\n   * Move a proxy with a swepted AABB. If the proxy has moved outside of its\n   * fattened AABB, then the proxy is removed from the tree and re-inserted.\n   * Otherwise the function returns immediately.\n   *\n   * @param d Displacement\n   *\n   * @return true if the proxy was re-inserted.\n   */\n  moveProxy(id: number, aabb: AABB, d: Vec2Value): boolean {\n    _ASSERT && console.assert(AABB.isValid(aabb));\n    _ASSERT && console.assert(!d || Vec2.isValid(d));\n\n    const node = this.m_nodes[id];\n\n    _ASSERT && console.assert(!!node);\n    _ASSERT && console.assert(node.isLeaf());\n\n    if (node.aabb.contains(aabb)) {\n      return false;\n    }\n\n    this.removeLeaf(node);\n\n    node.aabb.set(aabb);\n\n    // Extend AABB.\n    aabb = node.aabb;\n    AABB.extend(aabb, Settings.aabbExtension);\n\n    // Predict AABB displacement.\n    // const d = Vec2.mul(Settings.aabbMultiplier, displacement);\n\n    if (d.x < 0.0) {\n      aabb.lowerBound.x += d.x * Settings.aabbMultiplier;\n    } else {\n      aabb.upperBound.x += d.x * Settings.aabbMultiplier;\n    }\n\n    if (d.y < 0.0) {\n      aabb.lowerBound.y += d.y * Settings.aabbMultiplier;\n    } else {\n      aabb.upperBound.y += d.y * Settings.aabbMultiplier;\n    }\n\n    this.insertLeaf(node);\n\n    return true;\n  }\n\n  insertLeaf(leaf: TreeNode<T>): void {\n    _ASSERT && console.assert(AABB.isValid(leaf.aabb));\n\n    if (this.m_root == null) {\n      this.m_root = leaf;\n      this.m_root.parent = null;\n      return;\n    }\n\n    // Find the best sibling for this node\n    const leafAABB = leaf.aabb;\n    let index = this.m_root;\n    while (!index.isLeaf()) {\n      const child1 = index.child1;\n      const child2 = index.child2;\n\n      const area = index.aabb.getPerimeter();\n\n      const combinedArea = AABB.combinedPerimeter(index.aabb, leafAABB);\n\n      // Cost of creating a new parent for this node and the new leaf\n      const cost = 2.0 * combinedArea;\n\n      // Minimum cost of pushing the leaf further down the tree\n      const inheritanceCost = 2.0 * (combinedArea - area);\n\n      // Cost of descending into child1\n      const newArea1 = AABB.combinedPerimeter(leafAABB, child1.aabb);\n      let cost1 = newArea1 + inheritanceCost;\n      if (!child1.isLeaf()) {\n        const oldArea = child1.aabb.getPerimeter();\n        cost1 -= oldArea;\n      }\n\n      // Cost of descending into child2\n      const newArea2 = AABB.combinedPerimeter(leafAABB, child2.aabb);\n      let cost2 = newArea2 + inheritanceCost;\n      if (!child2.isLeaf()) {\n        const oldArea = child2.aabb.getPerimeter();\n        cost2 -= oldArea;\n      }\n\n      // Descend according to the minimum cost.\n      if (cost < cost1 && cost < cost2) {\n        break;\n      }\n\n      // Descend\n      if (cost1 < cost2) {\n        index = child1;\n      } else {\n        index = child2;\n      }\n    }\n\n    const sibling = index;\n\n    // Create a new parent.\n    const oldParent = sibling.parent;\n    const newParent = this.allocateNode();\n    newParent.parent = oldParent;\n    newParent.userData = null;\n    newParent.aabb.combine(leafAABB, sibling.aabb);\n    newParent.height = sibling.height + 1;\n\n    if (oldParent != null) {\n      // The sibling was not the root.\n      if (oldParent.child1 === sibling) {\n        oldParent.child1 = newParent;\n      } else {\n        oldParent.child2 = newParent;\n      }\n\n      newParent.child1 = sibling;\n      newParent.child2 = leaf;\n      sibling.parent = newParent;\n      leaf.parent = newParent;\n    } else {\n      // The sibling was the root.\n      newParent.child1 = sibling;\n      newParent.child2 = leaf;\n      sibling.parent = newParent;\n      leaf.parent = newParent;\n      this.m_root = newParent;\n    }\n\n    // Walk back up the tree fixing heights and AABBs\n    index = leaf.parent;\n    while (index != null) {\n      index = this.balance(index);\n\n      const child1 = index.child1;\n      const child2 = index.child2;\n\n      _ASSERT && console.assert(child1 != null);\n      _ASSERT && console.assert(child2 != null);\n\n      index.height = 1 + Math.max(child1.height, child2.height);\n      index.aabb.combine(child1.aabb, child2.aabb);\n\n      index = index.parent;\n    }\n\n    // validate();\n  }\n\n  removeLeaf(leaf: TreeNode<T>): void {\n    if (leaf === this.m_root) {\n      this.m_root = null;\n      return;\n    }\n\n    const parent = leaf.parent;\n    const grandParent = parent.parent;\n    let sibling;\n    if (parent.child1 === leaf) {\n      sibling = parent.child2;\n    } else {\n      sibling = parent.child1;\n    }\n\n    if (grandParent != null) {\n      // Destroy parent and connect sibling to grandParent.\n      if (grandParent.child1 === parent) {\n        grandParent.child1 = sibling;\n      } else {\n        grandParent.child2 = sibling;\n      }\n      sibling.parent = grandParent;\n      this.freeNode(parent);\n\n      // Adjust ancestor bounds.\n      let index = grandParent;\n      while (index != null) {\n        index = this.balance(index);\n\n        const child1 = index.child1;\n        const child2 = index.child2;\n\n        index.aabb.combine(child1.aabb, child2.aabb);\n        index.height = 1 + Math.max(child1.height, child2.height);\n\n        index = index.parent;\n      }\n    } else {\n      this.m_root = sibling;\n      sibling.parent = null;\n      this.freeNode(parent);\n    }\n\n    // validate();\n  }\n\n  /**\n   * Perform a left or right rotation if node A is imbalanced. Returns the new\n   * root index.\n   */\n  balance(iA: TreeNode<T>): TreeNode<T> {\n    _ASSERT && console.assert(iA != null);\n\n    const A = iA;\n    if (A.isLeaf() || A.height < 2) {\n      return iA;\n    }\n\n    const B = A.child1;\n    const C = A.child2;\n\n    const balance = C.height - B.height;\n\n    // Rotate C up\n    if (balance > 1) {\n      const F = C.child1;\n      const G = C.child2;\n\n      // Swap A and C\n      C.child1 = A;\n      C.parent = A.parent;\n      A.parent = C;\n\n      // A's old parent should point to C\n      if (C.parent != null) {\n        if (C.parent.child1 === iA) {\n          C.parent.child1 = C;\n        } else {\n          C.parent.child2 = C;\n        }\n      } else {\n        this.m_root = C;\n      }\n\n      // Rotate\n      if (F.height > G.height) {\n        C.child2 = F;\n        A.child2 = G;\n        G.parent = A;\n        A.aabb.combine(B.aabb, G.aabb);\n        C.aabb.combine(A.aabb, F.aabb);\n\n        A.height = 1 + Math.max(B.height, G.height);\n        C.height = 1 + Math.max(A.height, F.height);\n      } else {\n        C.child2 = G;\n        A.child2 = F;\n        F.parent = A;\n        A.aabb.combine(B.aabb, F.aabb);\n        C.aabb.combine(A.aabb, G.aabb);\n\n        A.height = 1 + Math.max(B.height, F.height);\n        C.height = 1 + Math.max(A.height, G.height);\n      }\n\n      return C;\n    }\n\n    // Rotate B up\n    if (balance < -1) {\n      const D = B.child1;\n      const E = B.child2;\n\n      // Swap A and B\n      B.child1 = A;\n      B.parent = A.parent;\n      A.parent = B;\n\n      // A's old parent should point to B\n      if (B.parent != null) {\n        if (B.parent.child1 === A) {\n          B.parent.child1 = B;\n        } else {\n          B.parent.child2 = B;\n        }\n      } else {\n        this.m_root = B;\n      }\n\n      // Rotate\n      if (D.height > E.height) {\n        B.child2 = D;\n        A.child1 = E;\n        E.parent = A;\n        A.aabb.combine(C.aabb, E.aabb);\n        B.aabb.combine(A.aabb, D.aabb);\n\n        A.height = 1 + Math.max(C.height, E.height);\n        B.height = 1 + Math.max(A.height, D.height);\n      } else {\n        B.child2 = E;\n        A.child1 = D;\n        D.parent = A;\n        A.aabb.combine(C.aabb, D.aabb);\n        B.aabb.combine(A.aabb, E.aabb);\n\n        A.height = 1 + Math.max(C.height, D.height);\n        B.height = 1 + Math.max(A.height, E.height);\n      }\n\n      return B;\n    }\n\n    return A;\n  }\n\n  /**\n   * Compute the height of the binary tree in O(N) time. Should not be called\n   * often.\n   */\n  getHeight(): number {\n    if (this.m_root == null) {\n      return 0;\n    }\n\n    return this.m_root.height;\n  }\n\n  /**\n   * Get the ratio of the sum of the node areas to the root area.\n   */\n  getAreaRatio(): number {\n    if (this.m_root == null) {\n      return 0.0;\n    }\n\n    const root = this.m_root;\n    const rootArea = root.aabb.getPerimeter();\n\n    let totalArea = 0.0;\n    let node;\n    const it = this.iteratorPool.allocate().preorder(this.m_root);\n    while (node = it.next()) {\n      if (node.height < 0) {\n        // Free node in pool\n        continue;\n      }\n\n      totalArea += node.aabb.getPerimeter();\n    }\n\n    this.iteratorPool.release(it);\n\n    return totalArea / rootArea;\n  }\n\n  /**\n   * Compute the height of a sub-tree.\n   */\n  computeHeight(id?: number): number {\n    let node;\n    if (typeof id !== 'undefined') {\n      node = this.m_nodes[id];\n    } else {\n      node = this.m_root;\n    }\n\n    // _ASSERT && console.assert(0 <= id && id < this.m_nodeCapacity);\n\n    if (node.isLeaf()) {\n      return 0;\n    }\n\n    const height1 = this.computeHeight(node.child1.id);\n    const height2 = this.computeHeight(node.child2.id);\n    return 1 + Math.max(height1, height2);\n  }\n\n  validateStructure(node: TreeNode<T>): void {\n    if (node == null) {\n      return;\n    }\n\n    if (node === this.m_root) {\n      _ASSERT && console.assert(node.parent == null);\n    }\n\n    const child1 = node.child1;\n    const child2 = node.child2;\n\n    if (node.isLeaf()) {\n      _ASSERT && console.assert(child1 == null);\n      _ASSERT && console.assert(child2 == null);\n      _ASSERT && console.assert(node.height === 0);\n      return;\n    }\n\n    // _ASSERT && console.assert(0 <= child1 && child1 < this.m_nodeCapacity);\n    // _ASSERT && console.assert(0 <= child2 && child2 < this.m_nodeCapacity);\n\n    _ASSERT && console.assert(child1.parent === node);\n    _ASSERT && console.assert(child2.parent === node);\n\n    this.validateStructure(child1);\n    this.validateStructure(child2);\n  }\n\n  validateMetrics(node: TreeNode<T>): void {\n    if (node == null) {\n      return;\n    }\n\n    const child1 = node.child1;\n    const child2 = node.child2;\n\n    if (node.isLeaf()) {\n      _ASSERT && console.assert(child1 == null);\n      _ASSERT && console.assert(child2 == null);\n      _ASSERT && console.assert(node.height === 0);\n      return;\n    }\n\n    // _ASSERT && console.assert(0 <= child1 && child1 < this.m_nodeCapacity);\n    // _ASSERT && console.assert(0 <= child2 && child2 < this.m_nodeCapacity);\n\n    const height1 = child1.height;\n    const height2 = child2.height;\n    const height = 1 + Math.max(height1, height2);\n    _ASSERT && console.assert(node.height === height);\n\n    const aabb = new AABB();\n    aabb.combine(child1.aabb, child2.aabb);\n\n    _ASSERT && console.assert(AABB.areEqual(aabb, node.aabb));\n\n    this.validateMetrics(child1);\n    this.validateMetrics(child2);\n  }\n\n  /**\n   * Validate this tree. For testing.\n   */\n  validate(): void {\n    if (!_ASSERT) return;\n    this.validateStructure(this.m_root);\n    this.validateMetrics(this.m_root);\n\n    console.assert(this.getHeight() === this.computeHeight());\n  }\n\n  /**\n   * Get the maximum balance of an node in the tree. The balance is the difference\n   * in height of the two children of a node.\n   */\n  getMaxBalance(): number {\n    let maxBalance = 0;\n    let node;\n    const it = this.iteratorPool.allocate().preorder(this.m_root);\n    while (node = it.next()) {\n      if (node.height <= 1) {\n        continue;\n      }\n\n      _ASSERT && console.assert(!node.isLeaf());\n\n      const balance = Math.abs(node.child2.height - node.child1.height);\n      maxBalance = Math.max(maxBalance, balance);\n    }\n    this.iteratorPool.release(it);\n\n    return maxBalance;\n  }\n\n  /**\n   * Build an optimal tree. Very expensive. For testing.\n   */\n  rebuildBottomUp(): void {\n    const nodes = [];\n    let count = 0;\n\n    // Build array of leaves. Free the rest.\n    let node;\n    const it = this.iteratorPool.allocate().preorder(this.m_root);\n    while (node = it.next()) {\n      if (node.height < 0) {\n        // free node in pool\n        continue;\n      }\n\n      if (node.isLeaf()) {\n        node.parent = null;\n        nodes[count] = node;\n        ++count;\n      } else {\n        this.freeNode(node);\n      }\n    }\n    this.iteratorPool.release(it);\n\n    while (count > 1) {\n      let minCost = Infinity;\n      let iMin = -1;\n      let jMin = -1;\n      for (let i = 0; i < count; ++i) {\n        const aabbi = nodes[i].aabb;\n        for (let j = i + 1; j < count; ++j) {\n          const aabbj = nodes[j].aabb;\n          const cost = AABB.combinedPerimeter(aabbi, aabbj);\n          if (cost < minCost) {\n            iMin = i;\n            jMin = j;\n            minCost = cost;\n          }\n        }\n      }\n\n      const child1 = nodes[iMin];\n      const child2 = nodes[jMin];\n\n      const parent = this.allocateNode();\n      parent.child1 = child1;\n      parent.child2 = child2;\n      parent.height = 1 + Math.max(child1.height, child2.height);\n      parent.aabb.combine(child1.aabb, child2.aabb);\n      parent.parent = null;\n\n      child1.parent = parent;\n      child2.parent = parent;\n\n      nodes[jMin] = nodes[count - 1];\n      nodes[iMin] = parent;\n      --count;\n    }\n\n    this.m_root = nodes[0];\n\n    _ASSERT && this.validate();\n  }\n\n  /**\n   * Shift the world origin. Useful for large worlds. The shift formula is:\n   * position -= newOrigin\n   *\n   * @param newOrigin The new origin with respect to the old origin\n   */\n  shiftOrigin(newOrigin: Vec2Value): void {\n    // Build array of leaves. Free the rest.\n    let node;\n    const it = this.iteratorPool.allocate().preorder(this.m_root);\n    while (node = it.next()) {\n      const aabb = node.aabb;\n      aabb.lowerBound.x -= newOrigin.x;\n      aabb.lowerBound.y -= newOrigin.y;\n      aabb.upperBound.x -= newOrigin.x;\n      aabb.upperBound.y -= newOrigin.y;\n    }\n    this.iteratorPool.release(it);\n  }\n\n  /**\n   * Query an AABB for overlapping proxies. The callback class is called for each\n   * proxy that overlaps the supplied AABB.\n   */\n  query(aabb: AABB, queryCallback: DynamicTreeQueryCallback): void {\n    _ASSERT && console.assert(typeof queryCallback === 'function');\n    const stack = this.stackPool.allocate();\n\n    stack.push(this.m_root);\n    while (stack.length > 0) {\n      const node = stack.pop();\n      if (node == null) {\n        continue;\n      }\n\n      if (AABB.testOverlap(node.aabb, aabb)) {\n        if (node.isLeaf()) {\n          const proceed = queryCallback(node.id);\n          if (proceed === false) {\n            return;\n          }\n        } else {\n          stack.push(node.child1);\n          stack.push(node.child2);\n        }\n      }\n    }\n\n    this.stackPool.release(stack);\n  }\n\n  /**\n   * Ray-cast against the proxies in the tree. This relies on the callback to\n   * perform a exact ray-cast in the case were the proxy contains a shape. The\n   * callback also performs the any collision filtering. This has performance\n   * roughly equal to k * log(n), where k is the number of collisions and n is the\n   * number of proxies in the tree.\n   *\n   * @param input The ray-cast input data. The ray extends from `p1` to `p1 + maxFraction * (p2 - p1)`.\n   * @param rayCastCallback A function that is called for each proxy that is hit by the ray.\n   */\n  rayCast(input: RayCastInput, rayCastCallback: RayCastCallback): void {\n    // TODO: GC\n    _ASSERT && console.assert(typeof rayCastCallback === 'function');\n    const p1 = input.p1;\n    const p2 = input.p2;\n    const r = Vec2.sub(p2, p1);\n    _ASSERT && console.assert(r.lengthSquared() > 0.0);\n    r.normalize();\n\n    // v is perpendicular to the segment.\n    const v = Vec2.crossNumVec2(1.0, r);\n    const abs_v = Vec2.abs(v);\n\n    // Separating axis for segment (Gino, p80).\n    // |dot(v, p1 - c)| > dot(|v|, h)\n\n    let maxFraction = input.maxFraction;\n\n    // Build a bounding box for the segment.\n    const segmentAABB = new AABB();\n    let t = Vec2.combine((1 - maxFraction), p1, maxFraction, p2);\n    segmentAABB.combinePoints(p1, t);\n\n    const stack = this.stackPool.allocate();\n    const subInput = this.inputPool.allocate();\n\n    stack.push(this.m_root);\n    while (stack.length > 0) {\n      const node = stack.pop();\n      if (node == null) {\n        continue;\n      }\n\n      if (AABB.testOverlap(node.aabb, segmentAABB) === false) {\n        continue;\n      }\n\n      // Separating axis for segment (Gino, p80).\n      // |dot(v, p1 - c)| > dot(|v|, h)\n      const c = node.aabb.getCenter();\n      const h = node.aabb.getExtents();\n      const separation = Math.abs(Vec2.dot(v, Vec2.sub(p1, c))) - Vec2.dot(abs_v, h);\n      if (separation > 0.0) {\n        continue;\n      }\n\n      if (node.isLeaf()) {\n        subInput.p1 = Vec2.clone(input.p1);\n        subInput.p2 = Vec2.clone(input.p2);\n        subInput.maxFraction = maxFraction;\n\n        const value = rayCastCallback(subInput, node.id);\n\n        if (value === 0.0) {\n          // The client has terminated the ray cast.\n          return;\n        }\n\n        if (value > 0.0) {\n          // update segment bounding box.\n          maxFraction = value;\n          t = Vec2.combine((1 - maxFraction), p1, maxFraction, p2);\n          segmentAABB.combinePoints(p1, t);\n        }\n      } else {\n        stack.push(node.child1);\n        stack.push(node.child2);\n      }\n    }\n    this.stackPool.release(stack);\n    this.inputPool.release(subInput);\n  }\n\n  private inputPool: Pool<RayCastInput> = new Pool<RayCastInput>({\n    create(): RayCastInput {\n      // tslint:disable-next-line:no-object-literal-type-assertion\n      return {} as RayCastInput;\n    },\n    release(stack: RayCastInput): void {\n    }\n  });\n\n  private stackPool: Pool<Array<TreeNode<T>>> = new Pool<Array<TreeNode<T>>>({\n    create(): Array<TreeNode<T>> {\n      return [];\n    },\n    release(stack: Array<TreeNode<T>>): void {\n      stack.length = 0;\n    }\n  });\n\n  private iteratorPool: Pool<Iterator<T>> = new Pool<Iterator<T>>({\n    create(): Iterator<T> {\n      return new Iterator();\n    },\n    release(iterator: Iterator<T>): void {\n      iterator.close();\n    }\n  });\n\n}\n\nclass Iterator<T> {\n  parents: Array<TreeNode<T>> = [];\n  states: number[] = [];\n  preorder(root: TreeNode<T>): Iterator<T> {\n    this.parents.length = 0;\n    this.parents.push(root);\n    this.states.length = 0;\n    this.states.push(0);\n    return this;\n  }\n  next(): TreeNode<T> {\n    while (this.parents.length > 0) {\n      const i = this.parents.length - 1;\n      const node = this.parents[i];\n      if (this.states[i] === 0) {\n        this.states[i] = 1;\n        return node;\n      }\n      if (this.states[i] === 1) {\n        this.states[i] = 2;\n        if (node.child1) {\n          this.parents.push(node.child1);\n          this.states.push(1);\n          return node.child1;\n        }\n      }\n      if (this.states[i] === 2) {\n        this.states[i] = 3;\n        if (node.child2) {\n          this.parents.push(node.child2);\n          this.states.push(1);\n          return node.child2;\n        }\n      }\n      this.parents.pop();\n      this.states.pop();\n    }\n  }\n  close(): void {\n    this.parents.length = 0;\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { Vec2Value } from '../common/Vec2';\nimport { AABB, RayCastCallback, RayCastInput } from './AABB';\nimport { DynamicTree, DynamicTreeQueryCallback } from './DynamicTree';\nimport { FixtureProxy } from \"../dynamics/Fixture\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\n/**\n * The broad-phase wraps and extends a dynamic-tree to keep track of moved\n * objects and query them on update.\n */\nexport class BroadPhase {\n  m_tree: DynamicTree<FixtureProxy> = new DynamicTree<FixtureProxy>();\n  m_moveBuffer: number[] = [];\n\n  m_callback: (userDataA: any, userDataB: any) => void;\n  m_queryProxyId: number;\n\n  /**\n   * Get user data from a proxy. Returns null if the id is invalid.\n   */\n  getUserData(proxyId: number): FixtureProxy {\n    return this.m_tree.getUserData(proxyId);\n  }\n\n  /**\n   * Test overlap of fat AABBs.\n   */\n  testOverlap(proxyIdA: number, proxyIdB: number): boolean {\n    const aabbA = this.m_tree.getFatAABB(proxyIdA);\n    const aabbB = this.m_tree.getFatAABB(proxyIdB);\n    return AABB.testOverlap(aabbA, aabbB);\n  }\n\n  /**\n   * Get the fat AABB for a proxy.\n   */\n  getFatAABB(proxyId: number): AABB {\n    return this.m_tree.getFatAABB(proxyId);\n  }\n\n  /**\n   * Get the number of proxies.\n   */\n  getProxyCount(): number {\n    return this.m_moveBuffer.length;\n  }\n\n  /**\n   * Get the height of the embedded tree.\n   */\n  getTreeHeight(): number {\n    return this.m_tree.getHeight();\n  }\n\n  /**\n   * Get the balance (integer) of the embedded tree.\n   */\n  getTreeBalance(): number {\n    return this.m_tree.getMaxBalance();\n  }\n\n  /**\n   * Get the quality metric of the embedded tree.\n   */\n  getTreeQuality(): number {\n    return this.m_tree.getAreaRatio();\n  }\n\n  /**\n   * Query an AABB for overlapping proxies. The callback class is called for each\n   * proxy that overlaps the supplied AABB.\n   */\n  query = (aabb: AABB, queryCallback: DynamicTreeQueryCallback): void => {\n    this.m_tree.query(aabb, queryCallback);\n  }\n\n  /**\n   * Ray-cast against the proxies in the tree. This relies on the callback to\n   * perform a exact ray-cast in the case were the proxy contains a shape. The\n   * callback also performs the any collision filtering. This has performance\n   * roughly equal to k * log(n), where k is the number of collisions and n is the\n   * number of proxies in the tree.\n   *\n   * @param input The ray-cast input data. The ray extends from `p1` to `p1 + maxFraction * (p2 - p1)`.\n   * @param rayCastCallback A function that is called for each proxy that is hit by the ray.\n   */\n  rayCast(input: RayCastInput, rayCastCallback: RayCastCallback): void {\n    this.m_tree.rayCast(input, rayCastCallback);\n  }\n\n  /**\n   * Shift the world origin. Useful for large worlds. The shift formula is:\n   * position -= newOrigin\n   *\n   * @param newOrigin The new origin with respect to the old origin\n   */\n  shiftOrigin(newOrigin: Vec2Value): void {\n    this.m_tree.shiftOrigin(newOrigin);\n  }\n\n  /**\n   * Create a proxy with an initial AABB. Pairs are not reported until UpdatePairs\n   * is called.\n   */\n  createProxy(aabb: AABB, userData: FixtureProxy): number {\n    _ASSERT && console.assert(AABB.isValid(aabb));\n    const proxyId = this.m_tree.createProxy(aabb, userData);\n    this.bufferMove(proxyId);\n    return proxyId;\n  }\n\n  /**\n   * Destroy a proxy. It is up to the client to remove any pairs.\n   */\n  destroyProxy(proxyId: number): void {\n    this.unbufferMove(proxyId);\n    this.m_tree.destroyProxy(proxyId);\n  }\n\n  /**\n   * Call moveProxy as many times as you like, then when you are done call\n   * UpdatePairs to finalized the proxy pairs (for your time step).\n   */\n  moveProxy(proxyId: number, aabb: AABB, displacement: Vec2Value): void {\n    _ASSERT && console.assert(AABB.isValid(aabb));\n    const changed = this.m_tree.moveProxy(proxyId, aabb, displacement);\n    if (changed) {\n      this.bufferMove(proxyId);\n    }\n  }\n\n  /**\n   * Call to trigger a re-processing of it's pairs on the next call to\n   * UpdatePairs.\n   */\n  touchProxy(proxyId: number): void {\n    this.bufferMove(proxyId);\n  }\n\n  bufferMove(proxyId: number): void {\n    this.m_moveBuffer.push(proxyId);\n  }\n\n  unbufferMove(proxyId: number): void {\n    for (let i = 0; i < this.m_moveBuffer.length; ++i) {\n      if (this.m_moveBuffer[i] === proxyId) {\n        this.m_moveBuffer[i] = null;\n      }\n    }\n  }\n\n  /**\n   * Update the pairs. This results in pair callbacks. This can only add pairs.\n   */\n  updatePairs(addPairCallback: (userDataA: FixtureProxy, userDataB: FixtureProxy) => void): void {\n    _ASSERT && console.assert(typeof addPairCallback === 'function');\n    this.m_callback = addPairCallback;\n\n    // Perform tree queries for all moving proxies.\n    while (this.m_moveBuffer.length > 0) {\n      this.m_queryProxyId = this.m_moveBuffer.pop();\n      if (this.m_queryProxyId === null) {\n        continue;\n      }\n\n      // We have to query the tree with the fat AABB so that\n      // we don't fail to create a pair that may touch later.\n      const fatAABB = this.m_tree.getFatAABB(this.m_queryProxyId);\n\n      // Query tree, create pairs and add them pair buffer.\n      this.m_tree.query(fatAABB, this.queryCallback);\n    }\n\n    // Try to keep the tree balanced.\n    // this.m_tree.rebalance(4);\n  }\n\n  queryCallback = (proxyId: number): boolean => {\n    // A proxy cannot form a pair with itself.\n    if (proxyId === this.m_queryProxyId) {\n      return true;\n    }\n\n    const proxyIdA = Math.min(proxyId, this.m_queryProxyId);\n    const proxyIdB = Math.max(proxyId, this.m_queryProxyId);\n\n    // TODO: Skip any duplicate pairs.\n\n    const userDataA = this.m_tree.getUserData(proxyIdA);\n    const userDataB = this.m_tree.getUserData(proxyIdB);\n\n    // Send the pairs back to the client.\n    this.m_callback(userDataA, userDataB);\n\n    return true;\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2023 Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { RotValue } from \"./Rot\";\nimport { TransformValue } from \"./Transform\";\nimport { Vec2Value } from \"./Vec2\";\nimport { Vec3Value } from \"./Vec3\";\n\nexport function vec2(x: number, y: number): Vec2Value {\n  return { x, y };\n}\n\nexport function vec3(x: number, y: number, z: number): Vec3Value {\n  return { x, y, z };\n}\n\nexport function rotation(angle: number): RotValue {\n  return { s: Math.sin(angle), c: Math.cos(angle) };\n}\n\nexport function setVec2(out: Vec2Value, x: number, y: number): Vec2Value {\n  out.x = x;\n  out.y = y;\n  return out;\n}\n\nexport function copyVec2(out: Vec2Value, w: Vec2Value): Vec2Value {\n  out.x = w.x;\n  out.y = w.y;\n  return out;\n}\n\nexport function zeroVec2(out: Vec2Value): Vec2Value {\n  out.x = 0;\n  out.y = 0;\n  return out;\n}\n\nexport function negVec2(out: Vec2Value): Vec2Value {\n  out.x = -out.x;\n  out.y = -out.y;\n  return out;\n}\n\nexport function addVec2(out: Vec2Value, w: Vec2Value): Vec2Value {\n  out.x += w.x;\n  out.y += w.y;\n  return out;\n}\n\nexport function sumVec2(out: Vec2Value, v: Vec2Value, w: Vec2Value): Vec2Value {\n  out.x = v.x + w.x;\n  out.y = v.x + w.y;\n  return out;\n}\n\nexport function subVec2(out: Vec2Value, w: Vec2Value): Vec2Value {\n  out.x -= w.x;\n  out.y -= w.y;\n  return out;\n}\n\nexport function diffVec2(out: Vec2Value, v: Vec2Value, w: Vec2Value): Vec2Value {\n  out.x = v.x - w.x;\n  out.y = v.y - w.y;\n  return out;\n}\n\nexport function scaleVec2(out: Vec2Value, m: number): Vec2Value {\n  out.x *= m;\n  out.y *= m;\n  return out;\n}\n\nexport function setMulVec2(out: Vec2Value, m: number, w: Vec2Value): Vec2Value {\n  out.x = m * w.x;\n  out.y = m * w.y;\n  return out;\n}\n\nexport function addMulVec2(out: Vec2Value, m: number, w: Vec2Value): Vec2Value {\n  out.x += m * w.x;\n  out.y += m * w.y;\n  return out;\n}\n\nexport function subMulVec2(out: Vec2Value, m: number, w: Vec2Value): Vec2Value {\n  out.x -= m * w.x;\n  out.y -= m * w.y;\n  return out;\n}\n\nexport function combineVec2(out: Vec2Value, am: number, a: Vec2Value, bm: number, b: Vec2Value): Vec2Value {\n  out.x = am * a.x + bm * b.x;\n  out.y = am * a.y + bm * b.y;\n  return out;\n}\n\nexport function normalizeVec2Length(out: Vec2Value): number {\n  const length = Math.sqrt(out.x * out.x + out.y * out.y);\n  if (length !== 0) {\n    const invLength = 1 / length;\n    out.x *= invLength;\n    out.y *= invLength;\n  }\n  return length;\n}\n\nexport function normalizeVec2(out: Vec2Value): Vec2Value {\n  const length = Math.sqrt(out.x * out.x + out.y * out.y);\n  if (length > 0) {\n    const invLength = 1 / length;\n    out.x *= invLength;\n    out.y *= invLength;\n  }\n  return out;\n}\n\nexport function crossVec2Num(out: Vec2Value, v: Vec2Value, w: number): Vec2Value {\n  const x = w * v.y;\n  const y = -w * v.x;\n  out.x = x;\n  out.y = y;\n  return out;\n}\n\nexport function crossNumVec2(out: Vec2Value, w: number, v: Vec2Value): Vec2Value {\n  const x = -w * v.y;\n  const y = w * v.x;\n  out.x = x;\n  out.y = y;\n  return out;\n}\n\nexport function crossVec2Vec2(a: Vec2Value, b: Vec2Value): number {\n  return a.x * b.y - a.y * b.x;\n}\n\nexport function dotVec2(a: Vec2Value, b: Vec2Value): number {\n  return a.x * b.x + a.y * b.y;\n}\n\nexport function lengthVec2(a: Vec2Value): number {\n  return Math.sqrt(a.x * a.x + a.y * a.y);\n}\n\nexport function lengthSqrVec2(a: Vec2Value): number {\n  return a.x * a.x + a.y * a.y;\n}\n\nexport function distVec2(a: Vec2Value, b: Vec2Value): number {\n  const dx = a.x - b.x;\n  const dy = a.y - b.y;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nexport function distSqrVec2(a: Vec2Value, b: Vec2Value): number {\n  const dx = a.x - b.x;\n  const dy = a.y - b.y;\n  return dx * dx + dy * dy;\n}\n\nexport function dotVec3(v: Vec3Value, w: Vec3Value): number {\n  return v.x * w.x + v.y * w.y + v.z * w.z;\n}\n\nexport function setRotAngle(out: RotValue, a: number): RotValue {\n  out.c = Math.cos(a);\n  out.s = Math.sin(a);\n  return out;\n}\n\nexport function rotVec2(out: Vec2Value, q: RotValue, v: Vec2Value): Vec2Value {\n  out.x = q.c * v.x - q.s * v.y;\n  out.y = q.s * v.x + q.c * v.y;\n  return out;\n}\n\nexport function invRotVec2(out: Vec2Value, q: RotValue, v: Vec2Value): Vec2Value {\n  const x = q.c * v.x + q.s * v.y;\n  const y = -q.s * v.x + q.c * v.y;\n  out.x = x;\n  out.y = y;\n  return out;\n}\n\nexport function rerotVec2(out: Vec2Value, before: RotValue, after: RotValue, v: Vec2Value): Vec2Value {\n  const x0 = before.c * v.x + before.s * v.y;\n  const y0 = -before.s * v.x + before.c * v.y;\n  const x = after.c * x0 - after.s * y0;\n  const y = after.s * x0 + after.c * y0;\n  out.x = x;\n  out.y = y;\n  return out;\n}\n\nexport function transform(x: number, y: number, a: number): TransformValue {\n  return { p: vec2(x, y), q: rotation(a) };\n}\n\nexport function copyTransform(out: TransformValue, transform: TransformValue): TransformValue {\n  out.p.x = transform.p.x;\n  out.p.y = transform.p.y;\n  out.q.s = transform.q.s;\n  out.q.c = transform.q.c;\n  return out;\n}\n\nexport function transformVec2(out: Vec2Value, xf: TransformValue, v: Vec2Value): Vec2Value {\n  const x = xf.q.c * v.x - xf.q.s * v.y + xf.p.x;\n  const y = xf.q.s * v.x + xf.q.c * v.y + xf.p.y;\n  out.x = x;\n  out.y = y;\n  return out;\n}\n\nexport function invTransformVec2(out: Vec2Value, xf: TransformValue, v: Vec2Value): Vec2Value {\n  const px = v.x - xf.p.x;\n  const py = v.y - xf.p.y;\n  const x = (xf.q.c * px + xf.q.s * py);\n  const y = (-xf.q.s * px + xf.q.c * py);\n  out.x = x;\n  out.y = y;\n  return out;\n}\n\nexport function retransformVec2(out: Vec2Value, from: TransformValue, to: TransformValue, v: Vec2Value): Vec2Value {\n  const x0 = from.q.c * v.x - from.q.s * v.y + from.p.x;\n  const y0 = from.q.s * v.x + from.q.c * v.y + from.p.y;\n  const px = x0 - to.p.x;\n  const py = y0 - to.p.y;\n  const x = to.q.c * px + to.q.s * py;\n  const y = -to.q.s * px + to.q.c * py;\n  out.x = x;\n  out.y = y;\n  return out;\n}\n\nexport function invTransformTransform(out: TransformValue, a: TransformValue, b: TransformValue): TransformValue {\n  const c = a.q.c * b.q.c + a.q.s * b.q.s;\n  const s = a.q.c * b.q.s - a.q.s * b.q.c;\n  const x = a.q.c * (b.p.x - a.p.x) + a.q.s * (b.p.y - a.p.y);\n  const y = -a.q.s * (b.p.x - a.p.x) + a.q.c * (b.p.y - a.p.y);\n  out.q.c = c;\n  out.q.s = s;\n  out.p.x = x;\n  out.p.y = y;\n  return out;\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { Vec2, Vec2Value } from './Vec2';\nimport { math as Math } from './Math';\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\nconst _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\nexport interface RotValue {\n  s: number;\n  c: number;\n}\n\nexport class Rot {\n  s: number;\n  c: number;\n\n  /** Initialize from an angle in radians. */\n  constructor(angle?: number | RotValue) {\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof Rot)) {\n      return new Rot(angle);\n    }\n    if (typeof angle === 'number') {\n      this.setAngle(angle);\n    } else if (typeof angle === 'object') {\n      this.setRot(angle);\n    } else {\n      this.setIdentity();\n    }\n  }\n\n  /** @internal */\n  static neo(angle: number): Rot {\n    const obj = Object.create(Rot.prototype);\n    obj.setAngle(angle);\n    return obj;\n  }\n\n  static clone(rot: RotValue): Rot {\n    _ASSERT && Rot.assert(rot);\n    const obj = Object.create(Rot.prototype);\n    obj.s = rot.s;\n    obj.c = rot.c;\n    return obj;\n  }\n\n  static identity(): Rot {\n    const obj = Object.create(Rot.prototype);\n    obj.s = 0.0;\n    obj.c = 1.0;\n    return obj;\n  }\n\n  static isValid(obj: any): boolean {\n    if (obj === null || typeof obj === 'undefined') {\n      return false;\n    }\n    return Math.isFinite(obj.s) && Math.isFinite(obj.c);\n  }\n\n  static assert(o: any): void {\n    _ASSERT && console.assert(!Rot.isValid(o), 'Invalid Rot!', o);\n  }\n\n  /** Set to the identity rotation. */\n  setIdentity(): void {\n    this.s = 0.0;\n    this.c = 1.0;\n  }\n\n  set(angle: number | RotValue): void {\n    if (typeof angle === 'object') {\n      _ASSERT && Rot.assert(angle);\n      this.s = angle.s;\n      this.c = angle.c;\n\n    } else {\n      _ASSERT && Math.assert(angle);\n      // TODO_ERIN optimize\n      this.s = Math.sin(angle);\n      this.c = Math.cos(angle);\n    }\n  }\n\n  setRot(angle: RotValue): void {\n    _ASSERT && Rot.assert(angle);\n    this.s = angle.s;\n    this.c = angle.c;\n  }\n\n  /** Set using an angle in radians. */\n  setAngle(angle: number): void {\n    _ASSERT && Math.assert(angle);\n    // TODO_ERIN optimize\n    this.s = Math.sin(angle);\n    this.c = Math.cos(angle);\n  }\n\n  /** Get the angle in radians. */\n  getAngle(): number {\n    return Math.atan2(this.s, this.c);\n  }\n\n  /** Get the x-axis. */\n  getXAxis(): Vec2 {\n    return Vec2.neo(this.c, this.s);\n  }\n\n  /** Get the u-axis. */\n  getYAxis(): Vec2 {\n    return Vec2.neo(-this.s, this.c);\n  }\n\n  /** Multiply two rotations: q * r */\n  static mul(rot: RotValue, m: RotValue): Rot;\n  /** Rotate a vector */\n  static mul(rot: RotValue, m: Vec2Value): Vec2;\n  // tslint:disable-next-line:typedef\n  static mul(rot, m) {\n    _ASSERT && Rot.assert(rot);\n    if ('c' in m && 's' in m) {\n      _ASSERT && Rot.assert(m);\n      // [qc -qs] * [rc -rs] = [qc*rc-qs*rs -qc*rs-qs*rc]\n      // [qs qc] [rs rc] [qs*rc+qc*rs -qs*rs+qc*rc]\n      // s = qs * rc + qc * rs\n      // c = qc * rc - qs * rs\n      const qr = Rot.identity();\n      qr.s = rot.s * m.c + rot.c * m.s;\n      qr.c = rot.c * m.c - rot.s * m.s;\n      return qr;\n\n    } else if ('x' in m && 'y' in m) {\n      _ASSERT && Vec2.assert(m);\n      return Vec2.neo(rot.c * m.x - rot.s * m.y, rot.s * m.x + rot.c * m.y);\n    }\n  }\n\n  /** Multiply two rotations: q * r */\n  static mulRot(rot: RotValue, m: RotValue): Rot {\n    _ASSERT && Rot.assert(rot);\n    _ASSERT && Rot.assert(m);\n    // [qc -qs] * [rc -rs] = [qc*rc-qs*rs -qc*rs-qs*rc]\n    // [qs qc] [rs rc] [qs*rc+qc*rs -qs*rs+qc*rc]\n    // s = qs * rc + qc * rs\n    // c = qc * rc - qs * rs\n    const qr = Rot.identity();\n    qr.s = rot.s * m.c + rot.c * m.s;\n    qr.c = rot.c * m.c - rot.s * m.s;\n    return qr;\n  }\n\n  /** Rotate a vector */\n  static mulVec2(rot: RotValue, m: Vec2Value): Vec2 {\n    _ASSERT && Rot.assert(rot);\n    _ASSERT && Vec2.assert(m);\n    return Vec2.neo(rot.c * m.x - rot.s * m.y, rot.s * m.x + rot.c * m.y);\n  }\n\n  static mulSub(rot: RotValue, v: Vec2Value, w: Vec2Value): Vec2 {\n    const x = rot.c * (v.x - w.x) - rot.s * (v.y - w.y);\n    const y = rot.s * (v.x - w.x) + rot.c * (v.y - w.y);\n    return Vec2.neo(x, y);\n  }\n\n  /** Transpose multiply two rotations: qT * r */\n  static mulT(rot: RotValue, m: RotValue): Rot;\n  /** Inverse rotate a vector */\n  static mulT(rot: RotValue, m: Vec2Value): Vec2;\n  // tslint:disable-next-line:typedef\n  static mulT(rot, m) {\n    if ('c' in m && 's' in m) {\n      _ASSERT && Rot.assert(m);\n      // [ qc qs] * [rc -rs] = [qc*rc+qs*rs -qc*rs+qs*rc]\n      // [-qs qc] [rs rc] [-qs*rc+qc*rs qs*rs+qc*rc]\n      // s = qc * rs - qs * rc\n      // c = qc * rc + qs * rs\n      const qr = Rot.identity();\n      qr.s = rot.c * m.s - rot.s * m.c;\n      qr.c = rot.c * m.c + rot.s * m.s;\n      return qr;\n\n    } else if ('x' in m && 'y' in m) {\n      _ASSERT && Vec2.assert(m);\n      return Vec2.neo(rot.c * m.x + rot.s * m.y, -rot.s * m.x + rot.c * m.y);\n    }\n  }\n\n  /** Transpose multiply two rotations: qT * r */\n  static mulTRot(rot: RotValue, m: RotValue): Rot {\n    _ASSERT && Rot.assert(m);\n    // [ qc qs] * [rc -rs] = [qc*rc+qs*rs -qc*rs+qs*rc]\n    // [-qs qc] [rs rc] [-qs*rc+qc*rs qs*rs+qc*rc]\n    // s = qc * rs - qs * rc\n    // c = qc * rc + qs * rs\n    const qr = Rot.identity();\n    qr.s = rot.c * m.s - rot.s * m.c;\n    qr.c = rot.c * m.c + rot.s * m.s;\n    return qr;\n  }\n\n  /** Inverse rotate a vector */\n  static mulTVec2(rot: RotValue, m: Vec2Value): Vec2 {\n    _ASSERT && Vec2.assert(m);\n    return Vec2.neo(rot.c * m.x + rot.s * m.y, -rot.s * m.x + rot.c * m.y);\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport * as matrix from './Matrix';\nimport { math as Math } from './Math';\nimport { Vec2, Vec2Value } from './Vec2';\nimport { TransformValue } from './Transform';\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nconst temp = matrix.vec2(0, 0);\n\n/**\n * This describes the motion of a body/shape for TOI computation. Shapes are\n * defined with respect to the body origin, which may not coincide with the\n * center of mass. However, to support dynamics we must interpolate the center\n * of mass position.\n */\nexport class Sweep {\n  /** Local center of mass position */\n  localCenter = Vec2.zero();\n\n  /** World center position */\n  c = Vec2.zero();\n\n  /** World angle */\n  a = 0;\n\n  /** Fraction of the current time step in the range [0,1], c0 and a0 are c and a at alpha0. */\n  alpha0 = 0;\n\n  c0 = Vec2.zero();\n  a0 = 0;\n\n  /** @internal */\n  recycle() {\n    matrix.zeroVec2(this.localCenter)\n    matrix.zeroVec2(this.c)\n    this.a = 0;\n    this.alpha0 = 0;\n    matrix.zeroVec2(this.c0)\n    this.a0 = 0;\n  }\n\n  setTransform(xf: TransformValue): void {\n    matrix.transformVec2(temp, xf, this.localCenter);\n    matrix.copyVec2(this.c, temp);\n    matrix.copyVec2(this.c0, temp);\n\n    this.a = this.a0 = Math.atan2(xf.q.s, xf.q.c);\n  }\n\n  setLocalCenter(localCenter: Vec2Value, xf: TransformValue): void {\n    matrix.copyVec2(this.localCenter, localCenter);\n\n    matrix.transformVec2(temp, xf, this.localCenter);\n    matrix.copyVec2(this.c, temp);\n    matrix.copyVec2(this.c0, temp);\n  }\n\n  /**\n   * Get the interpolated transform at a specific time.\n   *\n   * @param xf\n   * @param beta A factor in [0,1], where 0 indicates alpha0\n   */\n  getTransform(xf: TransformValue, beta: number = 0): void {\n    matrix.setRotAngle(xf.q, (1.0 - beta) * this.a0 + beta * this.a);\n    matrix.combineVec2(xf.p, (1.0 - beta), this.c0, beta, this.c);\n\n    // shift to origin\n    matrix.subVec2(xf.p, matrix.rotVec2(temp, xf.q, this.localCenter));\n  }\n\n  /**\n   * Advance the sweep forward, yielding a new initial state.\n   *\n   * @param alpha The new initial time\n   */\n  advance(alpha: number): void {\n    _ASSERT && console.assert(this.alpha0 < 1.0);\n    const beta = (alpha - this.alpha0) / (1.0 - this.alpha0);\n    matrix.combineVec2(this.c0, beta, this.c, 1 - beta, this.c0);\n    this.a0 = beta * this.a + (1 - beta) * this.a0;\n    this.alpha0 = alpha;\n  }\n\n  forward(): void {\n    this.a0 = this.a;\n    matrix.copyVec2(this.c0, this.c);\n  }\n\n  /**\n   * normalize the angles in radians to be between -pi and pi.\n   */\n  normalize(): void {\n    const a0 = Math.mod(this.a0, -Math.PI, +Math.PI);\n    this.a -= this.a0 - a0;\n    this.a0 = a0;\n  }\n\n  set(that: Sweep): void {\n    matrix.copyVec2(this.localCenter, that.localCenter);\n    matrix.copyVec2(this.c, that.c);\n    this.a = that.a;\n    this.alpha0 = that.alpha0;\n    matrix.copyVec2(this.c0, that.c0);\n    this.a0 = that.a0;\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { Vec2, Vec2Value } from './Vec2';\nimport { Rot, RotValue } from './Rot';\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\nconst _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\nexport type TransformValue = {\n  p: Vec2Value;\n  q: RotValue;\n};\n\n/**\n * A transform contains translation and rotation. It is used to represent the\n * position and orientation of rigid frames. Initialize using a position vector\n * and a rotation.\n */\nexport class Transform {\n  /** position */\n  p: Vec2;\n\n  /** rotation */\n  q: Rot;\n\n  constructor(position?: Vec2Value, rotation?: number) {\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof Transform)) {\n      return new Transform(position, rotation);\n    }\n    this.p = Vec2.zero();\n    this.q = Rot.identity();\n    if (typeof position !== 'undefined') {\n      this.p.setVec2(position);\n    }\n    if (typeof rotation !== 'undefined') {\n      this.q.setAngle(rotation);\n    }\n  }\n\n  static clone(xf: Transform): Transform {\n    const obj = Object.create(Transform.prototype);\n    obj.p = Vec2.clone(xf.p);\n    obj.q = Rot.clone(xf.q);\n    return obj;\n  }\n\n  /** @internal */\n  static neo(position: Vec2Value, rotation: Rot): Transform {\n    const obj = Object.create(Transform.prototype);\n    obj.p = Vec2.clone(position);\n    obj.q = Rot.clone(rotation);\n    return obj;\n  }\n\n  static identity(): Transform {\n    const obj = Object.create(Transform.prototype);\n    obj.p = Vec2.zero();\n    obj.q = Rot.identity();\n    return obj;\n  }\n\n  /**\n   * Set this to the identity transform.\n   */\n  setIdentity(): void {\n    this.p.setZero();\n    this.q.setIdentity();\n  }\n\n  set(position: Vec2Value, rotation: number): void;\n  set(xf: TransformValue): void;\n  /**\n   * Set this based on the position and angle.\n   */\n  // tslint:disable-next-line:typedef\n  set(a, b?) {\n    if (typeof b === 'undefined') {\n      this.p.set(a.p);\n      this.q.set(a.q);\n    } else {\n      this.p.set(a);\n      this.q.set(b);\n    }\n  }\n\n  /**\n   * Set this based on the position and angle.\n   */\n  setNum(position: Vec2Value, rotation: number) {\n    this.p.setVec2(position);\n    this.q.setAngle(rotation);\n  }\n\n  setTransform(xf: TransformValue): void {\n    this.p.setVec2(xf.p);\n    this.q.setRot(xf.q);\n  }\n\n  static isValid(obj: any): boolean {\n    if (obj === null || typeof obj === 'undefined') {\n      return false;\n    }\n    return Vec2.isValid(obj.p) && Rot.isValid(obj.q);\n  }\n\n  static assert(o: any): void {\n    _ASSERT && console.assert(!Transform.isValid(o), 'Invalid Transform!', o);\n  }\n\n  static mul(a: TransformValue, b: Vec2Value): Vec2;\n  static mul(a: TransformValue, b: TransformValue): Transform;\n  // static mul(a: Transform, b: Vec2Value[]): Vec2[];\n  // static mul(a: Transform, b: Transform[]): Transform[];\n  // tslint:disable-next-line:typedef\n  static mul(a, b) {\n    if (Array.isArray(b)) {\n      _ASSERT && Transform.assert(a);\n      const arr = [];\n      for (let i = 0; i < b.length; i++) {\n        arr[i] = Transform.mul(a, b[i]);\n      }\n      return arr;\n\n    } else if ('x' in b && 'y' in b) {\n      return Transform.mulVec2(a, b);\n\n    } else if ('p' in b && 'q' in b) {\n      return Transform.mulXf(a, b);\n    }\n  }\n\n  static mulAll(a: Transform, b: Vec2Value[]): Vec2[];\n  static mulAll(a: Transform, b: Transform[]): Transform[];\n  // tslint:disable-next-line:typedef\n  static mulAll(a: TransformValue, b) {\n    _ASSERT && Transform.assert(a);\n    const arr = [];\n    for (let i = 0; i < b.length; i++) {\n      arr[i] = Transform.mul(a, b[i]);\n    }\n    return arr;\n  }\n\n  /** @internal @deprecated */\n  // tslint:disable-next-line:typedef\n  static mulFn(a: TransformValue) {\n    _ASSERT && Transform.assert(a);\n    return function(b: Vec2Value): Vec2 {\n      return Transform.mul(a, b);\n    };\n  }\n\n  static mulVec2(a: TransformValue, b: Vec2Value): Vec2 {\n    _ASSERT && Transform.assert(a);\n    _ASSERT && Vec2.assert(b);\n    const x = (a.q.c * b.x - a.q.s * b.y) + a.p.x;\n    const y = (a.q.s * b.x + a.q.c * b.y) + a.p.y;\n    return Vec2.neo(x, y);\n  }\n\n  static mulXf(a: TransformValue, b: TransformValue): Transform {\n    _ASSERT && Transform.assert(a);\n    _ASSERT && Transform.assert(b);\n    // v2 = A.q.Rot(B.q.Rot(v1) + B.p) + A.p\n    // = (A.q * B.q).Rot(v1) + A.q.Rot(B.p) + A.p\n    const xf = Transform.identity();\n    xf.q = Rot.mulRot(a.q, b.q);\n    xf.p = Vec2.add(Rot.mulVec2(a.q, b.p), a.p);\n    return xf;\n  }\n\n  static mulT(a: TransformValue, b: Vec2Value): Vec2;\n  static mulT(a: TransformValue, b: TransformValue): Transform;\n  // tslint:disable-next-line:typedef\n  static mulT(a, b) {\n    if ('x' in b && 'y' in b) {\n      return Transform.mulTVec2(a, b);\n\n    } else if ('p' in b && 'q' in b) {\n      return Transform.mulTXf(a, b);\n    }\n  }\n\n  static mulTVec2(a: TransformValue, b: Vec2Value): Vec2 {\n    _ASSERT && Transform.assert(a);\n    _ASSERT && Vec2.assert(b);\n    const px = b.x - a.p.x;\n    const py = b.y - a.p.y;\n    const x = (a.q.c * px + a.q.s * py);\n    const y = (-a.q.s * px + a.q.c * py);\n    return Vec2.neo(x, y);\n  }\n\n  static mulTXf(a: TransformValue, b: TransformValue): Transform {\n    _ASSERT && Transform.assert(a);\n    _ASSERT && Transform.assert(b);\n    // v2 = A.q' * (B.q * v1 + B.p - A.p)\n    // = A.q' * B.q * v1 + A.q' * (B.p - A.p)\n    const xf = Transform.identity();\n    xf.q.setRot(Rot.mulTRot(a.q, b.q));\n    xf.p.setVec2(Rot.mulTVec2(a.q, Vec2.sub(b.p, a.p)));\n    return xf;\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { Vec2 } from '../common/Vec2';\n\nexport class Velocity {\n  /** linear */\n  v = Vec2.zero();\n\n  /** angular */\n  w = 0;\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { Vec2, Vec2Value } from '../common/Vec2';\nimport { TransformValue } from '../common/Transform';\n\n\nexport class Position {\n  /** location */\n  c = Vec2.zero();\n\n  /** angle */\n  a = 0;\n\n  // todo: cache sin/cos\n  getTransform(xf: TransformValue, p: Vec2Value): TransformValue {\n    // xf.q = rotation(this.a);\n    // xf.p = this.c - xf.q * p\n    xf.q.c = Math.cos(this.a);\n    xf.q.s = Math.sin(this.a);\n    xf.p.x = this.c.x - (xf.q.c * p.x - xf.q.s * p.y);\n    xf.p.y = this.c.y - (xf.q.s * p.x + xf.q.c * p.y);\n    return xf;\n  }\n}\n\nexport function getTransform(xf: TransformValue, p: Vec2Value, c: Vec2Value, a: number): TransformValue {\n  // xf.q = rotation(a);\n  // xf.p = this.c - xf.q * p\n  xf.q.c = Math.cos(a);\n  xf.q.s = Math.sin(a);\n  xf.p.x = c.x - (xf.q.c * p.x - xf.q.s * p.y);\n  xf.p.y = c.y - (xf.q.s * p.x + xf.q.c * p.y);\n  return xf;\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport type { MassData } from '../dynamics/Body';\nimport { RayCastOutput, RayCastInput, AABBValue } from './AABB';\nimport { DistanceProxy } from './Distance';\nimport type { Transform, TransformValue }  from '../common/Transform';\nimport type { Vec2Value }  from '../common/Vec2';\n\n// todo make shape an interface\n\n/**\n * A shape is used for collision detection. You can create a shape however you\n * like. Shapes used for simulation in World are created automatically when a\n * Fixture is created. Shapes may encapsulate one or more child shapes.\n */\nexport abstract class Shape {\n  m_type: ShapeType;\n\n  /**\n   * Radius of a shape. For polygonal shapes this must be b2_polygonRadius.\n   * There is no support for making rounded polygons.\n   */\n  m_radius: number;\n\n  /** @internal */\n  abstract _reset(): void;\n\n  static isValid(obj: any): boolean {\n    if (obj === null || typeof obj === 'undefined') {\n      return false;\n    }\n    return typeof obj.m_type === 'string' && typeof obj.m_radius === 'number';\n  }\n\n  abstract getRadius(): number;\n\n  /**\n   * Get the type of this shape. You can use this to down cast to the concrete\n   * shape.\n   *\n   * @return the shape type.\n   */\n  abstract getType(): ShapeType;\n\n  /**\n   * @internal\n   * @deprecated Shapes should be treated as immutable.\n   *\n   * clone the concrete shape.\n   */\n  abstract _clone(): Shape;\n\n  /**\n   * Get the number of child primitives.\n   */\n  abstract getChildCount(): number;\n\n  /**\n   * Test a point for containment in this shape. This only works for convex\n   * shapes.\n   *\n   * @param xf The shape world transform.\n   * @param p A point in world coordinates.\n   */\n  abstract testPoint(xf: TransformValue, p: Vec2Value): boolean;\n\n  /**\n   * Cast a ray against a child shape.\n   *\n   * @param output The ray-cast results.\n   * @param input The ray-cast input parameters.\n   * @param xf The transform to be applied to the shape.\n   * @param childIndex The child shape index\n   */\n  abstract rayCast(output: RayCastOutput, input: RayCastInput, xf: Transform, childIndex: number): boolean;\n\n  /**\n   * Given a transform, compute the associated axis aligned bounding box for a\n   * child shape.\n   *\n   * @param aabb Returns the axis aligned box.\n   * @param xf The world transform of the shape.\n   * @param childIndex The child shape\n   */\n  abstract computeAABB(aabb: AABBValue, xf: TransformValue, childIndex: number): void;\n\n  /**\n   * Compute the mass properties of this shape using its dimensions and density.\n   * The inertia tensor is computed about the local origin.\n   *\n   * @param massData Returns the mass data for this shape.\n   * @param density The density in kilograms per meter squared.\n   */\n  abstract computeMass(massData: MassData, density?: number): void;\n\n  abstract computeDistanceProxy(proxy: DistanceProxy, childIndex: number): void;\n\n}\n\nexport type ShapeType = \"circle\" | \"edge\" | \"polygon\" | \"chain\";\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport * as matrix from '../common/Matrix';\nimport { options } from '../util/options';\nimport { math as Math } from '../common/Math';\nimport { Vec2Value } from '../common/Vec2';\nimport { AABB, RayCastInput, RayCastOutput } from '../collision/AABB';\nimport { Shape, ShapeType } from '../collision/Shape';\nimport { Body, MassData } from \"./Body\";\nimport { BroadPhase } from \"../collision/BroadPhase\";\nimport { TransformValue } from \"../common/Transform\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\nconst synchronize_aabb1 = new AABB();\nconst synchronize_aabb2 = new AABB();\nconst displacement = matrix.vec2(0, 0);\n\n/**\n * A fixture definition is used to create a fixture. This class defines an\n * abstract fixture definition. You can reuse fixture definitions safely.\n */\nexport interface FixtureOpt {\n  userData?: unknown;\n  /**\n   * The friction coefficient, usually in the range [0,1]\n   */\n  friction?: number;\n  /**\n   * The restitution (elasticity) usually in the range [0,1]\n   */\n  restitution?: number;\n  /**\n   * The density, usually in kg/m^2\n   */\n  density?: number;\n  /**\n   * A sensor shape collects contact information but never generates a collision response.\n   */\n  isSensor?: boolean;\n  /**\n   * Zero, positive or negative collision group.\n   * Fixtures with same positive groupIndex always collide and fixtures with same negative groupIndex never collide.\n   */\n  filterGroupIndex?: number;\n  /**\n   * Collision category bit or bits that this fixture belongs to.\n   * If groupIndex is zero or not matching, then at least one bit in this fixture categoryBits should match other fixture maskBits and vice versa.\n   */\n  filterCategoryBits?: number;\n  /**\n   * Collision category bit or bits that this fixture accept for collision.\n   */\n  filterMaskBits?: number;\n}\n\nexport interface FixtureDef extends FixtureOpt {\n  shape: Shape;\n}\n\nconst FixtureDefDefault: FixtureOpt = {\n  userData : null,\n  friction : 0.2,\n  restitution : 0.0,\n  density : 0.0,\n  isSensor : false,\n\n  filterGroupIndex : 0,\n  filterCategoryBits : 0x0001,\n  filterMaskBits : 0xFFFF\n};\n\n/**\n * This proxy is used internally to connect shape children to the broad-phase.\n */\nexport class FixtureProxy {\n  aabb: AABB;\n  fixture: Fixture;\n  childIndex: number;\n  proxyId: number;\n  constructor(fixture: Fixture, childIndex: number) {\n    this.aabb = new AABB();\n    this.fixture = fixture;\n    this.childIndex = childIndex;\n    this.proxyId;\n  }\n}\n\n/**\n * A fixture is used to attach a shape to a body for collision detection. A\n * fixture inherits its transform from its parent. Fixtures hold additional\n * non-geometric data such as friction, collision filters, etc.\n *\n * To create a new Fixture use {@link Body.createFixture}.\n */\nexport class Fixture {\n  /** @internal */ m_body: Body;\n  /** @internal */ m_friction: number;\n  /** @internal */ m_restitution: number;\n  /** @internal */ m_density: number;\n  /** @internal */ m_isSensor: boolean;\n  /** @internal */ m_filterGroupIndex: number;\n  /** @internal */ m_filterCategoryBits: number;\n  /** @internal */ m_filterMaskBits: number;\n  /** @internal */ m_shape: Shape;\n  /** @internal */ m_next: Fixture | null;\n  /** @internal */ m_proxies: FixtureProxy[];\n  /** @internal */ m_userData: unknown;\n\n  constructor(body: Body, def: FixtureDef);\n  constructor(body: Body, shape: Shape, def?: FixtureOpt);\n  constructor(body: Body, shape: Shape, density?: number);\n  // tslint:disable-next-line:typedef\n  /** @internal */ constructor(body: Body, shape?, def?) {\n    if (shape.shape) {\n      def = shape;\n      shape = shape.shape;\n\n    } else if (typeof def === 'number') {\n      def = {density : def};\n    }\n\n    def = options(def, FixtureDefDefault);\n\n    this.m_body = body;\n\n    this.m_friction = def.friction;\n    this.m_restitution = def.restitution;\n    this.m_density = def.density;\n    this.m_isSensor = def.isSensor;\n\n    this.m_filterGroupIndex = def.filterGroupIndex;\n    this.m_filterCategoryBits = def.filterCategoryBits;\n    this.m_filterMaskBits = def.filterMaskBits;\n\n    // TODO validate shape\n    this.m_shape = shape; // .clone();\n\n    this.m_next = null;\n\n    this.m_proxies = [];\n\n    const childCount = this.m_shape.getChildCount();\n    for (let i = 0; i < childCount; ++i) {\n      this.m_proxies[i] = new FixtureProxy(this, i);\n    }\n\n    this.m_userData = def.userData;\n  }\n\n  /**\n   * Re-setup fixture.\n   * @internal\n   */\n  _reset(): void {\n    const body = this.getBody();\n    const broadPhase = body.m_world.m_broadPhase;\n    this.destroyProxies(broadPhase);\n    if (this.m_shape._reset) {\n      this.m_shape._reset();\n    }\n    const childCount = this.m_shape.getChildCount();\n    for (let i = 0; i < childCount; ++i) {\n      this.m_proxies[i] = new FixtureProxy(this, i);\n    }\n    this.createProxies(broadPhase, body.m_xf);\n    body.resetMassData();\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      friction: this.m_friction,\n      restitution: this.m_restitution,\n      density: this.m_density,\n      isSensor: this.m_isSensor,\n\n      filterGroupIndex: this.m_filterGroupIndex,\n      filterCategoryBits: this.m_filterCategoryBits,\n      filterMaskBits: this.m_filterMaskBits,\n\n      shape: this.m_shape,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, body: any, restore: any): Fixture {\n    const shape = restore(Shape, data.shape);\n    const fixture = shape && new Fixture(body, shape, data);\n    return fixture;\n  }\n\n  /**\n   * Get the type of the child shape. You can use this to down cast to the\n   * concrete shape.\n   */\n  getType(): ShapeType {\n    return this.m_shape.m_type;\n  }\n\n  /**\n   * Get the child shape. You can modify the child shape, however you should not\n   * change the number of vertices because this will crash some collision caching\n   * mechanisms. Manipulating the shape may lead to non-physical behavior.\n   */\n  getShape(): Shape {\n    return this.m_shape;\n  }\n\n  /**\n   * A sensor shape collects contact information but never generates a collision\n   * response.\n   */\n  isSensor(): boolean {\n    return this.m_isSensor;\n  }\n\n  /**\n   * Set if this fixture is a sensor.\n   */\n  setSensor(sensor: boolean): void {\n    if (sensor != this.m_isSensor) {\n      this.m_body.setAwake(true);\n      this.m_isSensor = sensor;\n    }\n  }\n\n  // /**\n  //  * Get the contact filtering data.\n  //  */\n  // getFilterData() {\n  //   return this.m_filter;\n  // }\n\n  /**\n   * Get the user data that was assigned in the fixture definition. Use this to\n   * store your application specific data.\n   */\n  getUserData(): unknown {\n    return this.m_userData;\n  }\n\n  /**\n   * Set the user data. Use this to store your application specific data.\n   */\n  setUserData(data: unknown): void {\n    this.m_userData = data;\n  }\n\n  /**\n   * Get the parent body of this fixture. This is null if the fixture is not\n   * attached.\n   */\n  getBody(): Body {\n    return this.m_body;\n  }\n\n  /**\n   * Get the next fixture in the parent body's fixture list.\n   */\n  getNext(): Fixture | null {\n    return this.m_next;\n  }\n\n  /**\n   * Get the density of this fixture.\n   */\n  getDensity(): number {\n    return this.m_density;\n  }\n\n  /**\n   * Set the density of this fixture. This will _not_ automatically adjust the\n   * mass of the body. You must call Body.resetMassData to update the body's mass.\n   */\n  setDensity(density: number): void {\n    _ASSERT && console.assert(Math.isFinite(density) && density >= 0.0);\n    this.m_density = density;\n  }\n\n  /**\n   * Get the coefficient of friction, usually in the range [0,1].\n   */\n  getFriction(): number {\n    return this.m_friction;\n  }\n\n  /**\n   * Set the coefficient of friction. This will not change the friction of\n   * existing contacts.\n   */\n  setFriction(friction: number): void {\n    this.m_friction = friction;\n  }\n\n  /**\n   * Get the coefficient of restitution.\n   */\n  getRestitution(): number {\n    return this.m_restitution;\n  }\n\n  /**\n   * Set the coefficient of restitution. This will not change the restitution of\n   * existing contacts.\n   */\n  setRestitution(restitution: number): void {\n    this.m_restitution = restitution;\n  }\n\n  /**\n   * Test a point in world coordinates for containment in this fixture.\n   */\n  testPoint(p: Vec2Value): boolean {\n    return this.m_shape.testPoint(this.m_body.getTransform(), p);\n  }\n\n  /**\n   * Cast a ray against this shape.\n   */\n  rayCast(output: RayCastOutput, input: RayCastInput, childIndex: number): boolean {\n    return this.m_shape.rayCast(output, input, this.m_body.getTransform(), childIndex);\n  }\n\n  /**\n   * Get the mass data for this fixture. The mass data is based on the density and\n   * the shape. The rotational inertia is about the shape's origin. This operation\n   * may be expensive.\n   */\n  getMassData(massData: MassData): void {\n    this.m_shape.computeMass(massData, this.m_density);\n  }\n\n  /**\n   * Get the fixture's AABB. This AABB may be enlarge and/or stale. If you need a\n   * more accurate AABB, compute it using the shape and the body transform.\n   */\n  getAABB(childIndex: number): AABB {\n    _ASSERT && console.assert(0 <= childIndex && childIndex < this.m_proxies.length);\n    return this.m_proxies[childIndex].aabb;\n  }\n\n  /**\n   * These support body activation/deactivation.\n   */\n  createProxies(broadPhase: BroadPhase, xf: TransformValue): void {\n    _ASSERT && console.assert(this.m_proxies.length == 0);\n\n    // Create proxies in the broad-phase.\n    const childCount = this.m_shape.getChildCount();\n\n    for (let i = 0; i < childCount; ++i) {\n      const proxy = this.m_proxies[i];\n      this.m_shape.computeAABB(proxy.aabb, xf, i);\n      proxy.proxyId = broadPhase.createProxy(proxy.aabb, proxy);\n    }\n  }\n\n  destroyProxies(broadPhase: BroadPhase): void {\n    // Destroy proxies in the broad-phase.\n    for (let i = 0; i < this.m_proxies.length; ++i) {\n      const proxy = this.m_proxies[i];\n      broadPhase.destroyProxy(proxy.proxyId);\n      proxy.proxyId = null;\n      proxy.fixture = null;\n    }\n\n    this.m_proxies.length = 0;\n  }\n\n  /**\n   * Updates this fixture proxy in broad-phase (with combined AABB of current and\n   * next transformation).\n   */\n  synchronize(broadPhase: BroadPhase, xf1: TransformValue, xf2: TransformValue): void {\n    for (let i = 0; i < this.m_proxies.length; ++i) {\n      const proxy = this.m_proxies[i];\n      // Compute an AABB that covers the swept shape (may miss some rotation\n      // effect).\n      this.m_shape.computeAABB(synchronize_aabb1, xf1, proxy.childIndex);\n      this.m_shape.computeAABB(synchronize_aabb2, xf2, proxy.childIndex);\n\n      proxy.aabb.combine(synchronize_aabb1, synchronize_aabb2);\n\n      matrix.diffVec2(displacement, xf2.p, xf1.p);\n\n      broadPhase.moveProxy(proxy.proxyId, proxy.aabb, displacement);\n    }\n  }\n\n  /**\n   * Set the contact filtering data. This will not update contacts until the next\n   * time step when either parent body is active and awake. This automatically\n   * calls refilter.\n   */\n  setFilterData(filter: { groupIndex: number, categoryBits: number, maskBits: number }): void {\n    this.m_filterGroupIndex = filter.groupIndex;\n    this.m_filterCategoryBits = filter.categoryBits;\n    this.m_filterMaskBits = filter.maskBits;\n    this.refilter();\n  }\n\n  getFilterGroupIndex(): number {\n    return this.m_filterGroupIndex;\n  }\n\n  setFilterGroupIndex(groupIndex: number): void {\n    this.m_filterGroupIndex = groupIndex;\n  }\n\n  getFilterCategoryBits(): number {\n    return this.m_filterCategoryBits;\n  }\n\n  setFilterCategoryBits(categoryBits: number): void {\n    this.m_filterCategoryBits = categoryBits;\n  }\n\n  getFilterMaskBits(): number {\n    return this.m_filterMaskBits;\n  }\n\n  setFilterMaskBits(maskBits: number): void {\n    this.m_filterMaskBits = maskBits;\n  }\n\n  /**\n   * Call this if you want to establish collision that was previously disabled by\n   * ContactFilter.\n   */\n  refilter(): void {\n    if (this.m_body == null) {\n      return;\n    }\n\n    // Flag associated contacts for filtering.\n    let edge = this.m_body.getContactList();\n    while (edge) {\n      const contact = edge.contact;\n      const fixtureA = contact.getFixtureA();\n      const fixtureB = contact.getFixtureB();\n      if (fixtureA == this || fixtureB == this) {\n        contact.flagForFiltering();\n      }\n\n      edge = edge.next;\n    }\n\n    const world = this.m_body.getWorld();\n\n    if (world == null) {\n      return;\n    }\n\n    // Touch each proxy so that new pairs may be created\n    const broadPhase = world.m_broadPhase;\n    for (let i = 0; i < this.m_proxies.length; ++i) {\n      broadPhase.touchProxy(this.m_proxies[i].proxyId);\n    }\n  }\n\n  /**\n   * Implement this method to provide collision filtering, if you want finer\n   * control over contact creation.\n   *\n   * Return true if contact calculations should be performed between these two\n   * fixtures.\n   *\n   * Warning: for performance reasons this is only called when the AABBs begin to\n   * overlap.\n   */\n  shouldCollide(that: Fixture): boolean {\n\n    if (that.m_filterGroupIndex === this.m_filterGroupIndex && that.m_filterGroupIndex !== 0) {\n      return that.m_filterGroupIndex > 0;\n    }\n\n    const collideA = (that.m_filterMaskBits & this.m_filterCategoryBits) !== 0;\n    const collideB = (that.m_filterCategoryBits & this.m_filterMaskBits) !== 0;\n    const collide = collideA && collideB;\n    return collide;\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport * as matrix from '../common/Matrix';\nimport { options } from '../util/options';\nimport { Vec2, Vec2Value } from '../common/Vec2';\nimport { Rot } from '../common/Rot';\nimport { math as Math } from '../common/Math';\nimport { Sweep } from '../common/Sweep';\nimport { Transform } from '../common/Transform';\nimport { Velocity } from './Velocity';\nimport { Position } from './Position';\nimport { Fixture, FixtureDef, FixtureOpt } from './Fixture';\nimport { Shape } from '../collision/Shape';\nimport { JointEdge } from \"./Joint\";\nimport { World } from \"./World\";\nimport { ContactEdge } from \"./Contact\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nexport type BodyType = 'static' | 'kinematic' | 'dynamic';\n\nconst STATIC = 'static';\nconst KINEMATIC = 'kinematic';\nconst DYNAMIC = 'dynamic';\n\nconst oldCenter = matrix.vec2(0, 0);\nconst localCenter = matrix.vec2(0, 0);\nconst shift = matrix.vec2(0, 0);\nconst xf = matrix.transform(0, 0, 0)\n\nexport interface BodyDef {\n  /**\n   * Body types are static, kinematic, or dynamic. Note: if a dynamic\n   * body would have zero mass, the mass is set to one.\n   */\n  type?: BodyType;\n  /**\n   * The world position of the body. Avoid creating bodies at the\n   * origin since this can lead to many overlapping shapes.\n   */\n  position?: Vec2;\n  /**\n   * The world angle of the body in radians.\n   */\n  angle?: number;\n  /**\n   * The linear velocity of the body's origin in world co-ordinates.\n   */\n  linearVelocity?: Vec2;\n  angularVelocity?: number;\n  /**\n   * Linear damping is use to reduce the linear velocity. The\n   * damping parameter can be larger than 1.0 but the damping effect becomes\n   * sensitive to the time step when the damping parameter is large.\n   * Units are 1/time\n   */\n  linearDamping?: number;\n  /**\n   * Angular damping is use to reduce the angular velocity.\n   * The damping parameter can be larger than 1.0 but the damping effect\n   * becomes sensitive to the time step when the damping parameter is large.\n   * Units are 1/time\n   */\n  angularDamping?: number;\n  /**\n   * Should this body be prevented from rotating? Useful for characters.\n   */\n  fixedRotation?: boolean;\n  /**\n   * Is this a fast moving body that should be prevented from\n   * tunneling through other moving bodies? Note that all bodies are\n   * prevented from tunneling through kinematic and static bodies. This\n   * setting is only considered on dynamic bodies. Warning: You should use\n   * this flag sparingly since it increases processing time.\n   */\n  bullet?: boolean;\n  gravityScale?: number;\n  /**\n   * Set this flag to false if this body should never fall asleep. Note that this increases CPU usage.\n   */\n  allowSleep?: boolean;\n  /**\n   * Is this body initially awake or sleeping?\n   */\n  awake?: boolean;\n  /**\n   * Does this body start out active?\n   */\n  active?: boolean;\n  userData?: any;\n}\n\nconst BodyDefDefault: BodyDef = {\n  type : STATIC,\n  position : Vec2.zero(),\n  angle : 0.0,\n\n  linearVelocity : Vec2.zero(),\n  angularVelocity : 0.0,\n\n  linearDamping : 0.0,\n  angularDamping : 0.0,\n\n  fixedRotation : false,\n  bullet : false,\n  gravityScale : 1.0,\n\n  allowSleep : true,\n  awake : true,\n  active : true,\n\n  userData : null\n};\n\n/**\n * MassData This holds the mass data computed for a shape.\n */\nexport class MassData {\n  /** The mass of the shape, usually in kilograms. */\n  mass: number = 0;\n  /** The position of the shape's centroid relative to the shape's origin. */\n  center = Vec2.zero();\n  /** The rotational inertia of the shape about the local origin. */\n  I: number = 0;\n}\n\n/**\n * A rigid body composed of one or more fixtures.\n *\n * To create a new Body use {@link World.createBody}.\n */\nexport class Body {\n  /**\n   * A static body does not move under simulation and behaves as if it has infinite mass.\n   * Internally, zero is stored for the mass and the inverse mass.\n   * Static bodies can be moved manually by the user.\n   * A static body has zero velocity.\n   * Static bodies do not collide with other static or kinematic bodies.\n   */\n  static readonly STATIC: BodyType = 'static';\n  /**\n   * A kinematic body moves under simulation according to its velocity.\n   * Kinematic bodies do not respond to forces.\n   * They can be moved manually by the user, but normally a kinematic body is moved by setting its velocity.\n   * A kinematic body behaves as if it has infinite mass, however, zero is stored for the mass and the inverse mass.\n   * Kinematic bodies do not collide with other kinematic or static bodies.\n   */\n  static readonly KINEMATIC: BodyType = 'kinematic';\n\n  /**\n   * A dynamic body is fully simulated.\n   * They can be moved manually by the user, but normally they move according to forces.\n   * A dynamic body can collide with all body types.\n   * A dynamic body always has finite, non-zero mass.\n   * If you try to set the mass of a dynamic body to zero, it will automatically acquire a mass of one kilogram and it won't rotate.\n   */\n  static readonly DYNAMIC: BodyType = 'dynamic';\n\n  /** @internal */ m_world: World;\n  /** @internal */ m_awakeFlag: boolean;\n  /** @internal */ m_autoSleepFlag: boolean;\n  /** @internal */ m_bulletFlag: boolean;\n  /** @internal */ m_fixedRotationFlag: boolean;\n  /** @internal */ m_activeFlag: boolean;\n  /** @internal */ m_islandFlag: boolean;\n  /** @internal */ m_toiFlag: boolean;\n  /** @internal */ m_userData: unknown;\n  /** @internal */ m_type: BodyType;\n  /** @internal */ m_mass: number;\n  /** @internal */ m_invMass: number;\n  /** @internal Rotational inertia about the center of mass. */\n  m_I: number;\n  /** @internal */ m_invI: number;\n  /** @internal the body origin transform */\n  m_xf: Transform;\n  /** @internal the swept motion for CCD */\n  m_sweep: Sweep;\n  // position and velocity correction\n  /** @internal */ c_velocity: Velocity;\n  /** @internal */ c_position: Position;\n  /** @internal */ m_force: Vec2;\n  /** @internal */ m_torque: number;\n  /** @internal */ m_linearVelocity: Vec2;\n  /** @internal */ m_angularVelocity: number;\n  /** @internal */ m_linearDamping: number;\n  /** @internal */ m_angularDamping: number;\n  /** @internal */ m_gravityScale: number;\n  /** @internal */ m_sleepTime: number;\n  /** @internal */ m_jointList: JointEdge | null;\n  /** @internal */ m_contactList: ContactEdge | null;\n  /** @internal */ m_fixtureList: Fixture | null;\n  /** @internal */ m_prev: Body | null;\n  /** @internal */ m_next: Body | null;\n  /** @internal */ m_destroyed: boolean;\n\n  /** @internal */\n  constructor(world: World, def: BodyDef) {\n    def = options(def, BodyDefDefault);\n\n    _ASSERT && console.assert(Vec2.isValid(def.position));\n    _ASSERT && console.assert(Vec2.isValid(def.linearVelocity));\n    _ASSERT && console.assert(Math.isFinite(def.angle));\n    _ASSERT && console.assert(Math.isFinite(def.angularVelocity));\n    _ASSERT && console.assert(Math.isFinite(def.angularDamping) && def.angularDamping >= 0.0);\n    _ASSERT && console.assert(Math.isFinite(def.linearDamping) && def.linearDamping >= 0.0);\n\n    this.m_world = world;\n\n    this.m_awakeFlag = def.awake;\n    this.m_autoSleepFlag = def.allowSleep;\n    this.m_bulletFlag = def.bullet;\n    this.m_fixedRotationFlag = def.fixedRotation;\n    this.m_activeFlag = def.active;\n\n    this.m_islandFlag = false;\n    this.m_toiFlag = false;\n\n    this.m_userData = def.userData;\n    this.m_type = def.type;\n\n    if (this.m_type == DYNAMIC) {\n      this.m_mass = 1.0;\n      this.m_invMass = 1.0;\n    } else {\n      this.m_mass = 0.0;\n      this.m_invMass = 0.0;\n    }\n\n    // Rotational inertia about the center of mass.\n    this.m_I = 0.0;\n    this.m_invI = 0.0;\n\n    // the body origin transform\n    this.m_xf = Transform.identity();\n    this.m_xf.p.setVec2(def.position);\n    this.m_xf.q.setAngle(def.angle);\n\n    // the swept motion for CCD\n    this.m_sweep = new Sweep();\n    this.m_sweep.setTransform(this.m_xf);\n\n    // position and velocity correction\n    this.c_velocity = new Velocity();\n    this.c_position = new Position();\n\n    this.m_force = Vec2.zero();\n    this.m_torque = 0.0;\n\n    this.m_linearVelocity = Vec2.clone(def.linearVelocity);\n    this.m_angularVelocity = def.angularVelocity;\n\n    this.m_linearDamping = def.linearDamping;\n    this.m_angularDamping = def.angularDamping;\n    this.m_gravityScale = def.gravityScale;\n\n    this.m_sleepTime = 0.0;\n\n    this.m_jointList = null;\n    this.m_contactList = null;\n    this.m_fixtureList = null;\n\n    this.m_prev = null;\n    this.m_next = null;\n\n    this.m_destroyed = false;\n  }\n\n  /** @internal */\n  _serialize(): object {\n    const fixtures = [];\n    for (let f = this.m_fixtureList; f; f = f.m_next) {\n      fixtures.push(f);\n    }\n    return {\n      type: this.m_type,\n      bullet: this.m_bulletFlag,\n      position: this.m_xf.p,\n      angle: this.m_xf.q.getAngle(),\n      linearVelocity: this.m_linearVelocity,\n      angularVelocity: this.m_angularVelocity,\n      fixtures,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): Body {\n    const body = new Body(world, data);\n\n    if (data.fixtures) {\n      for (let i = data.fixtures.length - 1; i >= 0; i--) {\n        const fixture = restore(Fixture, data.fixtures[i], body);\n        body._addFixture(fixture);\n      }\n    }\n    return body;\n  }\n\n  isWorldLocked(): boolean {\n    return this.m_world && this.m_world.isLocked() ? true : false;\n  }\n\n  getWorld(): World {\n    return this.m_world;\n  }\n\n  getNext(): Body | null {\n    return this.m_next;\n  }\n\n  setUserData(data: any): void {\n    this.m_userData = data;\n  }\n\n  getUserData(): unknown {\n    return this.m_userData;\n  }\n\n  getFixtureList(): Fixture | null {\n    return this.m_fixtureList;\n  }\n\n  getJointList(): JointEdge | null {\n    return this.m_jointList;\n  }\n\n  /**\n   * Warning: this list changes during the time step and you may miss some\n   * collisions if you don't use ContactListener.\n   */\n  getContactList(): ContactEdge | null {\n    return this.m_contactList;\n  }\n\n  isStatic(): boolean {\n    return this.m_type == STATIC;\n  }\n\n  isDynamic(): boolean {\n    return this.m_type == DYNAMIC;\n  }\n\n  isKinematic(): boolean {\n    return this.m_type == KINEMATIC;\n  }\n\n  /**\n   * This will alter the mass and velocity.\n   */\n  setStatic(): Body {\n    this.setType(STATIC);\n    return this;\n  }\n\n  setDynamic(): Body {\n    this.setType(DYNAMIC);\n    return this;\n  }\n\n  setKinematic(): Body {\n    this.setType(KINEMATIC);\n    return this;\n  }\n\n  /**\n   * @internal\n   */\n  getType(): BodyType {\n    return this.m_type;\n  }\n\n  /**\n   * @internal\n   */\n  setType(type: BodyType): void {\n    _ASSERT && console.assert(type === STATIC || type === KINEMATIC || type === DYNAMIC);\n    _ASSERT && console.assert(this.isWorldLocked() == false);\n\n    if (this.isWorldLocked() == true) {\n      return;\n    }\n\n    if (this.m_type == type) {\n      return;\n    }\n\n    this.m_type = type;\n\n    this.resetMassData();\n\n    if (this.m_type == STATIC) {\n      this.m_linearVelocity.setZero();\n      this.m_angularVelocity = 0.0;\n      this.m_sweep.forward();\n      this.synchronizeFixtures();\n    }\n\n    this.setAwake(true);\n\n    this.m_force.setZero();\n    this.m_torque = 0.0;\n\n    // Delete the attached contacts.\n    let ce = this.m_contactList;\n    while (ce) {\n      const ce0 = ce;\n      ce = ce.next;\n      this.m_world.destroyContact(ce0.contact);\n    }\n    this.m_contactList = null;\n\n    // Touch the proxies so that new contacts will be created (when appropriate)\n    const broadPhase = this.m_world.m_broadPhase;\n    for (let f = this.m_fixtureList; f; f = f.m_next) {\n      for (let i = 0; i < f.m_proxies.length; ++i) {\n        broadPhase.touchProxy(f.m_proxies[i].proxyId);\n      }\n    }\n  }\n\n  isBullet(): boolean {\n    return this.m_bulletFlag;\n  }\n\n  /**\n   * Should this body be treated like a bullet for continuous collision detection?\n   */\n  setBullet(flag: boolean): void {\n    this.m_bulletFlag = !!flag;\n  }\n\n  isSleepingAllowed(): boolean {\n    return this.m_autoSleepFlag;\n  }\n\n  setSleepingAllowed(flag: boolean): void {\n    this.m_autoSleepFlag = !!flag;\n    if (this.m_autoSleepFlag == false) {\n      this.setAwake(true);\n    }\n  }\n\n  isAwake(): boolean {\n    return this.m_awakeFlag;\n  }\n\n  /**\n   * Set the sleep state of the body. A sleeping body has very low CPU cost.\n   *\n   * @param flag Set to true to wake the body, false to put it to sleep.\n   */\n  setAwake(flag: boolean): void {\n    if (flag) {\n      this.m_awakeFlag = true;\n      this.m_sleepTime = 0.0;\n    } else {\n      this.m_awakeFlag = false;\n      this.m_sleepTime = 0.0;\n      this.m_linearVelocity.setZero();\n      this.m_angularVelocity = 0.0;\n      this.m_force.setZero();\n      this.m_torque = 0.0;\n    }\n  }\n\n  isActive(): boolean {\n    return this.m_activeFlag;\n  }\n\n  /**\n   * Set the active state of the body. An inactive body is not simulated and\n   * cannot be collided with or woken up. If you pass a flag of true, all fixtures\n   * will be added to the broad-phase. If you pass a flag of false, all fixtures\n   * will be removed from the broad-phase and all contacts will be destroyed.\n   * Fixtures and joints are otherwise unaffected.\n   *\n   * You may continue to create/destroy fixtures and joints on inactive bodies.\n   * Fixtures on an inactive body are implicitly inactive and will not participate\n   * in collisions, ray-casts, or queries. Joints connected to an inactive body\n   * are implicitly inactive. An inactive body is still owned by a World object\n   * and remains\n   */\n  setActive(flag: boolean): void {\n    _ASSERT && console.assert(this.isWorldLocked() == false);\n\n    if (flag == this.m_activeFlag) {\n      return;\n    }\n\n    this.m_activeFlag = !!flag;\n\n    if (this.m_activeFlag) {\n      // Create all proxies.\n      const broadPhase = this.m_world.m_broadPhase;\n      for (let f = this.m_fixtureList; f; f = f.m_next) {\n        f.createProxies(broadPhase, this.m_xf);\n      }\n      // Contacts are created the next time step.\n\n    } else {\n      // Destroy all proxies.\n      const broadPhase = this.m_world.m_broadPhase;\n      for (let f = this.m_fixtureList; f; f = f.m_next) {\n        f.destroyProxies(broadPhase);\n      }\n\n      // Destroy the attached contacts.\n      let ce = this.m_contactList;\n      while (ce) {\n        const ce0 = ce;\n        ce = ce.next;\n        this.m_world.destroyContact(ce0.contact);\n      }\n      this.m_contactList = null;\n    }\n  }\n\n  isFixedRotation(): boolean {\n    return this.m_fixedRotationFlag;\n  }\n\n  /**\n   * Set this body to have fixed rotation. This causes the mass to be reset.\n   */\n  setFixedRotation(flag: boolean): void {\n    if (this.m_fixedRotationFlag == flag) {\n      return;\n    }\n\n    this.m_fixedRotationFlag = !!flag;\n\n    this.m_angularVelocity = 0.0;\n\n    this.resetMassData();\n  }\n\n  /**\n   * Get the world transform for the body's origin.\n   */\n  getTransform(): Transform {\n    return this.m_xf;\n  }\n\n  /**\n   * Set the position of the body's origin and rotation. Manipulating a body's\n   * transform may cause non-physical behavior. Note: contacts are updated on the\n   * next call to World.step.\n   *\n   * @param position The world position of the body's local origin.\n   * @param angle The world rotation in radians.\n   */\n  setTransform(position: Vec2, angle: number): void {\n    _ASSERT && console.assert(this.isWorldLocked() == false);\n    if (this.isWorldLocked() == true) {\n      return;\n    }\n\n    this.m_xf.setNum(position, angle);\n    this.m_sweep.setTransform(this.m_xf);\n\n    const broadPhase = this.m_world.m_broadPhase;\n    for (let f = this.m_fixtureList; f; f = f.m_next) {\n      f.synchronize(broadPhase, this.m_xf, this.m_xf);\n    }\n  }\n\n  synchronizeTransform(): void {\n    this.m_sweep.getTransform(this.m_xf, 1);\n  }\n\n  /**\n   * Update fixtures in broad-phase.\n   */\n  synchronizeFixtures(): void {\n    this.m_sweep.getTransform(xf, 0);\n\n    const broadPhase = this.m_world.m_broadPhase;\n    for (let f = this.m_fixtureList; f; f = f.m_next) {\n      f.synchronize(broadPhase, xf, this.m_xf);\n    }\n  }\n\n  /**\n   * Used in TOI.\n   */\n  advance(alpha: number): void {\n    // Advance to the new safe time. This doesn't sync the broad-phase.\n    this.m_sweep.advance(alpha);\n    matrix.copyVec2(this.m_sweep.c, this.m_sweep.c0);\n    this.m_sweep.a = this.m_sweep.a0;\n    this.m_sweep.getTransform(this.m_xf, 1);\n  }\n\n  /**\n   * Get the world position for the body's origin.\n   */\n  getPosition(): Vec2 {\n    return this.m_xf.p;\n  }\n\n  setPosition(p: Vec2): void {\n    this.setTransform(p, this.m_sweep.a);\n  }\n\n  /**\n   * Get the current world rotation angle in radians.\n   */\n  getAngle(): number {\n    return this.m_sweep.a;\n  }\n\n  setAngle(angle: number): void {\n    this.setTransform(this.m_xf.p, angle);\n  }\n\n  /**\n   * Get the world position of the center of mass.\n   */\n  getWorldCenter(): Vec2 {\n    return this.m_sweep.c;\n  }\n\n  /**\n   * Get the local position of the center of mass.\n   */\n  getLocalCenter(): Vec2 {\n    return this.m_sweep.localCenter;\n  }\n\n  /**\n   * Get the linear velocity of the center of mass.\n   *\n   * @return the linear velocity of the center of mass.\n   */\n  getLinearVelocity(): Vec2 {\n    return this.m_linearVelocity;\n  }\n\n  /**\n   * Get the world linear velocity of a world point attached to this body.\n   *\n   * @param worldPoint A point in world coordinates.\n   */\n  getLinearVelocityFromWorldPoint(worldPoint: Vec2): Vec2 {\n    const localCenter = Vec2.sub(worldPoint, this.m_sweep.c);\n    return Vec2.add(this.m_linearVelocity, Vec2.crossNumVec2(this.m_angularVelocity,\n      localCenter));\n  }\n\n  /**\n   * Get the world velocity of a local point.\n   *\n   * @param localPoint A point in local coordinates.\n   */\n  getLinearVelocityFromLocalPoint(localPoint: Vec2): Vec2 {\n    return this.getLinearVelocityFromWorldPoint(this.getWorldPoint(localPoint));\n  }\n\n  /**\n   * Set the linear velocity of the center of mass.\n   *\n   * @param v The new linear velocity of the center of mass.\n   */\n  setLinearVelocity(v: Vec2): void {\n    if (this.m_type == STATIC) {\n      return;\n    }\n    if (Vec2.dot(v, v) > 0.0) {\n      this.setAwake(true);\n    }\n    this.m_linearVelocity.setVec2(v);\n  }\n\n  /**\n   * Get the angular velocity.\n   *\n   * @returns the angular velocity in radians/second.\n   */\n  getAngularVelocity(): number {\n    return this.m_angularVelocity;\n  }\n\n  /**\n   * Set the angular velocity.\n   *\n   * @param omega The new angular velocity in radians/second.\n   */\n  setAngularVelocity(w: number): void {\n    if (this.m_type == STATIC) {\n      return;\n    }\n    if (w * w > 0.0) {\n      this.setAwake(true);\n    }\n    this.m_angularVelocity = w;\n  }\n\n  getLinearDamping(): number {\n    return this.m_linearDamping;\n  }\n\n  setLinearDamping(linearDamping: number): void {\n    this.m_linearDamping = linearDamping;\n  }\n\n  getAngularDamping(): number {\n    return this.m_angularDamping;\n  }\n\n  setAngularDamping(angularDamping: number): void {\n    this.m_angularDamping = angularDamping;\n  }\n\n  getGravityScale(): number {\n    return this.m_gravityScale;\n  }\n\n  /**\n   * Scale the gravity applied to this body.\n   */\n  setGravityScale(scale: number): void {\n    this.m_gravityScale = scale;\n  }\n\n  /**\n   * Get the total mass of the body.\n   *\n   * @returns The mass, usually in kilograms (kg).\n   */\n  getMass(): number {\n    return this.m_mass;\n  }\n\n  /**\n   * Get the rotational inertia of the body about the local origin.\n   *\n   * @return the rotational inertia, usually in kg-m^2.\n   */\n  getInertia(): number {\n    return this.m_I + this.m_mass\n      * Vec2.dot(this.m_sweep.localCenter, this.m_sweep.localCenter);\n  }\n\n  /**\n   * Copy the mass data of the body to data.\n   */\n  getMassData(data: MassData): void {\n    data.mass = this.m_mass;\n    data.I = this.getInertia();\n    data.center.setVec2(this.m_sweep.localCenter);\n  }\n\n  /**\n   * This resets the mass properties to the sum of the mass properties of the\n   * fixtures. This normally does not need to be called unless you called\n   * SetMassData to override the mass and you later want to reset the mass.\n   */\n  resetMassData(): void {\n    // Compute mass data from shapes. Each shape has its own density.\n    this.m_mass = 0.0;\n    this.m_invMass = 0.0;\n    this.m_I = 0.0;\n    this.m_invI = 0.0;\n    matrix.zeroVec2(this.m_sweep.localCenter);\n\n    // Static and kinematic bodies have zero mass.\n    if (this.isStatic() || this.isKinematic()) {\n      matrix.copyVec2(this.m_sweep.c0, this.m_xf.p);\n      matrix.copyVec2(this.m_sweep.c, this.m_xf.p);\n      this.m_sweep.a0 = this.m_sweep.a;\n      return;\n    }\n\n    _ASSERT && console.assert(this.isDynamic());\n\n    // Accumulate mass over all fixtures.\n    matrix.zeroVec2(localCenter);\n    for (let f = this.m_fixtureList; f; f = f.m_next) {\n      if (f.m_density == 0.0) {\n        continue;\n      }\n\n      const massData = new MassData();\n      f.getMassData(massData);\n      this.m_mass += massData.mass;\n      matrix.addMulVec2(localCenter, massData.mass, massData.center)\n      this.m_I += massData.I;\n    }\n\n    // Compute center of mass.\n    if (this.m_mass > 0.0) {\n      this.m_invMass = 1.0 / this.m_mass;\n      matrix.setMulVec2(localCenter, this.m_invMass, localCenter)\n\n    } else {\n      // Force all dynamic bodies to have a positive mass.\n      this.m_mass = 1.0;\n      this.m_invMass = 1.0;\n    }\n\n    if (this.m_I > 0.0 && this.m_fixedRotationFlag == false) {\n      // Center the inertia about the center of mass.\n      this.m_I -= this.m_mass * matrix.dotVec2(localCenter, localCenter);\n      _ASSERT && console.assert(this.m_I > 0.0);\n      this.m_invI = 1.0 / this.m_I;\n\n    } else {\n      this.m_I = 0.0;\n      this.m_invI = 0.0;\n    }\n\n    // Move center of mass.\n    matrix.copyVec2(oldCenter, this.m_sweep.c);\n    this.m_sweep.setLocalCenter(localCenter, this.m_xf);\n\n    // Update center of mass velocity.\n    matrix.diffVec2(shift, this.m_sweep.c, oldCenter);\n    matrix.crossNumVec2(this.m_linearVelocity, this.m_angularVelocity, shift);\n  }\n\n  /**\n   * Set the mass properties to override the mass properties of the fixtures. Note\n   * that this changes the center of mass position. Note that creating or\n   * destroying fixtures can also alter the mass. This function has no effect if\n   * the body isn't dynamic.\n   *\n   * @param massData The mass properties.\n   */\n  setMassData(massData: MassData): void {\n    _ASSERT && console.assert(this.isWorldLocked() == false);\n    if (this.isWorldLocked() == true) {\n      return;\n    }\n\n    if (this.m_type != DYNAMIC) {\n      return;\n    }\n\n    this.m_invMass = 0.0;\n    this.m_I = 0.0;\n    this.m_invI = 0.0;\n\n    this.m_mass = massData.mass;\n    if (this.m_mass <= 0.0) {\n      this.m_mass = 1.0;\n    }\n\n    this.m_invMass = 1.0 / this.m_mass;\n\n    if (massData.I > 0.0 && this.m_fixedRotationFlag == false) {\n      this.m_I = massData.I - this.m_mass * matrix.dotVec2(massData.center, massData.center);\n      _ASSERT && console.assert(this.m_I > 0.0);\n      this.m_invI = 1.0 / this.m_I;\n    }\n\n    // Move center of mass.\n    matrix.copyVec2(oldCenter, this.m_sweep.c);\n    this.m_sweep.setLocalCenter(massData.center, this.m_xf);\n\n    // Update center of mass velocity.\n    matrix.diffVec2(shift, this.m_sweep.c, oldCenter);\n    matrix.crossNumVec2(this.m_linearVelocity, this.m_angularVelocity, shift);\n  }\n\n  /**\n   * Apply a force at a world point. If the force is not applied at the center of\n   * mass, it will generate a torque and affect the angular velocity. This wakes\n   * up the body.\n   *\n   * @param force The world force vector, usually in Newtons (N).\n   * @param point The world position of the point of application.\n   * @param wake Also wake up the body\n   */\n  applyForce(force: Vec2, point: Vec2, wake: boolean = true): void {\n    if (this.m_type != DYNAMIC) {\n      return;\n    }\n    if (wake && this.m_awakeFlag == false) {\n      this.setAwake(true);\n    }\n    // Don't accumulate a force if the body is sleeping.\n    if (this.m_awakeFlag) {\n      this.m_force.add(force);\n      this.m_torque += Vec2.crossVec2Vec2(Vec2.sub(point, this.m_sweep.c), force);\n    }\n  }\n\n  /**\n   * Apply a force to the center of mass. This wakes up the body.\n   *\n   * @param force The world force vector, usually in Newtons (N).\n   * @param wake Also wake up the body\n   */\n  applyForceToCenter(force: Vec2, wake: boolean = true): void {\n    if (this.m_type != DYNAMIC) {\n      return;\n    }\n    if (wake && this.m_awakeFlag == false) {\n      this.setAwake(true);\n    }\n    // Don't accumulate a force if the body is sleeping\n    if (this.m_awakeFlag) {\n      this.m_force.add(force);\n    }\n  }\n\n  /**\n   * Apply a torque. This affects the angular velocity without affecting the\n   * linear velocity of the center of mass. This wakes up the body.\n   *\n   * @param torque About the z-axis (out of the screen), usually in N-m.\n   * @param wake Also wake up the body\n   */\n  applyTorque(torque: number, wake: boolean = true): void {\n    if (this.m_type != DYNAMIC) {\n      return;\n    }\n    if (wake && this.m_awakeFlag == false) {\n      this.setAwake(true);\n    }\n    // Don't accumulate a force if the body is sleeping\n    if (this.m_awakeFlag) {\n      this.m_torque += torque;\n    }\n  }\n\n  /**\n   * Apply an impulse at a point. This immediately modifies the velocity. It also\n   * modifies the angular velocity if the point of application is not at the\n   * center of mass. This wakes up the body.\n   *\n   * @param impulse The world impulse vector, usually in N-seconds or kg-m/s.\n   * @param point The world position of the point of application.\n   * @param wake Also wake up the body\n   */\n  applyLinearImpulse(impulse: Vec2, point: Vec2, wake: boolean = true): void {\n    if (this.m_type != DYNAMIC) {\n      return;\n    }\n    if (wake && this.m_awakeFlag == false) {\n      this.setAwake(true);\n    }\n\n    // Don't accumulate velocity if the body is sleeping\n    if (this.m_awakeFlag) {\n      this.m_linearVelocity.addMul(this.m_invMass, impulse);\n      this.m_angularVelocity += this.m_invI * Vec2.crossVec2Vec2(Vec2.sub(point, this.m_sweep.c), impulse);\n    }\n  }\n\n  /**\n   * Apply an angular impulse.\n   *\n   * @param impulse The angular impulse in units of kg*m*m/s\n   * @param wake Also wake up the body\n   */\n  applyAngularImpulse(impulse: number, wake: boolean = true): void {\n    if (this.m_type != DYNAMIC) {\n      return;\n    }\n\n    if (wake && this.m_awakeFlag == false) {\n      this.setAwake(true);\n    }\n    // Don't accumulate velocity if the body is sleeping\n    if (this.m_awakeFlag) {\n      this.m_angularVelocity += this.m_invI * impulse;\n    }\n  }\n\n  /**\n   * This is used to prevent connected bodies (by joints) from colliding,\n   * depending on the joint's collideConnected flag.\n   */\n  shouldCollide(that: Body): boolean {\n    // At least one body should be dynamic.\n    if (this.m_type != DYNAMIC && that.m_type != DYNAMIC) {\n      return false;\n    }\n    // Does a joint prevent collision?\n    for (let jn = this.m_jointList; jn; jn = jn.next) {\n      if (jn.other == that) {\n        if (jn.joint.m_collideConnected == false) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  /**\n   * @internal Used for deserialize.\n   */\n  _addFixture(fixture: Fixture): Fixture {\n    _ASSERT && console.assert(this.isWorldLocked() == false);\n\n    if (this.isWorldLocked() == true) {\n      return null;\n    }\n\n    if (this.m_activeFlag) {\n      const broadPhase = this.m_world.m_broadPhase;\n      fixture.createProxies(broadPhase, this.m_xf);\n    }\n\n    fixture.m_next = this.m_fixtureList;\n    this.m_fixtureList = fixture;\n\n    // Adjust mass properties if needed.\n    if (fixture.m_density > 0.0) {\n      this.resetMassData();\n    }\n\n    // Let the world know we have a new fixture. This will cause new contacts\n    // to be created at the beginning of the next time step.\n    this.m_world.m_newFixture = true;\n\n    return fixture;\n  }\n\n  /**\n   * Creates a fixture and attach it to this body.\n   *\n   * If the density is non-zero, this function automatically updates the mass of\n   * the body.\n   *\n   * Contacts are not created until the next time step.\n   *\n   * Warning: This function is locked during callbacks.\n   */\n  createFixture(def: FixtureDef): Fixture;\n  createFixture(shape: Shape, opt?: FixtureOpt): Fixture;\n  createFixture(shape: Shape, density?: number): Fixture;\n  // tslint:disable-next-line:typedef\n  createFixture(shape, fixdef?) {\n    _ASSERT && console.assert(this.isWorldLocked() == false);\n\n    if (this.isWorldLocked() == true) {\n      return null;\n    }\n\n    const fixture = new Fixture(this, shape, fixdef);\n    this._addFixture(fixture);\n    return fixture;\n  }\n\n  /**\n   * Destroy a fixture. This removes the fixture from the broad-phase and destroys\n   * all contacts associated with this fixture. This will automatically adjust the\n   * mass of the body if the body is dynamic and the fixture has positive density.\n   * All fixtures attached to a body are implicitly destroyed when the body is\n   * destroyed.\n   *\n   * Warning: This function is locked during callbacks.\n   *\n   * @param fixture The fixture to be removed.\n   */\n  destroyFixture(fixture: Fixture): void {\n    _ASSERT && console.assert(this.isWorldLocked() == false);\n\n    if (this.isWorldLocked() == true) {\n      return;\n    }\n\n    _ASSERT && console.assert(fixture.m_body == this);\n\n    // Remove the fixture from this body's singly linked list.\n    let found = false;\n    if (this.m_fixtureList === fixture) {\n      this.m_fixtureList = fixture.m_next;\n      found = true;\n\n    } else {\n      let node = this.m_fixtureList;\n      while (node != null) {\n        if (node.m_next === fixture) {\n          node.m_next = fixture.m_next;\n          found = true;\n          break;\n        }\n        node = node.m_next;\n      }\n    }\n\n    // You tried to remove a shape that is not attached to this body.\n    _ASSERT && console.assert(found);\n\n    // Destroy any contacts associated with the fixture.\n    let edge = this.m_contactList;\n    while (edge) {\n      const c = edge.contact;\n      edge = edge.next;\n\n      const fixtureA = c.getFixtureA();\n      const fixtureB = c.getFixtureB();\n\n      if (fixture == fixtureA || fixture == fixtureB) {\n        // This destroys the contact and removes it from\n        // this body's contact list.\n        this.m_world.destroyContact(c);\n      }\n    }\n\n    if (this.m_activeFlag) {\n      const broadPhase = this.m_world.m_broadPhase;\n      fixture.destroyProxies(broadPhase);\n    }\n\n    fixture.m_body = null;\n    fixture.m_next = null;\n\n    this.m_world.publish('remove-fixture', fixture);\n\n    // Reset the mass data.\n    this.resetMassData();\n  }\n\n  /**\n   * Get the corresponding world point of a local point.\n   */\n  getWorldPoint(localPoint: Vec2): Vec2 {\n    return Transform.mulVec2(this.m_xf, localPoint);\n  }\n\n  /**\n   * Get the corresponding world vector of a local vector.\n   */\n  getWorldVector(localVector: Vec2): Vec2 {\n    return Rot.mulVec2(this.m_xf.q, localVector);\n  }\n\n  /**\n   * Gets the corresponding local point of a world point.\n   */\n  getLocalPoint(worldPoint: Vec2Value): Vec2 {\n    return Transform.mulTVec2(this.m_xf, worldPoint);\n  }\n\n  /**\n   * Gets the corresponding local vector of a world vector.\n   */\n  getLocalVector(worldVector: Vec2Value): Vec2 {\n    return Rot.mulTVec2(this.m_xf.q, worldVector);\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport type { Vec2 }  from '../common/Vec2';\nimport type { Body }  from './Body';\nimport { TimeStep } from \"./Solver\";\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n/**\n * A joint edge is used to connect bodies and joints together in a joint graph\n * where each body is a node and each joint is an edge. A joint edge belongs to\n * a doubly linked list maintained in each attached body. Each joint has two\n * joint nodes, one for each attached body.\n */\nexport class JointEdge {\n  /**\n   * provides quick access to the other body attached.\n   */\n  other: Body | null = null;\n  /**\n   * the joint\n   */\n  joint: Joint | null = null;\n  /**\n   * prev the previous joint edge in the body's joint list\n   */\n  prev: JointEdge | null = null;\n  /**\n   * the next joint edge in the body's joint list\n   */\n  next: JointEdge | null = null;\n}\n\n/**\n * Joint definitions are used to construct joints.\n */\nexport interface JointOpt {\n  /**\n   * Use this to attach application specific data to your joints.\n   */\n  userData?: any;\n  /**\n   * Set this flag to true if the attached bodies\n   * should collide.\n   */\n  collideConnected?: boolean;\n}\n/**\n * Joint definitions are used to construct joints.\n */\nexport interface JointDef extends JointOpt {\n  /**\n   * The first attached body.\n   */\n  bodyA: Body;\n  /**\n   * The second attached body.\n   */\n  bodyB: Body;\n}\n\nconst DEFAULTS = {\n  userData : null,\n  collideConnected : false\n};\n\n/**\n * The base joint class. Joints are used to constraint two bodies together in\n * various fashions. Some joints also feature limits and motors.\n */\nexport abstract class Joint {\n\n  /** @internal */ m_type: string = 'unknown-joint';\n\n  /** @internal */ m_bodyA: Body;\n  /** @internal */ m_bodyB: Body;\n\n  /** @internal */ m_collideConnected: boolean;\n\n  /** @internal */ m_prev: Joint | null = null;\n  /** @internal */ m_next: Joint | null = null;\n\n  /** @internal */ m_edgeA: JointEdge = new JointEdge();\n  /** @internal */ m_edgeB: JointEdge = new JointEdge();\n\n  /** @internal */ m_islandFlag: boolean = false;\n  /** @internal */ m_userData: unknown;\n\n  constructor(def: JointDef);\n  constructor(def: JointOpt, bodyA: Body, bodyB: Body);\n  constructor(def: JointDef | JointOpt, bodyA?: Body, bodyB?: Body) {\n    bodyA = 'bodyA' in def ? def.bodyA : bodyA;\n    bodyB = 'bodyB' in def ? def.bodyB : bodyB;\n\n    _ASSERT && console.assert(!!bodyA);\n    _ASSERT && console.assert(!!bodyB);\n    _ASSERT && console.assert(bodyA != bodyB);\n\n    this.m_bodyA = bodyA!;\n    this.m_bodyB = bodyB!;\n\n    this.m_collideConnected = !!def.collideConnected;\n    this.m_userData = def.userData;\n  }\n\n  /**\n   * Short-cut function to determine if either body is inactive.\n   */\n  isActive(): boolean {\n    return this.m_bodyA.isActive() && this.m_bodyB.isActive();\n  }\n\n  /**\n   * Get the type of the concrete joint.\n   */\n  getType(): string {\n    return this.m_type;\n  }\n\n  /**\n   * Get the first body attached to this joint.\n   */\n  getBodyA(): Body {\n    return this.m_bodyA;\n  }\n\n  /**\n   * Get the second body attached to this joint.\n   */\n  getBodyB(): Body {\n    return this.m_bodyB;\n  }\n\n  /**\n   * Get the next joint the world joint list.\n   */\n  getNext(): Joint {\n    return this.m_next;\n  }\n\n  getUserData(): unknown {\n    return this.m_userData;\n  }\n\n  setUserData(data: unknown): void {\n    this.m_userData = data;\n  }\n\n  /**\n   * Get collide connected. Note: modifying the collide connect flag won't work\n   * correctly because the flag is only checked when fixture AABBs begin to\n   * overlap.\n   */\n  getCollideConnected(): boolean {\n    return this.m_collideConnected;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  abstract getAnchorA(): Vec2;\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  abstract getAnchorB(): Vec2;\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  abstract getReactionForce(inv_dt: number): Vec2;\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  abstract getReactionTorque(inv_dt: number): number;\n\n  /**\n   * Shift the origin for any points stored in world coordinates.\n   */\n  shiftOrigin(newOrigin: Vec2): void {}\n\n  abstract initVelocityConstraints(step: TimeStep): void;\n\n  abstract solveVelocityConstraints(step: TimeStep): void;\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  abstract solvePositionConstraints(step: TimeStep): boolean;\n\n}\n","export const stats = {\n  gjkCalls: 0,\n  gjkIters: 0,\n  gjkMaxIters: 0,\n\n  toiTime: 0,\n  toiMaxTime: 0,\n  toiCalls: 0,\n  toiIters: 0,\n  toiMaxIters: 0,\n  toiRootIters: 0,\n  toiMaxRootIters: 0,\n\n  toString(newline?: string): string {\n    newline = typeof newline === 'string' ? newline : '\\n';\n    let string = \"\";\n    // tslint:disable-next-line:no-for-in\n    for (const name in this) {\n      if (typeof this[name] !== 'function' && typeof this[name] !== 'object') {\n        string += name + ': ' + this[name] + newline;\n      }\n    }\n    return string;\n  }\n};\n","export const now = function(): number {\n  return Date.now();\n};\n\nexport const diff = function(time: number): number {\n  return Date.now() - time;\n};\n\nexport default {\n  now,\n  diff,\n};\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport * as matrix from '../common/Matrix';\nimport { SettingsInternal as Settings } from '../Settings';\nimport { stats } from '../util/stats';\nimport { Shape } from './Shape';\nimport { math as Math } from '../common/Math';\nimport { Vec2, Vec2Value } from '../common/Vec2';\nimport { Rot } from '../common/Rot';\nimport { Transform, TransformValue } from '../common/Transform';\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\nconst temp = matrix.vec2(0, 0);\nconst normal = matrix.vec2(0, 0);\nconst e12 = matrix.vec2(0, 0);\nconst e13 = matrix.vec2(0, 0);\nconst e23 = matrix.vec2(0, 0);\nconst temp1 = matrix.vec2(0, 0);\nconst temp2 = matrix.vec2(0, 0);\n\n/**\n * GJK using Voronoi regions (Christer Ericson) and Barycentric coordinates.\n */\n\nstats.gjkCalls = 0;\nstats.gjkIters = 0;\nstats.gjkMaxIters = 0;\n\n/**\n * Input for Distance. You have to option to use the shape radii in the\n * computation. Even\n */\nexport class DistanceInput {\n  readonly proxyA = new DistanceProxy();\n  readonly proxyB = new DistanceProxy();\n  readonly transformA = Transform.identity();\n  readonly transformB = Transform.identity();\n  useRadii = false;\n  recycle() {\n    this.proxyA.recycle();\n    this.proxyB.recycle();\n    this.transformA.setIdentity();\n    this.transformB.setIdentity();\n    this.useRadii = false;\n  }\n}\n\n/**\n * Output for Distance.\n */\nexport class DistanceOutput {\n  /** closest point on shapeA */\n  pointA = matrix.vec2(0, 0);\n  /** closest point on shapeB */\n  pointB = matrix.vec2(0, 0);\n  distance = 0;\n  /** iterations number of GJK iterations used */\n  iterations = 0;\n  recycle() {\n    matrix.zeroVec2(this.pointA)\n    matrix.zeroVec2(this.pointB)\n    this.distance = 0;\n    this.iterations = 0;\n  }\n}\n\n/**\n * Used to warm start Distance. Set count to zero on first call.\n */\nexport class SimplexCache {\n  /** length or area */\n  metric: number = 0;\n  /** vertices on shape A */\n  indexA: number[] = [];\n  /** vertices on shape B */\n  indexB: number[] = [];\n  count: number = 0;\n  recycle() {\n    this.metric = 0;\n    this.indexA.length = 0;\n    this.indexB.length = 0;\n    this.count = 0;\n  }\n}\n\n/**\n * Compute the closest points between two shapes. Supports any combination of:\n * CircleShape, PolygonShape, EdgeShape. The simplex cache is input/output. On\n * the first call set SimplexCache.count to zero.\n */\nexport const Distance = function (output: DistanceOutput, cache: SimplexCache, input: DistanceInput): void {\n  ++stats.gjkCalls;\n\n  const proxyA = input.proxyA;\n  const proxyB = input.proxyB;\n  const xfA = input.transformA;\n  const xfB = input.transformB;\n\n  // Initialize the simplex.\n  // const simplex = new Simplex();\n  simplex.recycle();\n  simplex.readCache(cache, proxyA, xfA, proxyB, xfB);\n\n  // Get simplex vertices as an array.\n  const vertices = simplex.m_v;\n  const k_maxIters = Settings.maxDistnceIterations;\n\n  // These store the vertices of the last simplex so that we\n  // can check for duplicates and prevent cycling.\n  const saveA = [];\n  const saveB = []; // int[3]\n  let saveCount = 0;\n\n  // Main iteration loop.\n  let iter = 0;\n  while (iter < k_maxIters) {\n    // Copy simplex so we can identify duplicates.\n    saveCount = simplex.m_count;\n    for (let i = 0; i < saveCount; ++i) {\n      saveA[i] = vertices[i].indexA;\n      saveB[i] = vertices[i].indexB;\n    }\n\n    simplex.solve();\n\n    // If we have 3 points, then the origin is in the corresponding triangle.\n    if (simplex.m_count === 3) {\n      break;\n    }\n\n    // Get search direction.\n    const d = simplex.getSearchDirection();\n\n    // Ensure the search direction is numerically fit.\n    if (matrix.lengthSqrVec2(d) < Math.EPSILON * Math.EPSILON) {\n      // The origin is probably contained by a line segment\n      // or triangle. Thus the shapes are overlapped.\n\n      // We can't return zero here even though there may be overlap.\n      // In case the simplex is a point, segment, or triangle it is difficult\n      // to determine if the origin is contained in the CSO or very close to it.\n      break;\n    }\n\n    // Compute a tentative new simplex vertex using support points.\n    const vertex = vertices[simplex.m_count]; // SimplexVertex\n\n    vertex.indexA = proxyA.getSupport(matrix.invRotVec2(temp, xfA.q, matrix.setMulVec2(temp, -1, d)));\n    matrix.transformVec2(vertex.wA, xfA, proxyA.getVertex(vertex.indexA));\n\n    vertex.indexB = proxyB.getSupport(matrix.invRotVec2(temp, xfB.q, d));\n    matrix.transformVec2(vertex.wB, xfB, proxyB.getVertex(vertex.indexB));\n\n    matrix.diffVec2(vertex.w, vertex.wB, vertex.wA);\n\n    // Iteration count is equated to the number of support point calls.\n    ++iter;\n    ++stats.gjkIters;\n\n    // Check for duplicate support points. This is the main termination\n    // criteria.\n    let duplicate = false;\n    for (let i = 0; i < saveCount; ++i) {\n      if (vertex.indexA === saveA[i] && vertex.indexB === saveB[i]) {\n        duplicate = true;\n        break;\n      }\n    }\n\n    // If we found a duplicate support point we must exit to avoid cycling.\n    if (duplicate) {\n      break;\n    }\n\n    // New vertex is ok and needed.\n    ++simplex.m_count;\n  }\n\n  stats.gjkMaxIters = Math.max(stats.gjkMaxIters, iter);\n\n  // Prepare output.\n  simplex.getWitnessPoints(output.pointA, output.pointB);\n  output.distance = matrix.distVec2(output.pointA, output.pointB);\n  output.iterations = iter;\n\n  // Cache the simplex.\n  simplex.writeCache(cache);\n\n  // Apply radii if requested.\n  if (input.useRadii) {\n    const rA = proxyA.m_radius;\n    const rB = proxyB.m_radius;\n\n    if (output.distance > rA + rB && output.distance > Math.EPSILON) {\n      // Shapes are still no overlapped.\n      // Move the witness points to the outer surface.\n      output.distance -= rA + rB;\n      matrix.diffVec2(normal, output.pointB, output.pointA);\n      matrix.normalizeVec2(normal);\n      matrix.addMulVec2(output.pointA, rA, normal);\n      matrix.subMulVec2(output.pointB, rB, normal);\n    } else {\n      // Shapes are overlapped when radii are considered.\n      // Move the witness points to the middle.\n      const p = matrix.diffVec2(temp, output.pointA, output.pointB);\n      matrix.copyVec2(output.pointA, p);\n      matrix.copyVec2(output.pointB, p);\n      output.distance = 0.0;\n    }\n  }\n}\n\n/**\n * A distance proxy is used by the GJK algorithm. It encapsulates any shape.\n */\nexport class DistanceProxy {\n  /** @internal */ m_vertices: Vec2Value[] = [];\n  // todo: remove this?\n  /** @internal */ m_count = 0;\n  /** @internal */ m_radius = 0;\n\n  recycle() {\n    this.m_vertices.length = 0;\n    this.m_count = 0;\n    this.m_radius = 0;\n  }\n\n  /**\n   * Get the vertex count.\n   */\n  getVertexCount(): number {\n    return this.m_count;\n  }\n\n  /**\n   * Get a vertex by index. Used by Distance.\n   */\n  getVertex(index: number): Vec2Value {\n    _ASSERT && console.assert(0 <= index && index < this.m_count);\n    return this.m_vertices[index];\n  }\n\n  /**\n   * Get the supporting vertex index in the given direction.\n   */\n  getSupport(d: Vec2Value): number {\n    let bestIndex = -1;\n    let bestValue = -Infinity;\n    for (let i = 0; i < this.m_count; ++i) {\n      const value = matrix.dotVec2(this.m_vertices[i], d);\n      if (value > bestValue) {\n        bestIndex = i;\n        bestValue = value;\n      }\n    }\n    return bestIndex;\n  }\n\n  /**\n   * Get the supporting vertex in the given direction.\n   */\n  getSupportVertex(d: Vec2Value): Vec2Value {\n    return this.m_vertices[this.getSupport(d)];\n  }\n\n  /**\n   * Initialize the proxy using the given shape. The shape must remain in scope\n   * while the proxy is in use.\n   */\n  set(shape: Shape, index: number): void {\n    // TODO remove, use shape instead\n    _ASSERT && console.assert(typeof shape.computeDistanceProxy === 'function');\n    shape.computeDistanceProxy(this, index);\n  }\n\n  /**\n   * Initialize the proxy using a vertex cloud and radius. The vertices\n   * must remain in scope while the proxy is in use.\n   */\n  setVertices(vertices: Vec2Value[], count: number, radius: number) {\n    this.m_vertices = vertices;\n    this.m_count = count;\n    this.m_radius = radius;\n  }\n}\n\nclass SimplexVertex {\n  /** support point in proxyA */\n  wA = matrix.vec2(0, 0);\n  /** wA index */\n  indexA = 0;\n\n  /** support point in proxyB */\n  wB = matrix.vec2(0, 0);\n  /** wB index */\n  indexB = 0;\n\n  /** wB - wA; */\n  w = matrix.vec2(0, 0);\n  /** barycentric coordinate for closest point */\n  a = 0;\n\n  recycle() {\n    this.indexA = 0;\n    this.indexB = 0;\n    matrix.zeroVec2(this.wA)\n    matrix.zeroVec2(this.wB)\n    matrix.zeroVec2(this.w)\n    this.a = 0;\n  }\n  set(v: SimplexVertex): void {\n    this.indexA = v.indexA;\n    this.indexB = v.indexB;\n    matrix.copyVec2(this.wA, v.wA);\n    matrix.copyVec2(this.wB, v.wB);\n    matrix.copyVec2(this.w, v.w);\n    this.a = v.a;\n  }\n}\n\nconst searchDirection_reuse = matrix.vec2(0, 0);\nconst closestPoint_reuse = matrix.vec2(0, 0);  \n\nclass Simplex {\n  m_v1 = new SimplexVertex();\n  m_v2 = new SimplexVertex();\n  m_v3 = new SimplexVertex();\n  m_v = [this.m_v1, this.m_v2, this.m_v3];\n  m_count: number;\n  recycle() {\n    this.m_v1.recycle();\n    this.m_v2.recycle();\n    this.m_v3.recycle();\n    this.m_count = 0;\n  }\n\n  /** @internal */\n  toString(): string {\n    if (this.m_count === 3) {\n      return [\"+\" + this.m_count,\n        this.m_v1.a, this.m_v1.wA.x, this.m_v1.wA.y, this.m_v1.wB.x, this.m_v1.wB.y,\n        this.m_v2.a, this.m_v2.wA.x, this.m_v2.wA.y, this.m_v2.wB.x, this.m_v2.wB.y,\n        this.m_v3.a, this.m_v3.wA.x, this.m_v3.wA.y, this.m_v3.wB.x, this.m_v3.wB.y\n      ].toString();\n\n    } else if (this.m_count === 2) {\n      return [\"+\" + this.m_count,\n        this.m_v1.a, this.m_v1.wA.x, this.m_v1.wA.y, this.m_v1.wB.x, this.m_v1.wB.y,\n        this.m_v2.a, this.m_v2.wA.x, this.m_v2.wA.y, this.m_v2.wB.x, this.m_v2.wB.y\n      ].toString();\n\n    } else if (this.m_count === 1) {\n      return [\"+\" + this.m_count,\n        this.m_v1.a, this.m_v1.wA.x, this.m_v1.wA.y, this.m_v1.wB.x, this.m_v1.wB.y\n      ].toString();\n\n    } else {\n      return \"+\" + this.m_count;\n    }\n  }\n\n  readCache(cache: SimplexCache, proxyA: DistanceProxy, transformA: TransformValue, proxyB: DistanceProxy, transformB: TransformValue): void {\n    _ASSERT && console.assert(cache.count <= 3);\n\n    // Copy data from cache.\n    this.m_count = cache.count;\n    for (let i = 0; i < this.m_count; ++i) {\n      const v = this.m_v[i];\n      v.indexA = cache.indexA[i];\n      v.indexB = cache.indexB[i];\n      const wALocal = proxyA.getVertex(v.indexA);\n      const wBLocal = proxyB.getVertex(v.indexB);\n      matrix.transformVec2(v.wA, transformA, wALocal);\n      matrix.transformVec2(v.wB, transformB, wBLocal);\n      matrix.diffVec2(v.w,v.wB, v.wA);\n      v.a = 0.0;\n    }\n\n    // Compute the new simplex metric, if it is substantially different than\n    // old metric then flush the simplex.\n    if (this.m_count > 1) {\n      const metric1 = cache.metric;\n      const metric2 = this.getMetric();\n      if (metric2 < 0.5 * metric1 || 2.0 * metric1 < metric2 || metric2 < Math.EPSILON) {\n        // Reset the simplex.\n        this.m_count = 0;\n      }\n    }\n\n    // If the cache is empty or invalid...\n    if (this.m_count === 0) {\n      const v = this.m_v[0];\n      v.indexA = 0;\n      v.indexB = 0;\n      const wALocal = proxyA.getVertex(0);\n      const wBLocal = proxyB.getVertex(0);\n      matrix.transformVec2(v.wA, transformA, wALocal);\n      matrix.transformVec2(v.wB, transformB, wBLocal);\n      matrix.diffVec2(v.w,v.wB, v.wA);\n      v.a = 1.0;\n      this.m_count = 1;\n    }\n  }\n\n  writeCache(cache: SimplexCache): void {\n    cache.metric = this.getMetric();\n    cache.count = this.m_count;\n    for (let i = 0; i < this.m_count; ++i) {\n      cache.indexA[i] = this.m_v[i].indexA;\n      cache.indexB[i] = this.m_v[i].indexB;\n    }\n  }\n\n  getSearchDirection(): Vec2Value {\n    const v1 = this.m_v1;\n    const v2 = this.m_v2;\n    const v3 = this.m_v3;\n    switch (this.m_count) {\n      case 1:\n        return matrix.setVec2(searchDirection_reuse, -v1.w.x, -v1.w.y);\n\n      case 2: {\n        matrix.diffVec2(e12, v2.w, v1.w);\n        const sgn = -matrix.crossVec2Vec2(e12, v1.w);\n        if (sgn > 0.0) {\n          // Origin is left of e12.\n          return matrix.setVec2(searchDirection_reuse, -e12.y, e12.x);\n        } else {\n          // Origin is right of e12.\n          return matrix.setVec2(searchDirection_reuse, e12.y, -e12.x);\n        }\n      }\n\n      default:\n        _ASSERT && console.assert(false);\n        return matrix.zeroVec2(searchDirection_reuse);\n    }\n  }\n\n  getClosestPoint(): Vec2Value {\n    const v1 = this.m_v1;\n    const v2 = this.m_v2;\n    const v3 = this.m_v3;\n    switch (this.m_count) {\n      case 0:\n        _ASSERT && console.assert(false);\n        return matrix.zeroVec2(closestPoint_reuse);\n\n      case 1:\n        return matrix.copyVec2(closestPoint_reuse, v1.w);\n\n      case 2:\n        return  matrix.combineVec2(closestPoint_reuse, v1.a, v1.w, v2.a, v2.w);\n\n      case 3:\n        return matrix.zeroVec2(closestPoint_reuse);\n\n      default:\n        _ASSERT && console.assert(false);\n        return matrix.zeroVec2(closestPoint_reuse);\n    }\n  }\n\n  getWitnessPoints(pA: Vec2Value, pB: Vec2Value): void {\n    const v1 = this.m_v1;\n    const v2 = this.m_v2;\n    const v3 = this.m_v3;\n    switch (this.m_count) {\n      case 0:\n        _ASSERT && console.assert(false);\n        break;\n\n      case 1:\n        matrix.copyVec2(pA, v1.wA);\n        matrix.copyVec2(pB, v1.wB);\n        break;\n\n      case 2:\n        matrix.combineVec2(pA, v1.a, v1.wA, v2.a, v2.wA);\n        matrix.combineVec2(pB, v1.a, v1.wB, v2.a, v2.wB);\n        break;\n\n      case 3:\n        pB.x = pA.x = v1.a * v1.wA.x + v2.a * v2.wA.x + v3.a * v3.wA.x;\n        pB.y = pA.y = v1.a * v1.wA.y + v2.a * v2.wA.y + v3.a * v3.wA.y;\n        break;\n\n      default:\n        _ASSERT && console.assert(false);\n        break;\n    }\n  }\n\n  getMetric(): number {\n    switch (this.m_count) {\n      case 0:\n        _ASSERT && console.assert(false);\n        return 0.0;\n\n      case 1:\n        return 0.0;\n\n      case 2:\n        return matrix.distVec2(this.m_v1.w, this.m_v2.w);\n\n      case 3:\n        return matrix.crossVec2Vec2(\n          matrix.diffVec2(temp1, this.m_v2.w, this.m_v1.w),\n          matrix.diffVec2(temp2, this.m_v3.w, this.m_v1.w),\n        );\n\n      default:\n        _ASSERT && console.assert(false);\n        return 0.0;\n    }\n  }\n\n  solve(): void {\n    switch (this.m_count) {\n      case 1:\n        break;\n\n      case 2:\n        this.solve2();\n        break;\n\n      case 3:\n        this.solve3();\n        break;\n\n      default:\n        _ASSERT && console.assert(false);\n    }\n  }\n\n// Solve a line segment using barycentric coordinates.\n//\n// p = a1 * w1 + a2 * w2\n// a1 + a2 = 1\n//\n// The vector from the origin to the closest point on the line is\n// perpendicular to the line.\n// e12 = w2 - w1\n// dot(p, e) = 0\n// a1 * dot(w1, e) + a2 * dot(w2, e) = 0\n//\n// 2-by-2 linear system\n// [1 1 ][a1] = [1]\n// [w1.e12 w2.e12][a2] = [0]\n//\n// Define\n// d12_1 = dot(w2, e12)\n// d12_2 = -dot(w1, e12)\n// d12 = d12_1 + d12_2\n//\n// Solution\n// a1 = d12_1 / d12\n// a2 = d12_2 / d12\n  solve2(): void {\n    const w1 = this.m_v1.w;\n    const w2 = this.m_v2.w;\n    matrix.diffVec2(e12, w2, w1);\n\n    // w1 region\n    const d12_2 = -matrix.dotVec2(w1, e12);\n    if (d12_2 <= 0.0) {\n      // a2 <= 0, so we clamp it to 0\n      this.m_v1.a = 1.0;\n      this.m_count = 1;\n      return;\n    }\n\n    // w2 region\n    const d12_1 = matrix.dotVec2(w2, e12);\n    if (d12_1 <= 0.0) {\n      // a1 <= 0, so we clamp it to 0\n      this.m_v2.a = 1.0;\n      this.m_count = 1;\n      this.m_v1.set(this.m_v2);\n      return;\n    }\n\n    // Must be in e12 region.\n    const inv_d12 = 1.0 / (d12_1 + d12_2);\n    this.m_v1.a = d12_1 * inv_d12;\n    this.m_v2.a = d12_2 * inv_d12;\n    this.m_count = 2;\n  }\n\n// Possible regions:\n// - points[2]\n// - edge points[0]-points[2]\n// - edge points[1]-points[2]\n// - inside the triangle\n  solve3(): void {\n    const w1 = this.m_v1.w;\n    const w2 = this.m_v2.w;\n    const w3 = this.m_v3.w;\n\n    // Edge12\n    // [1 1 ][a1] = [1]\n    // [w1.e12 w2.e12][a2] = [0]\n    // a3 = 0\n    matrix.diffVec2(e12, w2, w1);\n    const w1e12 = matrix.dotVec2(w1, e12);\n    const w2e12 = matrix.dotVec2(w2, e12);\n    const d12_1 = w2e12;\n    const d12_2 = -w1e12;\n\n    // Edge13\n    // [1 1 ][a1] = [1]\n    // [w1.e13 w3.e13][a3] = [0]\n    // a2 = 0\n    matrix.diffVec2(e13, w3, w1);\n    const w1e13 = matrix.dotVec2(w1, e13);\n    const w3e13 = matrix.dotVec2(w3, e13);\n    const d13_1 = w3e13;\n    const d13_2 = -w1e13;\n\n    // Edge23\n    // [1 1 ][a2] = [1]\n    // [w2.e23 w3.e23][a3] = [0]\n    // a1 = 0\n    matrix.diffVec2(e23, w3, w2);\n    const w2e23 = matrix.dotVec2(w2, e23);\n    const w3e23 = matrix.dotVec2(w3, e23);\n    const d23_1 = w3e23;\n    const d23_2 = -w2e23;\n\n    // Triangle123\n    const n123 = matrix.crossVec2Vec2(e12, e13);\n\n    const d123_1 = n123 * matrix.crossVec2Vec2(w2, w3);\n    const d123_2 = n123 * matrix.crossVec2Vec2(w3, w1);\n    const d123_3 = n123 * matrix.crossVec2Vec2(w1, w2);\n\n    // w1 region\n    if (d12_2 <= 0.0 && d13_2 <= 0.0) {\n      this.m_v1.a = 1.0;\n      this.m_count = 1;\n      return;\n    }\n\n    // e12\n    if (d12_1 > 0.0 && d12_2 > 0.0 && d123_3 <= 0.0) {\n      const inv_d12 = 1.0 / (d12_1 + d12_2);\n      this.m_v1.a = d12_1 * inv_d12;\n      this.m_v2.a = d12_2 * inv_d12;\n      this.m_count = 2;\n      return;\n    }\n\n    // e13\n    if (d13_1 > 0.0 && d13_2 > 0.0 && d123_2 <= 0.0) {\n      const inv_d13 = 1.0 / (d13_1 + d13_2);\n      this.m_v1.a = d13_1 * inv_d13;\n      this.m_v3.a = d13_2 * inv_d13;\n      this.m_count = 2;\n      this.m_v2.set(this.m_v3);\n      return;\n    }\n\n    // w2 region\n    if (d12_1 <= 0.0 && d23_2 <= 0.0) {\n      this.m_v2.a = 1.0;\n      this.m_count = 1;\n      this.m_v1.set(this.m_v2);\n      return;\n    }\n\n    // w3 region\n    if (d13_1 <= 0.0 && d23_1 <= 0.0) {\n      this.m_v3.a = 1.0;\n      this.m_count = 1;\n      this.m_v1.set(this.m_v3);\n      return;\n    }\n\n    // e23\n    if (d23_1 > 0.0 && d23_2 > 0.0 && d123_1 <= 0.0) {\n      const inv_d23 = 1.0 / (d23_1 + d23_2);\n      this.m_v2.a = d23_1 * inv_d23;\n      this.m_v3.a = d23_2 * inv_d23;\n      this.m_count = 2;\n      this.m_v1.set(this.m_v3);\n      return;\n    }\n\n    // Must be in triangle123\n    const inv_d123 = 1.0 / (d123_1 + d123_2 + d123_3);\n    this.m_v1.a = d123_1 * inv_d123;\n    this.m_v2.a = d123_2 * inv_d123;\n    this.m_v3.a = d123_3 * inv_d123;\n    this.m_count = 3;\n  }\n}\n\nconst simplex = new Simplex();\n\nconst input = new DistanceInput();\nconst cache = new SimplexCache();\nconst output = new DistanceOutput();\n\n/**\n * Determine if two generic shapes overlap.\n */\nexport const testOverlap = function (shapeA: Shape, indexA: number, shapeB: Shape, indexB: number, xfA: TransformValue, xfB: TransformValue): boolean {\n  input.recycle();\n  input.proxyA.set(shapeA, indexA);\n  input.proxyB.set(shapeB, indexB);\n  matrix.copyTransform(input.transformA, xfA);\n  matrix.copyTransform(input.transformB, xfB);\n  input.useRadii = true;\n\n  output.recycle();\n  cache.recycle();\n\n  Distance(output, cache, input);\n\n  return output.distance < 10.0 * Math.EPSILON;\n}\n\n// legacy exports\nDistance.testOverlap = testOverlap;\nDistance.Input = DistanceInput;\nDistance.Output = DistanceOutput;\nDistance.Proxy = DistanceProxy;\nDistance.Cache = SimplexCache;\n\n/**\n * Input parameters for ShapeCast\n */\nexport class ShapeCastInput {\n  readonly proxyA = new DistanceProxy();\n  readonly proxyB = new DistanceProxy();\n  readonly transformA = Transform.identity();\n  readonly transformB = Transform.identity();\n  readonly translationB = Vec2.zero();\n  recycle() {\n    this.proxyA.recycle();\n    this.proxyB.recycle();\n    this.transformA.setIdentity();\n    this.transformB.setIdentity();\n    matrix.zeroVec2(this.translationB);\n  }\n}\n\n/**\n * Output results for b2ShapeCast\n */\nexport class ShapeCastOutput {\n  point: Vec2 = Vec2.zero();\n  normal: Vec2 = Vec2.zero();\n  lambda = 1.0;\n  iterations = 0;\n}\n\n/**\n * Perform a linear shape cast of shape B moving and shape A fixed. Determines\n * the hit point, normal, and translation fraction.\n * \n * @returns true if hit, false if there is no hit or an initial overlap\n */\n//\n// GJK-raycast\n// Algorithm by Gino van den Bergen.\n// \"Smooth Mesh Contacts with GJK\" in Game Physics Pearls. 2010\nexport const ShapeCast = function(output: ShapeCastOutput, input: ShapeCastInput): boolean {\n  output.iterations = 0;\n  output.lambda = 1.0;\n  output.normal.setZero();\n  output.point.setZero();\n\n  const proxyA = input.proxyA;\n  const proxyB = input.proxyB;\n\n  const radiusA = Math.max(proxyA.m_radius, Settings.polygonRadius);\n  const radiusB = Math.max(proxyB.m_radius, Settings.polygonRadius);\n  const radius = radiusA + radiusB;\n\n  const xfA = input.transformA;\n  const xfB = input.transformB;\n\n  const r = input.translationB;\n  const n = Vec2.zero();\n  let lambda = 0.0;\n\n  // Initial simplex\n  const simplex = new Simplex();\n  simplex.m_count = 0;\n\n  // Get simplex vertices as an array.\n  const vertices = simplex.m_v;\n\n  // Get support point in -r direction\n  let indexA = proxyA.getSupport(Rot.mulTVec2(xfA.q, Vec2.neg(r)));\n  let wA = Transform.mulVec2(xfA, proxyA.getVertex(indexA));\n  let indexB = proxyB.getSupport(Rot.mulTVec2(xfB.q, r));\n  let wB = Transform.mulVec2(xfB, proxyB.getVertex(indexB));\n  const v = Vec2.sub(wA, wB);\n\n  // Sigma is the target distance between polygons\n  const sigma = Math.max(Settings.polygonRadius, radius - Settings.polygonRadius);\n  const tolerance = 0.5 * Settings.linearSlop;\n\n  // Main iteration loop.\n  const k_maxIters = 20;\n  let iter = 0;\n  while (iter < k_maxIters && v.length() - sigma > tolerance) {\n    _ASSERT && console.assert(simplex.m_count < 3);\n\n    output.iterations += 1;\n\n    // Support in direction -v (A - B)\n    indexA = proxyA.getSupport(Rot.mulTVec2(xfA.q, Vec2.neg(v)));\n    wA = Transform.mulVec2(xfA, proxyA.getVertex(indexA));\n    indexB = proxyB.getSupport(Rot.mulTVec2(xfB.q, v));\n    wB = Transform.mulVec2(xfB, proxyB.getVertex(indexB));\n    const p = Vec2.sub(wA, wB);\n\n    // -v is a normal at p\n    v.normalize();\n\n    // Intersect ray with plane\n    const vp = Vec2.dot(v, p);\n    const vr = Vec2.dot(v, r);\n    if (vp - sigma > lambda * vr) {\n      if (vr <= 0.0) {\n        return false;\n      }\n\n      lambda = (vp - sigma) / vr;\n      if (lambda > 1.0) {\n        return false;\n      }\n\n      n.setMul(-1, v);\n      simplex.m_count = 0;\n    }\n\n    // Reverse simplex since it works with B - A.\n    // Shift by lambda * r because we want the closest point to the current clip point.\n    // Note that the support point p is not shifted because we want the plane equation\n    // to be formed in unshifted space.\n    const vertex = vertices[simplex.m_count];\n    vertex.indexA = indexB;\n    vertex.wA = Vec2.combine(1, wB, lambda, r);\n    vertex.indexB = indexA;\n    vertex.wB = wA;\n    vertex.w = Vec2.sub(vertex.wB, vertex.wA);\n    vertex.a = 1.0;\n    simplex.m_count += 1;\n\n    switch (simplex.m_count) {\n      case 1:\n        break;\n\n      case 2:\n        simplex.solve2();\n        break;\n\n      case 3:\n        simplex.solve3();\n        break;\n\n      default:\n        _ASSERT && console.assert(false);\n    }\n    \n    // If we have 3 points, then the origin is in the corresponding triangle.\n    if (simplex.m_count == 3) {\n      // Overlap\n      return false;\n    }\n\n    // Get search direction.\n    v.setVec2(simplex.getClosestPoint());\n\n    // Iteration count is equated to the number of support point calls.\n    ++iter;\n  }\n\n  if (iter == 0) {\n    // Initial overlap\n    return false;\n\t}\n\n  // Prepare output.\n  const pointA = Vec2.zero();\n  const pointB = Vec2.zero();\n  simplex.getWitnessPoints(pointB, pointA);\n\n  if (v.lengthSquared() > 0.0) {\n    n.setMul(-1, v);\n    n.normalize();\n  }\n\n  output.point = Vec2.combine(1, pointA, radiusA, n);\n  output.normal = n;\n  output.lambda = lambda;\n  output.iterations = iter;\n  return true;\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport * as matrix from '../common/Matrix';\nimport { SettingsInternal as Settings } from '../Settings';\nimport { stats } from '../util/stats';\nimport Timer from '../util/Timer';\nimport { math as Math } from '../common/Math';\nimport { Sweep } from '../common/Sweep';\nimport { Transform } from '../common/Transform';\nimport { Distance, DistanceInput, DistanceOutput, DistanceProxy, SimplexCache } from './Distance';\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n/**\n * Input parameters for TimeOfImpact.\n */\nexport class TOIInput {\n  proxyA = new DistanceProxy();\n  proxyB = new DistanceProxy();\n  sweepA = new Sweep();\n  sweepB = new Sweep();\n  /** defines sweep interval [0, tMax] */\n  tMax: number;\n  recycle() {\n    this.proxyA.recycle();\n    this.proxyB.recycle();\n    this.sweepA.recycle();\n    this.sweepB.recycle();\n    this.tMax = -1;\n  }\n}\n\nexport enum TOIOutputState {\n  e_unset = -1,\n  e_unknown = 0,\n  e_failed = 1,\n  e_overlapped = 2,\n  e_touching = 3,\n  e_separated = 4,\n}\n\n/**\n * Output parameters for TimeOfImpact.\n */\nexport class TOIOutput {\n  state = TOIOutputState.e_unset;\n  t = -1;\n  recycle() {\n    this.state = TOIOutputState.e_unset;\n    this.t = -1;\n  }\n}\n\nstats.toiTime = 0;\nstats.toiMaxTime = 0;\nstats.toiCalls = 0;\nstats.toiIters = 0;\nstats.toiMaxIters = 0;\nstats.toiRootIters = 0;\nstats.toiMaxRootIters = 0;\n\nconst distanceInput = new DistanceInput();\nconst distanceOutput = new DistanceOutput();\n// this is passed to Distance and SeparationFunction\nconst cache = new SimplexCache();\n\nconst xfA = matrix.transform(0, 0, 0);\nconst xfB = matrix.transform(0, 0, 0);\nconst temp = matrix.vec2(0, 0);\nconst pointA = matrix.vec2(0, 0);\nconst pointB = matrix.vec2(0, 0);\nconst normal = matrix.vec2(0, 0);\nconst axisA = matrix.vec2(0, 0);\nconst axisB = matrix.vec2(0, 0);\nconst localPointA = matrix.vec2(0, 0);\nconst localPointB = matrix.vec2(0, 0);\n\n\n/**\n * Compute the upper bound on time before two shapes penetrate. Time is\n * represented as a fraction between [0,tMax]. This uses a swept separating axis\n * and may miss some intermediate, non-tunneling collisions. If you change the\n * time interval, you should call this function again.\n *\n * Note: use Distance to compute the contact point and normal at the time of\n * impact.\n *\n * CCD via the local separating axis method. This seeks progression by computing\n * the largest time at which separation is maintained.\n */\nexport const TimeOfImpact = function (output: TOIOutput, input: TOIInput): void {\n  const timer = Timer.now();\n\n  ++stats.toiCalls;\n\n  output.state = TOIOutputState.e_unknown;\n  output.t = input.tMax;\n\n  const proxyA = input.proxyA; // DistanceProxy\n  const proxyB = input.proxyB; // DistanceProxy\n\n  const sweepA = input.sweepA; // Sweep\n  const sweepB = input.sweepB; // Sweep\n\n  // Large rotations can make the root finder fail, so we normalize the\n  // sweep angles.\n  sweepA.normalize();\n  sweepB.normalize();\n\n  const tMax = input.tMax;\n\n  const totalRadius = proxyA.m_radius + proxyB.m_radius;\n  const target = Math.max(Settings.linearSlop, totalRadius - 3.0 * Settings.linearSlop);\n  const tolerance = 0.25 * Settings.linearSlop;\n  _ASSERT && console.assert(target > tolerance);\n\n  let t1 = 0.0;\n  const k_maxIterations = Settings.maxTOIIterations;\n  let iter = 0;\n\n  // Prepare input for distance query.\n  // const cache = new SimplexCache();\n  cache.recycle();\n\n  distanceInput.proxyA.setVertices(proxyA.m_vertices, proxyA.m_count, proxyA.m_radius);\n  distanceInput.proxyB.setVertices(proxyB.m_vertices, proxyB.m_count, proxyB.m_radius);\n  distanceInput.useRadii = false;\n\n  // The outer loop progressively attempts to compute new separating axes.\n  // This loop terminates when an axis is repeated (no progress is made).\n  while (true) {\n    sweepA.getTransform(xfA, t1);\n    sweepB.getTransform(xfB, t1);\n\n    // Get the distance between shapes. We can also use the results\n    // to get a separating axis.\n    matrix.copyTransform(distanceInput.transformA, xfA);\n    matrix.copyTransform(distanceInput.transformB, xfB);\n    Distance(distanceOutput, cache, distanceInput);\n\n    // If the shapes are overlapped, we give up on continuous collision.\n    if (distanceOutput.distance <= 0.0) {\n      // Failure!\n      output.state = TOIOutputState.e_overlapped;\n      output.t = 0.0;\n      break;\n    }\n\n    if (distanceOutput.distance < target + tolerance) {\n      // Victory!\n      output.state = TOIOutputState.e_touching;\n      output.t = t1;\n      break;\n    }\n\n    // Initialize the separating axis.\n    separationFunction.initialize(cache, proxyA, sweepA, proxyB, sweepB, t1);\n\n    // if (false) {\n    //   // Dump the curve seen by the root finder\n    //   const N = 100;\n    //   const dx = 1.0 / N;\n    //   const xs = []; // [ N + 1 ];\n    //   const fs = []; // [ N + 1 ];\n    //   const x = 0.0;\n    //   for (const i = 0; i <= N; ++i) {\n    //     sweepA.getTransform(xfA, x);\n    //     sweepB.getTransform(xfB, x);\n    //     const f = fcn.evaluate(xfA, xfB) - target;\n    //     printf(\"%g %g\\n\", x, f);\n    //     xs[i] = x;\n    //     fs[i] = f;\n    //     x += dx;\n    //   }\n    // }\n\n    // Compute the TOI on the separating axis. We do this by successively\n    // resolving the deepest point. This loop is bounded by the number of\n    // vertices.\n    let done = false;\n    let t2 = tMax;\n    let pushBackIter = 0;\n    while (true) {\n      // Find the deepest point at t2. Store the witness point indices.\n      let s2 = separationFunction.findMinSeparation(t2);\n\n      // Is the final configuration separated?\n      if (s2 > target + tolerance) {\n        // Victory!\n        output.state = TOIOutputState.e_separated;\n        output.t = tMax;\n        done = true;\n        break;\n      }\n\n      // Has the separation reached tolerance?\n      if (s2 > target - tolerance) {\n        // Advance the sweeps\n        t1 = t2;\n        break;\n      }\n\n      // Compute the initial separation of the witness points.\n      let s1 = separationFunction.evaluate(t1);\n\n      // Check for initial overlap. This might happen if the root finder\n      // runs out of iterations.\n      if (s1 < target - tolerance) {\n        output.state = TOIOutputState.e_failed;\n        output.t = t1;\n        done = true;\n        break;\n      }\n\n      // Check for touching\n      if (s1 <= target + tolerance) {\n        // Victory! t1 should hold the TOI (could be 0.0).\n        output.state = TOIOutputState.e_touching;\n        output.t = t1;\n        done = true;\n        break;\n      }\n\n      // Compute 1D root of: f(x) - target = 0\n      let rootIterCount = 0;\n      let a1 = t1;\n      let a2 = t2;\n      while (true) {\n        // Use a mix of the secant rule and bisection.\n        let t;\n        if (rootIterCount & 1) {\n          // Secant rule to improve convergence.\n          t = a1 + (target - s1) * (a2 - a1) / (s2 - s1);\n        } else {\n          // Bisection to guarantee progress.\n          t = 0.5 * (a1 + a2);\n        }\n\n        ++rootIterCount;\n        ++stats.toiRootIters;\n\n        const s = separationFunction.evaluate(t);\n\n        if (Math.abs(s - target) < tolerance) {\n          // t2 holds a tentative value for t1\n          t2 = t;\n          break;\n        }\n\n        // Ensure we continue to bracket the root.\n        if (s > target) {\n          a1 = t;\n          s1 = s;\n        } else {\n          a2 = t;\n          s2 = s;\n        }\n\n        if (rootIterCount === 50) {\n          break;\n        }\n      }\n\n      stats.toiMaxRootIters = Math.max(stats.toiMaxRootIters, rootIterCount);\n\n      ++pushBackIter;\n\n      if (pushBackIter === Settings.maxPolygonVertices) {\n        break;\n      }\n    }\n\n    ++iter;\n    ++stats.toiIters;\n\n    if (done) {\n      break;\n    }\n\n    if (iter === k_maxIterations) {\n      // Root finder got stuck. Semi-victory.\n      output.state = TOIOutputState.e_failed;\n      output.t = t1;\n      break;\n    }\n  }\n\n  stats.toiMaxIters = Math.max(stats.toiMaxIters, iter);\n\n  const time = Timer.diff(timer);\n  stats.toiMaxTime = Math.max(stats.toiMaxTime, time);\n  stats.toiTime += time;\n\n  separationFunction.recycle();\n}\n\nenum SeparationFunctionType {\n  e_unset = -1,\n  e_points = 1,\n  e_faceA = 2,\n  e_faceB = 3,\n}\n\nclass SeparationFunction {\n  // input cache\n  // todo: maybe assign by copy instead of reference?\n  m_proxyA: DistanceProxy = null;\n  m_proxyB: DistanceProxy = null;\n  m_sweepA: Sweep = null;\n  m_sweepB: Sweep = null;\n\n  // initialize cache\n  m_type = SeparationFunctionType.e_unset;\n  m_localPoint = matrix.vec2(0, 0);\n  m_axis = matrix.vec2(0, 0);\n\n  // compute output\n  indexA = -1;\n  indexB = -1;\n\n  recycle() {\n    this.m_proxyA = null;\n    this.m_proxyB = null;\n    this.m_sweepA = null;\n    this.m_sweepB = null;\n\n    this.m_type = SeparationFunctionType.e_unset;\n    matrix.zeroVec2(this.m_localPoint)\n    matrix.zeroVec2(this.m_axis)\n\n    this.indexA = -1;\n    this.indexB = -1;\n  }\n\n  // TODO_ERIN might not need to return the separation\n\n  initialize(cache: SimplexCache, proxyA: DistanceProxy, sweepA: Sweep, proxyB: DistanceProxy, sweepB: Sweep, t1: number): number {\n    const count = cache.count;\n    _ASSERT && console.assert(0 < count && count < 3);\n\n    this.m_proxyA = proxyA;\n    this.m_proxyB = proxyB;\n    this.m_sweepA = sweepA;\n    this.m_sweepB = sweepB;\n\n    this.m_sweepA.getTransform(xfA, t1);\n    this.m_sweepB.getTransform(xfB, t1);\n\n    if (count === 1) {\n      this.m_type = SeparationFunctionType.e_points;\n      const localPointA = this.m_proxyA.getVertex(cache.indexA[0]);\n      const localPointB = this.m_proxyB.getVertex(cache.indexB[0]);\n      matrix.transformVec2(pointA, xfA, localPointA);\n      matrix.transformVec2(pointB, xfB, localPointB);\n      matrix.diffVec2(this.m_axis, pointB, pointA);\n      const s = matrix.normalizeVec2Length(this.m_axis);\n      return s;\n\n    } else if (cache.indexA[0] === cache.indexA[1]) {\n      // Two points on B and one on A.\n      this.m_type = SeparationFunctionType.e_faceB;\n      const localPointB1 = proxyB.getVertex(cache.indexB[0]);\n      const localPointB2 = proxyB.getVertex(cache.indexB[1]);\n\n      matrix.crossVec2Num(this.m_axis, matrix.diffVec2(temp, localPointB2, localPointB1), 1.0);\n      matrix.normalizeVec2(this.m_axis);\n      matrix.rotVec2(normal, xfB.q, this.m_axis);\n\n      matrix.combineVec2(this.m_localPoint, 0.5, localPointB1, 0.5, localPointB2);\n      matrix.transformVec2(pointB, xfB, this.m_localPoint);\n\n      const localPointA = proxyA.getVertex(cache.indexA[0]);\n      const pointA = Transform.mulVec2(xfA, localPointA);\n\n      let s = matrix.dotVec2(pointA, normal) - matrix.dotVec2(pointB, normal);\n      if (s < 0.0) {\n        matrix.negVec2(this.m_axis);\n        s = -s;\n      }\n      return s;\n\n    } else {\n      // Two points on A and one or two points on B.\n      this.m_type = SeparationFunctionType.e_faceA;\n      const localPointA1 = this.m_proxyA.getVertex(cache.indexA[0]);\n      const localPointA2 = this.m_proxyA.getVertex(cache.indexA[1]);\n\n      matrix.crossVec2Num(this.m_axis, matrix.diffVec2(temp, localPointA2, localPointA1), 1.0);\n      matrix.normalizeVec2(this.m_axis);\n      matrix.rotVec2(normal, xfA.q, this.m_axis);\n\n      matrix.combineVec2(this.m_localPoint, 0.5, localPointA1, 0.5, localPointA2);\n      matrix.transformVec2(pointA, xfA, this.m_localPoint);\n\n      const localPointB = this.m_proxyB.getVertex(cache.indexB[0]);\n      matrix.transformVec2(pointB, xfB, localPointB);\n\n      let s = matrix.dotVec2(pointB, normal) - matrix.dotVec2(pointA, normal);\n      if (s < 0.0) {\n        matrix.negVec2(this.m_axis);\n        s = -s;\n      }\n      return s;\n    }\n  }\n\n  compute(find: boolean, t: number): number {\n    // It was findMinSeparation and evaluate\n    this.m_sweepA.getTransform(xfA, t);\n    this.m_sweepB.getTransform(xfB, t);\n\n    switch (this.m_type) {\n      case SeparationFunctionType.e_points: {\n        if (find) {\n          matrix.invRotVec2(axisA, xfA.q, this.m_axis);\n          matrix.invRotVec2(axisB, xfB.q, matrix.setMulVec2(temp, -1, this.m_axis));\n\n          this.indexA = this.m_proxyA.getSupport(axisA);\n          this.indexB = this.m_proxyB.getSupport(axisB);\n        }\n\n        matrix.copyVec2(localPointA, this.m_proxyA.getVertex(this.indexA));\n        matrix.copyVec2(localPointB, this.m_proxyB.getVertex(this.indexB));\n\n        matrix.transformVec2(pointA, xfA, localPointA);\n        matrix.transformVec2(pointB, xfB, localPointB);\n\n        const sep = matrix.dotVec2(pointB, this.m_axis) - matrix.dotVec2(pointA, this.m_axis);\n        return sep;\n      }\n\n      case SeparationFunctionType.e_faceA: {\n        matrix.rotVec2(normal, xfA.q, this.m_axis);\n        matrix.transformVec2(pointA, xfA, this.m_localPoint);\n\n        if (find) {\n          matrix.invRotVec2(axisB, xfB.q, matrix.setMulVec2(temp, -1, normal));\n\n          this.indexA = -1;\n          this.indexB = this.m_proxyB.getSupport(axisB);\n        }\n\n        matrix.copyVec2(localPointB, this.m_proxyB.getVertex(this.indexB));\n        matrix.transformVec2(pointB, xfB, localPointB);\n\n        const sep = matrix.dotVec2(pointB, normal) - matrix.dotVec2(pointA, normal);\n        return sep;\n      }\n\n      case SeparationFunctionType.e_faceB: {\n        matrix.rotVec2(normal, xfB.q, this.m_axis);\n        matrix.transformVec2(pointB, xfB, this.m_localPoint);\n\n        if (find) {\n          matrix.invRotVec2(axisA, xfA.q, matrix.setMulVec2(temp, -1, normal));\n\n          this.indexB = -1;\n          this.indexA = this.m_proxyA.getSupport(axisA);\n        }\n\n        matrix.copyVec2(localPointA, this.m_proxyA.getVertex(this.indexA));\n        matrix.transformVec2(pointA, xfA, localPointA);\n\n        const sep = matrix.dotVec2(pointA, normal) - matrix.dotVec2(pointB, normal);\n        return sep;\n      }\n\n      default:\n        _ASSERT && console.assert(false);\n        if (find) {\n          this.indexA = -1;\n          this.indexB = -1;\n        }\n        return 0.0;\n    }\n  }\n\n  findMinSeparation(t: number): number {\n    return this.compute(true, t);\n  }\n\n  evaluate(t: number): number {\n    return this.compute(false, t);\n  }\n}\n\nconst separationFunction = new SeparationFunction();\n\n// legacy exports\nTimeOfImpact.Input = TOIInput;\nTimeOfImpact.Output = TOIOutput;\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport * as matrix from '../common/Matrix';\nimport { SettingsInternal as Settings } from '../Settings';\nimport { math as Math } from '../common/Math';\nimport { Body } from './Body';\nimport type { Contact } from './Contact';\nimport { Joint } from './Joint';\nimport { TimeOfImpact, TOIInput, TOIOutput, TOIOutputState } from '../collision/TimeOfImpact';\nimport { Distance, DistanceInput, DistanceOutput, SimplexCache } from '../collision/Distance';\nimport { World } from \"./World\";\nimport { Sweep } from '../common/Sweep';\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nexport class TimeStep {\n  /** time step */\n  dt: number = 0;\n  /** inverse time step (0 if dt == 0) */\n  inv_dt: number = 0;\n  velocityIterations: number = 0;\n  positionIterations: number = 0;\n  warmStarting: boolean = false;\n  blockSolve: boolean = true;\n\n  /** timestep ratio for variable timestep */\n  inv_dt0: number = 0.0;\n  /** dt * inv_dt0 */\n  dtRatio: number = 1;\n\n  reset(dt: number): void {\n    if (this.dt > 0.0) {\n      this.inv_dt0 = this.inv_dt;\n    }\n    this.dt = dt;\n    this.inv_dt = dt == 0 ? 0 : 1 / dt;\n    this.dtRatio = dt * this.inv_dt0;\n  }\n}\n\n// reuse\nconst s_subStep = new TimeStep();\nconst c = matrix.vec2(0, 0);\nconst v = matrix.vec2(0, 0);\nconst translation = matrix.vec2(0, 0);\nconst input = new TOIInput();\nconst output = new TOIOutput();\nconst backup = new Sweep();\nconst backup1 = new Sweep();\nconst backup2 = new Sweep();\n\n/**\n * Contact impulses for reporting. Impulses are used instead of forces because\n * sub-step forces may approach infinity for rigid body collisions. These match\n * up one-to-one with the contact points in Manifold.\n */\nexport class ContactImpulse {\n  // TODO: merge with Contact class?\n\n  private readonly contact: Contact;\n  private readonly normals: number[];\n  private readonly tangents: number[];\n\n  constructor(contact: Contact) {\n    this.contact = contact;\n    this.normals = [];\n    this.tangents = [];\n  }\n\n  recycle() {\n    this.normals.length = 0;\n    this.tangents.length = 0;\n  }\n\n  get normalImpulses(): number[] {\n    const contact = this.contact;\n    const normals = this.normals;\n    normals.length = 0;\n    for (let p = 0; p < contact.v_points.length; ++p) {\n      normals.push(contact.v_points[p].normalImpulse);\n    }\n    return normals;\n  }\n\n  get tangentImpulses(): number[] {\n    const contact = this.contact;\n    const tangents = this.tangents;\n    tangents.length = 0;\n    for (let p = 0; p < contact.v_points.length; ++p) {\n      tangents.push(contact.v_points[p].tangentImpulse);\n    }\n    return tangents;\n  }\n}\n\n/**\n * Finds and solves islands. An island is a connected subset of the world.\n */\nexport class Solver {\n  m_world: World;\n  m_stack: Body[];\n  m_bodies: Body[];\n  m_contacts: Contact[];\n  m_joints: Joint[];\n\n  constructor(world: World) {\n    this.m_world = world;\n    this.m_stack = [];\n    this.m_bodies = [];\n    this.m_contacts = [];\n    this.m_joints = [];\n  }\n\n  clear(): void {\n    this.m_stack.length = 0;\n    this.m_bodies.length = 0;\n    this.m_contacts.length = 0;\n    this.m_joints.length = 0;\n  }\n\n  addBody(body: Body): void {\n    _ASSERT && console.assert(body instanceof Body, 'Not a Body!', body);\n    this.m_bodies.push(body);\n    // why?\n    // body.c_position.c.setZero();\n    // body.c_position.a = 0;\n    // body.c_velocity.v.setZero();\n    // body.c_velocity.w = 0;\n  }\n\n  addContact(contact: Contact): void {\n    // _ASSERT && console.assert(contact instanceof Contact, 'Not a Contact!', contact);\n    this.m_contacts.push(contact);\n  }\n\n  addJoint(joint: Joint): void {\n    _ASSERT && console.assert(joint instanceof Joint, 'Not a Joint!', joint);\n    this.m_joints.push(joint);\n  }\n\n  solveWorld(step: TimeStep): void {\n    const world = this.m_world;\n\n    // Clear all the island flags.\n    for (let b = world.m_bodyList; b; b = b.m_next) {\n      b.m_islandFlag = false;\n    }\n    for (let c = world.m_contactList; c; c = c.m_next) {\n      c.m_islandFlag = false;\n    }\n    for (let j = world.m_jointList; j; j = j.m_next) {\n      j.m_islandFlag = false;\n    }\n\n    // Build and simulate all awake islands.\n    const stack = this.m_stack;\n    let loop = -1;\n    for (let seed = world.m_bodyList; seed; seed = seed.m_next) {\n      loop++;\n      if (seed.m_islandFlag) {\n        continue;\n      }\n\n      if (seed.isAwake() == false || seed.isActive() == false) {\n        continue;\n      }\n\n      // The seed can be dynamic or kinematic.\n      if (seed.isStatic()) {\n        continue;\n      }\n\n      // Reset island and stack.\n      this.clear();\n\n      stack.push(seed);\n\n      seed.m_islandFlag = true;\n\n      // Perform a depth first search (DFS) on the constraint graph.\n      while (stack.length > 0) {\n        // Grab the next body off the stack and add it to the island.\n        const b = stack.pop();\n        _ASSERT && console.assert(b.isActive() == true);\n        this.addBody(b);\n\n        // Make sure the body is awake (without resetting sleep timer).\n        b.m_awakeFlag = true;\n\n        // To keep islands as small as possible, we don't\n        // propagate islands across static bodies.\n        if (b.isStatic()) {\n          continue;\n        }\n\n        // Search all contacts connected to this body.\n        for (let ce = b.m_contactList; ce; ce = ce.next) {\n          const contact = ce.contact;\n\n          // Has this contact already been added to an island?\n          if (contact.m_islandFlag) {\n            continue;\n          }\n\n          // Is this contact solid and touching?\n          if (contact.isEnabled() == false || contact.isTouching() == false) {\n            continue;\n          }\n\n          // Skip sensors.\n          const sensorA = contact.m_fixtureA.m_isSensor;\n          const sensorB = contact.m_fixtureB.m_isSensor;\n          if (sensorA || sensorB) {\n            continue;\n          }\n\n          this.addContact(contact);\n          contact.m_islandFlag = true;\n\n          const other = ce.other;\n\n          // Was the other body already added to this island?\n          if (other.m_islandFlag) {\n            continue;\n          }\n\n          // _ASSERT && console.assert(stack.length < world.m_bodyCount);\n          stack.push(other);\n          other.m_islandFlag = true;\n        }\n\n        // Search all joints connect to this body.\n        for (let je = b.m_jointList; je; je = je.next) {\n          if (je.joint.m_islandFlag == true) {\n            continue;\n          }\n\n          const other = je.other;\n\n          // Don't simulate joints connected to inactive bodies.\n          if (other.isActive() == false) {\n            continue;\n          }\n\n          this.addJoint(je.joint);\n          je.joint.m_islandFlag = true;\n\n          if (other.m_islandFlag) {\n            continue;\n          }\n\n          // _ASSERT && console.assert(stack.length < world.m_bodyCount);\n          stack.push(other);\n          other.m_islandFlag = true;\n        }\n      }\n\n      this.solveIsland(step);\n\n      // Post solve cleanup.\n      for (let i = 0; i < this.m_bodies.length; ++i) {\n        // Allow static bodies to participate in other islands.\n        // TODO: are they added at all?\n        const b = this.m_bodies[i];\n        if (b.isStatic()) {\n          b.m_islandFlag = false;\n        }\n      }\n    }\n  }\n\n  solveIsland(step: TimeStep): void {\n    // B2: Island Solve\n    const world = this.m_world;\n    const gravity = world.m_gravity;\n    const allowSleep = world.m_allowSleep;\n\n    const h = step.dt;\n\n    // Integrate velocities and apply damping. Initialize the body state.\n    for (let i = 0; i < this.m_bodies.length; ++i) {\n      const body = this.m_bodies[i];\n\n      matrix.copyVec2(c, body.m_sweep.c);\n      const a = body.m_sweep.a;\n      matrix.copyVec2(v, body.m_linearVelocity);\n      let w = body.m_angularVelocity;\n\n      // Store positions for continuous collision.\n      matrix.copyVec2(body.m_sweep.c0, body.m_sweep.c);\n      body.m_sweep.a0 = body.m_sweep.a;\n\n      if (body.isDynamic()) {\n        // Integrate velocities.\n        matrix.addMulVec2(v, h * body.m_gravityScale, gravity);\n        matrix.addMulVec2(v, h * body.m_invMass, body.m_force);\n        w += h * body.m_invI * body.m_torque;\n        /**\n         * <pre>\n         * Apply damping.\n         * ODE: dv/dt + c * v = 0\n         * Solution: v(t) = v0 * exp(-c * t)\n         * Time step: v(t + dt) = v0 * exp(-c * (t + dt)) = v0 * exp(-c * t) * exp(-c * dt) = v * exp(-c * dt)\n         * v2 = exp(-c * dt) * v1\n         * Pade approximation:\n         * v2 = v1 * 1 / (1 + c * dt)\n         * </pre>\n         */\n        matrix.setMulVec2(v, 1.0 / (1.0 + h * body.m_linearDamping), v)\n        w *= 1.0 / (1.0 + h * body.m_angularDamping);\n      }\n\n      matrix.copyVec2(body.c_position.c, c);\n      body.c_position.a = a;\n      matrix.copyVec2(body.c_velocity.v, v);\n      body.c_velocity.w = w;\n    }\n\n    for (let i = 0; i < this.m_contacts.length; ++i) {\n      const contact = this.m_contacts[i];\n      contact.initConstraint(step);\n    }\n\n    for (let i = 0; i < this.m_contacts.length; ++i) {\n      const contact = this.m_contacts[i];\n      contact.initVelocityConstraint(step);\n    }\n\n    if (step.warmStarting) {\n      // Warm start.\n      for (let i = 0; i < this.m_contacts.length; ++i) {\n        const contact = this.m_contacts[i];\n        contact.warmStartConstraint(step);\n      }\n    }\n\n    for (let i = 0; i < this.m_joints.length; ++i) {\n      const joint = this.m_joints[i];\n      joint.initVelocityConstraints(step);\n    }\n\n    // Solve velocity constraints\n    for (let i = 0; i < step.velocityIterations; ++i) {\n      for (let j = 0; j < this.m_joints.length; ++j) {\n        const joint = this.m_joints[j];\n        joint.solveVelocityConstraints(step);\n      }\n\n      for (let j = 0; j < this.m_contacts.length; ++j) {\n        const contact = this.m_contacts[j];\n        contact.solveVelocityConstraint(step);\n      }\n    }\n\n    // Store impulses for warm starting\n    for (let i = 0; i < this.m_contacts.length; ++i) {\n      const contact = this.m_contacts[i];\n      contact.storeConstraintImpulses(step);\n    }\n\n    // Integrate positions\n    for (let i = 0; i < this.m_bodies.length; ++i) {\n      const body = this.m_bodies[i];\n\n      matrix.copyVec2(c, body.c_position.c);\n      let a = body.c_position.a;\n      matrix.copyVec2(v, body.c_velocity.v);\n      let w = body.c_velocity.w;\n\n      // Check for large velocities\n      matrix.setMulVec2(translation, h, v);\n      const translationLengthSqr = matrix.lengthSqrVec2(translation);\n      if (translationLengthSqr > Settings.maxTranslationSquared) {\n        const ratio = Settings.maxTranslation / Math.sqrt(translationLengthSqr);\n        matrix.scaleVec2(v, ratio);\n      }\n\n      const rotation = h * w;\n      if (rotation * rotation > Settings.maxRotationSquared) {\n        const ratio = Settings.maxRotation / Math.abs(rotation);\n        w *= ratio;\n      }\n\n      // Integrate\n      matrix.addMulVec2(c, h, v);\n      a += h * w;\n\n      matrix.copyVec2(body.c_position.c, c);\n      body.c_position.a = a;\n      matrix.copyVec2(body.c_velocity.v, v);\n      body.c_velocity.w = w;\n    }\n\n    // Solve position constraints\n    let positionSolved = false;\n    for (let i = 0; i < step.positionIterations; ++i) {\n      let minSeparation = 0.0;\n      for (let j = 0; j < this.m_contacts.length; ++j) {\n        const contact = this.m_contacts[j];\n        const separation = contact.solvePositionConstraint(step);\n        minSeparation = Math.min(minSeparation, separation);\n      }\n      // We can't expect minSpeparation >= -Settings.linearSlop because we don't\n      // push the separation above -Settings.linearSlop.\n      const contactsOkay = minSeparation >= -3.0 * Settings.linearSlop;\n\n      let jointsOkay = true;\n      for (let j = 0; j < this.m_joints.length; ++j) {\n        const joint = this.m_joints[j];\n        const jointOkay = joint.solvePositionConstraints(step);\n        jointsOkay = jointsOkay && jointOkay;\n      }\n\n      if (contactsOkay && jointsOkay) {\n        // Exit early if the position errors are small.\n        positionSolved = true;\n        break;\n      }\n    }\n\n    // Copy state buffers back to the bodies\n    for (let i = 0; i < this.m_bodies.length; ++i) {\n      const body = this.m_bodies[i];\n\n      matrix.copyVec2(body.m_sweep.c, body.c_position.c);\n      body.m_sweep.a = body.c_position.a;\n      matrix.copyVec2(body.m_linearVelocity, body.c_velocity.v);\n      body.m_angularVelocity = body.c_velocity.w;\n      body.synchronizeTransform();\n    }\n\n    this.postSolveIsland();\n\n    if (allowSleep) {\n      let minSleepTime = Infinity;\n\n      const linTolSqr = Settings.linearSleepToleranceSqr;\n      const angTolSqr = Settings.angularSleepToleranceSqr;\n\n      for (let i = 0; i < this.m_bodies.length; ++i) {\n        const body = this.m_bodies[i];\n        if (body.isStatic()) {\n          continue;\n        }\n\n        if ((body.m_autoSleepFlag == false)\n          || (body.m_angularVelocity * body.m_angularVelocity > angTolSqr)\n          || (matrix.lengthSqrVec2(body.m_linearVelocity) > linTolSqr)) {\n          body.m_sleepTime = 0.0;\n          minSleepTime = 0.0;\n        } else {\n          body.m_sleepTime += h;\n          minSleepTime = Math.min(minSleepTime, body.m_sleepTime);\n        }\n      }\n\n      if (minSleepTime >= Settings.timeToSleep && positionSolved) {\n        for (let i = 0; i < this.m_bodies.length; ++i) {\n          const body = this.m_bodies[i];\n          body.setAwake(false);\n        }\n      }\n    }\n  }\n\n  /**\n   * Find TOI contacts and solve them.\n   */\n  solveWorldTOI(step: TimeStep): void {\n    const world = this.m_world;\n\n    if (world.m_stepComplete) {\n      for (let b = world.m_bodyList; b; b = b.m_next) {\n        b.m_islandFlag = false;\n        b.m_sweep.alpha0 = 0.0;\n      }\n\n      for (let c = world.m_contactList; c; c = c.m_next) {\n        // Invalidate TOI\n        c.m_toiFlag = false;\n        c.m_islandFlag = false;\n        c.m_toiCount = 0;\n        c.m_toi = 1.0;\n      }\n    }\n\n    // Find TOI events and solve them.\n    while (true) {\n      // Find the first TOI.\n      let minContact: Contact | null = null;\n      let minAlpha = 1.0;\n\n      for (let c = world.m_contactList; c; c = c.m_next) {\n        // Is this contact disabled?\n        if (c.isEnabled() == false) {\n          continue;\n        }\n\n        // Prevent excessive sub-stepping.\n        if (c.m_toiCount > Settings.maxSubSteps) {\n          continue;\n        }\n\n        let alpha = 1.0;\n        if (c.m_toiFlag) {\n          // This contact has a valid cached TOI.\n          alpha = c.m_toi;\n        } else {\n          const fA = c.getFixtureA();\n          const fB = c.getFixtureB();\n\n          // Is there a sensor?\n          if (fA.isSensor() || fB.isSensor()) {\n            continue;\n          }\n\n          const bA = fA.getBody();\n          const bB = fB.getBody();\n\n          _ASSERT && console.assert(bA.isDynamic() || bB.isDynamic());\n\n          const activeA = bA.isAwake() && !bA.isStatic();\n          const activeB = bB.isAwake() && !bB.isStatic();\n\n          // Is at least one body active (awake and dynamic or kinematic)?\n          if (activeA == false && activeB == false) {\n            continue;\n          }\n\n          const collideA = bA.isBullet() || !bA.isDynamic();\n          const collideB = bB.isBullet() || !bB.isDynamic();\n\n          // Are these two non-bullet dynamic bodies?\n          if (collideA == false && collideB == false) {\n            continue;\n          }\n\n          // Compute the TOI for this contact.\n          // Put the sweeps onto the same time interval.\n          let alpha0 = bA.m_sweep.alpha0;\n\n          if (bA.m_sweep.alpha0 < bB.m_sweep.alpha0) {\n            alpha0 = bB.m_sweep.alpha0;\n            bA.m_sweep.advance(alpha0);\n          } else if (bB.m_sweep.alpha0 < bA.m_sweep.alpha0) {\n            alpha0 = bA.m_sweep.alpha0;\n            bB.m_sweep.advance(alpha0);\n          }\n\n          _ASSERT && console.assert(alpha0 < 1.0);\n\n          const indexA = c.getChildIndexA();\n          const indexB = c.getChildIndexB();\n\n          const sweepA = bA.m_sweep;\n          const sweepB = bB.m_sweep;\n\n          // Compute the time of impact in interval [0, minTOI]\n          input.proxyA.set(fA.getShape(), indexA);\n          input.proxyB.set(fB.getShape(), indexB);\n          input.sweepA.set(bA.m_sweep);\n          input.sweepB.set(bB.m_sweep);\n          input.tMax = 1.0;\n\n          TimeOfImpact(output, input);\n\n          // Beta is the fraction of the remaining portion of the [time?].\n          const beta = output.t;\n          if (output.state == TOIOutputState.e_touching) {\n            alpha = Math.min(alpha0 + (1.0 - alpha0) * beta, 1.0);\n          } else {\n            alpha = 1.0;\n          }\n\n          c.m_toi = alpha;\n          c.m_toiFlag = true;\n        }\n\n        if (alpha < minAlpha) {\n          // This is the minimum TOI found so far.\n          minContact = c;\n          minAlpha = alpha;\n        }\n      }\n\n      if (minContact == null || 1.0 - 10.0 * Math.EPSILON < minAlpha) {\n        // No more TOI events. Done!\n        world.m_stepComplete = true;\n        break;\n      }\n\n      // Advance the bodies to the TOI.\n      const fA = minContact.getFixtureA();\n      const fB = minContact.getFixtureB();\n      const bA = fA.getBody();\n      const bB = fB.getBody();\n\n      backup1.set(bA.m_sweep);\n      backup2.set(bB.m_sweep);\n\n      bA.advance(minAlpha);\n      bB.advance(minAlpha);\n\n      // The TOI contact likely has some new contact points.\n      minContact.update(world);\n      minContact.m_toiFlag = false;\n      ++minContact.m_toiCount;\n\n      // Is the contact solid?\n      if (minContact.isEnabled() == false || minContact.isTouching() == false) {\n        // Restore the sweeps.\n        minContact.setEnabled(false);\n        bA.m_sweep.set(backup1);\n        bB.m_sweep.set(backup2);\n        bA.synchronizeTransform();\n        bB.synchronizeTransform();\n        continue;\n      }\n\n      bA.setAwake(true);\n      bB.setAwake(true);\n\n      // Build the island\n      this.clear();\n      this.addBody(bA);\n      this.addBody(bB);\n      this.addContact(minContact);\n\n      bA.m_islandFlag = true;\n      bB.m_islandFlag = true;\n      minContact.m_islandFlag = true;\n\n      // Get contacts on bodyA and bodyB.\n      const bodies = [ bA, bB ];\n      for (let i = 0; i < bodies.length; ++i) {\n        const body = bodies[i];\n        if (body.isDynamic()) {\n          for (let ce = body.m_contactList; ce; ce = ce.next) {\n            // if (this.m_bodyCount == this.m_bodyCapacity) { break; }\n            // if (this.m_contactCount == this.m_contactCapacity) { break; }\n\n            const contact = ce.contact;\n\n            // Has this contact already been added to the island?\n            if (contact.m_islandFlag) {\n              continue;\n            }\n\n            // Only add if either is static, kinematic or bullet.\n            const other = ce.other;\n            if (other.isDynamic() && !body.isBullet() && !other.isBullet()) {\n              continue;\n            }\n\n            // Skip sensors.\n            const sensorA = contact.m_fixtureA.m_isSensor;\n            const sensorB = contact.m_fixtureB.m_isSensor;\n            if (sensorA || sensorB) {\n              continue;\n            }\n\n            // Tentatively advance the body to the TOI.\n            backup.set(other.m_sweep);\n            if (other.m_islandFlag == false) {\n              other.advance(minAlpha);\n            }\n\n            // Update the contact points\n            contact.update(world);\n\n            // Was the contact disabled by the user?\n            // Are there contact points?\n            if (contact.isEnabled() == false || contact.isTouching() == false) {\n              other.m_sweep.set(backup);\n              other.synchronizeTransform();\n              continue;\n            }\n\n            // Add the contact to the island\n            contact.m_islandFlag = true;\n            this.addContact(contact);\n\n            // Has the other body already been added to the island?\n            if (other.m_islandFlag) {\n              continue;\n            }\n\n            // Add the other body to the island.\n            other.m_islandFlag = true;\n\n            if (!other.isStatic()) {\n              other.setAwake(true);\n            }\n\n            this.addBody(other);\n          }\n        }\n      }\n\n      s_subStep.reset((1.0 - minAlpha) * step.dt);\n      s_subStep.dtRatio = 1.0;\n      s_subStep.positionIterations = 20;\n      s_subStep.velocityIterations = step.velocityIterations;\n      s_subStep.warmStarting = false;\n\n      this.solveIslandTOI(s_subStep, bA, bB);\n\n      // Reset island flags and synchronize broad-phase proxies.\n      for (let i = 0; i < this.m_bodies.length; ++i) {\n        const body = this.m_bodies[i];\n        body.m_islandFlag = false;\n\n        if (!body.isDynamic()) {\n          continue;\n        }\n\n        body.synchronizeFixtures();\n\n        // Invalidate all contact TOIs on this displaced body.\n        for (let ce = body.m_contactList; ce; ce = ce.next) {\n          ce.contact.m_toiFlag = false;\n          ce.contact.m_islandFlag = false;\n        }\n      }\n\n      // Commit fixture proxy movements to the broad-phase so that new contacts\n      // are created.\n      // Also, some contacts can be destroyed.\n      world.findNewContacts();\n\n      if (world.m_subStepping) {\n        world.m_stepComplete = false;\n        break;\n      }\n    }\n  }\n\n  solveIslandTOI(subStep: TimeStep, toiA: Body, toiB: Body): void {\n\n    // Initialize the body state.\n    for (let i = 0; i < this.m_bodies.length; ++i) {\n      const body = this.m_bodies[i];\n      matrix.copyVec2(body.c_position.c, body.m_sweep.c);\n      body.c_position.a = body.m_sweep.a;\n      matrix.copyVec2(body.c_velocity.v, body.m_linearVelocity);\n      body.c_velocity.w = body.m_angularVelocity;\n    }\n\n    for (let i = 0; i < this.m_contacts.length; ++i) {\n      const contact = this.m_contacts[i];\n      contact.initConstraint(subStep);\n    }\n\n    // Solve position constraints.\n    for (let i = 0; i < subStep.positionIterations; ++i) {\n      let minSeparation = 0.0;\n      for (let j = 0; j < this.m_contacts.length; ++j) {\n        const contact = this.m_contacts[j];\n        const separation = contact.solvePositionConstraintTOI(subStep, toiA, toiB);\n        minSeparation = Math.min(minSeparation, separation);\n      }\n      // We can't expect minSpeparation >= -Settings.linearSlop because we don't\n      // push the separation above -Settings.linearSlop.\n      const contactsOkay = minSeparation >= -1.5 * Settings.linearSlop;\n      if (contactsOkay) {\n        break;\n      }\n    }\n\n    if (false) {\n      // Is the new position really safe?\n      for (let i = 0; i < this.m_contacts.length; ++i) {\n        const c = this.m_contacts[i];\n        const fA = c.getFixtureA();\n        const fB = c.getFixtureB();\n\n        const bA = fA.getBody();\n        const bB = fB.getBody();\n\n        const indexA = c.getChildIndexA();\n        const indexB = c.getChildIndexB();\n\n        const input = new DistanceInput();\n        input.proxyA.set(fA.getShape(), indexA);\n        input.proxyB.set(fB.getShape(), indexB);\n        input.transformA.set(bA.getTransform());\n        input.transformB.set(bB.getTransform());\n        input.useRadii = false;\n\n        const output = new DistanceOutput();\n        const cache = new SimplexCache();\n        Distance(output, cache, input);\n\n        if (output.distance == 0 || cache.count == 3) {\n          cache.count += 0;\n        }\n      }\n    }\n\n    // Leap of faith to new safe state.\n    matrix.copyVec2(toiA.m_sweep.c0, toiA.c_position.c);\n    toiA.m_sweep.a0 = toiA.c_position.a;\n    matrix.copyVec2(toiB.m_sweep.c0, toiB.c_position.c);\n    toiB.m_sweep.a0 = toiB.c_position.a;\n\n    // No warm starting is needed for TOI events because warm\n    // starting impulses were applied in the discrete solver.\n    for (let i = 0; i < this.m_contacts.length; ++i) {\n      const contact = this.m_contacts[i];\n      contact.initVelocityConstraint(subStep);\n    }\n\n    // Solve velocity constraints.\n    for (let i = 0; i < subStep.velocityIterations; ++i) {\n      for (let j = 0; j < this.m_contacts.length; ++j) {\n        const contact = this.m_contacts[j];\n        contact.solveVelocityConstraint(subStep);\n      }\n    }\n\n    // Don't store the TOI contact forces for warm starting\n    // because they can be quite large.\n\n    const h = subStep.dt;\n\n    // Integrate positions\n    for (let i = 0; i < this.m_bodies.length; ++i) {\n      const body = this.m_bodies[i];\n\n      matrix.copyVec2(c, body.c_position.c);\n      let a = body.c_position.a;\n      matrix.copyVec2(v, body.c_velocity.v);\n      let w = body.c_velocity.w;\n\n      // Check for large velocities\n      matrix.setMulVec2(translation, h, v);\n      const translationLengthSqr = matrix.lengthSqrVec2(translation);\n      if (translationLengthSqr > Settings.maxTranslationSquared) {\n        const ratio = Settings.maxTranslation / Math.sqrt(translationLengthSqr);\n        matrix.scaleVec2(v, ratio);\n      }\n\n      const rotation = h * w;\n      if (rotation * rotation > Settings.maxRotationSquared) {\n        const ratio = Settings.maxRotation / Math.abs(rotation);\n        w *= ratio;\n      }\n\n      // Integrate\n      matrix.addMulVec2(c, h, v);\n      a += h * w;\n\n      matrix.copyVec2(body.c_position.c, c);\n      body.c_position.a = a;\n      matrix.copyVec2(body.c_velocity.v, v);\n      body.c_velocity.w = w;\n\n      // Sync bodies\n      matrix.copyVec2(body.m_sweep.c, c);\n      body.m_sweep.a = a;\n      matrix.copyVec2(body.m_linearVelocity, v);\n      body.m_angularVelocity = w;\n      body.synchronizeTransform();\n    }\n\n    this.postSolveIsland();\n  }\n\n  /** @internal */\n  postSolveIsland(): void {\n    for (let c = 0; c < this.m_contacts.length; ++c) {\n      const contact = this.m_contacts[c];\n      this.m_world.postSolve(contact, contact.m_impulse);\n    }\n  }\n}\n\n// @ts-ignore\nSolver.TimeStep = TimeStep;\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { Vec2 } from './Vec2';\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\n/**\n * A 2-by-2 matrix. Stored in column-major order.\n */\nexport class Mat22 {\n  ex: Vec2;\n  ey: Vec2;\n\n  constructor(a: number, b: number, c: number, d: number);\n  constructor(a: { x: number; y: number }, b: { x: number; y: number });\n  constructor();\n  // tslint:disable-next-line:typedef\n  constructor(a?, b?, c?, d?) {\n    if (typeof a === 'object' && a !== null) {\n      this.ex = Vec2.clone(a);\n      this.ey = Vec2.clone(b);\n    } else if (typeof a === 'number') {\n      this.ex = Vec2.neo(a, c);\n      this.ey = Vec2.neo(b, d);\n    } else {\n      this.ex = Vec2.zero();\n      this.ey = Vec2.zero();\n    }\n  }\n\n  /** @internal */\n  toString(): string {\n    return JSON.stringify(this);\n  }\n\n  static isValid(obj: any): boolean {\n    if (obj === null || typeof obj === 'undefined') {\n      return false;\n    }\n    return Vec2.isValid(obj.ex) && Vec2.isValid(obj.ey);\n  }\n\n  static assert(o: any): void {\n    _ASSERT && console.assert(!Mat22.isValid(o), 'Invalid Mat22!', o);\n  }\n\n  set(a: Mat22): void;\n  set(a: Vec2, b: Vec2): void;\n  set(a: number, b: number, c: number, d: number): void;\n  // tslint:disable-next-line:typedef\n  set(a, b?, c?, d?): void {\n    if (typeof a === 'number' && typeof b === 'number' && typeof c === 'number'\n      && typeof d === 'number') {\n      this.ex.setNum(a, c);\n      this.ey.setNum(b, d);\n\n    } else if (typeof a === 'object' && typeof b === 'object') {\n      this.ex.setVec2(a);\n      this.ey.setVec2(b);\n\n    } else if (typeof a === 'object') {\n      _ASSERT && Mat22.assert(a);\n      this.ex.setVec2(a.ex);\n      this.ey.setVec2(a.ey);\n\n    } else {\n      _ASSERT && console.assert(false);\n    }\n  }\n\n  setIdentity(): void {\n    this.ex.x = 1.0;\n    this.ey.x = 0.0;\n    this.ex.y = 0.0;\n    this.ey.y = 1.0;\n  }\n\n  setZero(): void {\n    this.ex.x = 0.0;\n    this.ey.x = 0.0;\n    this.ex.y = 0.0;\n    this.ey.y = 0.0;\n  }\n\n  getInverse(): Mat22 {\n    const a = this.ex.x;\n    const b = this.ey.x;\n    const c = this.ex.y;\n    const d = this.ey.y;\n    let det = a * d - b * c;\n    if (det !== 0.0) {\n      det = 1.0 / det;\n    }\n    const imx = new Mat22();\n    imx.ex.x = det * d;\n    imx.ey.x = -det * b;\n    imx.ex.y = -det * c;\n    imx.ey.y = det * a;\n    return imx;\n  }\n\n  /**\n   * Solve A * x = b, where b is a column vector. This is more efficient than\n   * computing the inverse in one-shot cases.\n   */\n  solve(v: Vec2): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    const a = this.ex.x;\n    const b = this.ey.x;\n    const c = this.ex.y;\n    const d = this.ey.y;\n    let det = a * d - b * c;\n    if (det !== 0.0) {\n      det = 1.0 / det;\n    }\n    const w = Vec2.zero();\n    w.x = det * (d * v.x - b * v.y);\n    w.y = det * (a * v.y - c * v.x);\n    return w;\n  }\n\n  /**\n   * Multiply a matrix times a vector. If a rotation matrix is provided, then this\n   * transforms the vector from one frame to another.\n   */\n  static mul(mx: Mat22, my: Mat22): Mat22;\n  static mul(mx: Mat22, v: Vec2): Vec2;\n  // tslint:disable-next-line:typedef\n  static mul(mx, v) {\n    if (v && 'x' in v && 'y' in v) {\n      _ASSERT && Vec2.assert(v);\n      const x = mx.ex.x * v.x + mx.ey.x * v.y;\n      const y = mx.ex.y * v.x + mx.ey.y * v.y;\n      return Vec2.neo(x, y);\n\n    } else if (v && 'ex' in v && 'ey' in v) { // Mat22\n      _ASSERT && Mat22.assert(v);\n      // return new Mat22(Vec2.mul(mx, v.ex), Vec2.mul(mx, v.ey));\n      const a = mx.ex.x * v.ex.x + mx.ey.x * v.ex.y;\n      const b = mx.ex.x * v.ey.x + mx.ey.x * v.ey.y;\n      const c = mx.ex.y * v.ex.x + mx.ey.y * v.ex.y;\n      const d = mx.ex.y * v.ey.x + mx.ey.y * v.ey.y;\n      return new Mat22(a, b, c, d);\n    }\n\n    _ASSERT && console.assert(false);\n  }\n\n  static mulVec2(mx: Mat22, v: Vec2): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    const x = mx.ex.x * v.x + mx.ey.x * v.y;\n    const y = mx.ex.y * v.x + mx.ey.y * v.y;\n    return Vec2.neo(x, y);\n  }\n\n  static mulMat22(mx: Mat22, v: Mat22): Mat22 {\n    _ASSERT && Mat22.assert(v);\n    // return new Mat22(Vec2.mul(mx, v.ex), Vec2.mul(mx, v.ey));\n    const a = mx.ex.x * v.ex.x + mx.ey.x * v.ex.y;\n    const b = mx.ex.x * v.ey.x + mx.ey.x * v.ey.y;\n    const c = mx.ex.y * v.ex.x + mx.ey.y * v.ex.y;\n    const d = mx.ex.y * v.ey.x + mx.ey.y * v.ey.y;\n    return new Mat22(a, b, c, d);\n  }\n\n  /**\n   * Multiply a matrix transpose times a vector. If a rotation matrix is provided,\n   * then this transforms the vector from one frame to another (inverse\n   * transform).\n   */\n  static mulT(mx: Mat22, my: Mat22): Mat22;\n  static mulT(mx: Mat22, v: Vec2): Vec2;\n  // tslint:disable-next-line:typedef\n  static mulT(mx, v) {\n    if (v && 'x' in v && 'y' in v) { // Vec2\n      _ASSERT && Vec2.assert(v);\n      return Vec2.neo(Vec2.dot(v, mx.ex), Vec2.dot(v, mx.ey));\n\n    } else if (v && 'ex' in v && 'ey' in v) { // Mat22\n      _ASSERT && Mat22.assert(v);\n      const c1 = Vec2.neo(Vec2.dot(mx.ex, v.ex), Vec2.dot(mx.ey, v.ex));\n      const c2 = Vec2.neo(Vec2.dot(mx.ex, v.ey), Vec2.dot(mx.ey, v.ey));\n      return new Mat22(c1, c2);\n    }\n\n    _ASSERT && console.assert(false);\n  }\n\n  static mulTVec2(mx: Mat22, v: Vec2): Vec2 {\n    _ASSERT && Mat22.assert(mx);\n    _ASSERT && Vec2.assert(v);\n    return Vec2.neo(Vec2.dot(v, mx.ex), Vec2.dot(v, mx.ey));\n  }\n\n  static mulTMat22(mx: Mat22, v: Mat22): Mat22 {\n    _ASSERT && Mat22.assert(mx);\n    _ASSERT && Mat22.assert(v);\n    const c1 = Vec2.neo(Vec2.dot(mx.ex, v.ex), Vec2.dot(mx.ey, v.ex));\n    const c2 = Vec2.neo(Vec2.dot(mx.ex, v.ey), Vec2.dot(mx.ey, v.ey));\n    return new Mat22(c1, c2);\n  }\n\n  static abs(mx: Mat22): Mat22 {\n    _ASSERT && Mat22.assert(mx);\n    return new Mat22(Vec2.abs(mx.ex), Vec2.abs(mx.ey));\n  }\n\n  static add(mx1: Mat22, mx2: Mat22): Mat22 {\n    _ASSERT && Mat22.assert(mx1);\n    _ASSERT && Mat22.assert(mx2);\n    return new Mat22(Vec2.add(mx1.ex, mx2.ex), Vec2.add(mx1.ey, mx2.ey));\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport * as matrix from '../common/Matrix';\nimport { Vec2Value } from '../common/Vec2';\nimport { TransformValue } from '../common/Transform';\nimport { math as Math } from '../common/Math';\n\nconst pointA = matrix.vec2(0, 0);\nconst pointB = matrix.vec2(0, 0);\nconst temp = matrix.vec2(0, 0);\nconst cA = matrix.vec2(0, 0);\nconst cB = matrix.vec2(0, 0);\nconst dist = matrix.vec2(0, 0);\nconst planePoint = matrix.vec2(0, 0);\nconst clipPoint = matrix.vec2(0, 0);\n\nexport enum ManifoldType {\n  e_unset = -1,\n  e_circles = 0,\n  e_faceA = 1,\n  e_faceB = 2\n}\n\nexport enum ContactFeatureType {\n  e_unset = -1,\n  e_vertex = 0,\n  e_face = 1\n}\n\n/**\n * This is used for determining the state of contact points.\n */\n export enum PointState {\n  /** Point does not exist */\n  nullState = 0,\n  /** Point was added in the update */\n  addState = 1,\n  /** Point persisted across the update */\n  persistState = 2,\n  /** Point was removed in the update */\n  removeState = 3\n}\n\n/**\n * Used for computing contact manifolds.\n */\n export class ClipVertex {\n  v = matrix.vec2(0, 0);\n  id: ContactID = new ContactID();\n\n  set(o: ClipVertex): void {\n    matrix.copyVec2(this.v, o.v);\n    this.id.set(o.id);\n  }\n  recycle() {\n    matrix.zeroVec2(this.v)\n    this.id.recycle();\n  }\n}\n\n/**\n * A manifold for two touching convex shapes. Manifolds are created in `evaluate`\n * method of Contact subclasses.\n *\n * Supported manifold types are e_faceA or e_faceB for clip point versus plane\n * with radius and e_circles point versus point with radius.\n *\n * We store contacts in this way so that position correction can account for\n * movement, which is critical for continuous physics. All contact scenarios\n * must be expressed in one of these types. This structure is stored across time\n * steps, so we keep it small.\n */\nexport class Manifold {\n  type: ManifoldType;\n\n  /**\n   * Usage depends on manifold type:\n   * - circles: not used\n   * - faceA: the normal on polygonA\n   * - faceB: the normal on polygonB\n   */\n  localNormal = matrix.vec2(0, 0);\n\n  /**\n   * Usage depends on manifold type:\n   * - circles: the local center of circleA\n   * - faceA: the center of faceA\n   * - faceB: the center of faceB\n   */\n  localPoint = matrix.vec2(0, 0);\n\n  /** The points of contact */\n  points: ManifoldPoint[] = [ new ManifoldPoint(), new ManifoldPoint() ];\n\n  /** The number of manifold points */\n  pointCount: number = 0;\n\n  set(that: Manifold): void {\n    this.type = that.type;\n    matrix.copyVec2(this.localNormal, that.localNormal);\n    matrix.copyVec2(this.localPoint, that.localPoint);\n    this.pointCount = that.pointCount;\n    this.points[0].set(that.points[0]);\n    this.points[1].set(that.points[1]);\n  }\n\n  recycle(): void {\n    this.type = ManifoldType.e_unset;\n    matrix.zeroVec2(this.localNormal)\n    matrix.zeroVec2(this.localPoint)\n    this.pointCount = 0;\n    this.points[0].recycle();\n    this.points[1].recycle();\n  }\n\n  /**\n   * Evaluate the manifold with supplied transforms. This assumes modest motion\n   * from the original state. This does not change the point count, impulses, etc.\n   * The radii must come from the shapes that generated the manifold.\n   */\n  getWorldManifold(wm: WorldManifold | null, xfA: TransformValue, radiusA: number, xfB: TransformValue, radiusB: number): WorldManifold {\n    if (this.pointCount == 0) {\n      return wm;\n    }\n\n    wm = wm || new WorldManifold();\n\n    wm.pointCount = this.pointCount;\n\n    const normal = wm.normal;\n    const points = wm.points;\n    const separations = wm.separations;\n\n    switch (this.type) {\n      case ManifoldType.e_circles: {\n        matrix.setVec2(normal, 1.0, 0.0);\n        const manifoldPoint = this.points[0];\n        matrix.transformVec2(pointA, xfA, this.localPoint);\n        matrix.transformVec2(pointB, xfB, manifoldPoint.localPoint);\n        matrix.diffVec2(dist, pointB, pointA);\n        const lengthSqr = matrix.lengthSqrVec2(dist);\n          if (lengthSqr > Math.EPSILON * Math.EPSILON) {\n          const length = Math.sqrt(lengthSqr);\n          matrix.setMulVec2(normal, 1 / length, dist);\n        }\n        matrix.combineVec2(cA, 1, pointA, radiusA, normal);\n        matrix.combineVec2(cB, 1, pointB, -radiusB, normal);\n        matrix.combineVec2(points[0], 0.5, cA, 0.5, cB);\n        separations[0] = matrix.dotVec2(matrix.diffVec2(temp, cB, cA), normal);\n        break;\n      }\n\n      case ManifoldType.e_faceA: {\n        matrix.rotVec2(normal, xfA.q, this.localNormal);\n        matrix.transformVec2(planePoint, xfA, this.localPoint);\n\n        for (let i = 0; i < this.pointCount; ++i) {\n          const manifoldPoint = this.points[i];\n          matrix.transformVec2(clipPoint, xfB, manifoldPoint.localPoint);\n          matrix.combineVec2(cA, 1, clipPoint, radiusA - matrix.dotVec2(matrix.diffVec2(temp, clipPoint, planePoint), normal), normal);\n          matrix.combineVec2(cB, 1, clipPoint, -radiusB, normal);\n          matrix.combineVec2(points[i], 0.5, cA, 0.5, cB);\n          separations[i] = matrix.dotVec2(matrix.diffVec2(temp, cB, cA), normal);\n        }\n        break;\n      }\n\n      case ManifoldType.e_faceB: {\n        matrix.rotVec2(normal, xfB.q, this.localNormal);\n        matrix.transformVec2(planePoint, xfB, this.localPoint);\n\n        for (let i = 0; i < this.pointCount; ++i) {\n          const manifoldPoint = this.points[i];\n          matrix.transformVec2(clipPoint, xfA, manifoldPoint.localPoint);\n          matrix.combineVec2(cB, 1, clipPoint, radiusB - matrix.dotVec2(matrix.diffVec2(temp, clipPoint, planePoint), normal), normal);\n          matrix.combineVec2(cA, 1, clipPoint, -radiusA, normal);\n          matrix.combineVec2(points[i], 0.5, cA, 0.5, cB);\n          separations[i] = matrix.dotVec2(matrix.diffVec2(temp, cA, cB), normal);\n        }\n        // Ensure normal points from A to B.\n        matrix.negVec2(normal);\n        break;\n      }\n    }\n\n    return wm;\n  }\n\n  static clipSegmentToLine = clipSegmentToLine;\n  static ClipVertex = ClipVertex;\n  static getPointStates = getPointStates;\n  static PointState = PointState;\n}\n\n/**\n * A manifold point is a contact point belonging to a contact manifold. It holds\n * details related to the geometry and dynamics of the contact points.\n *\n * This structure is stored across time steps, so we keep it small.\n *\n * Note: impulses are used for internal caching and may not provide reliable\n * contact forces, especially for high speed collisions.\n */\nexport class ManifoldPoint {\n  /**\n   * Usage depends on manifold type:\n   * - circles: the local center of circleB\n   * - faceA: the local center of circleB or the clip point of polygonB\n   * - faceB: the clip point of polygonA\n   */\n  localPoint = matrix.vec2(0, 0);\n  /**\n   * The non-penetration impulse\n   */\n  normalImpulse = 0;\n  /**\n   * The friction impulse\n   */\n  tangentImpulse = 0;\n  /**\n   * Uniquely identifies a contact point between two shapes to facilitate warm starting\n   */\n  readonly id = new ContactID();\n\n  set(that: ManifoldPoint): void {\n    matrix.copyVec2(this.localPoint, that.localPoint);\n    this.normalImpulse = that.normalImpulse;\n    this.tangentImpulse = that.tangentImpulse;\n    this.id.set(that.id);\n  }\n\n  recycle(): void {\n    matrix.zeroVec2(this.localPoint)\n    this.normalImpulse = 0;\n    this.tangentImpulse = 0;\n    this.id.recycle();\n  }\n}\n\n/**\n * Contact ids to facilitate warm starting.\n * \n * ContactFeature: The features that intersect to form the contact point.\n */\nexport class ContactID {\n\n  /**\n   * Used to quickly compare contact ids.\n   */\n  key = -1;\n\n  /** ContactFeature index on shapeA */\n  indexA = -1;\n\n  /** ContactFeature index on shapeB */\n  indexB = -1;\n\n  /** ContactFeature type on shapeA */\n  typeA = ContactFeatureType.e_unset;\n\n  /** ContactFeature type on shapeB */\n  typeB = ContactFeatureType.e_unset;\n\n  setFeatures(indexA: number, typeA: ContactFeatureType, indexB: number, typeB: ContactFeatureType): void {\n    this.indexA = indexA;\n    this.indexB = indexB;\n    this.typeA = typeA;\n    this.typeB = typeB;\n    this.key = this.indexA + this.indexB * 4 + this.typeA * 16 + this.typeB * 64\n  }\n\n  set(that: ContactID): void {\n    this.indexA = that.indexA;\n    this.indexB = that.indexB;\n    this.typeA = that.typeA;\n    this.typeB = that.typeB;\n    this.key = this.indexA + this.indexB * 4 + this.typeA * 16 + this.typeB * 64\n  }\n\n  swapFeatures(): void {\n    const indexA = this.indexA;\n    const indexB = this.indexB;\n    const typeA = this.typeA;\n    const typeB = this.typeB;\n    this.indexA = indexB;\n    this.indexB = indexA;\n    this.typeA = typeB;\n    this.typeB = typeA;\n    this.key = this.indexA + this.indexB * 4 + this.typeA * 16 + this.typeB * 64\n  }\n\n  recycle(): void {\n    this.indexA = 0;\n    this.indexB = 0;\n    this.typeA = ContactFeatureType.e_unset;\n    this.typeB = ContactFeatureType.e_unset;\n    this.key = -1;\n  }\n}\n\n/**\n * This is used to compute the current state of a contact manifold.\n */\nexport class WorldManifold {\n  /** World vector pointing from A to B */\n  normal = matrix.vec2(0, 0);\n\n  /** World contact point (point of intersection) */\n  points = [matrix.vec2(0, 0), matrix.vec2(0, 0)]; // [maxManifoldPoints]\n\n  /** A negative value indicates overlap, in meters */\n  separations = [0, 0]; // [maxManifoldPoints]\n\n  /** The number of manifold points */\n  pointCount = 0;\n\n  recycle() {\n    matrix.zeroVec2(this.normal)\n    matrix.zeroVec2(this.points[0]);\n    matrix.zeroVec2(this.points[1]);\n    this.separations[0] = 0;\n    this.separations[1] = 0;\n    this.pointCount = 0;\n  }\n}\n\n/**\n * Compute the point states given two manifolds. The states pertain to the\n * transition from manifold1 to manifold2. So state1 is either persist or remove\n * while state2 is either add or persist.\n */\nexport function getPointStates(\n  state1: PointState[],\n  state2: PointState[],\n  manifold1: Manifold,\n  manifold2: Manifold\n): void {\n  // state1, state2: PointState[Settings.maxManifoldPoints]\n\n  // for (var i = 0; i < Settings.maxManifoldPoints; ++i) {\n  // state1[i] = PointState.nullState;\n  // state2[i] = PointState.nullState;\n  // }\n\n  // Detect persists and removes.\n  for (let i = 0; i < manifold1.pointCount; ++i) {\n    const id = manifold1.points[i].id;\n\n    state1[i] = PointState.removeState;\n\n    for (let j = 0; j < manifold2.pointCount; ++j) {\n      if (manifold2.points[j].id.key === id.key) {\n        state1[i] = PointState.persistState;\n        break;\n      }\n    }\n  }\n\n  // Detect persists and adds.\n  for (let i = 0; i < manifold2.pointCount; ++i) {\n    const id = manifold2.points[i].id;\n\n    state2[i] = PointState.addState;\n\n    for (let j = 0; j < manifold1.pointCount; ++j) {\n      if (manifold1.points[j].id.key === id.key) {\n        state2[i] = PointState.persistState;\n        break;\n      }\n    }\n  }\n}\n\n/**\n * Clipping for contact manifolds. Sutherland-Hodgman clipping.\n */\nexport function clipSegmentToLine(\n  vOut: ClipVertex[],\n  vIn: ClipVertex[],\n  normal: Vec2Value,\n  offset: number,\n  vertexIndexA: number\n): number {\n  // Start with no output points\n  let numOut = 0;\n\n  // Calculate the distance of end points to the line\n  const distance0 = matrix.dotVec2(normal, vIn[0].v) - offset;\n  const distance1 = matrix.dotVec2(normal, vIn[1].v) - offset;\n\n  // If the points are behind the plane\n  if (distance0 <= 0.0)\n    vOut[numOut++].set(vIn[0]);\n  if (distance1 <= 0.0)\n    vOut[numOut++].set(vIn[1]);\n\n  // If the points are on different sides of the plane\n  if (distance0 * distance1 < 0.0) {\n    // Find intersection point of edge and plane\n    const interp = distance0 / (distance0 - distance1);\n    matrix.combineVec2(vOut[numOut].v, 1 - interp, vIn[0].v, interp, vIn[1].v);\n\n    // VertexA is hitting edgeB.\n    vOut[numOut].id.setFeatures(vertexIndexA, ContactFeatureType.e_vertex, vIn[0].id.indexB, ContactFeatureType.e_face);\n    ++numOut;\n  }\n\n  return numOut;\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport * as matrix from '../common/Matrix';\nimport { ShapeType } from \"../collision/Shape\";\nimport { math as Math } from '../common/Math';\nimport { TransformValue } from '../common/Transform';\nimport { Mat22 } from '../common/Mat22';\nimport { SettingsInternal as Settings } from '../Settings';\nimport { Manifold, ManifoldType, WorldManifold } from '../collision/Manifold';\nimport { testOverlap } from '../collision/Distance';\nimport { Fixture } from \"./Fixture\";\nimport { Body } from \"./Body\";\nimport { ContactImpulse, TimeStep } from \"./Solver\";\nimport { Pool } from \"../util/Pool\";\nimport { getTransform } from \"./Position\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\n// Solver debugging is normally disabled because the block solver sometimes has to deal with a poorly conditioned effective mass matrix.\nconst DEBUG_SOLVER = false;\n\nconst contactPool = new Pool<Contact>({\n  create() {\n    return new Contact();\n  },\n  release(contact: Contact) {\n    contact.recycle();\n  }\n});\n\nconst oldManifold = new Manifold();\n\nconst worldManifold = new WorldManifold();\n\n/**\n * A contact edge is used to connect bodies and contacts together in a contact\n * graph where each body is a node and each contact is an edge. A contact edge\n * belongs to a doubly linked list maintained in each attached body. Each\n * contact has two contact nodes, one for each attached body.\n */\nexport class ContactEdge {\n  contact: Contact;\n  prev: ContactEdge | null = null;\n  next: ContactEdge | null = null;\n  other: Body | null = null;\n  constructor(contact: Contact) {\n    this.contact = contact;\n  }\n\n  /** @internal */\n  recycle() {\n    this.prev = null;\n    this.next = null;\n    this.other = null;\n  }\n}\n\nexport type EvaluateFunction = (\n  manifold: Manifold,\n  xfA: TransformValue,\n  fixtureA: Fixture,\n  indexA: number,\n  xfB: TransformValue,\n  fixtureB: Fixture,\n  indexB: number\n) => void;\n\n/**\n * Friction mixing law. The idea is to allow either fixture to drive the\n * friction to zero. For example, anything slides on ice.\n */\nexport function mixFriction(friction1: number, friction2: number): number {\n  return Math.sqrt(friction1 * friction2);\n}\n\n/**\n * Restitution mixing law. The idea is allow for anything to bounce off an\n * inelastic surface. For example, a superball bounces on anything.\n */\nexport function mixRestitution(restitution1: number, restitution2: number): number {\n  return restitution1 > restitution2 ? restitution1 : restitution2;\n}\n\n// TODO: move this to Settings?\nconst s_registers = [];\n\n// TODO: merge with ManifoldPoint?\nexport class VelocityConstraintPoint {\n  rA = matrix.vec2(0, 0);\n  rB = matrix.vec2(0, 0);\n  normalImpulse = 0;\n  tangentImpulse = 0;\n  normalMass = 0;\n  tangentMass = 0;\n  velocityBias = 0;\n\n  recycle() {\n    matrix.zeroVec2(this.rA)\n    matrix.zeroVec2(this.rB)\n    this.normalImpulse = 0;\n    this.tangentImpulse = 0;\n    this.normalMass = 0;\n    this.tangentMass = 0;\n    this.velocityBias = 0;\n  }\n}\n\nconst cA = matrix.vec2(0, 0);\nconst vA = matrix.vec2(0, 0);\nconst cB = matrix.vec2(0, 0);\nconst vB = matrix.vec2(0, 0);\nconst tangent = matrix.vec2(0, 0);\nconst xfA = matrix.transform(0, 0, 0);\nconst xfB = matrix.transform(0, 0, 0);\nconst pointA = matrix.vec2(0, 0);\nconst pointB = matrix.vec2(0, 0);\nconst clipPoint = matrix.vec2(0, 0);\nconst planePoint = matrix.vec2(0, 0);\nconst rA = matrix.vec2(0, 0);\nconst rB = matrix.vec2(0, 0);\nconst P = matrix.vec2(0, 0);\nconst normal = matrix.vec2(0, 0);\nconst point = matrix.vec2(0, 0);\nconst dv = matrix.vec2(0, 0);\nconst dv1 = matrix.vec2(0, 0);\nconst dv2 = matrix.vec2(0, 0);\nconst b = matrix.vec2(0, 0);\nconst a = matrix.vec2(0, 0);\nconst x = matrix.vec2(0, 0);\nconst d = matrix.vec2(0, 0);\nconst P1 = matrix.vec2(0, 0);\nconst P2 = matrix.vec2(0, 0);\nconst temp = matrix.vec2(0, 0);\n\n/**\n * The class manages contact between two shapes. A contact exists for each\n * overlapping AABB in the broad-phase (except if filtered). Therefore a contact\n * object may exist that has no contact points.\n */\nexport class Contact {\n  // Nodes for connecting bodies.\n  /** @internal */\n  m_nodeA = new ContactEdge(this);\n  /** @internal */\n  m_nodeB = new ContactEdge(this);\n  /** @internal */\n  m_fixtureA: Fixture | null = null;\n  /** @internal */\n  m_fixtureB: Fixture | null = null;\n  /** @internal */\n  m_indexA = -1;\n  /** @internal */\n  m_indexB = -1;\n  /** @internal */\n  m_evaluateFcn: EvaluateFunction | null = null;\n  /** @internal */\n  m_manifold: Manifold = new Manifold();\n  /** @internal */\n  m_prev: Contact | null = null;\n  /** @internal */\n  m_next: Contact | null = null;\n  /** @internal */\n  m_toi = 1.0;\n  /** @internal */\n  m_toiCount = 0;\n  /** @internal This contact has a valid TOI in m_toi */\n  m_toiFlag = false;\n  /** @internal */\n  m_friction = 0.0;\n  /** @internal */\n  m_restitution = 0.0;\n  /** @internal */\n  m_tangentSpeed = 0.0;\n  /** @internal This contact can be disabled (by user) */\n  m_enabledFlag = true;\n  /** @internal Used when crawling contact graph when forming islands. */\n  m_islandFlag = false;\n  /** @internal Set when the shapes are touching. */\n  m_touchingFlag = false;\n  /** @internal This contact needs filtering because a fixture filter was changed. */\n  m_filterFlag = false;\n  /** @internal This bullet contact had a TOI event */\n  m_bulletHitFlag = false;\n\n  /** @internal Contact reporting impulse object cache */\n  m_impulse: ContactImpulse = new ContactImpulse(this);\n\n  // VelocityConstraint\n  /** @internal */\n  v_points = [new VelocityConstraintPoint(), new VelocityConstraintPoint()]; // [maxManifoldPoints];\n  /** @internal */\n  v_normal = matrix.vec2(0, 0);\n  /** @internal */ v_normalMass: Mat22 = new Mat22();\n  /** @internal */ v_K: Mat22 = new Mat22();\n  /** @internal */ v_pointCount = 0;\n  /** @internal */ v_tangentSpeed = 0;\n  /** @internal */ v_friction = 0;\n  /** @internal */ v_restitution = 0;\n  /** @internal */ v_invMassA = 0;\n  /** @internal */ v_invMassB = 0;\n  /** @internal */ v_invIA = 0;\n  /** @internal */ v_invIB = 0;\n\n  // PositionConstraint\n  /** @internal */ p_localPoints = [matrix.vec2(0, 0), matrix.vec2(0, 0)]; // [maxManifoldPoints];\n  /** @internal */ p_localNormal = matrix.vec2(0, 0);\n  /** @internal */ p_localPoint = matrix.vec2(0, 0);\n  /** @internal */ p_localCenterA = matrix.vec2(0, 0);\n  /** @internal */ p_localCenterB = matrix.vec2(0, 0);\n  /** @internal */ p_type = ManifoldType.e_unset;\n  /** @internal */ p_radiusA = 0;\n  /** @internal */ p_radiusB = 0;\n  /** @internal */ p_pointCount = 0;\n  /** @internal */ p_invMassA = 0;\n  /** @internal */ p_invMassB = 0;\n  /** @internal */ p_invIA = 0;\n  /** @internal */ p_invIB = 0;\n\n  initialize(fA: Fixture, indexA: number, fB: Fixture, indexB: number, evaluateFcn: EvaluateFunction) {\n    this.m_fixtureA = fA;\n    this.m_fixtureB = fB;\n\n    this.m_indexA = indexA;\n    this.m_indexB = indexB;\n\n    this.m_evaluateFcn = evaluateFcn;\n\n    this.m_friction = mixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction);\n    this.m_restitution = mixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution);\n  }\n\n  recycle() {\n    this.m_nodeA.recycle();\n    this.m_nodeB.recycle();\n    this.m_fixtureA = null;\n    this.m_fixtureB = null;\n    this.m_indexA = -1;\n    this.m_indexB = -1;\n    this.m_evaluateFcn = null;\n    this.m_manifold.recycle();\n    this.m_prev = null;\n    this.m_next = null;\n    this.m_toi = 1;\n    this.m_toiCount = 0;\n    this.m_toiFlag = false;\n    this.m_friction = 0;\n    this.m_restitution = 0;\n    this.m_tangentSpeed = 0;\n    this.m_enabledFlag = true;\n    this.m_islandFlag = false;\n    this.m_touchingFlag = false;\n    this.m_filterFlag = false;\n    this.m_bulletHitFlag = false;\n\n    this.m_impulse.recycle();\n\n    // VelocityConstraint\n    for(const point of this.v_points) {\n      point.recycle();\n    }\n    matrix.zeroVec2(this.v_normal)\n    this.v_normalMass.setZero();\n    this.v_K.setZero();\n    this.v_pointCount = 0;\n    this.v_tangentSpeed = 0;\n    this.v_friction = 0;\n    this.v_restitution = 0;\n    this.v_invMassA = 0;\n    this.v_invMassB = 0;\n    this.v_invIA = 0;\n    this.v_invIB = 0;\n\n    // PositionConstraint\n    for(const point of this.p_localPoints) {\n      matrix.zeroVec2(point);\n    }\n    matrix.zeroVec2(this.p_localNormal)\n    matrix.zeroVec2(this.p_localPoint)\n    matrix.zeroVec2(this.p_localCenterA)\n    matrix.zeroVec2(this.p_localCenterB)\n    this.p_type = ManifoldType.e_unset;\n    this.p_radiusA = 0;\n    this.p_radiusB = 0;\n    this.p_pointCount = 0;\n    this.p_invMassA = 0;\n    this.p_invMassB = 0;\n    this.p_invIA = 0;\n    this.p_invIB = 0;\n  }\n\n  initConstraint(step: TimeStep): void {\n    const fixtureA = this.m_fixtureA;\n    const fixtureB = this.m_fixtureB;\n    if (fixtureA === null || fixtureB === null) return;\n    const bodyA = fixtureA.m_body;\n    const bodyB = fixtureB.m_body;\n    if (bodyA === null || bodyB === null) return;\n    const shapeA = fixtureA.m_shape;\n    const shapeB = fixtureB.m_shape;\n    if (shapeA === null || shapeB === null) return;\n\n    const manifold = this.m_manifold;\n\n    const pointCount = manifold.pointCount;\n    _ASSERT && console.assert(pointCount > 0);\n\n    this.v_invMassA = bodyA.m_invMass;\n    this.v_invMassB = bodyB.m_invMass;\n    this.v_invIA = bodyA.m_invI;\n    this.v_invIB = bodyB.m_invI;\n\n    this.v_friction = this.m_friction;\n    this.v_restitution = this.m_restitution;\n    this.v_tangentSpeed = this.m_tangentSpeed;\n\n    this.v_pointCount = pointCount;\n\n    this.v_K.setZero();\n    this.v_normalMass.setZero();\n\n    this.p_invMassA = bodyA.m_invMass;\n    this.p_invMassB = bodyB.m_invMass;\n    this.p_invIA = bodyA.m_invI;\n    this.p_invIB = bodyB.m_invI;\n    matrix.copyVec2(this.p_localCenterA, bodyA.m_sweep.localCenter);\n    matrix.copyVec2(this.p_localCenterB, bodyB.m_sweep.localCenter);\n\n    this.p_radiusA = shapeA.m_radius;\n    this.p_radiusB = shapeB.m_radius;\n\n    this.p_type = manifold.type;\n    matrix.copyVec2(this.p_localNormal, manifold.localNormal);\n    matrix.copyVec2(this.p_localPoint, manifold.localPoint);\n    this.p_pointCount = pointCount;\n\n    for (let j = 0; j < Settings.maxManifoldPoints; ++j) {\n      this.v_points[j].recycle();\n      matrix.zeroVec2(this.p_localPoints[j]);\n    }\n\n    for (let j = 0; j < pointCount; ++j) {\n      const cp = manifold.points[j];\n      const vcp = this.v_points[j];\n      if (step.warmStarting) {\n        vcp.normalImpulse = step.dtRatio * cp.normalImpulse;\n        vcp.tangentImpulse = step.dtRatio * cp.tangentImpulse;\n      }\n      matrix.copyVec2(this.p_localPoints[j], cp.localPoint);\n    }\n  }\n\n  /**\n   * Get the contact manifold. Do not modify the manifold unless you understand\n   * the internals of the library.\n   */\n  getManifold(): Manifold {\n    return this.m_manifold;\n  }\n\n  /**\n   * Get the world manifold.\n   */\n  getWorldManifold(worldManifold: WorldManifold | null): WorldManifold | undefined {\n    const fixtureA = this.m_fixtureA;\n    const fixtureB = this.m_fixtureB;\n    if (fixtureA === null || fixtureB === null) return;\n    const bodyA = fixtureA.m_body;\n    const bodyB = fixtureB.m_body;\n    if (bodyA === null || bodyB === null) return;\n    const shapeA = fixtureA.m_shape;\n    const shapeB = fixtureB.m_shape;\n    if (shapeA === null || shapeB === null) return;\n\n    return this.m_manifold.getWorldManifold(\n      worldManifold,\n      bodyA.getTransform(), shapeA.m_radius,\n      bodyB.getTransform(), shapeB.m_radius\n    );\n  }\n\n  /**\n   * Enable/disable this contact. This can be used inside the pre-solve contact\n   * listener. The contact is only disabled for the current time step (or sub-step\n   * in continuous collisions).\n   */\n  setEnabled(flag: boolean): void {\n    this.m_enabledFlag = !!flag;\n  }\n\n  /**\n   * Has this contact been disabled?\n   */\n  isEnabled(): boolean {\n    return this.m_enabledFlag;\n  }\n\n  /**\n   * Is this contact touching?\n   */\n  isTouching(): boolean {\n    return this.m_touchingFlag;\n  }\n\n  /**\n   * Get the next contact in the world's contact list.\n   */\n  getNext(): Contact | null {\n    return this.m_next;\n  }\n\n  /**\n   * Get fixture A in this contact.\n   */\n  getFixtureA(): Fixture {\n    return this.m_fixtureA;\n  }\n\n  /**\n   * Get fixture B in this contact.\n   */\n  getFixtureB(): Fixture {\n    return this.m_fixtureB;\n  }\n\n  /**\n   * Get the child primitive index for fixture A.\n   */\n  getChildIndexA(): number {\n    return this.m_indexA;\n  }\n\n  /**\n   * Get the child primitive index for fixture B.\n   */\n  getChildIndexB(): number {\n    return this.m_indexB;\n  }\n\n  /**\n   * Flag this contact for filtering. Filtering will occur the next time step.\n   */\n  flagForFiltering(): void {\n    this.m_filterFlag = true;\n  }\n\n  /**\n   * Override the default friction mixture. You can call this in\n   * ContactListener.preSolve. This value persists until set or reset.\n   */\n  setFriction(friction: number): void {\n    this.m_friction = friction;\n  }\n\n  /**\n   * Get the friction.\n   */\n  getFriction(): number {\n    return this.m_friction;\n  }\n\n  /**\n   * Reset the friction mixture to the default value.\n   */\n  resetFriction(): void {\n    const fixtureA = this.m_fixtureA;\n    const fixtureB = this.m_fixtureB;\n    if (fixtureA === null || fixtureB === null) return;\n    this.m_friction = mixFriction(fixtureA.m_friction, fixtureB.m_friction);\n  }\n\n  /**\n   * Override the default restitution mixture. You can call this in\n   * ContactListener.preSolve. The value persists until you set or reset.\n   */\n  setRestitution(restitution: number): void {\n    this.m_restitution = restitution;\n  }\n\n  /**\n   * Get the restitution.\n   */\n  getRestitution(): number {\n    return this.m_restitution;\n  }\n\n  /**\n   * Reset the restitution to the default value.\n   */\n  resetRestitution(): void {\n    const fixtureA = this.m_fixtureA;\n    const fixtureB = this.m_fixtureB;\n    if (fixtureA === null || fixtureB === null) return;\n    this.m_restitution = mixRestitution(fixtureA.m_restitution, fixtureB.m_restitution);\n  }\n\n  /**\n   * Set the desired tangent speed for a conveyor belt behavior. In meters per\n   * second.\n   */\n  setTangentSpeed(speed: number): void {\n    this.m_tangentSpeed = speed;\n  }\n\n  /**\n   * Get the desired tangent speed. In meters per second.\n   */\n  getTangentSpeed(): number {\n    return this.m_tangentSpeed;\n  }\n\n  /**\n   * Called by Update method, and implemented by subclasses.\n   */\n  evaluate(manifold: Manifold, xfA: TransformValue, xfB: TransformValue): void {\n    const fixtureA = this.m_fixtureA;\n    const fixtureB = this.m_fixtureB;\n    if (fixtureA === null || fixtureB === null) return;\n    this.m_evaluateFcn(manifold, xfA, fixtureA, this.m_indexA, xfB, fixtureB, this.m_indexB);\n  }\n\n  /**\n   * Updates the contact manifold and touching status.\n   *\n   * Note: do not assume the fixture AABBs are overlapping or are valid.\n   *\n   * @param listener.beginContact\n   * @param listener.endContact\n   * @param listener.preSolve\n   */\n  update(listener?: {\n    beginContact(contact: Contact): void,\n    endContact(contact: Contact): void,\n    preSolve(contact: Contact, oldManifold: Manifold): void\n  }): void {\n    const fixtureA = this.m_fixtureA;\n    const fixtureB = this.m_fixtureB;\n    if (fixtureA === null || fixtureB === null) return;\n    const bodyA = fixtureA.m_body;\n    const bodyB = fixtureB.m_body;\n    if (bodyA === null || bodyB === null) return;\n    const shapeA = fixtureA.m_shape;\n    const shapeB = fixtureB.m_shape;\n    if (shapeA === null || shapeB === null) return;\n\n    // Re-enable this contact.\n    this.m_enabledFlag = true;\n\n    let touching = false;\n    const wasTouching = this.m_touchingFlag;\n\n    const sensorA = fixtureA.m_isSensor;\n    const sensorB = fixtureB.m_isSensor;\n    const sensor = sensorA || sensorB;\n\n    const xfA = bodyA.m_xf;\n    const xfB = bodyB.m_xf;\n\n    // Is this contact a sensor?\n    if (sensor) {\n      touching = testOverlap(shapeA, this.m_indexA, shapeB, this.m_indexB, xfA, xfB);\n\n      // Sensors don't generate manifolds.\n      this.m_manifold.pointCount = 0;\n    } else {\n\n      oldManifold.recycle();\n      oldManifold.set(this.m_manifold);\n      this.m_manifold.recycle();\n\n      this.evaluate(this.m_manifold, xfA, xfB);\n      touching = this.m_manifold.pointCount > 0;\n\n      // Match old contact ids to new contact ids and copy the\n      // stored impulses to warm start the solver.\n      for (let i = 0; i < this.m_manifold.pointCount; ++i) {\n        const nmp = this.m_manifold.points[i];\n        nmp.normalImpulse = 0.0;\n        nmp.tangentImpulse = 0.0;\n\n        for (let j = 0; j < oldManifold.pointCount; ++j) {\n          const omp = oldManifold.points[j];\n          if (omp.id.key === nmp.id.key) {\n            nmp.normalImpulse = omp.normalImpulse;\n            nmp.tangentImpulse = omp.tangentImpulse;\n            break;\n          }\n        }\n      }\n\n      if (touching !== wasTouching) {\n        bodyA.setAwake(true);\n        bodyB.setAwake(true);\n      }\n    }\n\n    this.m_touchingFlag = touching;\n\n    const hasListener = typeof listener === 'object' && listener !== null;\n\n    if (!wasTouching && touching && hasListener) {\n      listener.beginContact(this);\n    }\n\n    if (wasTouching && !touching && hasListener) {\n      listener.endContact(this);\n    }\n\n    if (!sensor && touching && hasListener && oldManifold) {\n      listener.preSolve(this, oldManifold);\n    }\n  }\n\n  solvePositionConstraint(step: TimeStep): number {\n    return this._solvePositionConstraint(step, null, null);\n  }\n\n  solvePositionConstraintTOI(step: TimeStep, toiA: Body, toiB: Body): number {\n    return this._solvePositionConstraint(step, toiA, toiB);\n  }\n\n  private _solvePositionConstraint(step: TimeStep, toiA: Body | null, toiB: Body | null): number {\n    const toi = toiA !== null && toiB !== null ? true : false;\n    let minSeparation = 0.0;\n\n    const fixtureA = this.m_fixtureA;\n    const fixtureB = this.m_fixtureB;\n    if (fixtureA === null || fixtureB === null) return minSeparation;\n    const bodyA = fixtureA.m_body;\n    const bodyB = fixtureB.m_body;\n    if (bodyA === null || bodyB === null) return minSeparation;\n\n    const velocityA = bodyA.c_velocity;\n    const velocityB = bodyB.c_velocity;\n    const positionA = bodyA.c_position;\n    const positionB = bodyB.c_position;\n\n    const localCenterA = this.p_localCenterA;\n    const localCenterB = this.p_localCenterB;\n\n    let mA = 0.0;\n    let iA = 0.0;\n    if (!toi || (bodyA === toiA || bodyA === toiB)) {\n      mA = this.p_invMassA;\n      iA = this.p_invIA;\n    }\n\n    let mB = 0.0;\n    let iB = 0.0;\n    if (!toi || (bodyB === toiA || bodyB === toiB)) {\n      mB = this.p_invMassB;\n      iB = this.p_invIB;\n    }\n\n    matrix.copyVec2(cA, positionA.c);\n    let aA = positionA.a;\n\n    matrix.copyVec2(cB, positionB.c);\n    let aB = positionB.a;\n\n    // Solve normal constraints\n    for (let j = 0; j < this.p_pointCount; ++j) {\n      getTransform(xfA, localCenterA, cA, aA);\n      getTransform(xfB, localCenterB, cB, aB);\n\n      // PositionSolverManifold\n      let separation: number;\n      switch (this.p_type) {\n        case ManifoldType.e_circles: {\n          matrix.transformVec2(pointA, xfA, this.p_localPoint);\n          matrix.transformVec2(pointB, xfB, this.p_localPoints[0]);\n          matrix.diffVec2(normal, pointB, pointA);\n          matrix.normalizeVec2(normal);\n\n          matrix.combineVec2(point, 0.5, pointA, 0.5, pointB);\n          separation = matrix.dotVec2(pointB, normal) - matrix.dotVec2(pointA, normal) - this.p_radiusA - this.p_radiusB;\n          break;\n        }\n\n        case ManifoldType.e_faceA: {\n          matrix.rotVec2(normal, xfA.q, this.p_localNormal);\n          matrix.transformVec2(planePoint, xfA, this.p_localPoint);\n          matrix.transformVec2(clipPoint, xfB, this.p_localPoints[j]);\n          separation = matrix.dotVec2(clipPoint, normal) - matrix.dotVec2(planePoint, normal) - this.p_radiusA - this.p_radiusB;\n          matrix.copyVec2(point, clipPoint);\n          break;\n        }\n\n        case ManifoldType.e_faceB: {\n          matrix.rotVec2(normal, xfB.q, this.p_localNormal);\n          matrix.transformVec2(planePoint, xfB, this.p_localPoint);\n          matrix.transformVec2(clipPoint, xfA, this.p_localPoints[j]);\n          separation = matrix.dotVec2(clipPoint, normal) - matrix.dotVec2(planePoint, normal) - this.p_radiusA - this.p_radiusB;\n          matrix.copyVec2(point, clipPoint);\n\n          // Ensure normal points from A to B\n          matrix.negVec2(normal);\n          break;\n        }\n        // todo: what should we do here?\n        default: {\n          return minSeparation;\n        }\n      }\n\n      matrix.diffVec2(rA, point, cA);\n      matrix.diffVec2(rB, point, cB);\n\n      // Track max constraint error.\n      minSeparation = Math.min(minSeparation, separation);\n\n      const baumgarte = toi ? Settings.toiBaugarte : Settings.baumgarte;\n      const linearSlop = Settings.linearSlop;\n      const maxLinearCorrection = Settings.maxLinearCorrection;\n\n      // Prevent large corrections and allow slop.\n      const C = Math.clamp(baumgarte * (separation + linearSlop), -maxLinearCorrection, 0.0);\n\n      // Compute the effective mass.\n      const rnA = matrix.crossVec2Vec2(rA, normal);\n      const rnB = matrix.crossVec2Vec2(rB, normal);\n      const K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;\n\n      // Compute normal impulse\n      const impulse = K > 0.0 ? -C / K : 0.0;\n\n      matrix.setMulVec2(P, impulse, normal);\n\n      matrix.subMulVec2(cA, mA, P);\n      aA -= iA * matrix.crossVec2Vec2(rA, P);\n\n      matrix.addMulVec2(cB, mB, P);\n      aB += iB * matrix.crossVec2Vec2(rB, P);\n    }\n\n    matrix.copyVec2(positionA.c, cA);\n    positionA.a = aA;\n\n    matrix.copyVec2(positionB.c, cB);\n    positionB.a = aB;\n\n    return minSeparation;\n  }\n\n  initVelocityConstraint(step: TimeStep): void {\n    const fixtureA = this.m_fixtureA;\n    const fixtureB = this.m_fixtureB;\n    if (fixtureA === null || fixtureB === null) return;\n    const bodyA = fixtureA.m_body;\n    const bodyB = fixtureB.m_body;\n    if (bodyA === null || bodyB === null) return;\n\n    const velocityA = bodyA.c_velocity;\n    const velocityB = bodyB.c_velocity;\n\n    const positionA = bodyA.c_position;\n    const positionB = bodyB.c_position;\n\n    const radiusA = this.p_radiusA;\n    const radiusB = this.p_radiusB;\n    const manifold = this.m_manifold;\n\n    const mA = this.v_invMassA;\n    const mB = this.v_invMassB;\n    const iA = this.v_invIA;\n    const iB = this.v_invIB;\n    const localCenterA = this.p_localCenterA;\n    const localCenterB = this.p_localCenterB;\n\n    matrix.copyVec2(cA, positionA.c);\n    const aA = positionA.a;\n    matrix.copyVec2(vA, velocityA.v);\n    const wA = velocityA.w;\n\n    matrix.copyVec2(cB, positionB.c);\n    const aB = positionB.a;\n    matrix.copyVec2(vB, velocityB.v);\n    const wB = velocityB.w;\n\n    _ASSERT && console.assert(manifold.pointCount > 0);\n\n    getTransform(xfA, localCenterA, cA, aA);\n    getTransform(xfB, localCenterB, cB, aB);\n\n    worldManifold.recycle();\n    manifold.getWorldManifold(worldManifold, xfA, radiusA, xfB, radiusB);\n\n    matrix.copyVec2(this.v_normal, worldManifold.normal);\n\n    for (let j = 0; j < this.v_pointCount; ++j) {\n      const vcp = this.v_points[j]; // VelocityConstraintPoint\n      const wmp = worldManifold.points[j];\n\n      matrix.diffVec2(vcp.rA, wmp, cA);\n      matrix.diffVec2(vcp.rB, wmp, cB);\n\n      const rnA = matrix.crossVec2Vec2(vcp.rA, this.v_normal);\n      const rnB = matrix.crossVec2Vec2(vcp.rB, this.v_normal);\n\n      const kNormal = mA + mB + iA * rnA * rnA + iB * rnB * rnB;\n\n      vcp.normalMass = kNormal > 0.0 ? 1.0 / kNormal : 0.0;\n\n      matrix.crossVec2Num(tangent, this.v_normal, 1.0);\n\n      const rtA = matrix.crossVec2Vec2(vcp.rA, tangent);\n      const rtB = matrix.crossVec2Vec2(vcp.rB, tangent);\n\n      const kTangent = mA + mB + iA * rtA * rtA + iB * rtB * rtB;\n\n      vcp.tangentMass = kTangent > 0.0 ? 1.0 / kTangent : 0.0;\n\n      // Setup a velocity bias for restitution.\n      vcp.velocityBias = 0.0;\n      let vRel = 0;\n      vRel += matrix.dotVec2(this.v_normal, vB)\n      vRel += matrix.dotVec2(this.v_normal, matrix.crossNumVec2(temp, wB, vcp.rB))\n      vRel -= matrix.dotVec2(this.v_normal, vA)\n      vRel -= matrix.dotVec2(this.v_normal, matrix.crossNumVec2(temp, wA, vcp.rA));\n      if (vRel < -Settings.velocityThreshold) {\n        vcp.velocityBias = -this.v_restitution * vRel;\n      }\n    }\n\n    // If we have two points, then prepare the block solver.\n    if (this.v_pointCount == 2 && step.blockSolve) {\n      const vcp1 = this.v_points[0]; // VelocityConstraintPoint\n      const vcp2 = this.v_points[1]; // VelocityConstraintPoint\n\n      const rn1A = matrix.crossVec2Vec2(vcp1.rA, this.v_normal);\n      const rn1B = matrix.crossVec2Vec2(vcp1.rB, this.v_normal);\n      const rn2A = matrix.crossVec2Vec2(vcp2.rA, this.v_normal);\n      const rn2B = matrix.crossVec2Vec2(vcp2.rB, this.v_normal);\n\n      const k11 = mA + mB + iA * rn1A * rn1A + iB * rn1B * rn1B;\n      const k22 = mA + mB + iA * rn2A * rn2A + iB * rn2B * rn2B;\n      const k12 = mA + mB + iA * rn1A * rn2A + iB * rn1B * rn2B;\n\n      // Ensure a reasonable condition number.\n      const k_maxConditionNumber = 1000.0;\n      if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {\n        // K is safe to invert.\n        this.v_K.ex.setNum(k11, k12);\n        this.v_K.ey.setNum(k12, k22);\n        // this.v_normalMass.set(this.v_K.getInverse());\n        const a = this.v_K.ex.x;\n        const b = this.v_K.ey.x;\n        const c = this.v_K.ex.y;\n        const d = this.v_K.ey.y;\n        let det = a * d - b * c;\n        if (det !== 0.0) {\n          det = 1.0 / det;\n        }\n        this.v_normalMass.ex.x = det * d;\n        this.v_normalMass.ey.x = -det * b;\n        this.v_normalMass.ex.y = -det * c;\n        this.v_normalMass.ey.y = det * a;\n\n      } else {\n        // The constraints are redundant, just use one.\n        // TODO_ERIN use deepest?\n        this.v_pointCount = 1;\n      }\n    }\n\n    matrix.copyVec2(positionA.c, cA);\n    positionA.a = aA;\n    matrix.copyVec2(velocityA.v, vA);\n    velocityA.w = wA;\n\n    matrix.copyVec2(positionB.c, cB);\n    positionB.a = aB;\n    matrix.copyVec2(velocityB.v, vB);\n    velocityB.w = wB;\n  }\n\n  warmStartConstraint(step: TimeStep): void {\n    const fixtureA = this.m_fixtureA;\n    const fixtureB = this.m_fixtureB;\n    if (fixtureA === null || fixtureB === null) return;\n    const bodyA = fixtureA.m_body;\n    const bodyB = fixtureB.m_body;\n    if (bodyA === null || bodyB === null) return;\n\n    const velocityA = bodyA.c_velocity;\n    const velocityB = bodyB.c_velocity;\n    const positionA = bodyA.c_position;\n    const positionB = bodyB.c_position;\n\n    const mA = this.v_invMassA;\n    const iA = this.v_invIA;\n    const mB = this.v_invMassB;\n    const iB = this.v_invIB;\n\n    matrix.copyVec2(vA, velocityA.v);\n    let wA = velocityA.w;\n    matrix.copyVec2(vB, velocityB.v);\n    let wB = velocityB.w;\n\n    matrix.copyVec2(normal, this.v_normal);\n    matrix.crossVec2Num(tangent, normal, 1.0);\n\n    for (let j = 0; j < this.v_pointCount; ++j) {\n      const vcp = this.v_points[j]; // VelocityConstraintPoint\n\n      matrix.combineVec2(P, vcp.normalImpulse, normal, vcp.tangentImpulse, tangent);\n\n      wA -= iA * matrix.crossVec2Vec2(vcp.rA, P);\n      matrix.subMulVec2(vA, mA, P);\n      wB += iB * matrix.crossVec2Vec2(vcp.rB, P);\n      matrix.addMulVec2(vB, mB, P);\n    }\n\n    matrix.copyVec2(velocityA.v, vA);\n    velocityA.w = wA;\n    matrix.copyVec2(velocityB.v, vB);\n    velocityB.w = wB;\n  }\n\n  storeConstraintImpulses(step: TimeStep): void {\n    const manifold = this.m_manifold;\n    for (let j = 0; j < this.v_pointCount; ++j) {\n      manifold.points[j].normalImpulse = this.v_points[j].normalImpulse;\n      manifold.points[j].tangentImpulse = this.v_points[j].tangentImpulse;\n    }\n  }\n\n  solveVelocityConstraint(step: TimeStep): void {\n    const fixtureA = this.m_fixtureA;\n    const fixtureB = this.m_fixtureB;\n    if (fixtureA === null || fixtureB === null) return;\n    const bodyA = fixtureA.m_body;\n    const bodyB = fixtureB.m_body;\n    if (bodyA === null || bodyB === null) return;\n\n    const velocityA = bodyA.c_velocity;\n    const positionA = bodyA.c_position;\n\n    const velocityB = bodyB.c_velocity;\n    const positionB = bodyB.c_position;\n\n    const mA = this.v_invMassA;\n    const iA = this.v_invIA;\n    const mB = this.v_invMassB;\n    const iB = this.v_invIB;\n\n    matrix.copyVec2(vA, velocityA.v);\n    let wA = velocityA.w;\n    matrix.copyVec2(vB, velocityB.v);\n    let wB = velocityB.w;\n\n    matrix.copyVec2(normal, this.v_normal);\n    matrix.crossVec2Num(tangent, normal, 1.0);\n    const friction = this.v_friction;\n\n    _ASSERT && console.assert(this.v_pointCount == 1 || this.v_pointCount == 2);\n\n    // Solve tangent constraints first because non-penetration is more important\n    // than friction.\n    for (let j = 0; j < this.v_pointCount; ++j) {\n      const vcp = this.v_points[j]; // VelocityConstraintPoint\n\n      // Relative velocity at contact\n      matrix.zeroVec2(dv);\n      matrix.addVec2(dv, vB);\n      matrix.addVec2(dv, matrix.crossNumVec2(temp, wB, vcp.rB));\n      matrix.subVec2(dv, vA);\n      matrix.subVec2(dv, matrix.crossNumVec2(temp, wA, vcp.rA));\n\n      // Compute tangent force\n      const vt = matrix.dotVec2(dv, tangent) - this.v_tangentSpeed;\n      let lambda = vcp.tangentMass * (-vt);\n\n      // Clamp the accumulated force\n      const maxFriction = friction * vcp.normalImpulse;\n      const newImpulse = Math.clamp(vcp.tangentImpulse + lambda, -maxFriction, maxFriction);\n      lambda = newImpulse - vcp.tangentImpulse;\n      vcp.tangentImpulse = newImpulse;\n\n      // Apply contact impulse\n      matrix.setMulVec2(P, lambda, tangent);\n\n      matrix.subMulVec2(vA, mA, P);\n      wA -= iA * matrix.crossVec2Vec2(vcp.rA, P);\n\n      matrix.addMulVec2(vB, mB, P);\n      wB += iB * matrix.crossVec2Vec2(vcp.rB, P);\n    }\n\n    // Solve normal constraints\n    if (this.v_pointCount == 1 || step.blockSolve == false) {\n      for (let i = 0; i < this.v_pointCount; ++i) {\n        const vcp = this.v_points[i]; // VelocityConstraintPoint\n\n        // Relative velocity at contact\n        matrix.zeroVec2(dv);\n        matrix.addVec2(dv, vB);\n        matrix.addVec2(dv, matrix.crossNumVec2(temp, wB, vcp.rB));\n        matrix.subVec2(dv, vA);\n        matrix.subVec2(dv, matrix.crossNumVec2(temp, wA, vcp.rA));\n\n        // Compute normal impulse\n        const vn = matrix.dotVec2(dv, normal);\n        let lambda = -vcp.normalMass * (vn - vcp.velocityBias);\n\n        // Clamp the accumulated impulse\n        const newImpulse = Math.max(vcp.normalImpulse + lambda, 0.0);\n        lambda = newImpulse - vcp.normalImpulse;\n        vcp.normalImpulse = newImpulse;\n\n        // Apply contact impulse\n        matrix.setMulVec2(P, lambda, normal);\n\n        matrix.subMulVec2(vA, mA, P);\n        wA -= iA * matrix.crossVec2Vec2(vcp.rA, P);\n\n        matrix.addMulVec2(vB, mB, P);\n        wB += iB * matrix.crossVec2Vec2(vcp.rB, P);\n      }\n    } else {\n      // Block solver developed in collaboration with Dirk Gregorius (back in\n      // 01/07 on Box2D_Lite).\n      // Build the mini LCP for this contact patch\n      //\n      // vn = A * x + b, vn >= 0, x >= 0 and vn_i * x_i = 0 with i = 1..2\n      //\n      // A = J * W * JT and J = ( -n, -r1 x n, n, r2 x n )\n      // b = vn0 - velocityBias\n      //\n      // The system is solved using the \"Total enumeration method\" (s. Murty).\n      // The complementary constraint vn_i * x_i\n      // implies that we must have in any solution either vn_i = 0 or x_i = 0.\n      // So for the 2D contact problem the cases\n      // vn1 = 0 and vn2 = 0, x1 = 0 and x2 = 0, x1 = 0 and vn2 = 0, x2 = 0 and\n      // vn1 = 0 need to be tested. The first valid\n      // solution that satisfies the problem is chosen.\n      //\n      // In order to account of the accumulated impulse 'a' (because of the\n      // iterative nature of the solver which only requires\n      // that the accumulated impulse is clamped and not the incremental\n      // impulse) we change the impulse variable (x_i).\n      //\n      // Substitute:\n      //\n      // x = a + d\n      //\n      // a := old total impulse\n      // x := new total impulse\n      // d := incremental impulse\n      //\n      // For the current iteration we extend the formula for the incremental\n      // impulse\n      // to compute the new total impulse:\n      //\n      // vn = A * d + b\n      // = A * (x - a) + b\n      // = A * x + b - A * a\n      // = A * x + b'\n      // b' = b - A * a;\n\n      const vcp1 = this.v_points[0]; // VelocityConstraintPoint\n      const vcp2 = this.v_points[1]; // VelocityConstraintPoint\n\n      matrix.setVec2(a, vcp1.normalImpulse, vcp2.normalImpulse);\n      _ASSERT && console.assert(a.x >= 0.0 && a.y >= 0.0);\n\n      // Relative velocity at contact\n      // let dv1 = Vec2.zero().add(vB).add(Vec2.crossNumVec2(wB, vcp1.rB)).sub(vA).sub(Vec2.crossNumVec2(wA, vcp1.rA));\n      matrix.zeroVec2(dv1);\n      matrix.addVec2(dv1, vB);\n      matrix.addVec2(dv1, matrix.crossNumVec2(temp, wB, vcp1.rB));\n      matrix.subVec2(dv1, vA);\n      matrix.subVec2(dv1, matrix.crossNumVec2(temp, wA, vcp1.rA));\n\n      // let dv2 = Vec2.zero().add(vB).add(Vec2.crossNumVec2(wB, vcp2.rB)).sub(vA).sub(Vec2.crossNumVec2(wA, vcp2.rA));\n      matrix.zeroVec2(dv2);\n      matrix.addVec2(dv2, vB);\n      matrix.addVec2(dv2, matrix.crossNumVec2(temp, wB, vcp2.rB));\n      matrix.subVec2(dv2, vA);\n      matrix.subVec2(dv2, matrix.crossNumVec2(temp, wA, vcp2.rA));\n\n      // Compute normal velocity\n      let vn1 = matrix.dotVec2(dv1, normal);\n      let vn2 = matrix.dotVec2(dv2, normal);\n\n      matrix.setVec2(b, vn1 - vcp1.velocityBias, vn2 - vcp2.velocityBias);\n\n      // Compute b'\n      // b.sub(Mat22.mulVec2(this.v_K, a));\n      b.x -= this.v_K.ex.x * a.x + this.v_K.ey.x * a.y;\n      b.y -= this.v_K.ex.y * a.x + this.v_K.ey.y * a.y;\n\n      const k_errorTol = 1e-3;\n      // NOT_USED(k_errorTol);\n\n      while (true) {\n        //\n        // Case 1: vn = 0\n        //\n        // 0 = A * x + b'\n        //\n        // Solve for x:\n        //\n        // x = - inv(A) * b'\n        //\n        // const x = Mat22.mulVec2(this.v_normalMass, b).neg();\n        matrix.zeroVec2(x);\n        x.x = -(this.v_normalMass.ex.x * b.x + this.v_normalMass.ey.x * b.y);\n        x.y = -(this.v_normalMass.ex.y * b.x + this.v_normalMass.ey.y * b.y);\n\n        if (x.x >= 0.0 && x.y >= 0.0) {\n          // Get the incremental impulse\n          matrix.diffVec2(d, x, a)\n\n          // Apply incremental impulse\n          matrix.setMulVec2(P1, d.x, normal);\n          matrix.setMulVec2(P2, d.y, normal);\n\n          // vA.subCombine(mA, P1, mA, P2);\n          matrix.subMulVec2(vA, mA, P1);\n          matrix.subMulVec2(vA, mA, P2);\n          wA -= iA * (matrix.crossVec2Vec2(vcp1.rA, P1) + matrix.crossVec2Vec2(vcp2.rA, P2));\n\n          // vB.addCombine(mB, P1, mB, P2);\n          matrix.addMulVec2(vB, mB, P1);\n          matrix.addMulVec2(vB, mB, P2);\n          wB += iB * (matrix.crossVec2Vec2(vcp1.rB, P1) + matrix.crossVec2Vec2(vcp2.rB, P2));\n\n          // Accumulate\n          vcp1.normalImpulse = x.x;\n          vcp2.normalImpulse = x.y;\n\n          if (DEBUG_SOLVER) {\n            // Postconditions\n            matrix.zeroVec2(dv1);\n            matrix.addVec2(dv1, vB);\n            matrix.addVec2(dv1, matrix.crossNumVec2(temp, wB, vcp1.rB));\n            matrix.subVec2(dv1, vA);\n            matrix.subVec2(dv1, matrix.crossNumVec2(temp, wA, vcp1.rA));\n\n            matrix.zeroVec2(dv2);\n            matrix.addVec2(dv2, vB);\n            matrix.addVec2(dv2, matrix.crossNumVec2(temp, wB, vcp2.rB));\n            matrix.subVec2(dv2, vA);\n            matrix.subVec2(dv2, matrix.crossNumVec2(temp, wA, vcp2.rA));\n\n            // Compute normal velocity\n            vn1 = matrix.dotVec2(dv1, normal);\n            vn2 = matrix.dotVec2(dv2, normal);\n\n            _ASSERT && console.assert(Math.abs(vn1 - vcp1.velocityBias) < k_errorTol);\n            _ASSERT && console.assert(Math.abs(vn2 - vcp2.velocityBias) < k_errorTol);\n          }\n          break;\n        }\n\n        //\n        // Case 2: vn1 = 0 and x2 = 0\n        //\n        // 0 = a11 * x1 + a12 * 0 + b1'\n        // vn2 = a21 * x1 + a22 * 0 + b2'\n        //\n        x.x = -vcp1.normalMass * b.x;\n        x.y = 0.0;\n        vn1 = 0.0;\n        vn2 = this.v_K.ex.y * x.x + b.y;\n\n        if (x.x >= 0.0 && vn2 >= 0.0) {\n          // Get the incremental impulse\n          matrix.diffVec2(d, x, a);\n\n          // Apply incremental impulse\n          matrix.setMulVec2(P1, d.x, normal);\n          matrix.setMulVec2(P2, d.y, normal);\n\n          // vA.subCombine(mA, P1, mA, P2);\n          matrix.subMulVec2(vA, mA, P1);\n          matrix.subMulVec2(vA, mA, P2);\n          wA -= iA * (matrix.crossVec2Vec2(vcp1.rA, P1) + matrix.crossVec2Vec2(vcp2.rA, P2));\n\n          // vB.addCombine(mB, P1, mB, P2);\n          matrix.addMulVec2(vB, mB, P1);\n          matrix.addMulVec2(vB, mB, P2);\n          wB += iB * (matrix.crossVec2Vec2(vcp1.rB, P1) + matrix.crossVec2Vec2(vcp2.rB, P2));\n\n          // Accumulate\n          vcp1.normalImpulse = x.x;\n          vcp2.normalImpulse = x.y;\n\n          if (DEBUG_SOLVER) {\n            // Postconditions\n            matrix.zeroVec2(dv1);\n            matrix.addVec2(dv1, vB);\n            matrix.addVec2(dv1, matrix.crossNumVec2(temp, wB, vcp1.rB));\n            matrix.subVec2(dv1, vA);\n            matrix.subVec2(dv1, matrix.crossNumVec2(temp, wA, vcp1.rA));\n\n            // Compute normal velocity\n            vn1 = matrix.dotVec2(dv1, normal);\n\n            _ASSERT && console.assert(Math.abs(vn1 - vcp1.velocityBias) < k_errorTol);\n          }\n          break;\n        }\n\n        //\n        // Case 3: vn2 = 0 and x1 = 0\n        //\n        // vn1 = a11 * 0 + a12 * x2 + b1'\n        // 0 = a21 * 0 + a22 * x2 + b2'\n        //\n        x.x = 0.0;\n        x.y = -vcp2.normalMass * b.y;\n        vn1 = this.v_K.ey.x * x.y + b.x;\n        vn2 = 0.0;\n\n        if (x.y >= 0.0 && vn1 >= 0.0) {\n          // Resubstitute for the incremental impulse\n          matrix.diffVec2(d, x, a);\n\n          // Apply incremental impulse\n          matrix.setMulVec2(P1, d.x, normal);\n          matrix.setMulVec2(P2, d.y, normal);\n\n          // vA.subCombine(mA, P1, mA, P2);\n          matrix.subMulVec2(vA, mA, P1);\n          matrix.subMulVec2(vA, mA, P2);\n          wA -= iA * (matrix.crossVec2Vec2(vcp1.rA, P1) + matrix.crossVec2Vec2(vcp2.rA, P2));\n\n          // vB.addCombine(mB, P1, mB, P2);\n          matrix.addMulVec2(vB, mB, P1);\n          matrix.addMulVec2(vB, mB, P2);\n          wB += iB * (matrix.crossVec2Vec2(vcp1.rB, P1) + matrix.crossVec2Vec2(vcp2.rB, P2));\n\n          // Accumulate\n          vcp1.normalImpulse = x.x;\n          vcp2.normalImpulse = x.y;\n\n          if (DEBUG_SOLVER) {\n            // Postconditions\n            matrix.zeroVec2(dv2);\n            matrix.addVec2(dv2, vB);\n            matrix.addVec2(dv2, matrix.crossNumVec2(temp, wB, vcp2.rB));\n            matrix.subVec2(dv2, vA);\n            matrix.subVec2(dv2, matrix.crossNumVec2(temp, wA, vcp2.rA));\n\n            // Compute normal velocity\n            vn2 = matrix.dotVec2(dv2, normal);\n\n            _ASSERT && console.assert(Math.abs(vn2 - vcp2.velocityBias) < k_errorTol);\n          }\n          break;\n        }\n\n        //\n        // Case 4: x1 = 0 and x2 = 0\n        //\n        // vn1 = b1\n        // vn2 = b2;\n        //\n        x.x = 0.0;\n        x.y = 0.0;\n        vn1 = b.x;\n        vn2 = b.y;\n\n        if (vn1 >= 0.0 && vn2 >= 0.0) {\n          // Resubstitute for the incremental impulse\n          matrix.diffVec2(d, x, a);\n\n          // Apply incremental impulse\n          matrix.setMulVec2(P1, d.x, normal);\n          matrix.setMulVec2(P2, d.y, normal);\n\n          // vA.subCombine(mA, P1, mA, P2);\n          matrix.subMulVec2(vA, mA, P1);\n          matrix.subMulVec2(vA, mA, P2);\n          wA -= iA * (matrix.crossVec2Vec2(vcp1.rA, P1) + matrix.crossVec2Vec2(vcp2.rA, P2));\n\n          // vB.addCombine(mB, P1, mB, P2);\n          matrix.addMulVec2(vB, mB, P1);\n          matrix.addMulVec2(vB, mB, P2);\n          wB += iB * (matrix.crossVec2Vec2(vcp1.rB, P1) + matrix.crossVec2Vec2(vcp2.rB, P2));\n\n          // Accumulate\n          vcp1.normalImpulse = x.x;\n          vcp2.normalImpulse = x.y;\n\n          break;\n        }\n\n        // No solution, give up. This is hit sometimes, but it doesn't seem to\n        // matter.\n        break;\n      }\n    }\n\n    matrix.copyVec2(velocityA.v, vA);\n    velocityA.w = wA;\n\n    matrix.copyVec2(velocityB.v, vB);\n    velocityB.w = wB;\n  }\n\n  /**\n   * @internal\n   */\n  static addType(type1: ShapeType, type2: ShapeType, callback: EvaluateFunction): void {\n    s_registers[type1] = s_registers[type1] || {};\n    s_registers[type1][type2] = callback;\n  }\n\n  /**\n   * @internal\n   */\n  static create(fixtureA: Fixture, indexA: number, fixtureB: Fixture, indexB: number): Contact | null {\n    const typeA = fixtureA.m_shape.m_type;\n    const typeB = fixtureB.m_shape.m_type;\n\n    const contact = contactPool.allocate();\n    let evaluateFcn;\n    if (evaluateFcn = s_registers[typeA] && s_registers[typeA][typeB]) {\n      contact.initialize(fixtureA, indexA, fixtureB, indexB, evaluateFcn);\n    } else if (evaluateFcn = s_registers[typeB] && s_registers[typeB][typeA]) {\n      contact.initialize(fixtureB, indexB, fixtureA, indexA, evaluateFcn);\n    } else {\n      return null;\n    }\n\n    // Contact creation may swap fixtures.\n    fixtureA = contact.m_fixtureA;\n    fixtureB = contact.m_fixtureB;\n    indexA = contact.getChildIndexA();\n    indexB = contact.getChildIndexB();\n    const bodyA = fixtureA.m_body;\n    const bodyB = fixtureB.m_body;\n\n    // Connect to body A\n    contact.m_nodeA.contact = contact;\n    contact.m_nodeA.other = bodyB;\n\n    contact.m_nodeA.prev = null;\n    contact.m_nodeA.next = bodyA.m_contactList;\n    if (bodyA.m_contactList != null) {\n      bodyA.m_contactList.prev = contact.m_nodeA;\n    }\n    bodyA.m_contactList = contact.m_nodeA;\n\n    // Connect to body B\n    contact.m_nodeB.contact = contact;\n    contact.m_nodeB.other = bodyA;\n\n    contact.m_nodeB.prev = null;\n    contact.m_nodeB.next = bodyB.m_contactList;\n    if (bodyB.m_contactList != null) {\n      bodyB.m_contactList.prev = contact.m_nodeB;\n    }\n    bodyB.m_contactList = contact.m_nodeB;\n\n    // Wake up the bodies\n    if (fixtureA.isSensor() == false && fixtureB.isSensor() == false) {\n      bodyA.setAwake(true);\n      bodyB.setAwake(true);\n    }\n\n    return contact;\n  }\n\n  /** @internal */\n  static destroy(contact: Contact, listener: { endContact: (contact: Contact) => void }): void {\n    const fixtureA = contact.m_fixtureA;\n    const fixtureB = contact.m_fixtureB;\n    if (fixtureA === null || fixtureB === null) return;\n    const bodyA = fixtureA.m_body;\n    const bodyB = fixtureB.m_body;\n    if (bodyA === null || bodyB === null) return;\n\n    if (contact.isTouching()) {\n      listener.endContact(contact);\n    }\n\n    // Remove from body 1\n    if (contact.m_nodeA.prev) {\n      contact.m_nodeA.prev.next = contact.m_nodeA.next;\n    }\n\n    if (contact.m_nodeA.next) {\n      contact.m_nodeA.next.prev = contact.m_nodeA.prev;\n    }\n\n    if (contact.m_nodeA == bodyA.m_contactList) {\n      bodyA.m_contactList = contact.m_nodeA.next;\n    }\n\n    // Remove from body 2\n    if (contact.m_nodeB.prev) {\n      contact.m_nodeB.prev.next = contact.m_nodeB.next;\n    }\n\n    if (contact.m_nodeB.next) {\n      contact.m_nodeB.next.prev = contact.m_nodeB.prev;\n    }\n\n    if (contact.m_nodeB == bodyB.m_contactList) {\n      bodyB.m_contactList = contact.m_nodeB.next;\n    }\n\n    if (contact.m_manifold.pointCount > 0 && !fixtureA.m_isSensor && !fixtureB.m_isSensor) {\n      bodyA.setAwake(true);\n      bodyB.setAwake(true);\n    }\n\n    // const typeA = fixtureA.getType();\n    // const typeB = fixtureB.getType();\n\n    // const destroyFcn = s_registers[typeA][typeB].destroyFcn;\n    // if (typeof destroyFcn === 'function') {\n    //   destroyFcn(contact);\n    // }\n\n    contactPool.release(contact);\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { options } from '../util/options';\nimport { Vec2 } from '../common/Vec2';\nimport { BroadPhase } from '../collision/BroadPhase';\nimport { Solver, ContactImpulse, TimeStep } from './Solver';\nimport { Body, BodyDef } from './Body';\nimport { Joint } from './Joint';\nimport { Contact } from './Contact';\nimport { AABB, RayCastInput, RayCastOutput } from \"../collision/AABB\";\nimport { Fixture, FixtureProxy } from \"./Fixture\";\nimport { Manifold } from \"../collision/Manifold\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\nconst _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\n/**\n * @prop gravity [{ x : 0, y : 0}]\n * @prop allowSleep [true]\n * @prop warmStarting [true]\n * @prop continuousPhysics [true]\n * @prop subStepping [false]\n * @prop blockSolve [true]\n * @prop velocityIterations [8] For the velocity constraint solver.\n * @prop positionIterations [3] For the position constraint solver.\n */\nexport interface WorldDef {\n  gravity?: Vec2;\n  allowSleep?: boolean;\n  warmStarting?: boolean;\n  continuousPhysics?: boolean;\n  subStepping?: boolean;\n  blockSolve?: boolean;\n  velocityIterations?: number;\n  positionIterations?: number;\n}\n\nconst WorldDefDefault: WorldDef = {\n  gravity : Vec2.zero(),\n  allowSleep : true,\n  warmStarting : true,\n  continuousPhysics : true,\n  subStepping : false,\n  blockSolve : true,\n  velocityIterations : 8,\n  positionIterations : 3\n};\n\n/**\n * Callback function for ray casts, see {@link World.rayCast}.\n *\n * Called for each fixture found in the query. You control how the ray cast\n * proceeds by returning a float: return -1: ignore this fixture and continue\n * return 0: terminate the ray cast return fraction: clip the ray to this point\n * return 1: don't clip the ray and continue\n *\n * @param fixture The fixture hit by the ray\n * @param point The point of initial intersection\n * @param normal The normal vector at the point of intersection\n * @param fraction\n *\n * @return -1 to filter, 0 to terminate, fraction to clip the ray for closest hit, 1 to continue\n */\nexport type WorldRayCastCallback = (fixture: Fixture, point: Vec2, normal: Vec2, fraction: number) => number;\n\n/**\n * Called for each fixture found in the query AABB. It may return `false` to terminate the query.\n */\nexport type WorldAABBQueryCallback = (fixture: Fixture) => boolean;\n\nexport class World {\n  /** @internal */ m_solver: Solver;\n  /** @internal */ m_broadPhase: BroadPhase;\n  /** @internal */ m_contactList: Contact | null;\n  /** @internal */ m_contactCount: number;\n  /** @internal */ m_bodyList: Body | null;\n  /** @internal */ m_bodyCount: number;\n  /** @internal */ m_jointList: Joint | null;\n  /** @internal */ m_jointCount: number;\n  /** @internal */ m_stepComplete: boolean;\n  /** @internal */ m_allowSleep: boolean;\n  /** @internal */ m_gravity: Vec2;\n  /** @internal */ m_clearForces: boolean;\n  /** @internal */ m_newFixture: boolean;\n  /** @internal */ m_locked: boolean;\n  /** @internal */ m_warmStarting: boolean;\n  /** @internal */ m_continuousPhysics: boolean;\n  /** @internal */ m_subStepping: boolean;\n  /** @internal */ m_blockSolve: boolean;\n  /** @internal */ m_velocityIterations: number;\n  /** @internal */ m_positionIterations: number;\n  /** @internal */ m_t: number;\n\n  // TODO\n  /** @internal */ _listeners: {\n    [key: string]: any[]\n  };\n\n  /**\n   * @param def World definition or gravity vector.\n   */\n  constructor(def?: WorldDef | Vec2 | null) {\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof World)) {\n      return new World(def);\n    }\n\n    this.s_step = new TimeStep();\n\n\n    if (def && Vec2.isValid(def)) {\n      def = { gravity: def as Vec2 };\n    }\n\n    def = options(def, WorldDefDefault) as WorldDef;\n\n    this.m_solver = new Solver(this);\n\n    this.m_broadPhase = new BroadPhase();\n\n    this.m_contactList = null;\n    this.m_contactCount = 0;\n\n    this.m_bodyList = null;\n    this.m_bodyCount = 0;\n\n    this.m_jointList = null;\n    this.m_jointCount = 0;\n\n    this.m_stepComplete = true;\n\n    this.m_allowSleep = def.allowSleep;\n    this.m_gravity = Vec2.clone(def.gravity);\n\n    this.m_clearForces = true;\n    this.m_newFixture = false;\n    this.m_locked = false;\n\n    // These are for debugging the solver.\n    this.m_warmStarting = def.warmStarting;\n    this.m_continuousPhysics = def.continuousPhysics;\n    this.m_subStepping = def.subStepping;\n\n    this.m_blockSolve = def.blockSolve;\n    this.m_velocityIterations = def.velocityIterations;\n    this.m_positionIterations = def.positionIterations;\n\n    this.m_t = 0;\n  }\n\n  /** @internal */\n  _serialize(): object {\n    const bodies = [];\n    const joints = [];\n\n    for (let b = this.getBodyList(); b; b = b.getNext()) {\n      bodies.push(b);\n    }\n\n    for (let j = this.getJointList(); j; j = j.getNext()) {\n      // @ts-ignore\n      if (typeof j._serialize === 'function') {\n        joints.push(j);\n      }\n    }\n\n    return {\n      gravity: this.m_gravity,\n      bodies,\n      joints,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, context: any, restore: any): World {\n    if (!data) {\n      return new World();\n    }\n\n    const world = new World(data.gravity);\n\n    if (data.bodies) {\n      for (let i = data.bodies.length - 1; i >= 0; i -= 1) {\n        world._addBody(restore(Body, data.bodies[i], world));\n      }\n    }\n\n    if (data.joints) {\n      for (let i = data.joints.length - 1; i >= 0; i--) {\n        world.createJoint(restore(Joint, data.joints[i], world));\n      }\n    }\n\n    return world;\n  }\n\n  /**\n   * Get the world body list. With the returned body, use Body.getNext to get the\n   * next body in the world list. A null body indicates the end of the list.\n   *\n   * @return the head of the world body list.\n   */\n  getBodyList(): Body | null {\n    return this.m_bodyList;\n  }\n\n  /**\n   * Get the world joint list. With the returned joint, use Joint.getNext to get\n   * the next joint in the world list. A null joint indicates the end of the list.\n   *\n   * @return the head of the world joint list.\n   */\n  getJointList(): Joint | null {\n    return this.m_jointList;\n  }\n\n  /**\n   * Get the world contact list. With the returned contact, use Contact.getNext to\n   * get the next contact in the world list. A null contact indicates the end of\n   * the list.\n   *\n   * Warning: contacts are created and destroyed in the middle of a time step.\n   * Use ContactListener to avoid missing contacts.\n   *\n   * @return the head of the world contact list.\n   */\n  getContactList(): Contact | null {\n    return this.m_contactList;\n  }\n\n  getBodyCount(): number {\n    return this.m_bodyCount;\n  }\n\n  getJointCount(): number {\n    return this.m_jointCount;\n  }\n\n  /**\n   * Get the number of contacts (each may have 0 or more contact points).\n   */\n  getContactCount(): number {\n    return this.m_contactCount;\n  }\n\n  /**\n   * Change the global gravity vector.\n   */\n  setGravity(gravity: Vec2): void {\n    this.m_gravity = gravity;\n  }\n\n  /**\n   * Get the global gravity vector.\n   */\n  getGravity(): Vec2 {\n    return this.m_gravity;\n  }\n\n  /**\n   * Is the world locked (in the middle of a time step).\n   */\n  isLocked(): boolean {\n    return this.m_locked;\n  }\n\n  /**\n   * Enable/disable sleep.\n   */\n  setAllowSleeping(flag: boolean): void {\n    if (flag == this.m_allowSleep) {\n      return;\n    }\n\n    this.m_allowSleep = flag;\n    if (this.m_allowSleep == false) {\n      for (let b = this.m_bodyList; b; b = b.m_next) {\n        b.setAwake(true);\n      }\n    }\n  }\n\n  getAllowSleeping(): boolean {\n    return this.m_allowSleep;\n  }\n\n  /**\n   * Enable/disable warm starting. For testing.\n   */\n  setWarmStarting(flag: boolean): void {\n    this.m_warmStarting = flag;\n  }\n\n  getWarmStarting(): boolean {\n    return this.m_warmStarting;\n  }\n\n  /**\n   * Enable/disable continuous physics. For testing.\n   */\n  setContinuousPhysics(flag: boolean): void {\n    this.m_continuousPhysics = flag;\n  }\n\n  getContinuousPhysics(): boolean {\n    return this.m_continuousPhysics;\n  }\n\n  /**\n   * Enable/disable single stepped continuous physics. For testing.\n   */\n  setSubStepping(flag: boolean): void {\n    this.m_subStepping = flag;\n  }\n\n  getSubStepping(): boolean {\n    return this.m_subStepping;\n  }\n\n  /**\n   * Set flag to control automatic clearing of forces after each time step.\n   */\n  setAutoClearForces(flag: boolean): void {\n    this.m_clearForces = flag;\n  }\n\n  /**\n   * Get the flag that controls automatic clearing of forces after each time step.\n   */\n  getAutoClearForces(): boolean {\n    return this.m_clearForces;\n  }\n\n  /**\n   * Manually clear the force buffer on all bodies. By default, forces are cleared\n   * automatically after each call to step. The default behavior is modified by\n   * calling setAutoClearForces. The purpose of this function is to support\n   * sub-stepping. Sub-stepping is often used to maintain a fixed sized time step\n   * under a variable frame-rate. When you perform sub-stepping you will disable\n   * auto clearing of forces and instead call clearForces after all sub-steps are\n   * complete in one pass of your game loop.\n   *\n   * See {@link World.setAutoClearForces}\n   */\n  clearForces(): void {\n    for (let body = this.m_bodyList; body; body = body.getNext()) {\n      body.m_force.setZero();\n      body.m_torque = 0.0;\n    }\n  }\n\n  /**\n   * Query the world for all fixtures that potentially overlap the provided AABB.\n   *\n   * @param aabb The query box.\n   * @param callback Called for each fixture found in the query AABB. It may return `false` to terminate the query.\n   */\n  queryAABB(aabb: AABB, callback: WorldAABBQueryCallback): void {\n    _ASSERT && console.assert(typeof callback === 'function');\n    const broadPhase = this.m_broadPhase;\n    this.m_broadPhase.query(aabb, function(proxyId: number): boolean { // TODO GC\n      const proxy = broadPhase.getUserData(proxyId);\n      return callback(proxy.fixture);\n    });\n  }\n\n  /**\n   * Ray-cast the world for all fixtures in the path of the ray. Your callback\n   * controls whether you get the closest point, any point, or n-points. The\n   * ray-cast ignores shapes that contain the starting point.\n   *\n   * @param point1 The ray starting point\n   * @param point2 The ray ending point\n   * @param callback A user implemented callback function.\n   */\n  rayCast(point1: Vec2, point2: Vec2, callback: WorldRayCastCallback): void {\n    _ASSERT && console.assert(typeof callback === 'function');\n    const broadPhase = this.m_broadPhase;\n\n    this.m_broadPhase.rayCast({\n      maxFraction : 1.0,\n      p1 : point1,\n      p2 : point2\n    }, function(input: RayCastInput, proxyId: number): number { // TODO GC\n      const proxy = broadPhase.getUserData(proxyId);\n      const fixture = proxy.fixture;\n      const index = proxy.childIndex;\n      // @ts-ignore\n      const output: RayCastOutput = {}; // TODO GC\n      const hit = fixture.rayCast(output, input, index);\n      if (hit) {\n        const fraction = output.fraction;\n        const point = Vec2.add(Vec2.mulNumVec2((1.0 - fraction), input.p1), Vec2.mulNumVec2(fraction, input.p2));\n        return callback(fixture, point, output.normal, fraction);\n      }\n      return input.maxFraction;\n    });\n  }\n\n  /**\n   * Get the number of broad-phase proxies.\n   */\n  getProxyCount(): number {\n    return this.m_broadPhase.getProxyCount();\n  }\n\n  /**\n   * Get the height of broad-phase dynamic tree.\n   */\n  getTreeHeight(): number {\n    return this.m_broadPhase.getTreeHeight();\n  }\n\n  /**\n   * Get the balance of broad-phase dynamic tree.\n   */\n  getTreeBalance(): number {\n    return this.m_broadPhase.getTreeBalance();\n  }\n\n  /**\n   * Get the quality metric of broad-phase dynamic tree. The smaller the better.\n   * The minimum is 1.\n   */\n  getTreeQuality(): number {\n    return this.m_broadPhase.getTreeQuality();\n  }\n\n  /**\n   * Shift the world origin. Useful for large worlds. The body shift formula is:\n   * position -= newOrigin\n   *\n   * @param newOrigin The new origin with respect to the old origin\n   */\n  shiftOrigin(newOrigin: Vec2): void {\n    _ASSERT && console.assert(this.m_locked == false);\n    if (this.m_locked) {\n      return;\n    }\n\n    for (let b = this.m_bodyList; b; b = b.m_next) {\n      b.m_xf.p.sub(newOrigin);\n      b.m_sweep.c0.sub(newOrigin);\n      b.m_sweep.c.sub(newOrigin);\n    }\n\n    for (let j = this.m_jointList; j; j = j.m_next) {\n      j.shiftOrigin(newOrigin);\n    }\n\n    this.m_broadPhase.shiftOrigin(newOrigin);\n  }\n\n  /**\n   * @internal Used for deserialize.\n   */\n  _addBody(body: Body): void {\n    _ASSERT && console.assert(this.isLocked() === false);\n    if (this.isLocked()) {\n      return;\n    }\n\n    // Add to world doubly linked list.\n    body.m_prev = null;\n    body.m_next = this.m_bodyList;\n    if (this.m_bodyList) {\n      this.m_bodyList.m_prev = body;\n    }\n    this.m_bodyList = body;\n    ++this.m_bodyCount;\n  }\n\n  /**\n   * Create a rigid body given a definition. No reference to the definition is\n   * retained.\n   *\n   * Warning: This function is locked during callbacks.\n   */\n  createBody(def?: BodyDef): Body;\n  createBody(position: Vec2, angle?: number): Body;\n  // tslint:disable-next-line:typedef\n  /** @internal */ createBody(arg1?, arg2?) {\n    _ASSERT && console.assert(this.isLocked() == false);\n    if (this.isLocked()) {\n      return null;\n    }\n\n    let def: BodyDef = {};\n    if (!arg1) {\n    } else if (Vec2.isValid(arg1)) {\n      def = { position : arg1, angle: arg2 };\n    } else if (typeof arg1 === 'object') {\n      def = arg1;\n    }\n\n    const body = new Body(this, def);\n    this._addBody(body);\n    return body;\n  }\n\n  createDynamicBody(def?: BodyDef): Body;\n  createDynamicBody(position: Vec2, angle?: number): Body;\n  // tslint:disable-next-line:typedef\n  /** @internal */ createDynamicBody(arg1?, arg2?) {\n    let def: BodyDef = {};\n    if (!arg1) {\n    } else if (Vec2.isValid(arg1)) {\n      def = { position : arg1, angle: arg2 };\n    } else if (typeof arg1 === 'object') {\n      def = arg1;\n    }\n    def.type = 'dynamic';\n    return this.createBody(def);\n  }\n\n  createKinematicBody(def?: BodyDef): Body;\n  createKinematicBody(position: Vec2, angle?: number): Body;\n  // tslint:disable-next-line:typedef\n  createKinematicBody(arg1?, arg2?) {\n    let def: BodyDef = {};\n    if (!arg1) {\n    } else if (Vec2.isValid(arg1)) {\n      def = { position : arg1, angle: arg2 };\n    } else if (typeof arg1 === 'object') {\n      def = arg1;\n    }\n    def.type = 'kinematic';\n    return this.createBody(def);\n  }\n\n  /**\n   * Destroy a rigid body given a definition. No reference to the definition is\n   * retained.\n   *\n   * Warning: This automatically deletes all associated shapes and joints.\n   *\n   * Warning: This function is locked during callbacks.\n   */\n  destroyBody(b: Body): boolean {\n    _ASSERT && console.assert(this.m_bodyCount > 0);\n    _ASSERT && console.assert(this.isLocked() == false);\n    if (this.isLocked()) {\n      return;\n    }\n\n    if (b.m_destroyed) {\n      return false;\n    }\n\n    // Delete the attached joints.\n    let je = b.m_jointList;\n    while (je) {\n      const je0 = je;\n      je = je.next;\n\n      this.publish('remove-joint', je0.joint);\n      this.destroyJoint(je0.joint);\n\n      b.m_jointList = je;\n    }\n    b.m_jointList = null;\n\n    // Delete the attached contacts.\n    let ce = b.m_contactList;\n    while (ce) {\n      const ce0 = ce;\n      ce = ce.next;\n\n      this.destroyContact(ce0.contact);\n\n      b.m_contactList = ce;\n    }\n    b.m_contactList = null;\n\n    // Delete the attached fixtures. This destroys broad-phase proxies.\n    let f = b.m_fixtureList;\n    while (f) {\n      const f0 = f;\n      f = f.m_next;\n\n      this.publish('remove-fixture', f0);\n      f0.destroyProxies(this.m_broadPhase);\n\n      b.m_fixtureList = f;\n    }\n    b.m_fixtureList = null;\n\n    // Remove world body list.\n    if (b.m_prev) {\n      b.m_prev.m_next = b.m_next;\n    }\n\n    if (b.m_next) {\n      b.m_next.m_prev = b.m_prev;\n    }\n\n    if (b == this.m_bodyList) {\n      this.m_bodyList = b.m_next;\n    }\n\n    b.m_destroyed = true;\n\n    --this.m_bodyCount;\n\n    this.publish('remove-body', b);\n\n    return true;\n  }\n\n  /**\n   * Create a joint to constrain bodies together. No reference to the definition\n   * is retained. This may cause the connected bodies to cease colliding.\n   *\n   * Warning: This function is locked during callbacks.\n   */\n  createJoint<T extends Joint>(joint: T): T | null {\n    _ASSERT && console.assert(!!joint.m_bodyA);\n    _ASSERT && console.assert(!!joint.m_bodyB);\n    _ASSERT && console.assert(this.isLocked() == false);\n    if (this.isLocked()) {\n      return null;\n    }\n\n    // Connect to the world list.\n    joint.m_prev = null;\n    joint.m_next = this.m_jointList;\n    if (this.m_jointList) {\n      this.m_jointList.m_prev = joint;\n    }\n    this.m_jointList = joint;\n    ++this.m_jointCount;\n\n    // Connect to the bodies' doubly linked lists.\n    joint.m_edgeA.joint = joint;\n    joint.m_edgeA.other = joint.m_bodyB;\n    joint.m_edgeA.prev = null;\n    joint.m_edgeA.next = joint.m_bodyA.m_jointList;\n    if (joint.m_bodyA.m_jointList)\n      joint.m_bodyA.m_jointList.prev = joint.m_edgeA;\n    joint.m_bodyA.m_jointList = joint.m_edgeA;\n\n    joint.m_edgeB.joint = joint;\n    joint.m_edgeB.other = joint.m_bodyA;\n    joint.m_edgeB.prev = null;\n    joint.m_edgeB.next = joint.m_bodyB.m_jointList;\n    if (joint.m_bodyB.m_jointList)\n      joint.m_bodyB.m_jointList.prev = joint.m_edgeB;\n    joint.m_bodyB.m_jointList = joint.m_edgeB;\n\n    // If the joint prevents collisions, then flag any contacts for filtering.\n    if (joint.m_collideConnected == false) {\n      for (let edge = joint.m_bodyB.getContactList(); edge; edge = edge.next) {\n        if (edge.other == joint.m_bodyA) {\n          // Flag the contact for filtering at the next time step (where either\n          // body is awake).\n          edge.contact.flagForFiltering();\n        }\n      }\n    }\n\n    // Note: creating a joint doesn't wake the bodies.\n\n    return joint;\n  }\n\n  /**\n   * Destroy a joint. This may cause the connected bodies to begin colliding.\n   * Warning: This function is locked during callbacks.\n   */\n  destroyJoint(joint: Joint): void {\n    _ASSERT && console.assert(this.isLocked() == false);\n    if (this.isLocked()) {\n      return;\n    }\n\n    // Remove from the doubly linked list.\n    if (joint.m_prev) {\n      joint.m_prev.m_next = joint.m_next;\n    }\n\n    if (joint.m_next) {\n      joint.m_next.m_prev = joint.m_prev;\n    }\n\n    if (joint == this.m_jointList) {\n      this.m_jointList = joint.m_next;\n    }\n\n    // Disconnect from bodies.\n    const bodyA = joint.m_bodyA;\n    const bodyB = joint.m_bodyB;\n\n    // Wake up connected bodies.\n    bodyA.setAwake(true);\n    bodyB.setAwake(true);\n\n    // Remove from body 1.\n    if (joint.m_edgeA.prev) {\n      joint.m_edgeA.prev.next = joint.m_edgeA.next;\n    }\n\n    if (joint.m_edgeA.next) {\n      joint.m_edgeA.next.prev = joint.m_edgeA.prev;\n    }\n\n    if (joint.m_edgeA == bodyA.m_jointList) {\n      bodyA.m_jointList = joint.m_edgeA.next;\n    }\n\n    joint.m_edgeA.prev = null;\n    joint.m_edgeA.next = null;\n\n    // Remove from body 2\n    if (joint.m_edgeB.prev) {\n      joint.m_edgeB.prev.next = joint.m_edgeB.next;\n    }\n\n    if (joint.m_edgeB.next) {\n      joint.m_edgeB.next.prev = joint.m_edgeB.prev;\n    }\n\n    if (joint.m_edgeB == bodyB.m_jointList) {\n      bodyB.m_jointList = joint.m_edgeB.next;\n    }\n\n    joint.m_edgeB.prev = null;\n    joint.m_edgeB.next = null;\n\n    _ASSERT && console.assert(this.m_jointCount > 0);\n    --this.m_jointCount;\n\n    // If the joint prevents collisions, then flag any contacts for filtering.\n    if (joint.m_collideConnected == false) {\n      let edge = bodyB.getContactList();\n      while (edge) {\n        if (edge.other == bodyA) {\n          // Flag the contact for filtering at the next time step (where either\n          // body is awake).\n          edge.contact.flagForFiltering();\n        }\n\n        edge = edge.next;\n      }\n    }\n\n    this.publish('remove-joint', joint);\n  }\n\n  /** @internal */\n  s_step: TimeStep; // reuse\n\n  /**\n   * Take a time step. This performs collision detection, integration, and\n   * constraint solution.\n   *\n   * Broad-phase, narrow-phase, solve and solve time of impacts.\n   *\n   * @param timeStep Time step, this should not vary.\n   */\n  step(timeStep: number, velocityIterations?: number, positionIterations?: number): void {\n    this.publish('pre-step', timeStep);\n\n    if ((velocityIterations | 0) !== velocityIterations) {\n      // TODO: remove this in future\n      velocityIterations = 0;\n    }\n\n    velocityIterations = velocityIterations || this.m_velocityIterations;\n    positionIterations = positionIterations || this.m_positionIterations;\n\n    // If new fixtures were added, we need to find the new contacts.\n    if (this.m_newFixture) {\n      this.findNewContacts();\n      this.m_newFixture = false;\n    }\n\n    this.m_locked = true;\n\n    this.s_step.reset(timeStep);\n    this.s_step.velocityIterations = velocityIterations;\n    this.s_step.positionIterations = positionIterations;\n    this.s_step.warmStarting = this.m_warmStarting;\n    this.s_step.blockSolve = this.m_blockSolve;\n\n    // Update contacts. This is where some contacts are destroyed.\n    this.updateContacts();\n\n    // Integrate velocities, solve velocity constraints, and integrate positions.\n    if (this.m_stepComplete && timeStep > 0.0) {\n      this.m_solver.solveWorld(this.s_step);\n\n      // Synchronize fixtures, check for out of range bodies.\n      for (let b = this.m_bodyList; b; b = b.getNext()) {\n        // If a body was not in an island then it did not move.\n        if (b.m_islandFlag == false) {\n          continue;\n        }\n\n        if (b.isStatic()) {\n          continue;\n        }\n\n        // Update fixtures (for broad-phase).\n        b.synchronizeFixtures();\n      }\n      // Look for new contacts.\n      this.findNewContacts();\n    }\n\n    // Handle TOI events.\n    if (this.m_continuousPhysics && timeStep > 0.0) {\n      this.m_solver.solveWorldTOI(this.s_step);\n    }\n\n    if (this.m_clearForces) {\n      this.clearForces();\n    }\n\n    this.m_locked = false;\n\n    this.publish('post-step', timeStep);\n  }\n\n  /**\n   * @internal\n   * Call this method to find new contacts.\n   */\n  findNewContacts(): void {\n    this.m_broadPhase.updatePairs(\n      (proxyA: FixtureProxy, proxyB: FixtureProxy) => this.createContact(proxyA, proxyB)\n    );\n  }\n\n  /**\n   * @internal\n   * Callback for broad-phase.\n   */\n  createContact(proxyA: FixtureProxy, proxyB: FixtureProxy): void {\n    const fixtureA = proxyA.fixture;\n    const fixtureB = proxyB.fixture;\n\n    const indexA = proxyA.childIndex;\n    const indexB = proxyB.childIndex;\n\n    const bodyA = fixtureA.getBody();\n    const bodyB = fixtureB.getBody();\n\n    // Are the fixtures on the same body?\n    if (bodyA == bodyB) {\n      return;\n    }\n\n    // TODO_ERIN use a hash table to remove a potential bottleneck when both\n    // bodies have a lot of contacts.\n    // Does a contact already exist?\n    let edge = bodyB.getContactList(); // ContactEdge\n    while (edge) {\n      if (edge.other == bodyA) {\n        const fA = edge.contact.getFixtureA();\n        const fB = edge.contact.getFixtureB();\n        const iA = edge.contact.getChildIndexA();\n        const iB = edge.contact.getChildIndexB();\n\n        if (fA == fixtureA && fB == fixtureB && iA == indexA && iB == indexB) {\n          // A contact already exists.\n          return;\n        }\n\n        if (fA == fixtureB && fB == fixtureA && iA == indexB && iB == indexA) {\n          // A contact already exists.\n          return;\n        }\n      }\n\n      edge = edge.next;\n    }\n\n    if (bodyB.shouldCollide(bodyA) == false) {\n      return;\n    }\n    if (fixtureB.shouldCollide(fixtureA) == false) {\n      return;\n    }\n\n    // Call the factory.\n    const contact = Contact.create(fixtureA, indexA, fixtureB, indexB);\n    if (contact == null) {\n      return;\n    }\n\n    // Insert into the world.\n    contact.m_prev = null;\n    if (this.m_contactList != null) {\n      contact.m_next = this.m_contactList;\n      this.m_contactList.m_prev = contact;\n    }\n    this.m_contactList = contact;\n\n    ++this.m_contactCount;\n  }\n\n  /**\n   * @internal\n   * Removes old non-overlapping contacts, applies filters and updates contacts.\n   */\n  updateContacts(): void {\n    // Update awake contacts.\n    let c;\n    let next_c = this.m_contactList;\n    while (c = next_c) {\n      next_c = c.getNext();\n      const fixtureA = c.getFixtureA();\n      const fixtureB = c.getFixtureB();\n      const indexA = c.getChildIndexA();\n      const indexB = c.getChildIndexB();\n      const bodyA = fixtureA.getBody();\n      const bodyB = fixtureB.getBody();\n\n      // Is this contact flagged for filtering?\n      if (c.m_filterFlag) {\n        if (bodyB.shouldCollide(bodyA) == false) {\n          this.destroyContact(c);\n          continue;\n        }\n\n        if (fixtureB.shouldCollide(fixtureA) == false) {\n          this.destroyContact(c);\n          continue;\n        }\n\n        // Clear the filtering flag.\n        c.m_filterFlag = false;\n      }\n\n      const activeA = bodyA.isAwake() && !bodyA.isStatic();\n      const activeB = bodyB.isAwake() && !bodyB.isStatic();\n\n      // At least one body must be awake and it must be dynamic or kinematic.\n      if (activeA == false && activeB == false) {\n        continue;\n      }\n\n      const proxyIdA = fixtureA.m_proxies[indexA].proxyId;\n      const proxyIdB = fixtureB.m_proxies[indexB].proxyId;\n      const overlap = this.m_broadPhase.testOverlap(proxyIdA, proxyIdB);\n\n      // Here we destroy contacts that cease to overlap in the broad-phase.\n      if (overlap == false) {\n        this.destroyContact(c);\n        continue;\n      }\n\n      // The contact persists.\n      c.update(this);\n    }\n  }\n\n  /** @internal */\n  destroyContact(contact: Contact): void {\n    // Remove from the world.\n    if (contact.m_prev) {\n      contact.m_prev.m_next = contact.m_next;\n    }\n    if (contact.m_next) {\n      contact.m_next.m_prev = contact.m_prev;\n    }\n    if (contact == this.m_contactList) {\n      this.m_contactList = contact.m_next;\n    }\n\n    Contact.destroy(contact, this);\n\n    --this.m_contactCount;\n  }\n\n\n  /**\n   * Called when two fixtures begin to touch.\n   *\n   * Implement contact callbacks to get contact information. You can use these\n   * results for things like sounds and game logic. You can also get contact\n   * results by traversing the contact lists after the time step. However, you\n   * might miss some contacts because continuous physics leads to sub-stepping.\n   * Additionally you may receive multiple callbacks for the same contact in a\n   * single time step. You should strive to make your callbacks efficient because\n   * there may be many callbacks per time step.\n   *\n   * Warning: You cannot create/destroy world entities inside these callbacks.\n   */\n  on(name: 'begin-contact', listener: (contact: Contact) => void): World;\n  /**\n   * Called when two fixtures cease to touch.\n   *\n   * Implement contact callbacks to get contact information. You can use these\n   * results for things like sounds and game logic. You can also get contact\n   * results by traversing the contact lists after the time step. However, you\n   * might miss some contacts because continuous physics leads to sub-stepping.\n   * Additionally you may receive multiple callbacks for the same contact in a\n   * single time step. You should strive to make your callbacks efficient because\n   * there may be many callbacks per time step.\n   *\n   * Warning: You cannot create/destroy world entities inside these callbacks.\n   */\n  on(name: 'end-contact', listener: (contact: Contact) => void): World;\n  /**\n   * This is called after a contact is updated. This allows you to inspect a\n   * contact before it goes to the solver. If you are careful, you can modify the\n   * contact manifold (e.g. disable contact). A copy of the old manifold is\n   * provided so that you can detect changes. Note: this is called only for awake\n   * bodies. Note: this is called even when the number of contact points is zero.\n   * Note: this is not called for sensors. Note: if you set the number of contact\n   * points to zero, you will not get an endContact callback. However, you may get\n   * a beginContact callback the next step.\n   *\n   * Warning: You cannot create/destroy world entities inside these callbacks.\n   */\n  on(name: 'pre-solve', listener: (contact: Contact, oldManifold: Manifold) => void): World;\n  /**\n   * This lets you inspect a contact after the solver is finished. This is useful\n   * for inspecting impulses. Note: the contact manifold does not include time of\n   * impact impulses, which can be arbitrarily large if the sub-step is small.\n   * Hence the impulse is provided explicitly in a separate data structure. Note:\n   * this is only called for contacts that are touching, solid, and awake.\n   *\n   * Warning: You cannot create/destroy world entities inside these callbacks.\n   */\n  on(name: 'post-solve', listener: (contact: Contact, impulse: ContactImpulse) => void): World;\n  /** Listener is called whenever a body is removed. */\n  on(name: 'remove-body', listener: (body: Body) => void): World;\n  /** Listener is called whenever a joint is removed implicitly or explicitly. */\n  on(name: 'remove-joint', listener: (joint: Joint) => void): World;\n  /** Listener is called whenever a fixture is removed implicitly or explicitly. */\n  on(name: 'remove-fixture', listener: (fixture: Fixture) => void): World;\n  /**\n   * Register an event listener.\n   */\n  // tslint:disable-next-line:typedef\n  on(name, listener) {\n    if (typeof name !== 'string' || typeof listener !== 'function') {\n      return this;\n    }\n    if (!this._listeners) {\n      this._listeners = {};\n    }\n    if (!this._listeners[name]) {\n      this._listeners[name] = [];\n    }\n    this._listeners[name].push(listener);\n    return this;\n  }\n\n  off(name: 'begin-contact', listener: (contact: Contact) => void): World;\n  off(name: 'end-contact', listener: (contact: Contact) => void): World;\n  off(name: 'pre-solve', listener: (contact: Contact, oldManifold: Manifold) => void): World;\n  off(name: 'post-solve', listener: (contact: Contact, impulse: ContactImpulse) => void): World;\n  off(name: 'remove-body', listener: (body: Body) => void): World;\n  off(name: 'remove-joint', listener: (joint: Joint) => void): World;\n  off(name: 'remove-fixture', listener: (fixture: Fixture) => void): World;\n  /**\n   * Remove an event listener.\n   */\n  // tslint:disable-next-line:typedef\n  off(name, listener) {\n    if (typeof name !== 'string' || typeof listener !== 'function') {\n      return this;\n    }\n    const listeners = this._listeners && this._listeners[name];\n    if (!listeners || !listeners.length) {\n      return this;\n    }\n    const index = listeners.indexOf(listener);\n    if (index >= 0) {\n      listeners.splice(index, 1);\n    }\n    return this;\n  }\n\n  publish(name: string, arg1?: any, arg2?: any, arg3?: any): number {\n    const listeners = this._listeners && this._listeners[name];\n    if (!listeners || !listeners.length) {\n      return 0;\n    }\n    for (let l = 0; l < listeners.length; l++) {\n      listeners[l].call(this, arg1, arg2, arg3);\n    }\n    return listeners.length;\n  }\n\n  /**\n   * @internal\n   */\n  beginContact(contact: Contact): void {\n    this.publish('begin-contact', contact);\n  }\n\n  /**\n   * @internal\n   */\n  endContact(contact: Contact): void {\n    this.publish('end-contact', contact);\n  }\n\n  /**\n   * @internal\n   */\n  preSolve(contact: Contact, oldManifold: Manifold): void {\n    this.publish('pre-solve', contact, oldManifold);\n  }\n\n  /**\n   * @internal\n   */\n  postSolve(contact: Contact, impulse: ContactImpulse): void {\n    this.publish('post-solve', contact, impulse);\n  }\n\n  /**\n   * Joints and fixtures are destroyed when their associated body is destroyed.\n   * Register a destruction listener so that you may nullify references to these\n   * joints and shapes.\n   *\n   * `function(object)` is called when any joint or fixture is about to\n   * be destroyed due to the destruction of one of its attached or parent bodies.\n   */\n\n  /**\n   * Register a contact filter to provide specific control over collision.\n   * Otherwise the default filter is used (defaultFilter). The listener is owned\n   * by you and must remain in scope.\n   *\n   * Moved to Fixture.\n   */\n}","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport * as matrix from './Matrix';\nimport { math as Math } from './Math';\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\nconst _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\nexport interface Vec3Value {\n  x: number;\n  y: number;\n  z: number;\n}\n\nexport class Vec3 {\n  x: number;\n  y: number;\n  z: number;\n\n  constructor(x: number, y: number, z: number);\n  constructor(obj: { x: number, y: number, z: number });\n  constructor();\n  // tslint:disable-next-line:typedef\n  constructor(x?, y?, z?) {\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof Vec3)) {\n      return new Vec3(x, y, z);\n    }\n    if (typeof x === 'undefined') {\n      this.x = 0;\n      this.y = 0;\n      this.z = 0;\n    } else if (typeof x === 'object') {\n      this.x = x.x;\n      this.y = x.y;\n      this.z = x.z;\n    } else {\n      this.x = x;\n      this.y = y;\n      this.z = z;\n    }\n    _ASSERT && Vec3.assert(this);\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      x: this.x,\n      y: this.y,\n      z: this.z\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any): Vec3 {\n    const obj = Object.create(Vec3.prototype);\n    obj.x = data.x;\n    obj.y = data.y;\n    obj.z = data.z;\n    return obj;\n  }\n\n  /** @internal */\n  static neo(x: number, y: number, z: number): Vec3 {\n    const obj = Object.create(Vec3.prototype);\n    obj.x = x;\n    obj.y = y;\n    obj.z = z;\n    return obj;\n  }\n\n  static zero(): Vec3 {\n    const obj = Object.create(Vec3.prototype);\n    obj.x = 0;\n    obj.y = 0;\n    obj.z = 0;\n    return obj;\n  }\n\n  static clone(v: Vec3Value): Vec3 {\n    _ASSERT && Vec3.assert(v);\n    return Vec3.neo(v.x, v.y, v.z);\n  }\n\n  /** @internal */\n  toString(): string {\n    return JSON.stringify(this);\n  }\n\n  /**\n   * Does this vector contain finite coordinates?\n   */\n  static isValid(obj: any): boolean {\n    if (obj === null || typeof obj === 'undefined') {\n      return false;\n    }\n    return Math.isFinite(obj.x) && Math.isFinite(obj.y) && Math.isFinite(obj.z);\n  }\n\n  static assert(o: any): void {\n    _ASSERT && console.assert(!Vec3.isValid(o), 'Invalid Vec3!', o);\n  }\n\n  setZero(): Vec3 {\n    this.x = 0.0;\n    this.y = 0.0;\n    this.z = 0.0;\n    return this;\n  }\n\n  set(x: number, y: number, z: number): Vec3 {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    return this;\n  }\n\n  add(w: Vec3Value): Vec3 {\n    this.x += w.x;\n    this.y += w.y;\n    this.z += w.z;\n    return this;\n  }\n\n  sub(w: Vec3Value): Vec3 {\n    this.x -= w.x;\n    this.y -= w.y;\n    this.z -= w.z;\n    return this;\n  }\n\n  mul(m: number): Vec3 {\n    this.x *= m;\n    this.y *= m;\n    this.z *= m;\n    return this;\n  }\n\n  static areEqual(v: Vec3Value, w: Vec3Value): boolean {\n    _ASSERT && Vec3.assert(v);\n    _ASSERT && Vec3.assert(w);\n    return v === w ||\n      typeof v === 'object' && v !== null &&\n      typeof w === 'object' && w !== null &&\n      v.x === w.x && v.y === w.y && v.z === w.z;\n  }\n\n  /**\n   * Perform the dot product on two vectors.\n   */\n  static dot(v: Vec3Value, w: Vec3Value): number {\n    return v.x * w.x + v.y * w.y + v.z * w.z;\n  }\n\n  /**\n   * Perform the cross product on two vectors. In 2D this produces a scalar.\n   */\n  static cross(v: Vec3Value, w: Vec3Value): Vec3 {\n    return new Vec3(\n      v.y * w.z - v.z * w.y,\n      v.z * w.x - v.x * w.z,\n      v.x * w.y - v.y * w.x\n    );\n  }\n\n  static add(v: Vec3Value, w: Vec3Value): Vec3 {\n    return new Vec3(v.x + w.x, v.y + w.y, v.z + w.z);\n  }\n\n  static sub(v: Vec3Value, w: Vec3Value): Vec3 {\n    return new Vec3(v.x - w.x, v.y - w.y, v.z - w.z);\n  }\n\n  static mul(v: Vec3Value, m: number): Vec3 {\n    return new Vec3(m * v.x, m * v.y, m * v.z);\n  }\n\n  neg(): Vec3 {\n    this.x = -this.x;\n    this.y = -this.y;\n    this.z = -this.z;\n    return this;\n  }\n\n  static neg(v: Vec3Value): Vec3 {\n    return new Vec3(-v.x, -v.y, -v.z);\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { SettingsInternal as Settings } from '../../Settings';\nimport * as matrix from '../../common/Matrix';\nimport { Shape } from '../Shape';\nimport { Transform, TransformValue } from '../../common/Transform';\nimport { Rot } from '../../common/Rot';\nimport { Vec2, Vec2Value } from '../../common/Vec2';\nimport { AABB, AABBValue, RayCastInput, RayCastOutput } from '../AABB';\nimport { MassData } from '../../dynamics/Body';\nimport { DistanceProxy } from '../Distance';\n\n\nconst _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\nconst v1 = matrix.vec2(0, 0);\nconst v2 = matrix.vec2(0, 0);\n\n/**\n * A line segment (edge) shape. These can be connected in chains or loops to\n * other edge shapes. The connectivity information is used to ensure correct\n * contact normals.\n */\nexport class EdgeShape extends Shape {\n  static TYPE = 'edge' as const;\n  m_type: 'edge';\n\n  m_radius: number;\n\n  // These are the edge vertices\n  m_vertex1: Vec2;\n  m_vertex2: Vec2;\n\n  // Optional adjacent vertices. These are used for smooth collision.\n  // Used by chain shape.\n  m_vertex0: Vec2;\n  m_vertex3: Vec2;\n  m_hasVertex0: boolean;\n  m_hasVertex3: boolean;\n\n  constructor(v1?: Vec2Value, v2?: Vec2Value) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof EdgeShape)) {\n      return new EdgeShape(v1, v2);\n    }\n\n    super();\n\n    this.m_type = EdgeShape.TYPE;\n    this.m_radius = Settings.polygonRadius;\n\n    this.m_vertex1 = v1 ? Vec2.clone(v1) : Vec2.zero();\n    this.m_vertex2 = v2 ? Vec2.clone(v2) : Vec2.zero();\n\n    this.m_vertex0 = Vec2.zero();\n    this.m_vertex3 = Vec2.zero();\n    this.m_hasVertex0 = false;\n    this.m_hasVertex3 = false;\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n\n      vertex1: this.m_vertex1,\n      vertex2: this.m_vertex2,\n\n      vertex0: this.m_vertex0,\n      vertex3: this.m_vertex3,\n      hasVertex0: this.m_hasVertex0,\n      hasVertex3: this.m_hasVertex3,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any): EdgeShape {\n    const shape = new EdgeShape(data.vertex1, data.vertex2);\n    if (shape.m_hasVertex0) {\n      shape.setPrevVertex(data.vertex0);\n    }\n    if (shape.m_hasVertex3) {\n      shape.setNextVertex(data.vertex3);\n    }\n    return shape;\n  }\n\n  /** @internal */\n  _reset(): void {\n    // noop\n  }\n\n  getRadius(): number {\n    return this.m_radius;\n  }\n\n  getType(): 'edge' {\n    return this.m_type;\n  }\n\n  /** @internal @deprecated */\n  setNext(v?: Vec2): EdgeShape {\n    return this.setNextVertex(v);\n  }\n\n  /**\n   * Optional next vertex, used for smooth collision.\n   */\n  setNextVertex(v?: Vec2): EdgeShape {\n    if (v) {\n      this.m_vertex3.setVec2(v);\n      this.m_hasVertex3 = true;\n    } else {\n      this.m_vertex3.setZero();\n      this.m_hasVertex3 = false;\n    }\n    return this;\n  }\n\n  /**\n   * Optional next vertex, used for smooth collision.\n   */\n  getNextVertex(): Vec2 {\n    return this.m_vertex3;\n  }\n\n  /** @internal @deprecated */\n  setPrev(v?: Vec2): EdgeShape {\n    return this.setPrevVertex(v);\n  }\n\n  /**\n   * Optional prev vertex, used for smooth collision.\n   */\n  setPrevVertex(v?: Vec2): EdgeShape {\n    if (v) {\n      this.m_vertex0.setVec2(v);\n      this.m_hasVertex0 = true;\n    } else {\n      this.m_vertex0.setZero();\n      this.m_hasVertex0 = false;\n    }\n    return this;\n  }\n\n  /**\n   * Optional prev vertex, used for smooth collision.\n   */\n  getPrevVertex(): Vec2 {\n    return this.m_vertex0;\n  }\n\n  /**\n   * Set this as an isolated edge.\n   */\n  _set(v1: Vec2, v2: Vec2): EdgeShape {\n    this.m_vertex1.setVec2(v1);\n    this.m_vertex2.setVec2(v2);\n    this.m_hasVertex0 = false;\n    this.m_hasVertex3 = false;\n    return this;\n  }\n\n  /**\n   * @internal\n   * @deprecated Shapes should be treated as immutable.\n   *\n   * clone the concrete shape.\n   */\n  _clone(): EdgeShape {\n    const clone = new EdgeShape();\n    clone.m_type = this.m_type;\n    clone.m_radius = this.m_radius;\n    clone.m_vertex1.setVec2(this.m_vertex1);\n    clone.m_vertex2.setVec2(this.m_vertex2);\n    clone.m_vertex0.setVec2(this.m_vertex0);\n    clone.m_vertex3.setVec2(this.m_vertex3);\n    clone.m_hasVertex0 = this.m_hasVertex0;\n    clone.m_hasVertex3 = this.m_hasVertex3;\n    return clone;\n  }\n\n  /**\n   * Get the number of child primitives.\n   */\n  getChildCount(): 1 {\n    return 1;\n  }\n\n  /**\n   * Test a point for containment in this shape. This only works for convex\n   * shapes.\n   *\n   * @param xf The shape world transform.\n   * @param p A point in world coordinates.\n   */\n  testPoint(xf: TransformValue, p: Vec2Value): false {\n    return false;\n  }\n\n  /**\n   * Cast a ray against a child shape.\n   *\n   * @param output The ray-cast results.\n   * @param input The ray-cast input parameters.\n   * @param xf The transform to be applied to the shape.\n   * @param childIndex The child shape index\n   */\n  rayCast(output: RayCastOutput, input: RayCastInput, xf: Transform, childIndex: number): boolean {\n    // p = p1 + t * d\n    // v = v1 + s * e\n    // p1 + t * d = v1 + s * e\n    // s * e - t * d = p1 - v1\n\n    // NOT_USED(childIndex);\n\n    // Put the ray into the edge's frame of reference.\n    const p1 = Rot.mulTVec2(xf.q, Vec2.sub(input.p1, xf.p));\n    const p2 = Rot.mulTVec2(xf.q, Vec2.sub(input.p2, xf.p));\n    const d = Vec2.sub(p2, p1);\n\n    const v1 = this.m_vertex1;\n    const v2 = this.m_vertex2;\n    const e = Vec2.sub(v2, v1);\n    const normal = Vec2.neo(e.y, -e.x);\n    normal.normalize();\n\n    // q = p1 + t * d\n    // dot(normal, q - v1) = 0\n    // dot(normal, p1 - v1) + t * dot(normal, d) = 0\n    const numerator = Vec2.dot(normal, Vec2.sub(v1, p1));\n    const denominator = Vec2.dot(normal, d);\n\n    if (denominator == 0.0) {\n      return false;\n    }\n\n    const t = numerator / denominator;\n    if (t < 0.0 || input.maxFraction < t) {\n      return false;\n    }\n\n    const q = Vec2.add(p1, Vec2.mulNumVec2(t, d));\n\n    // q = v1 + s * r\n    // s = dot(q - v1, r) / dot(r, r)\n    const r = Vec2.sub(v2, v1);\n    const rr = Vec2.dot(r, r);\n    if (rr == 0.0) {\n      return false;\n    }\n\n    const s = Vec2.dot(Vec2.sub(q, v1), r) / rr;\n    if (s < 0.0 || 1.0 < s) {\n      return false;\n    }\n\n    output.fraction = t;\n    if (numerator > 0.0) {\n      output.normal = Rot.mulVec2(xf.q, normal).neg();\n    } else {\n      output.normal = Rot.mulVec2(xf.q, normal);\n    }\n    return true;\n  }\n\n  /**\n   * Given a transform, compute the associated axis aligned bounding box for a\n   * child shape.\n   *\n   * @param aabb Returns the axis aligned box.\n   * @param xf The world transform of the shape.\n   * @param childIndex The child shape\n   */\n  computeAABB(aabb: AABBValue, xf: TransformValue, childIndex: number): void {\n    matrix.transformVec2(v1, xf, this.m_vertex1);\n    matrix.transformVec2(v2, xf, this.m_vertex2);\n\n    AABB.combinePoints(aabb, v1, v2);\n    AABB.extend(aabb, this.m_radius);\n  }\n\n  /**\n   * Compute the mass properties of this shape using its dimensions and density.\n   * The inertia tensor is computed about the local origin.\n   *\n   * @param massData Returns the mass data for this shape.\n   * @param density The density in kilograms per meter squared.\n   */\n  computeMass(massData: MassData, density?: number): void {\n    massData.mass = 0.0;\n    matrix.combineVec2(massData.center, 0.5, this.m_vertex1, 0.5, this.m_vertex2);\n    massData.I = 0.0;\n  }\n\n  computeDistanceProxy(proxy: DistanceProxy): void {\n    proxy.m_vertices[0] = this.m_vertex1;\n    proxy.m_vertices[1] = this.m_vertex2;\n    proxy.m_vertices.length = 2;\n    proxy.m_count = 2;\n    proxy.m_radius = this.m_radius;\n  }\n}\n\nexport const Edge = EdgeShape;\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport * as matrix from '../../common/Matrix';\nimport type { MassData } from '../../dynamics/Body';\nimport { AABBValue, RayCastOutput, RayCastInput, AABB } from '../AABB';\nimport { DistanceProxy } from '../Distance';\nimport { Transform, TransformValue } from '../../common/Transform';\nimport { Vec2, Vec2Value } from '../../common/Vec2';\nimport { SettingsInternal as Settings } from '../../Settings';\nimport { Shape } from '../Shape';\nimport { EdgeShape } from './EdgeShape';\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\nconst _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\nconst v1 = matrix.vec2(0, 0);\nconst v2 = matrix.vec2(0, 0);\n\n\n/**\n * A chain shape is a free form sequence of line segments. The chain has\n * two-sided collision, so you can use inside and outside collision. Therefore,\n * you may use any winding order. Connectivity information is used to create\n * smooth collisions.\n *\n * WARNING: The chain will not collide properly if there are self-intersections.\n */\nexport class ChainShape extends Shape {\n  static TYPE = 'chain' as const;\n  m_type: 'chain';\n\n  m_radius: number;\n\n  m_vertices: Vec2[];\n  m_count: number;\n  m_prevVertex: Vec2 | null;\n  m_nextVertex: Vec2 | null;\n  m_hasPrevVertex: boolean;\n  m_hasNextVertex: boolean;\n\n  m_isLoop: boolean;\n\n  constructor(vertices?: Vec2Value[], loop?: boolean) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof ChainShape)) {\n      return new ChainShape(vertices, loop);\n    }\n\n    super();\n\n    this.m_type = ChainShape.TYPE;\n    this.m_radius = Settings.polygonRadius;\n    this.m_vertices = [];\n    this.m_count = 0;\n    this.m_prevVertex = null;\n    this.m_nextVertex = null;\n    this.m_hasPrevVertex = false;\n    this.m_hasNextVertex = false;\n\n    this.m_isLoop = !!loop;\n\n    if (vertices && vertices.length) {\n      if (loop) {\n        this._createLoop(vertices);\n      } else {\n        this._createChain(vertices);\n      }\n    }\n  }\n\n  /** @internal */\n  _serialize(): object {\n    const data = {\n      type: this.m_type,\n      vertices: this.m_vertices,\n      isLoop: this.m_isLoop,\n      hasPrevVertex: this.m_hasPrevVertex,\n      hasNextVertex: this.m_hasNextVertex,\n      prevVertex: null as Vec2 | null,\n      nextVertex: null as Vec2 | null,\n    };\n    if (this.m_prevVertex) {\n      data.prevVertex = this.m_prevVertex;\n    }\n    if (this.m_nextVertex) {\n      data.nextVertex = this.m_nextVertex;\n    }\n    return data;\n  }\n\n  /** @internal */\n  static _deserialize(data: any, fixture: any, restore: any): ChainShape {\n    const vertices: Vec2[] = [];\n    if (data.vertices) {\n      for (let i = 0; i < data.vertices.length; i++) {\n        vertices.push(restore(Vec2, data.vertices[i]));\n      }\n    }\n    const shape = new ChainShape(vertices, data.isLoop);\n    if (data.prevVertex) {\n      shape.setPrevVertex(data.prevVertex);\n    }\n    if (data.nextVertex) {\n      shape.setNextVertex(data.nextVertex);\n    }\n    return shape;\n  }\n\n  // clear() {\n  //   this.m_vertices.length = 0;\n  //   this.m_count = 0;\n  // }\n\n  getType(): 'chain' {\n    return this.m_type;\n  }\n\n  getRadius(): number {\n    return this.m_radius;\n  }\n\n  /**\n   * @internal\n   * Create a loop. This automatically adjusts connectivity.\n   *\n   * @param vertices an array of vertices, these are copied\n   * @param count the vertex count\n   */\n  _createLoop(vertices: Vec2Value[]): ChainShape {\n    _ASSERT && console.assert(this.m_vertices.length == 0 && this.m_count == 0);\n    _ASSERT && console.assert(vertices.length >= 3);\n    if (vertices.length < 3) {\n      return;\n    }\n\n    for (let i = 1; i < vertices.length; ++i) {\n      const v1 = vertices[i - 1];\n      const v2 = vertices[i];\n      // If the code crashes here, it means your vertices are too close together.\n      _ASSERT && console.assert(Vec2.distanceSquared(v1, v2) > Settings.linearSlopSquared);\n    }\n\n    this.m_vertices = [];\n    this.m_count = vertices.length + 1;\n    for (let i = 0; i < vertices.length; ++i) {\n      this.m_vertices[i] = Vec2.clone(vertices[i]);\n    }\n    this.m_vertices[vertices.length] = Vec2.clone(vertices[0]);\n\n    this.m_prevVertex = this.m_vertices[this.m_count - 2];\n    this.m_nextVertex = this.m_vertices[1];\n    this.m_hasPrevVertex = true;\n    this.m_hasNextVertex = true;\n    return this;\n  }\n\n  /**\n   * @internal\n   * Create a chain with isolated end vertices.\n   *\n   * @param vertices an array of vertices, these are copied\n   * @param count the vertex count\n   */\n  _createChain(vertices: Vec2Value[]): ChainShape {\n    _ASSERT && console.assert(this.m_vertices.length == 0 && this.m_count == 0);\n    _ASSERT && console.assert(vertices.length >= 2);\n    for (let i = 1; i < vertices.length; ++i) {\n      // If the code crashes here, it means your vertices are too close together.\n      const v1 = vertices[i - 1];\n      const v2 = vertices[i];\n      _ASSERT && console.assert(Vec2.distanceSquared(v1, v2) > Settings.linearSlopSquared);\n    }\n\n    this.m_count = vertices.length;\n    for (let i = 0; i < vertices.length; ++i) {\n      this.m_vertices[i] = Vec2.clone(vertices[i]);\n    }\n\n    this.m_hasPrevVertex = false;\n    this.m_hasNextVertex = false;\n    this.m_prevVertex = null;\n    this.m_nextVertex = null;\n    return this;\n  }\n\n  /** @internal */\n  _reset(): void {\n    if (this.m_isLoop) {\n      this._createLoop(this.m_vertices);\n    } else {\n      this._createChain(this.m_vertices);\n    }\n  }\n\n  /**\n   * Establish connectivity to a vertex that precedes the first vertex. Don't call\n   * this for loops.\n   */\n  setPrevVertex(prevVertex: Vec2): void {\n    this.m_prevVertex = prevVertex;\n    this.m_hasPrevVertex = true;\n  }\n\n  getPrevVertex(): Vec2 {\n    return this.m_prevVertex;\n  }\n\n  /**\n   * Establish connectivity to a vertex that follows the last vertex. Don't call\n   * this for loops.\n   */\n  setNextVertex(nextVertex: Vec2): void {\n    this.m_nextVertex = nextVertex;\n    this.m_hasNextVertex = true;\n  }\n\n  getNextVertex(): Vec2 {\n    return this.m_nextVertex;\n  }\n\n  /**\n   * @internal\n   * @deprecated Shapes should be treated as immutable.\n   *\n   * clone the concrete shape.\n   */\n  _clone(): ChainShape {\n    const clone = new ChainShape();\n    clone._createChain(this.m_vertices);\n    clone.m_type = this.m_type;\n    clone.m_radius = this.m_radius;\n    clone.m_prevVertex = this.m_prevVertex;\n    clone.m_nextVertex = this.m_nextVertex;\n    clone.m_hasPrevVertex = this.m_hasPrevVertex;\n    clone.m_hasNextVertex = this.m_hasNextVertex;\n    return clone;\n  }\n\n  /**\n   * Get the number of child primitives.\n   */\n  getChildCount(): number {\n    // edge count = vertex count - 1\n    return this.m_count - 1;\n  }\n\n  // Get a child edge.\n  getChildEdge(edge: EdgeShape, childIndex: number): void {\n    _ASSERT && console.assert(0 <= childIndex && childIndex < this.m_count - 1);\n    edge.m_type = EdgeShape.TYPE;\n    edge.m_radius = this.m_radius;\n\n    edge.m_vertex1 = this.m_vertices[childIndex];\n    edge.m_vertex2 = this.m_vertices[childIndex + 1];\n\n    if (childIndex > 0) {\n      edge.m_vertex0 = this.m_vertices[childIndex - 1];\n      edge.m_hasVertex0 = true;\n    } else {\n      edge.m_vertex0 = this.m_prevVertex;\n      edge.m_hasVertex0 = this.m_hasPrevVertex;\n    }\n\n    if (childIndex < this.m_count - 2) {\n      edge.m_vertex3 = this.m_vertices[childIndex + 2];\n      edge.m_hasVertex3 = true;\n    } else {\n      edge.m_vertex3 = this.m_nextVertex;\n      edge.m_hasVertex3 = this.m_hasNextVertex;\n    }\n  }\n\n  getVertex(index: number): Vec2 {\n    _ASSERT && console.assert(0 <= index && index <= this.m_count);\n    if (index < this.m_count) {\n      return this.m_vertices[index];\n    } else {\n      return this.m_vertices[0];\n    }\n  }\n\n  isLoop(): boolean {\n    return this.m_isLoop;\n  }\n\n  /**\n   * Test a point for containment in this shape. This only works for convex\n   * shapes.\n   *\n   * This always return false.\n   *\n   * @param xf The shape world transform.\n   * @param p A point in world coordinates.\n   */\n  testPoint(xf: TransformValue, p: Vec2Value): false {\n    return false;\n  }\n\n  /**\n   * Cast a ray against a child shape.\n   *\n   * @param output The ray-cast results.\n   * @param input The ray-cast input parameters.\n   * @param xf The transform to be applied to the shape.\n   * @param childIndex The child shape index\n   */\n  rayCast(output: RayCastOutput, input: RayCastInput, xf: Transform, childIndex: number): boolean {\n    _ASSERT && console.assert(0 <= childIndex && childIndex < this.m_count);\n\n    const edgeShape = new EdgeShape(this.getVertex(childIndex), this.getVertex(childIndex + 1));\n    return edgeShape.rayCast(output, input, xf, 0);\n  }\n\n  /**\n   * Given a transform, compute the associated axis aligned bounding box for a\n   * child shape.\n   *\n   * @param aabb Returns the axis aligned box.\n   * @param xf The world transform of the shape.\n   * @param childIndex The child shape\n   */\n  computeAABB(aabb: AABBValue, xf: TransformValue, childIndex: number): void {\n    _ASSERT && console.assert(0 <= childIndex && childIndex < this.m_count);\n\n    matrix.transformVec2(v1, xf, this.getVertex(childIndex));\n    matrix.transformVec2(v2, xf, this.getVertex(childIndex + 1));\n\n    AABB.combinePoints(aabb, v1, v2);\n  }\n\n  /**\n   * Compute the mass properties of this shape using its dimensions and density.\n   * The inertia tensor is computed about the local origin.\n   *\n   * Chains have zero mass.\n   *\n   * @param massData Returns the mass data for this shape.\n   * @param density The density in kilograms per meter squared.\n   */\n  computeMass(massData: MassData, density?: number): void {\n    massData.mass = 0.0;\n    matrix.zeroVec2(massData.center)\n    massData.I = 0.0;\n  }\n\n  computeDistanceProxy(proxy: DistanceProxy, childIndex: number): void {\n    _ASSERT && console.assert(0 <= childIndex && childIndex < this.m_count);\n    proxy.m_vertices[0] = this.getVertex(childIndex);\n    proxy.m_vertices[1] = this.getVertex(childIndex + 1);\n    proxy.m_count = 2;\n    proxy.m_radius = this.m_radius;\n  }\n}\n\nexport const Chain = ChainShape;\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport * as matrix from '../../common/Matrix';\nimport type { MassData } from '../../dynamics/Body';\nimport { RayCastOutput, RayCastInput, AABBValue } from '../AABB';\nimport { DistanceProxy } from '../Distance';\nimport { math as Math } from '../../common/Math';\nimport { Transform, TransformValue } from '../../common/Transform';\nimport { Rot } from '../../common/Rot';\nimport { Vec2, Vec2Value } from '../../common/Vec2';\nimport { SettingsInternal as Settings } from '../../Settings';\nimport { Shape } from '../Shape';\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\nconst _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\nconst temp = matrix.vec2(0, 0);\nconst e = matrix.vec2(0, 0);\nconst e1 = matrix.vec2(0, 0);\nconst e2 = matrix.vec2(0, 0);\nconst center = matrix.vec2(0, 0);\nconst s = matrix.vec2(0, 0);\n\n/**\n * A convex polygon. It is assumed that the interior of the polygon is to the\n * left of each edge. Polygons have a maximum number of vertices equal to\n * Settings.maxPolygonVertices. In most cases you should not need many vertices\n * for a convex polygon. extends Shape\n */\nexport class PolygonShape extends Shape {\n  static TYPE = 'polygon' as const;\n  m_type: 'polygon';\n\n  m_centroid: Vec2;\n  m_vertices: Vec2[]; // [Settings.maxPolygonVertices]\n  m_normals: Vec2[]; // [Settings.maxPolygonVertices]\n  m_count: number;\n  m_radius: number;\n\n  // @ts-ignore\n  constructor(vertices?: Vec2Value[]) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof PolygonShape)) {\n      return new PolygonShape(vertices);\n    }\n\n    super();\n\n    this.m_type = PolygonShape.TYPE;\n    this.m_radius = Settings.polygonRadius;\n    this.m_centroid = Vec2.zero();\n    this.m_vertices = [];\n    this.m_normals = [];\n    this.m_count = 0;\n\n    if (vertices && vertices.length) {\n      this._set(vertices);\n    }\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n\n      vertices: this.m_vertices,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, fixture: any, restore: any): PolygonShape {\n    const vertices: Vec2[] = [];\n    if (data.vertices) {\n      for (let i = 0; i < data.vertices.length; i++) {\n        vertices.push(restore(Vec2, data.vertices[i]));\n      }\n    }\n\n    const shape = new PolygonShape(vertices);\n    return shape;\n  }\n\n  getType(): 'polygon' {\n    return this.m_type;\n  }\n\n  getRadius(): number {\n    return this.m_radius;\n  }\n\n  /**\n   * @internal\n   * @deprecated Shapes should be treated as immutable.\n   *\n   * clone the concrete shape.\n   */\n  _clone(): PolygonShape {\n    const clone = new PolygonShape();\n    clone.m_type = this.m_type;\n    clone.m_radius = this.m_radius;\n    clone.m_count = this.m_count;\n    clone.m_centroid.setVec2(this.m_centroid);\n    for (let i = 0; i < this.m_count; i++) {\n      clone.m_vertices.push(this.m_vertices[i].clone());\n    }\n    for (let i = 0; i < this.m_normals.length; i++) {\n      clone.m_normals.push(this.m_normals[i].clone());\n    }\n    return clone;\n  }\n\n  /**\n   * Get the number of child primitives.\n   */\n  getChildCount(): 1 {\n    return 1;\n  }\n\n  /** @internal */\n  _reset(): void {\n    this._set(this.m_vertices);\n  }\n\n  /**\n   * @internal\n   *\n   * Create a convex hull from the given array of local points. The count must be\n   * in the range [3, Settings.maxPolygonVertices].\n   *\n   * Warning: the points may be re-ordered, even if they form a convex polygon\n   * Warning: collinear points are handled but not removed. Collinear points may\n   * lead to poor stacking behavior.\n   */\n  _set(vertices: Vec2Value[]): void {\n    _ASSERT && console.assert(3 <= vertices.length && vertices.length <= Settings.maxPolygonVertices);\n    if (vertices.length < 3) {\n      this._setAsBox(1.0, 1.0);\n      return;\n    }\n\n    let n = Math.min(vertices.length, Settings.maxPolygonVertices);\n\n    // Perform welding and copy vertices into local buffer.\n    const ps: Vec2[] = []; // [Settings.maxPolygonVertices];\n    for (let i = 0; i < n; ++i) {\n      const v = vertices[i];\n\n      let unique = true;\n      for (let j = 0; j < ps.length; ++j) {\n        if (Vec2.distanceSquared(v, ps[j]) < 0.25 * Settings.linearSlopSquared) {\n          unique = false;\n          break;\n        }\n      }\n\n      if (unique) {\n        ps.push(Vec2.clone(v));\n      }\n    }\n\n    n = ps.length;\n    if (n < 3) {\n      // Polygon is degenerate.\n      _ASSERT && console.assert(false);\n      this._setAsBox(1.0, 1.0);\n      return;\n    }\n\n    // Create the convex hull using the Gift wrapping algorithm\n    // http://en.wikipedia.org/wiki/Gift_wrapping_algorithm\n\n    // Find the right most point on the hull (in case of multiple points bottom most is used)\n    let i0 = 0;\n    let x0 = ps[0].x;\n    for (let i = 1; i < n; ++i) {\n      const x = ps[i].x;\n      if (x > x0 || (x === x0 && ps[i].y < ps[i0].y)) {\n        i0 = i;\n        x0 = x;\n      }\n    }\n\n    const hull = [] as number[]; // [Settings.maxPolygonVertices];\n    let m = 0;\n    let ih = i0;\n\n    while (true) {\n      _ASSERT && console.assert(m < Settings.maxPolygonVertices);\n      hull[m] = ih;\n\n      let ie = 0;\n      for (let j = 1; j < n; ++j) {\n        if (ie === ih) {\n          ie = j;\n          continue;\n        }\n\n        const r = Vec2.sub(ps[ie], ps[hull[m]]);\n        const v = Vec2.sub(ps[j], ps[hull[m]]);\n        const c = Vec2.crossVec2Vec2(r, v);\n        // c < 0 means counter-clockwise wrapping, c > 0 means clockwise wrapping\n        if (c < 0.0) {\n          ie = j;\n        }\n\n        // Collinearity check\n        if (c === 0.0 && v.lengthSquared() > r.lengthSquared()) {\n          ie = j;\n        }\n      }\n\n      ++m;\n      ih = ie;\n\n      if (ie === i0) {\n        break;\n      }\n    }\n\n    if (m < 3) {\n      // Polygon is degenerate.\n      _ASSERT && console.assert(false);\n      this._setAsBox(1.0, 1.0);\n      return;\n    }\n\n    this.m_count = m;\n\n    // Copy vertices.\n    this.m_vertices = [];\n    for (let i = 0; i < m; ++i) {\n      this.m_vertices[i] = ps[hull[i]];\n    }\n\n    // Compute normals. Ensure the edges have non-zero length.\n    for (let i = 0; i < m; ++i) {\n      const i1 = i;\n      const i2 = i + 1 < m ? i + 1 : 0;\n      const edge = Vec2.sub(this.m_vertices[i2], this.m_vertices[i1]);\n      _ASSERT && console.assert(edge.lengthSquared() > Math.EPSILON * Math.EPSILON);\n      this.m_normals[i] = Vec2.crossVec2Num(edge, 1.0);\n      this.m_normals[i].normalize();\n    }\n\n    // Compute the polygon centroid.\n    this.m_centroid = ComputeCentroid(this.m_vertices, m);\n  }\n\n  /** @internal */\n  _setAsBox(hx: number, hy: number, center?: Vec2Value, angle?: number): void {\n    // start with right-bottom, counter-clockwise, as in Gift wrapping algorithm in PolygonShape._set()\n    this.m_vertices[0] = Vec2.neo(hx, -hy);\n    this.m_vertices[1] = Vec2.neo(hx, hy);\n    this.m_vertices[2] = Vec2.neo(-hx, hy);\n    this.m_vertices[3] = Vec2.neo(-hx, -hy);\n\n    this.m_normals[0] = Vec2.neo(1.0, 0.0);\n    this.m_normals[1] = Vec2.neo(0.0, 1.0);\n    this.m_normals[2] = Vec2.neo(-1.0, 0.0);\n    this.m_normals[3] = Vec2.neo(0.0, -1.0);\n\n    this.m_count = 4;\n\n    if (center && Vec2.isValid(center)) {\n      angle = angle || 0;\n\n      matrix.copyVec2(this.m_centroid, center);\n\n      const xf = Transform.identity();\n      xf.p.setVec2(center);\n      xf.q.setAngle(angle);\n\n      // Transform vertices and normals.\n      for (let i = 0; i < this.m_count; ++i) {\n        this.m_vertices[i] = Transform.mulVec2(xf, this.m_vertices[i]);\n        this.m_normals[i] = Rot.mulVec2(xf.q, this.m_normals[i]);\n      }\n    }\n  }\n\n  /**\n   * Test a point for containment in this shape. This only works for convex\n   * shapes.\n   *\n   * @param xf The shape world transform.\n   * @param p A point in world coordinates.\n   */\n  testPoint(xf: TransformValue, p: Vec2): boolean {\n    const pLocal = matrix.invTransformVec2(temp, xf, p);\n\n    for (let i = 0; i < this.m_count; ++i) {\n      const dot = matrix.dotVec2(this.m_normals[i], pLocal) - matrix.dotVec2(this.m_normals[i], this.m_vertices[i]);\n      if (dot > 0.0) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Cast a ray against a child shape.\n   *\n   * @param output The ray-cast results.\n   * @param input The ray-cast input parameters.\n   * @param xf The transform to be applied to the shape.\n   * @param childIndex The child shape index\n   */\n  rayCast(output: RayCastOutput, input: RayCastInput, xf: Transform, childIndex: number): boolean {\n\n    // Put the ray into the polygon's frame of reference.\n    const p1 = Rot.mulTVec2(xf.q, Vec2.sub(input.p1, xf.p));\n    const p2 = Rot.mulTVec2(xf.q, Vec2.sub(input.p2, xf.p));\n    const d = Vec2.sub(p2, p1);\n\n    let lower = 0.0;\n    let upper = input.maxFraction;\n\n    let index = -1;\n\n    for (let i = 0; i < this.m_count; ++i) {\n      // p = p1 + a * d\n      // dot(normal, p - v) = 0\n      // dot(normal, p1 - v) + a * dot(normal, d) = 0\n      const numerator = Vec2.dot(this.m_normals[i], Vec2.sub(this.m_vertices[i], p1));\n      const denominator = Vec2.dot(this.m_normals[i], d);\n\n      if (denominator == 0.0) {\n        if (numerator < 0.0) {\n          return false;\n        }\n      } else {\n        // Note: we want this predicate without division:\n        // lower < numerator / denominator, where denominator < 0\n        // Since denominator < 0, we have to flip the inequality:\n        // lower < numerator / denominator <==> denominator * lower > numerator.\n        if (denominator < 0.0 && numerator < lower * denominator) {\n          // Increase lower.\n          // The segment enters this half-space.\n          lower = numerator / denominator;\n          index = i;\n        } else if (denominator > 0.0 && numerator < upper * denominator) {\n          // Decrease upper.\n          // The segment exits this half-space.\n          upper = numerator / denominator;\n        }\n      }\n\n      // The use of epsilon here causes the assert on lower to trip\n      // in some cases. Apparently the use of epsilon was to make edge\n      // shapes work, but now those are handled separately.\n      // if (upper < lower - matrix.EPSILON)\n      if (upper < lower) {\n        return false;\n      }\n    }\n\n    _ASSERT && console.assert(0.0 <= lower && lower <= input.maxFraction);\n\n    if (index >= 0) {\n      output.fraction = lower;\n      output.normal = Rot.mulVec2(xf.q, this.m_normals[index]);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Given a transform, compute the associated axis aligned bounding box for a\n   * child shape.\n   *\n   * @param aabb Returns the axis aligned box.\n   * @param xf The world transform of the shape.\n   * @param childIndex The child shape\n   */\n  computeAABB(aabb: AABBValue, xf: TransformValue, childIndex: number): void {\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n    for (let i = 0; i < this.m_count; ++i) {\n      const v = matrix.transformVec2(temp, xf, this.m_vertices[i]);\n      minX = Math.min(minX, v.x);\n      maxX = Math.max(maxX, v.x);\n      minY = Math.min(minY, v.y);\n      maxY = Math.max(maxY, v.y);\n    }\n\n    matrix.setVec2(aabb.lowerBound, minX - this.m_radius, minY - this.m_radius);\n    matrix.setVec2(aabb.upperBound, maxX + this.m_radius, maxY + this.m_radius);\n  }\n\n  /**\n   * Compute the mass properties of this shape using its dimensions and density.\n   * The inertia tensor is computed about the local origin.\n   *\n   * @param massData Returns the mass data for this shape.\n   * @param density The density in kilograms per meter squared.\n   */\n  computeMass(massData: MassData, density: number): void {\n    // Polygon mass, centroid, and inertia.\n    // Let rho be the polygon density in mass per unit area.\n    // Then:\n    // mass = rho * int(dA)\n    // centroid.x = (1/mass) * rho * int(x * dA)\n    // centroid.y = (1/mass) * rho * int(y * dA)\n    // I = rho * int((x*x + y*y) * dA)\n    //\n    // We can compute these integrals by summing all the integrals\n    // for each triangle of the polygon. To evaluate the integral\n    // for a single triangle, we make a change of variables to\n    // the (u,v) coordinates of the triangle:\n    // x = x0 + e1x * u + e2x * v\n    // y = y0 + e1y * u + e2y * v\n    // where 0 <= u && 0 <= v && u + v <= 1.\n    //\n    // We integrate u from [0,1-v] and then v from [0,1].\n    // We also need to use the Jacobian of the transformation:\n    // D = cross(e1, e2)\n    //\n    // Simplification: triangle centroid = (1/3) * (p1 + p2 + p3)\n    //\n    // The rest of the derivation is handled by computer algebra.\n\n    _ASSERT && console.assert(this.m_count >= 3);\n\n    matrix.zeroVec2(center);\n    let area = 0.0;\n    let I = 0.0;\n\n    // s is the reference point for forming triangles.\n    // It's location doesn't change the result (except for rounding error).\n    matrix.zeroVec2(s);\n\n    // This code would put the reference point inside the polygon.\n    for (let i = 0; i < this.m_count; ++i) {\n      matrix.addVec2(s, this.m_vertices[i]);\n    }\n    matrix.setMulVec2(s, 1.0 / this.m_count, s);\n\n    const k_inv3 = 1.0 / 3.0;\n\n    for (let i = 0; i < this.m_count; ++i) {\n      // Triangle vertices.\n      matrix.diffVec2(e1, this.m_vertices[i], s);\n      if ( i + 1 < this.m_count) {\n        matrix.diffVec2(e2, this.m_vertices[i + 1], s);\n      } else {\n        matrix.diffVec2(e2, this.m_vertices[0], s);\n      }\n\n      const D = matrix.crossVec2Vec2(e1, e2);\n\n      const triangleArea = 0.5 * D;\n      area += triangleArea;\n\n      // Area weighted centroid\n      matrix.combineVec2(center, 1, center, triangleArea * k_inv3, e1);\n      matrix.combineVec2(center, 1, center, triangleArea * k_inv3, e2);\n\n      const ex1 = e1.x;\n      const ey1 = e1.y;\n      const ex2 = e2.x;\n      const ey2 = e2.y;\n\n      const intx2 = ex1 * ex1 + ex2 * ex1 + ex2 * ex2;\n      const inty2 = ey1 * ey1 + ey2 * ey1 + ey2 * ey2;\n\n      I += (0.25 * k_inv3 * D) * (intx2 + inty2);\n    }\n\n    // Total mass\n    massData.mass = density * area;\n\n    // Center of mass\n    _ASSERT && console.assert(area > Math.EPSILON);\n    matrix.setMulVec2(center, 1.0 / area, center);\n    matrix.sumVec2(massData.center, center, s);\n\n    // Inertia tensor relative to the local origin (point s).\n    massData.I = density * I;\n\n    // Shift to center of mass then to original body origin.\n    massData.I += massData.mass * (matrix.dotVec2(massData.center, massData.center) - matrix.dotVec2(center, center));\n  }\n\n  /**\n   * Validate convexity. This is a very time consuming operation.\n   * @returns true if valid\n   */\n  validate(): boolean {\n    for (let i = 0; i < this.m_count; ++i) {\n      const i1 = i;\n      const i2 = i < this.m_count - 1 ? i1 + 1 : 0;\n      const p = this.m_vertices[i1];\n      matrix.diffVec2(e, this.m_vertices[i2], p);\n\n      for (let j = 0; j < this.m_count; ++j) {\n        if (j == i1 || j == i2) {\n          continue;\n        }\n\n        const c = matrix.crossVec2Vec2(e, matrix.diffVec2(temp, this.m_vertices[j], p));\n        if (c < 0.0) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  computeDistanceProxy(proxy: DistanceProxy): void {\n    for (let i = 0; i < this.m_count; ++i) {\n      proxy.m_vertices[i] = this.m_vertices[i];\n    }\n    proxy.m_vertices.length = this.m_count;\n    proxy.m_count = this.m_count;\n    proxy.m_radius = this.m_radius;\n  }\n}\n\nfunction ComputeCentroid(vs: Vec2[], count: number): Vec2 {\n  _ASSERT && console.assert(count >= 3);\n\n  const c = Vec2.zero();\n  let area = 0.0;\n\n  // pRef is the reference point for forming triangles.\n  // It's location doesn't change the result (except for rounding error).\n  const pRef = Vec2.zero();\n  if (false) {\n    // This code would put the reference point inside the polygon.\n    for (let i = 0; i < count; ++i) {\n      pRef.add(vs[i]);\n    }\n    pRef.mul(1.0 / count);\n  }\n\n  const inv3 = 1.0 / 3.0;\n\n  for (let i = 0; i < count; ++i) {\n    // Triangle vertices.\n    const p1 = pRef;\n    const p2 = vs[i];\n    const p3 = i + 1 < count ? vs[i + 1] : vs[0];\n\n    const e1 = Vec2.sub(p2, p1);\n    const e2 = Vec2.sub(p3, p1);\n\n    const D = Vec2.crossVec2Vec2(e1, e2);\n\n    const triangleArea = 0.5 * D;\n    area += triangleArea;\n\n    // Area weighted centroid\n    c.addMul(triangleArea * inv3, p1);\n    c.addMul(triangleArea * inv3, p2);\n    c.addMul(triangleArea * inv3, p3);\n  }\n\n  // Centroid\n  _ASSERT && console.assert(area > Math.EPSILON);\n  c.mul(1.0 / area);\n  return c;\n}\n\nexport const Polygon = PolygonShape;\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport type { Vec2Value } from '../../common/Vec2';\nimport { PolygonShape } from './PolygonShape';\n\n\nconst _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\n/**\n * A rectangle polygon which extend PolygonShape.\n */\nexport class BoxShape extends PolygonShape {\n  static TYPE = 'polygon' as const;\n\n  constructor(hx: number, hy: number, center?: Vec2Value, angle?: number) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof BoxShape)) {\n      return new BoxShape(hx, hy, center, angle);\n    }\n\n    super();\n\n    this._setAsBox(hx, hy, center, angle);\n  }\n}\n\nexport const Box = BoxShape;\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport * as matrix from '../../common/Matrix';\nimport { math as Math } from '../../common/Math';\nimport { Rot } from '../../common/Rot';\nimport { Vec2, Vec2Value } from '../../common/Vec2';\nimport { Shape } from '../Shape';\nimport { AABBValue, RayCastInput, RayCastOutput } from '../AABB';\nimport { Transform, TransformValue } from '../../common/Transform';\nimport { MassData } from '../../dynamics/Body';\nimport { DistanceProxy } from '../Distance';\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\nconst _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\nconst temp = matrix.vec2(0, 0);\n\nexport class CircleShape extends Shape {\n  static TYPE = 'circle' as const;\n  m_type: 'circle';\n\n  m_p: Vec2;\n  m_radius: number;\n\n  constructor(position: Vec2Value, radius?: number);\n  constructor(radius?: number);\n  // tslint:disable-next-line:typedef\n  constructor(a, b?) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof CircleShape)) {\n      return new CircleShape(a, b);\n    }\n\n    super();\n\n    this.m_type = CircleShape.TYPE;\n    this.m_p = Vec2.zero();\n    this.m_radius = 1;\n\n    if (typeof a === 'object' && Vec2.isValid(a)) {\n      this.m_p.setVec2(a);\n\n      if (typeof b === 'number') {\n        this.m_radius = b;\n      }\n\n    } else if (typeof a === 'number') {\n      this.m_radius = a;\n    }\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n\n      p: this.m_p,\n      radius: this.m_radius,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any): CircleShape {\n    return new CircleShape(data.p, data.radius);\n  }\n\n  /** @internal */\n  _reset(): void {\n    // noop\n  }\n\n  getType(): 'circle' {\n    return this.m_type;\n  }\n\n  getRadius(): number {\n    return this.m_radius;\n  }\n\n  getCenter(): Vec2 {\n    return this.m_p;\n  }\n\n  /**\n   * @internal\n   * @deprecated Shapes should be treated as immutable.\n   *\n   * clone the concrete shape.\n   */\n  _clone(): CircleShape {\n    const clone = new CircleShape();\n    clone.m_type = this.m_type;\n    clone.m_radius = this.m_radius;\n    clone.m_p = this.m_p.clone();\n    return clone;\n  }\n\n  /**\n   * Get the number of child primitives.\n   */\n  getChildCount(): 1 {\n    return 1;\n  }\n\n  /**\n   * Test a point for containment in this shape. This only works for convex\n   * shapes.\n   *\n   * @param xf The shape world transform.\n   * @param p A point in world coordinates.\n   */\n  testPoint(xf: TransformValue, p: Vec2Value): boolean {\n    const center = matrix.transformVec2(temp, xf, this.m_p)\n    return matrix.distSqrVec2(p, center) <= this.m_radius * this.m_radius;\n  }\n\n  /**\n   * Cast a ray against a child shape.\n   *\n   * @param output The ray-cast results.\n   * @param input The ray-cast input parameters.\n   * @param xf The transform to be applied to the shape.\n   * @param childIndex The child shape index\n   */\n  rayCast(output: RayCastOutput, input: RayCastInput, xf: Transform, childIndex: number): boolean {\n    // Collision Detection in Interactive 3D Environments by Gino van den Bergen\n    // From Section 3.1.2\n    // x = s + a * r\n    // norm(x) = radius\n\n    const position = Vec2.add(xf.p, Rot.mulVec2(xf.q, this.m_p));\n    const s = Vec2.sub(input.p1, position);\n    const b = Vec2.dot(s, s) - this.m_radius * this.m_radius;\n\n    // Solve quadratic equation.\n    const r = Vec2.sub(input.p2, input.p1);\n    const c = Vec2.dot(s, r);\n    const rr = Vec2.dot(r, r);\n    const sigma = c * c - rr * b;\n\n    // Check for negative discriminant and short segment.\n    if (sigma < 0.0 || rr < Math.EPSILON) {\n      return false;\n    }\n\n    // Find the point of intersection of the line with the circle.\n    let a = -(c + Math.sqrt(sigma));\n\n    // Is the intersection point on the segment?\n    if (0.0 <= a && a <= input.maxFraction * rr) {\n      a /= rr;\n      output.fraction = a;\n      output.normal = Vec2.add(s, Vec2.mulNumVec2(a, r));\n      output.normal.normalize();\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Given a transform, compute the associated axis aligned bounding box for a\n   * child shape.\n   *\n   * @param aabb Returns the axis aligned box.\n   * @param xf The world transform of the shape.\n   * @param childIndex The child shape\n   */\n  computeAABB(aabb: AABBValue, xf: TransformValue, childIndex: number): void {\n    const p = matrix.transformVec2(temp, xf, this.m_p);\n\n    matrix.setVec2(aabb.lowerBound, p.x - this.m_radius, p.y - this.m_radius);\n    matrix.setVec2(aabb.upperBound, p.x + this.m_radius, p.y + this.m_radius);\n  }\n\n  /**\n   * Compute the mass properties of this shape using its dimensions and density.\n   * The inertia tensor is computed about the local origin.\n   *\n   * @param massData Returns the mass data for this shape.\n   * @param density The density in kilograms per meter squared.\n   */\n  computeMass(massData: MassData, density: number): void {\n    massData.mass = density * Math.PI * this.m_radius * this.m_radius;\n    matrix.copyVec2(massData.center, this.m_p);\n    // inertia about the local origin\n    massData.I = massData.mass * (0.5 * this.m_radius * this.m_radius + matrix.lengthSqrVec2(this.m_p));\n  }\n\n  computeDistanceProxy(proxy: DistanceProxy): void {\n    proxy.m_vertices[0] = this.m_p;\n    proxy.m_vertices.length = 1;\n    proxy.m_count = 1;\n    proxy.m_radius = this.m_radius;\n  }\n}\n\nexport const Circle = CircleShape;\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { options } from '../../util/options';\nimport { SettingsInternal as Settings } from '../../Settings';\nimport { math as Math } from '../../common/Math';\nimport { Vec2 } from '../../common/Vec2';\nimport { Rot } from '../../common/Rot';\nimport { Joint, JointOpt, JointDef } from '../Joint';\nimport { Body } from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\nconst _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\n/**\n * Distance joint definition. This requires defining an anchor point on both\n * bodies and the non-zero length of the distance joint. The definition uses\n * local anchor points so that the initial configuration can violate the\n * constraint slightly. This helps when saving and loading a game. Warning: Do\n * not use a zero or short length.\n */\nexport interface DistanceJointOpt extends JointOpt {\n  /**\n   * The mass-spring-damper frequency in Hertz. A value of 0 disables softness.\n   */\n  frequencyHz?: number;\n  /**\n   * The damping ratio. 0 = no damping, 1 = critical damping.\n   */\n  dampingRatio?: number;\n  /**\n   * Distance length.\n   */\n  length?: number;\n}\n/**\n * Distance joint definition. This requires defining an anchor point on both\n * bodies and the non-zero length of the distance joint. The definition uses\n * local anchor points so that the initial configuration can violate the\n * constraint slightly. This helps when saving and loading a game. Warning: Do\n * not use a zero or short length.\n */\nexport interface DistanceJointDef extends JointDef, DistanceJointOpt {\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  localAnchorA: Vec2;\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  localAnchorB: Vec2;\n}\n\nconst DEFAULTS = {\n  frequencyHz : 0.0,\n  dampingRatio : 0.0\n};\n\n/**\n * A distance joint constrains two points on two bodies to remain at a fixed\n * distance from each other. You can view this as a massless, rigid rod.\n *\n * @param anchorA Anchor A in global coordination.\n * @param anchorB Anchor B in global coordination.\n */\nexport class DistanceJoint extends Joint {\n  static TYPE = 'distance-joint' as const;\n\n  // Solver shared\n  /** @internal */ m_localAnchorA: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n  /** @internal */ m_length: number;\n  /** @internal */ m_frequencyHz: number;\n  /** @internal */ m_dampingRatio: number;\n  /** @internal */ m_impulse: number;\n  /** @internal */ m_gamma: number;\n  /** @internal */ m_bias: number;\n\n  // Solver temp\n  /** @internal */ m_u: Vec2;\n  /** @internal */ m_rA: Vec2;\n  /** @internal */ m_rB: Vec2;\n  /** @internal */ m_localCenterA: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_invMassA: number;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIA: number;\n  /** @internal */ m_invIB: number;\n  /** @internal */ m_mass: number;\n\n  constructor(def: DistanceJointDef);\n  constructor(def: DistanceJointOpt, bodyA: Body, bodyB: Body, anchorA: Vec2, anchorB: Vec2);\n  constructor(def: DistanceJointDef, bodyA?: Body, bodyB?: Body, anchorA?: Vec2, anchorB?: Vec2) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof DistanceJoint)) {\n      return new DistanceJoint(def, bodyA, bodyB, anchorA, anchorB);\n    }\n\n    // order of constructor arguments is changed in v0.2\n    if (bodyB && anchorA && ('m_type' in anchorA) && ('x' in bodyB) && ('y' in bodyB)) {\n      const temp = bodyB;\n      bodyB = anchorA as any as Body;\n      anchorA = temp as any as Vec2;\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = DistanceJoint.TYPE;\n\n    // Solver shared\n    this.m_localAnchorA = Vec2.clone(anchorA ? bodyA.getLocalPoint(anchorA) : def.localAnchorA || Vec2.zero());\n    this.m_localAnchorB = Vec2.clone(anchorB ? bodyB.getLocalPoint(anchorB) : def.localAnchorB || Vec2.zero());\n    this.m_length = Math.isFinite(def.length) ? def.length :\n      Vec2.distance(bodyA.getWorldPoint(this.m_localAnchorA), bodyB.getWorldPoint(this.m_localAnchorB));\n    this.m_frequencyHz = def.frequencyHz;\n    this.m_dampingRatio = def.dampingRatio;\n    this.m_impulse = 0.0;\n    this.m_gamma = 0.0;\n    this.m_bias = 0.0;\n\n    // 1-D constrained system\n    // m (v2 - v1) = lambda\n    // v2 + (beta/h) * x1 + gamma * lambda = 0, gamma has units of inverse mass.\n    // x2 = x1 + h * v2\n\n    // 1-D mass-damper-spring system\n    // m (v2 - v1) + h * d * v2 + h * k *\n\n    // C = norm(p2 - p1) - L\n    // u = (p2 - p1) / norm(p2 - p1)\n    // Cdot = dot(u, v2 + cross(w2, r2) - v1 - cross(w1, r1))\n    // J = [-u -cross(r1, u) u cross(r2, u)]\n    // K = J * invM * JT\n    // = invMass1 + invI1 * cross(r1, u)^2 + invMass2 + invI2 * cross(r2, u)^2\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      frequencyHz: this.m_frequencyHz,\n      dampingRatio: this.m_dampingRatio,\n\n      localAnchorA: this.m_localAnchorA,\n      localAnchorB: this.m_localAnchorB,\n      length: this.m_length,\n\n      impulse: this.m_impulse,\n      gamma: this.m_gamma,\n      bias: this.m_bias,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): DistanceJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    const joint = new DistanceJoint(data);\n    return joint;\n  }\n\n  /** @internal */\n  _setAnchors(def: {\n    anchorA?: Vec2,\n    localAnchorA?: Vec2,\n    anchorB?: Vec2,\n    localAnchorB?: Vec2,\n    length?: number,\n  }): void {\n    if (def.anchorA) {\n      this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n    } else if (def.localAnchorA) {\n      this.m_localAnchorA.setVec2(def.localAnchorA);\n    }\n\n    if (def.anchorB) {\n      this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n    } else if (def.localAnchorB) {\n      this.m_localAnchorB.setVec2(def.localAnchorB);\n    }\n\n    if (def.length > 0) {\n      this.m_length = +def.length;\n    } else if (def.length < 0) { // don't change length\n    } else if (def.anchorA || def.anchorA || def.anchorA || def.anchorA) {\n      this.m_length = Vec2.distance(\n          this.m_bodyA.getWorldPoint(this.m_localAnchorA),\n          this.m_bodyB.getWorldPoint(this.m_localAnchorB)\n      );\n    }\n  }\n\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  getLocalAnchorA(): Vec2 {\n    return this.m_localAnchorA;\n  }\n\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  getLocalAnchorB(): Vec2 {\n    return this.m_localAnchorB;\n  }\n\n  /**\n   * Set the natural length. Manipulating the length can lead to non-physical\n   * behavior when the frequency is zero.\n   */\n  setLength(length: number): void {\n    this.m_length = length;\n  }\n\n  /**\n   * Get the natural length.\n   */\n  getLength(): number {\n    return this.m_length;\n  }\n\n  setFrequency(hz: number): void {\n    this.m_frequencyHz = hz;\n  }\n\n  getFrequency(): number {\n    return this.m_frequencyHz;\n  }\n\n  setDampingRatio(ratio: number): void {\n    this.m_dampingRatio = ratio;\n  }\n\n  getDampingRatio(): number {\n    return this.m_dampingRatio;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.mulNumVec2(this.m_impulse, this.m_u).mul(inv_dt);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return 0.0;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassA = this.m_bodyA.m_invMass;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIA = this.m_bodyA.m_invI;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const cA = this.m_bodyA.c_position.c;\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const cB = this.m_bodyB.c_position.c;\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n    this.m_u = Vec2.sub(Vec2.add(cB, this.m_rB), Vec2.add(cA, this.m_rA));\n\n    // Handle singularity.\n    const length = this.m_u.length();\n    if (length > Settings.linearSlop) {\n      this.m_u.mul(1.0 / length);\n    } else {\n      this.m_u.setNum(0.0, 0.0);\n    }\n\n    const crAu = Vec2.crossVec2Vec2(this.m_rA, this.m_u);\n    const crBu = Vec2.crossVec2Vec2(this.m_rB, this.m_u);\n    let invMass = this.m_invMassA + this.m_invIA * crAu * crAu + this.m_invMassB\n        + this.m_invIB * crBu * crBu;\n\n    // Compute the effective mass matrix.\n    this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;\n\n    if (this.m_frequencyHz > 0.0) {\n      const C = length - this.m_length;\n\n      // Frequency\n      const omega = 2.0 * Math.PI * this.m_frequencyHz;\n\n      // Damping coefficient\n      const d = 2.0 * this.m_mass * this.m_dampingRatio * omega;\n\n      // Spring stiffness\n      const k = this.m_mass * omega * omega;\n\n      // magic formulas\n      const h = step.dt;\n      this.m_gamma = h * (d + h * k);\n      this.m_gamma = this.m_gamma != 0.0 ? 1.0 / this.m_gamma : 0.0;\n      this.m_bias = C * h * k * this.m_gamma;\n\n      invMass += this.m_gamma;\n      this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;\n    } else {\n      this.m_gamma = 0.0;\n      this.m_bias = 0.0;\n    }\n\n    if (step.warmStarting) {\n      // Scale the impulse to support a variable time step.\n      this.m_impulse *= step.dtRatio;\n\n      const P = Vec2.mulNumVec2(this.m_impulse, this.m_u);\n\n      vA.subMul(this.m_invMassA, P);\n      wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P);\n\n      vB.addMul(this.m_invMassB, P);\n      wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P);\n\n    } else {\n      this.m_impulse = 0.0;\n    }\n\n    this.m_bodyA.c_velocity.v.setVec2(vA);\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v.setVec2(vB);\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    // Cdot = dot(u, v + cross(w, r))\n    const vpA = Vec2.add(vA, Vec2.crossNumVec2(wA, this.m_rA));\n    const vpB = Vec2.add(vB, Vec2.crossNumVec2(wB, this.m_rB));\n    const Cdot = Vec2.dot(this.m_u, vpB) - Vec2.dot(this.m_u, vpA);\n\n    const impulse = -this.m_mass\n        * (Cdot + this.m_bias + this.m_gamma * this.m_impulse);\n    this.m_impulse += impulse;\n\n    const P = Vec2.mulNumVec2(impulse, this.m_u);\n    vA.subMul(this.m_invMassA, P);\n    wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P);\n    vB.addMul(this.m_invMassB, P);\n    wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P);\n\n    this.m_bodyA.c_velocity.v.setVec2(vA);\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v.setVec2(vB);\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    if (this.m_frequencyHz > 0.0) {\n      // There is no position correction for soft distance constraints.\n      return true;\n    }\n\n    const cA = this.m_bodyA.c_position.c;\n    let aA = this.m_bodyA.c_position.a;\n    const cB = this.m_bodyB.c_position.c;\n    let aB = this.m_bodyB.c_position.a;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    const rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);\n    const rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);\n    const u = Vec2.sub(Vec2.add(cB, rB), Vec2.add(cA, rA));\n\n    const length = u.normalize();\n    let C = length - this.m_length;\n    C = Math\n        .clamp(C, -Settings.maxLinearCorrection, Settings.maxLinearCorrection);\n\n    const impulse = -this.m_mass * C;\n    const P = Vec2.mulNumVec2(impulse, u);\n\n    cA.subMul(this.m_invMassA, P);\n    aA -= this.m_invIA * Vec2.crossVec2Vec2(rA, P);\n    cB.addMul(this.m_invMassB, P);\n    aB += this.m_invIB * Vec2.crossVec2Vec2(rB, P);\n\n    this.m_bodyA.c_position.c.setVec2(cA);\n    this.m_bodyA.c_position.a = aA;\n    this.m_bodyB.c_position.c.setVec2(cB);\n    this.m_bodyB.c_position.a = aB;\n\n    return Math.abs(C) < Settings.linearSlop;\n  }\n\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { options } from '../../util/options';\nimport { math as Math } from '../../common/Math';\nimport { Vec2 } from '../../common/Vec2';\nimport { Mat22 } from '../../common/Mat22';\nimport { Rot } from '../../common/Rot';\nimport { Joint, JointOpt, JointDef } from '../Joint';\nimport { Body } from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\nconst _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\n/**\n * Friction joint definition.\n */\nexport interface FrictionJointOpt extends JointOpt {\n  /**\n   * The maximum friction force in N.\n   */\n  maxForce?: number;\n  /**\n   * The maximum friction torque in N-m.\n   */\n  maxTorque?: number;\n}\n/**\n * Friction joint definition.\n */\nexport interface FrictionJointDef extends JointDef, FrictionJointOpt {\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  localAnchorA: Vec2;\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  localAnchorB: Vec2;\n}\n\nconst DEFAULTS = {\n  maxForce : 0.0,\n  maxTorque : 0.0,\n};\n\n/**\n * Friction joint. This is used for top-down friction. It provides 2D\n * translational friction and angular friction.\n *\n * @param anchor Anchor in global coordination.\n */\nexport class FrictionJoint extends Joint {\n  static TYPE = 'friction-joint' as const;\n\n  /** @internal */ m_type: 'friction-joint';\n\n  /** @internal */ m_localAnchorA: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n\n  // Solver shared\n  /** @internal */ m_linearImpulse: Vec2;\n  /** @internal */ m_angularImpulse: number;\n  /** @internal */ m_maxForce: number;\n  /** @internal */ m_maxTorque: number;\n\n  // Solver temp\n  /** @internal */ m_rA: Vec2;\n  /** @internal */ m_rB: Vec2;\n  /** @internal */ m_localCenterA: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_invMassA: number;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIA: number;\n  /** @internal */ m_invIB: number;\n  /** @internal */ m_linearMass: Mat22;\n  /** @internal */ m_angularMass: number;\n\n  constructor(def: FrictionJointDef);\n  constructor(def: FrictionJointOpt, bodyA: Body, bodyB: Body, anchor: Vec2);\n  constructor(def: FrictionJointDef, bodyA?: Body, bodyB?: Body, anchor?: Vec2) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof FrictionJoint)) {\n      return new FrictionJoint(def, bodyA, bodyB, anchor);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = FrictionJoint.TYPE;\n\n    this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n    this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n\n    // Solver shared\n    this.m_linearImpulse = Vec2.zero();\n    this.m_angularImpulse = 0.0;\n    this.m_maxForce = def.maxForce;\n    this.m_maxTorque = def.maxTorque;\n\n    // Point-to-point constraint\n    // Cdot = v2 - v1\n    // = v2 + cross(w2, r2) - v1 - cross(w1, r1)\n    // J = [-I -r1_skew I r2_skew ]\n    // Identity used:\n    // w k % (rx i + ry j) = w * (-ry i + rx j)\n\n    // Angle constraint\n    // Cdot = w2 - w1\n    // J = [0 0 -1 0 0 1]\n    // K = invI1 + invI2\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      maxForce: this.m_maxForce,\n      maxTorque: this.m_maxTorque,\n\n      localAnchorA: this.m_localAnchorA,\n      localAnchorB: this.m_localAnchorB,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): FrictionJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    const joint = new FrictionJoint(data);\n    return joint;\n  }\n\n  /** @internal */\n  _setAnchors(def: {\n    anchorA?: Vec2,\n    localAnchorA?: Vec2,\n    anchorB?: Vec2,\n    localAnchorB?: Vec2,\n  }): void {\n    if (def.anchorA) {\n      this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n    } else if (def.localAnchorA) {\n      this.m_localAnchorA.setVec2(def.localAnchorA);\n    }\n\n    if (def.anchorB) {\n      this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n    } else if (def.localAnchorB) {\n      this.m_localAnchorB.setVec2(def.localAnchorB);\n    }\n  }\n\n\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  getLocalAnchorA(): Vec2 {\n    return this.m_localAnchorA;\n  }\n\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  getLocalAnchorB(): Vec2 {\n    return this.m_localAnchorB;\n  }\n\n  /**\n   * Set the maximum friction force in N.\n   */\n  setMaxForce(force: number): void {\n    _ASSERT && console.assert(Math.isFinite(force) && force >= 0.0);\n    this.m_maxForce = force;\n  }\n\n  /**\n   * Get the maximum friction force in N.\n   */\n  getMaxForce(): number {\n    return this.m_maxForce;\n  }\n\n  /**\n   * Set the maximum friction torque in N*m.\n   */\n  setMaxTorque(torque: number): void {\n    _ASSERT && console.assert(Math.isFinite(torque) && torque >= 0.0);\n    this.m_maxTorque = torque;\n  }\n\n  /**\n   * Get the maximum friction torque in N*m.\n   */\n  getMaxTorque(): number {\n    return this.m_maxTorque;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.mulNumVec2(inv_dt, this.m_linearImpulse);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return inv_dt * this.m_angularImpulse;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassA = this.m_bodyA.m_invMass;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIA = this.m_bodyA.m_invI;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    // Compute the effective mass matrix.\n    this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n\n    // J = [-I -r1_skew I r2_skew]\n    // [ 0 -1 0 1]\n    // r_skew = [-ry; rx]\n\n    // Matlab\n    // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]\n    // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]\n    // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    const K = new Mat22();\n    K.ex.x = mA + mB + iA * this.m_rA.y * this.m_rA.y + iB * this.m_rB.y\n        * this.m_rB.y;\n    K.ex.y = -iA * this.m_rA.x * this.m_rA.y - iB * this.m_rB.x * this.m_rB.y;\n    K.ey.x = K.ex.y;\n    K.ey.y = mA + mB + iA * this.m_rA.x * this.m_rA.x + iB * this.m_rB.x\n        * this.m_rB.x;\n\n    this.m_linearMass = K.getInverse();\n\n    this.m_angularMass = iA + iB;\n    if (this.m_angularMass > 0.0) {\n      this.m_angularMass = 1.0 / this.m_angularMass;\n    }\n\n    if (step.warmStarting) {\n      // Scale impulses to support a variable time step.\n      this.m_linearImpulse.mul(step.dtRatio);\n      this.m_angularImpulse *= step.dtRatio;\n\n      const P = Vec2.neo(this.m_linearImpulse.x, this.m_linearImpulse.y);\n\n      vA.subMul(mA, P);\n      wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + this.m_angularImpulse);\n\n      vB.addMul(mB, P);\n      wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + this.m_angularImpulse);\n\n    } else {\n      this.m_linearImpulse.setZero();\n      this.m_angularImpulse = 0.0;\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    const h = step.dt; // float\n\n    // Solve angular friction\n    {\n      const Cdot = wB - wA; // float\n      let impulse = -this.m_angularMass * Cdot; // float\n\n      const oldImpulse = this.m_angularImpulse; // float\n      const maxImpulse = h * this.m_maxTorque; // float\n      this.m_angularImpulse = Math.clamp(this.m_angularImpulse + impulse,\n          -maxImpulse, maxImpulse);\n      impulse = this.m_angularImpulse - oldImpulse;\n\n      wA -= iA * impulse;\n      wB += iB * impulse;\n    }\n\n    // Solve linear friction\n    {\n      const Cdot = Vec2.sub(Vec2.add(vB, Vec2.crossNumVec2(wB, this.m_rB)), Vec2.add(vA,\n          Vec2.crossNumVec2(wA, this.m_rA))); // Vec2\n\n      let impulse = Vec2.neg(Mat22.mulVec2(this.m_linearMass, Cdot)); // Vec2\n      const oldImpulse = this.m_linearImpulse; // Vec2\n      this.m_linearImpulse.add(impulse);\n\n      const maxImpulse = h * this.m_maxForce; // float\n\n      if (this.m_linearImpulse.lengthSquared() > maxImpulse * maxImpulse) {\n        this.m_linearImpulse.normalize();\n        this.m_linearImpulse.mul(maxImpulse);\n      }\n\n      impulse = Vec2.sub(this.m_linearImpulse, oldImpulse);\n\n      vA.subMul(mA, impulse);\n      wA -= iA * Vec2.crossVec2Vec2(this.m_rA, impulse);\n\n      vB.addMul(mB, impulse);\n      wB += iB * Vec2.crossVec2Vec2(this.m_rB, impulse);\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    return true;\n  }\n\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { Vec2, Vec2Value } from './Vec2';\nimport { Vec3, Vec3Value } from './Vec3';\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\n/**\n * A 3-by-3 matrix. Stored in column-major order.\n */\nexport class Mat33 {\n  ex: Vec3;\n  ey: Vec3;\n  ez: Vec3;\n\n  constructor(a: Vec3Value, b: Vec3Value, c: Vec3Value);\n  constructor();\n  constructor(a?: Vec3Value, b?: Vec3Value, c?: Vec3Value) {\n    if (typeof a === 'object' && a !== null) {\n      this.ex = Vec3.clone(a);\n      this.ey = Vec3.clone(b);\n      this.ez = Vec3.clone(c);\n    } else {\n      this.ex = Vec3.zero();\n      this.ey = Vec3.zero();\n      this.ez = Vec3.zero();\n    }\n  }\n\n  /** @internal */\n  toString(): string {\n    return JSON.stringify(this);\n  }\n\n  static isValid(obj: any): boolean {\n    if (obj === null || typeof obj === 'undefined') {\n      return false;\n    }\n    return Vec3.isValid(obj.ex) && Vec3.isValid(obj.ey) && Vec3.isValid(obj.ez);\n  }\n\n  static assert(o: any): void {\n    _ASSERT && console.assert(!Mat33.isValid(o), 'Invalid Mat33!', o);\n  }\n\n  /**\n   * Set this matrix to all zeros.\n   */\n  setZero(): Mat33 {\n    this.ex.setZero();\n    this.ey.setZero();\n    this.ez.setZero();\n    return this;\n  }\n\n  /**\n   * Solve A * x = b, where b is a column vector. This is more efficient than\n   * computing the inverse in one-shot cases.\n   */\n  solve33(v: Vec3Value): Vec3 {\n    // let det = matrix.dotVec3(this.ex, matrix.newCrossVec3(this.ey, this.ez));\n    let cross_x = this.ey.y * this.ez.z - this.ey.z * this.ez.y;\n    let cross_y = this.ey.z * this.ez.x - this.ey.x * this.ez.z;\n    let cross_z = this.ey.x * this.ez.y - this.ey.y * this.ez.x;\n    let det = this.ex.x * cross_x + this.ex.y * cross_y + this.ex.z * cross_z;\n    if (det !== 0.0) {\n      det = 1.0 / det;\n    }\n    const r = new Vec3();\n    // r.x = det * matrix.dotVec3(v, matrix.newCrossVec3(this.ey, this.ez));\n    cross_x = this.ey.y * this.ez.z - this.ey.z * this.ez.y;\n    cross_y = this.ey.z * this.ez.x - this.ey.x * this.ez.z;\n    cross_z = this.ey.x * this.ez.y - this.ey.y * this.ez.x;\n    r.x = det * (v.x * cross_x + v.y * cross_y + v.z * cross_z);\n\n    // r.y = det * matrix.dotVec3(this.ex, matrix.newCrossVec3(v, this.ez));\n    cross_x = v.y * this.ez.z - v.z * this.ez.y;\n    cross_y = v.z * this.ez.x - v.x * this.ez.z;\n    cross_z = v.x * this.ez.y - v.y * this.ez.x;\n    r.y = det * (this.ex.x * cross_x + this.ex.y * cross_y + this.ex.z * cross_z);\n\n    // r.z = det * matrix.dotVec3(this.ex, matrix.newCrossVec3(this.ey, v));\n    cross_x = this.ey.y * v.z - this.ey.z * v.y;\n    cross_y = this.ey.z * v.x - this.ey.x * v.z;\n    cross_z = this.ey.x * v.y - this.ey.y * v.x;\n    r.z = det * (this.ex.x * cross_x + this.ex.y * cross_y + this.ex.z * cross_z);\n    return r;\n  }\n\n  /**\n   * Solve A * x = b, where b is a column vector. This is more efficient than\n   * computing the inverse in one-shot cases. Solve only the upper 2-by-2 matrix\n   * equation.\n   */\n  solve22(v: Vec2Value): Vec2 {\n    const a11 = this.ex.x;\n    const a12 = this.ey.x;\n    const a21 = this.ex.y;\n    const a22 = this.ey.y;\n    let det = a11 * a22 - a12 * a21;\n    if (det !== 0.0) {\n      det = 1.0 / det;\n    }\n    const r = Vec2.zero();\n    r.x = det * (a22 * v.x - a12 * v.y);\n    r.y = det * (a11 * v.y - a21 * v.x);\n    return r;\n  }\n\n  /**\n   * Get the inverse of this matrix as a 2-by-2. Returns the zero matrix if\n   * singular.\n   */\n  getInverse22(M: Mat33): void {\n    const a = this.ex.x;\n    const b = this.ey.x;\n    const c = this.ex.y;\n    const d = this.ey.y;\n    let det = a * d - b * c;\n    if (det !== 0.0) {\n      det = 1.0 / det;\n    }\n    M.ex.x = det * d;\n    M.ey.x = -det * b;\n    M.ex.z = 0.0;\n    M.ex.y = -det * c;\n    M.ey.y = det * a;\n    M.ey.z = 0.0;\n    M.ez.x = 0.0;\n    M.ez.y = 0.0;\n    M.ez.z = 0.0;\n  }\n\n  /**\n   * Get the symmetric inverse of this matrix as a 3-by-3. Returns the zero matrix\n   * if singular.\n   */\n  getSymInverse33(M: Mat33): void {\n    let det = Vec3.dot(this.ex, Vec3.cross(this.ey, this.ez));\n    if (det !== 0.0) {\n      det = 1.0 / det;\n    }\n    const a11 = this.ex.x;\n    const a12 = this.ey.x;\n    const a13 = this.ez.x;\n    const a22 = this.ey.y;\n    const a23 = this.ez.y;\n    const a33 = this.ez.z;\n\n    M.ex.x = det * (a22 * a33 - a23 * a23);\n    M.ex.y = det * (a13 * a23 - a12 * a33);\n    M.ex.z = det * (a12 * a23 - a13 * a22);\n\n    M.ey.x = M.ex.y;\n    M.ey.y = det * (a11 * a33 - a13 * a13);\n    M.ey.z = det * (a13 * a12 - a11 * a23);\n\n    M.ez.x = M.ex.z;\n    M.ez.y = M.ey.z;\n    M.ez.z = det * (a11 * a22 - a12 * a12);\n  }\n\n  /**\n   * Multiply a matrix times a vector.\n   */\n  static mul(a: Mat33, b: Vec2Value): Vec2;\n  static mul(a: Mat33, b: Vec3Value): Vec3;\n  // tslint:disable-next-line:typedef\n  static mul(a, b) {\n    _ASSERT && Mat33.assert(a);\n    if (b && 'z' in b && 'y' in b && 'x' in b) {\n      _ASSERT && Vec3.assert(b);\n      const x = a.ex.x * b.x + a.ey.x * b.y + a.ez.x * b.z;\n      const y = a.ex.y * b.x + a.ey.y * b.y + a.ez.y * b.z;\n      const z = a.ex.z * b.x + a.ey.z * b.y + a.ez.z * b.z;\n      return new Vec3(x, y, z);\n\n    } else if (b && 'y' in b && 'x' in b) {\n      _ASSERT && Vec2.assert(b);\n      const x = a.ex.x * b.x + a.ey.x * b.y;\n      const y = a.ex.y * b.x + a.ey.y * b.y;\n      return Vec2.neo(x, y);\n    }\n\n    _ASSERT && console.assert(false);\n  }\n\n  static mulVec3(a: Mat33, b: Vec3): Vec3 {\n    _ASSERT && Mat33.assert(a);\n    _ASSERT && Vec3.assert(b);\n    const x = a.ex.x * b.x + a.ey.x * b.y + a.ez.x * b.z;\n    const y = a.ex.y * b.x + a.ey.y * b.y + a.ez.y * b.z;\n    const z = a.ex.z * b.x + a.ey.z * b.y + a.ez.z * b.z;\n    return new Vec3(x, y, z);\n  }\n\n  static mulVec2(a: Mat33, b: Vec2Value): Vec2 {\n    _ASSERT && Mat33.assert(a);\n    _ASSERT && Vec2.assert(b);\n    const x = a.ex.x * b.x + a.ey.x * b.y;\n    const y = a.ex.y * b.x + a.ey.y * b.y;\n    return Vec2.neo(x, y);\n  }\n\n  static add(a: Mat33, b: Mat33): Mat33 {\n    _ASSERT && Mat33.assert(a);\n    _ASSERT && Mat33.assert(b);\n    return new Mat33(\n      Vec3.add(a.ex, b.ex),\n      Vec3.add(a.ey, b.ey),\n      Vec3.add(a.ez, b.ez)\n    );\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { options } from '../../util/options';\nimport { SettingsInternal as Settings } from '../../Settings';\nimport { math as Math } from '../../common/Math';\nimport { Vec2 } from '../../common/Vec2';\nimport { Vec3 } from '../../common/Vec3';\nimport { Mat22 } from '../../common/Mat22';\nimport { Mat33 } from '../../common/Mat33';\nimport { Rot } from '../../common/Rot';\nimport { Joint, JointOpt, JointDef } from '../Joint';\nimport { Body } from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\nconst _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\nconst inactiveLimit = 0;\nconst atLowerLimit = 1;\nconst atUpperLimit = 2;\nconst equalLimits = 3;\n\n/**\n * Revolute joint definition. This requires defining an anchor point where the\n * bodies are joined. The definition uses local anchor points so that the\n * initial configuration can violate the constraint slightly. You also need to\n * specify the initial relative angle for joint limits. This helps when saving\n * and loading a game.\n *\n * The local anchor points are measured from the body's origin rather than the\n * center of mass because: 1. you might not know where the center of mass will\n * be. 2. if you add/remove shapes from a body and recompute the mass, the\n * joints will be broken.\n */\nexport interface RevoluteJointOpt extends JointOpt {\n  /**\n   * The lower angle for the joint limit (radians).\n   */\n  lowerAngle?: number;\n  /**\n   * The upper angle for the joint limit (radians).\n   */\n  upperAngle?: number;\n  /**\n   * The maximum motor torque used to achieve the desired motor speed. Usually\n   * in N-m.\n   */\n  maxMotorTorque?: number;\n  /**\n   * The desired motor speed. Usually in radians per second.\n   */\n  motorSpeed?: number;\n  /**\n   * A flag to enable joint limits.\n   */\n  enableLimit?: boolean;\n  /**\n   * A flag to enable the joint motor.\n   */\n  enableMotor?: boolean;\n}\n/**\n * Revolute joint definition. This requires defining an anchor point where the\n * bodies are joined. The definition uses local anchor points so that the\n * initial configuration can violate the constraint slightly. You also need to\n * specify the initial relative angle for joint limits. This helps when saving\n * and loading a game.\n *\n * The local anchor points are measured from the body's origin rather than the\n * center of mass because: 1. you might not know where the center of mass will\n * be. 2. if you add/remove shapes from a body and recompute the mass, the\n * joints will be broken.\n */\nexport interface RevoluteJointDef extends JointDef, RevoluteJointOpt {\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  localAnchorA: Vec2;\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  localAnchorB: Vec2;\n  /**\n   * The bodyB angle minus bodyA angle in the reference state (radians).\n   */\n  referenceAngle: number;\n}\n\nconst DEFAULTS = {\n  lowerAngle : 0.0,\n  upperAngle : 0.0,\n  maxMotorTorque : 0.0,\n  motorSpeed : 0.0,\n  enableLimit : false,\n  enableMotor : false\n};\n\n/**\n * A revolute joint constrains two bodies to share a common point while they are\n * free to rotate about the point. The relative rotation about the shared point\n * is the joint angle. You can limit the relative rotation with a joint limit\n * that specifies a lower and upper angle. You can use a motor to drive the\n * relative rotation about the shared point. A maximum motor torque is provided\n * so that infinite forces are not generated.\n */\nexport class RevoluteJoint extends Joint {\n  static TYPE = 'revolute-joint' as const;\n\n  /** @internal */ m_type: 'revolute-joint';\n  /** @internal */ m_localAnchorA: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n  /** @internal */ m_referenceAngle: number;\n  /** @internal */ m_impulse: Vec3;\n  /** @internal */ m_motorImpulse: number;\n  /** @internal */ m_lowerAngle: number;\n  /** @internal */ m_upperAngle: number;\n  /** @internal */ m_maxMotorTorque: number;\n  /** @internal */ m_motorSpeed: number;\n  /** @internal */ m_enableLimit: boolean;\n  /** @internal */ m_enableMotor: boolean;\n\n  // Solver temp\n  /** @internal */ m_rA: Vec2;\n  /** @internal */ m_rB: Vec2;\n  /** @internal */ m_localCenterA: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_invMassA: number;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIA: number;\n  /** @internal */ m_invIB: number;\n  // effective mass for point-to-point constraint.\n  /** @internal */ m_mass: Mat33 = new Mat33();\n  // effective mass for motor/limit angular constraint.\n  /** @internal */ m_motorMass: number;\n  /** @internal */ m_limitState: number = inactiveLimit; // TODO enum\n\n  constructor(def: RevoluteJointDef);\n  constructor(def: RevoluteJointOpt, bodyA: Body, bodyB: Body, anchor: Vec2);\n  // @ts-ignore\n  constructor(def: RevoluteJointDef, bodyA?: Body, bodyB?: Body, anchor?: Vec2) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof RevoluteJoint)) {\n      return new RevoluteJoint(def, bodyA, bodyB, anchor);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = RevoluteJoint.TYPE;\n\n    this.m_localAnchorA =  Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n    this.m_localAnchorB =  Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n    this.m_referenceAngle = Math.isFinite(def.referenceAngle) ? def.referenceAngle : bodyB.getAngle() - bodyA.getAngle();\n\n    this.m_impulse = new Vec3();\n    this.m_motorImpulse = 0.0;\n\n    this.m_lowerAngle = def.lowerAngle;\n    this.m_upperAngle = def.upperAngle;\n    this.m_maxMotorTorque = def.maxMotorTorque;\n    this.m_motorSpeed = def.motorSpeed;\n    this.m_enableLimit = def.enableLimit;\n    this.m_enableMotor = def.enableMotor;\n\n    // Point-to-point constraint\n    // C = p2 - p1\n    // Cdot = v2 - v1\n    // = v2 + cross(w2, r2) - v1 - cross(w1, r1)\n    // J = [-I -r1_skew I r2_skew ]\n    // Identity used:\n    // w k % (rx i + ry j) = w * (-ry i + rx j)\n\n    // Motor constraint\n    // Cdot = w2 - w1\n    // J = [0 0 -1 0 0 1]\n    // K = invI1 + invI2\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      lowerAngle: this.m_lowerAngle,\n      upperAngle: this.m_upperAngle,\n      maxMotorTorque: this.m_maxMotorTorque,\n      motorSpeed: this.m_motorSpeed,\n      enableLimit: this.m_enableLimit,\n      enableMotor: this.m_enableMotor,\n\n      localAnchorA: this.m_localAnchorA,\n      localAnchorB: this.m_localAnchorB,\n      referenceAngle: this.m_referenceAngle,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any):RevoluteJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    const joint = new RevoluteJoint(data);\n    return joint;\n  }\n\n  /** @internal */\n  _setAnchors(def: {\n    anchorA?: Vec2,\n    localAnchorA?: Vec2,\n    anchorB?: Vec2,\n    localAnchorB?: Vec2,\n  }): void {\n    if (def.anchorA) {\n      this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n    } else if (def.localAnchorA) {\n      this.m_localAnchorA.setVec2(def.localAnchorA);\n    }\n\n    if (def.anchorB) {\n      this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n    } else if (def.localAnchorB) {\n      this.m_localAnchorB.setVec2(def.localAnchorB);\n    }\n  }\n\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  getLocalAnchorA(): Vec2 {\n    return this.m_localAnchorA;\n  }\n\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  getLocalAnchorB(): Vec2 {\n    return this.m_localAnchorB;\n  }\n\n  /**\n   * Get the reference angle.\n   */\n  getReferenceAngle(): number {\n    return this.m_referenceAngle;\n  }\n\n  /**\n   * Get the current joint angle in radians.\n   */\n  getJointAngle(): number {\n    const bA = this.m_bodyA;\n    const bB = this.m_bodyB;\n    return bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;\n  }\n\n  /**\n   * Get the current joint angle speed in radians per second.\n   */\n  getJointSpeed(): number {\n    const bA = this.m_bodyA;\n    const bB = this.m_bodyB;\n    return bB.m_angularVelocity - bA.m_angularVelocity;\n  }\n\n  /**\n   * Is the joint motor enabled?\n   */\n  isMotorEnabled(): boolean {\n    return this.m_enableMotor;\n  }\n\n  /**\n   * Enable/disable the joint motor.\n   */\n  enableMotor(flag: boolean): void {\n    if (flag == this.m_enableMotor) return;\n    this.m_bodyA.setAwake(true);\n    this.m_bodyB.setAwake(true);\n    this.m_enableMotor = flag;\n  }\n\n  /**\n   * Get the current motor torque given the inverse time step. Unit is N*m.\n   */\n  getMotorTorque(inv_dt: number): number {\n    return inv_dt * this.m_motorImpulse;\n  }\n\n  /**\n   * Set the motor speed in radians per second.\n   */\n  setMotorSpeed(speed: number): void {\n    if (speed == this.m_motorSpeed) return;\n    this.m_bodyA.setAwake(true);\n    this.m_bodyB.setAwake(true);\n    this.m_motorSpeed = speed;\n  }\n\n  /**\n   * Get the motor speed in radians per second.\n   */\n  getMotorSpeed(): number {\n    return this.m_motorSpeed;\n  }\n\n  /**\n   * Set the maximum motor torque, usually in N-m.\n   */\n  setMaxMotorTorque(torque: number): void {\n    if (torque == this.m_maxMotorTorque) return;\n    this.m_bodyA.setAwake(true);\n    this.m_bodyB.setAwake(true);\n    this.m_maxMotorTorque = torque;\n  }\n\n  getMaxMotorTorque(): number {\n    return this.m_maxMotorTorque;\n  }\n\n  /**\n   * Is the joint limit enabled?\n   */\n  isLimitEnabled(): boolean {\n    return this.m_enableLimit;\n  }\n\n  /**\n   * Enable/disable the joint limit.\n   */\n  enableLimit(flag: boolean): void {\n    if (flag != this.m_enableLimit) {\n      this.m_bodyA.setAwake(true);\n      this.m_bodyB.setAwake(true);\n      this.m_enableLimit = flag;\n      this.m_impulse.z = 0.0;\n    }\n  }\n\n  /**\n   * Get the lower joint limit in radians.\n   */\n  getLowerLimit(): number {\n    return this.m_lowerAngle;\n  }\n\n  /**\n   * Get the upper joint limit in radians.\n   */\n  getUpperLimit(): number {\n    return this.m_upperAngle;\n  }\n\n  /**\n   * Set the joint limits in radians.\n   */\n  setLimits(lower: number, upper: number): void {\n    _ASSERT && console.assert(lower <= upper);\n\n    if (lower != this.m_lowerAngle || upper != this.m_upperAngle) {\n      this.m_bodyA.setAwake(true);\n      this.m_bodyB.setAwake(true);\n      this.m_impulse.z = 0.0;\n      this.m_lowerAngle = lower;\n      this.m_upperAngle = upper;\n    }\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force given the inverse time step. Unit is N.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.neo(this.m_impulse.x, this.m_impulse.y).mul(inv_dt);\n  }\n\n  /**\n   * Get the reaction torque due to the joint limit given the inverse time step.\n   * Unit is N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return inv_dt * this.m_impulse.z;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassA = this.m_bodyA.m_invMass;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIA = this.m_bodyA.m_invI;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n\n    // J = [-I -r1_skew I r2_skew]\n    // [ 0 -1 0 1]\n    // r_skew = [-ry; rx]\n\n    // Matlab\n    // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]\n    // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]\n    // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB; // float\n    const iA = this.m_invIA;\n    const iB = this.m_invIB; // float\n\n    const fixedRotation = (iA + iB === 0.0); // bool\n\n    this.m_mass.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y\n        * this.m_rB.y * iB;\n    this.m_mass.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y\n        * this.m_rB.x * iB;\n    this.m_mass.ez.x = -this.m_rA.y * iA - this.m_rB.y * iB;\n    this.m_mass.ex.y = this.m_mass.ey.x;\n    this.m_mass.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x\n        * this.m_rB.x * iB;\n    this.m_mass.ez.y = this.m_rA.x * iA + this.m_rB.x * iB;\n    this.m_mass.ex.z = this.m_mass.ez.x;\n    this.m_mass.ey.z = this.m_mass.ez.y;\n    this.m_mass.ez.z = iA + iB;\n\n    this.m_motorMass = iA + iB;\n    if (this.m_motorMass > 0.0) {\n      this.m_motorMass = 1.0 / this.m_motorMass;\n    }\n\n    if (this.m_enableMotor == false || fixedRotation) {\n      this.m_motorImpulse = 0.0;\n    }\n\n    if (this.m_enableLimit && fixedRotation == false) {\n      const jointAngle = aB - aA - this.m_referenceAngle; // float\n\n      if (Math.abs(this.m_upperAngle - this.m_lowerAngle) < 2.0 * Settings.angularSlop) {\n        this.m_limitState = equalLimits;\n\n      } else if (jointAngle <= this.m_lowerAngle) {\n        if (this.m_limitState != atLowerLimit) {\n          this.m_impulse.z = 0.0;\n        }\n        this.m_limitState = atLowerLimit;\n\n      } else if (jointAngle >= this.m_upperAngle) {\n        if (this.m_limitState != atUpperLimit) {\n          this.m_impulse.z = 0.0;\n        }\n        this.m_limitState = atUpperLimit;\n\n      } else {\n        this.m_limitState = inactiveLimit;\n        this.m_impulse.z = 0.0;\n      }\n\n    } else {\n      this.m_limitState = inactiveLimit;\n    }\n\n    if (step.warmStarting) {\n      // Scale impulses to support a variable time step.\n      this.m_impulse.mul(step.dtRatio);\n      this.m_motorImpulse *= step.dtRatio;\n\n      const P = Vec2.neo(this.m_impulse.x, this.m_impulse.y);\n\n      vA.subMul(mA, P);\n      wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + this.m_motorImpulse + this.m_impulse.z);\n\n      vB.addMul(mB, P);\n      wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + this.m_motorImpulse + this.m_impulse.z);\n\n    } else {\n      this.m_impulse.setZero();\n      this.m_motorImpulse = 0.0;\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB; // float\n    const iA = this.m_invIA;\n    const iB = this.m_invIB; // float\n\n    const fixedRotation = (iA + iB === 0.0); // bool\n\n    // Solve motor constraint.\n    if (this.m_enableMotor && this.m_limitState != equalLimits\n        && fixedRotation == false) {\n      const Cdot = wB - wA - this.m_motorSpeed; // float\n      let impulse = -this.m_motorMass * Cdot; // float\n      const oldImpulse = this.m_motorImpulse; // float\n      const maxImpulse = step.dt * this.m_maxMotorTorque; // float\n      this.m_motorImpulse = Math.clamp(this.m_motorImpulse + impulse,\n          -maxImpulse, maxImpulse);\n      impulse = this.m_motorImpulse - oldImpulse;\n\n      wA -= iA * impulse;\n      wB += iB * impulse;\n    }\n\n    // Solve limit constraint.\n    if (this.m_enableLimit && this.m_limitState != inactiveLimit\n        && fixedRotation == false) {\n      const Cdot1 = Vec2.zero();\n      Cdot1.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, this.m_rB));\n      Cdot1.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, this.m_rA));\n      const Cdot2 = wB - wA; // float\n      const Cdot = new Vec3(Cdot1.x, Cdot1.y, Cdot2);\n\n      const impulse = Vec3.neg(this.m_mass.solve33(Cdot)); // Vec3\n\n      if (this.m_limitState == equalLimits) {\n        this.m_impulse.add(impulse);\n\n      } else if (this.m_limitState == atLowerLimit) {\n        const newImpulse = this.m_impulse.z + impulse.z; // float\n\n        if (newImpulse < 0.0) {\n          const rhs = Vec2.combine(-1, Cdot1, this.m_impulse.z, Vec2.neo(this.m_mass.ez.x, this.m_mass.ez.y)); // Vec2\n          const reduced = this.m_mass.solve22(rhs); // Vec2\n          impulse.x = reduced.x;\n          impulse.y = reduced.y;\n          impulse.z = -this.m_impulse.z;\n          this.m_impulse.x += reduced.x;\n          this.m_impulse.y += reduced.y;\n          this.m_impulse.z = 0.0;\n\n        } else {\n          this.m_impulse.add(impulse);\n        }\n\n      } else if (this.m_limitState == atUpperLimit) {\n        const newImpulse = this.m_impulse.z + impulse.z; // float\n\n        if (newImpulse > 0.0) {\n          const rhs = Vec2.combine(-1, Cdot1, this.m_impulse.z, Vec2.neo(this.m_mass.ez.x, this.m_mass.ez.y)); // Vec2\n          const reduced = this.m_mass.solve22(rhs); // Vec2\n          impulse.x = reduced.x;\n          impulse.y = reduced.y;\n          impulse.z = -this.m_impulse.z;\n          this.m_impulse.x += reduced.x;\n          this.m_impulse.y += reduced.y;\n          this.m_impulse.z = 0.0;\n\n        } else {\n          this.m_impulse.add(impulse);\n        }\n      }\n\n      const P = Vec2.neo(impulse.x, impulse.y);\n\n      vA.subMul(mA, P);\n      wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + impulse.z);\n\n      vB.addMul(mB, P);\n      wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + impulse.z);\n\n    } else {\n      // Solve point-to-point constraint\n      const Cdot = Vec2.zero();\n      Cdot.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, this.m_rB));\n      Cdot.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, this.m_rA));\n      const impulse = this.m_mass.solve22(Vec2.neg(Cdot)); // Vec2\n\n      this.m_impulse.x += impulse.x;\n      this.m_impulse.y += impulse.y;\n\n      vA.subMul(mA, impulse);\n      wA -= iA * Vec2.crossVec2Vec2(this.m_rA, impulse);\n\n      vB.addMul(mB, impulse);\n      wB += iB * Vec2.crossVec2Vec2(this.m_rB, impulse);\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    const cA = this.m_bodyA.c_position.c;\n    let aA = this.m_bodyA.c_position.a;\n    const cB = this.m_bodyB.c_position.c;\n    let aB = this.m_bodyB.c_position.a;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    let angularError = 0.0; // float\n    let positionError = 0.0; // float\n\n    const fixedRotation = (this.m_invIA + this.m_invIB == 0.0); // bool\n\n    // Solve angular limit constraint.\n    if (this.m_enableLimit && this.m_limitState != inactiveLimit\n        && fixedRotation == false) {\n      const angle = aB - aA - this.m_referenceAngle; // float\n      let limitImpulse = 0.0; // float\n\n      if (this.m_limitState == equalLimits) {\n        // Prevent large angular corrections\n        const C = Math.clamp(angle - this.m_lowerAngle,\n            -Settings.maxAngularCorrection, Settings.maxAngularCorrection); // float\n        limitImpulse = -this.m_motorMass * C;\n        angularError = Math.abs(C);\n\n      } else if (this.m_limitState == atLowerLimit) {\n        let C = angle - this.m_lowerAngle; // float\n        angularError = -C;\n\n        // Prevent large angular corrections and allow some slop.\n        C = Math.clamp(C + Settings.angularSlop, -Settings.maxAngularCorrection,\n            0.0);\n        limitImpulse = -this.m_motorMass * C;\n\n      } else if (this.m_limitState == atUpperLimit) {\n        let C = angle - this.m_upperAngle; // float\n        angularError = C;\n\n        // Prevent large angular corrections and allow some slop.\n        C = Math.clamp(C - Settings.angularSlop, 0.0,\n            Settings.maxAngularCorrection);\n        limitImpulse = -this.m_motorMass * C;\n      }\n\n      aA -= this.m_invIA * limitImpulse;\n      aB += this.m_invIB * limitImpulse;\n    }\n\n    // Solve point-to-point constraint.\n    {\n      qA.setAngle(aA);\n      qB.setAngle(aB);\n      const rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA)); // Vec2\n      const rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB)); // Vec2\n\n      const C = Vec2.zero();\n      C.addCombine(1, cB, 1, rB);\n      C.subCombine(1, cA, 1, rA);\n      positionError = C.length();\n\n      const mA = this.m_invMassA;\n      const mB = this.m_invMassB; // float\n      const iA = this.m_invIA;\n      const iB = this.m_invIB; // float\n\n      const K = new Mat22();\n      K.ex.x = mA + mB + iA * rA.y * rA.y + iB * rB.y * rB.y;\n      K.ex.y = -iA * rA.x * rA.y - iB * rB.x * rB.y;\n      K.ey.x = K.ex.y;\n      K.ey.y = mA + mB + iA * rA.x * rA.x + iB * rB.x * rB.x;\n\n      const impulse = Vec2.neg(K.solve(C)); // Vec2\n\n      cA.subMul(mA, impulse);\n      aA -= iA * Vec2.crossVec2Vec2(rA, impulse);\n\n      cB.addMul(mB, impulse);\n      aB += iB * Vec2.crossVec2Vec2(rB, impulse);\n    }\n\n    this.m_bodyA.c_position.c.setVec2(cA);\n    this.m_bodyA.c_position.a = aA;\n    this.m_bodyB.c_position.c.setVec2(cB);\n    this.m_bodyB.c_position.a = aB;\n\n    return positionError <= Settings.linearSlop\n        && angularError <= Settings.angularSlop;\n  }\n\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { options } from '../../util/options';\nimport { SettingsInternal as Settings } from '../../Settings';\nimport { math as Math } from '../../common/Math';\nimport { Vec2 } from '../../common/Vec2';\nimport { Vec3 } from '../../common/Vec3';\nimport { Mat22 } from '../../common/Mat22';\nimport { Mat33 } from '../../common/Mat33';\nimport { Rot } from '../../common/Rot';\nimport { Joint, JointOpt, JointDef } from '../Joint';\nimport { Body } from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\nconst _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\nconst inactiveLimit = 0;\nconst atLowerLimit = 1;\nconst atUpperLimit = 2;\nconst equalLimits = 3;\n\n/**\n * Prismatic joint definition. This requires defining a line of motion using an\n * axis and an anchor point. The definition uses local anchor points and a local\n * axis so that the initial configuration can violate the constraint slightly.\n * The joint translation is zero when the local anchor points coincide in world\n * space. Using local anchors and a local axis helps when saving and loading a\n * game.\n */\nexport interface PrismaticJointOpt extends JointOpt {\n  /**\n   * Enable/disable the joint limit.\n   */\n  enableLimit?: boolean;\n  /**\n   * The lower translation limit, usually in meters.\n   */\n  lowerTranslation?: number;\n  /**\n   * The upper translation limit, usually in meters.\n   */\n  upperTranslation?: number;\n  /**\n   * Enable/disable the joint motor.\n   */\n  enableMotor?: boolean;\n  /**\n   * The maximum motor torque, usually in N-m.\n   */\n  maxMotorForce?: number;\n  /**\n   * The desired motor speed in radians per second.\n   */\n  motorSpeed?: number;\n}\n/**\n * Prismatic joint definition. This requires defining a line of motion using an\n * axis and an anchor point. The definition uses local anchor points and a local\n * axis so that the initial configuration can violate the constraint slightly.\n * The joint translation is zero when the local anchor points coincide in world\n * space. Using local anchors and a local axis helps when saving and loading a\n * game.\n */\nexport interface PrismaticJointDef extends JointDef, PrismaticJointOpt {\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  localAnchorA: Vec2;\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  localAnchorB: Vec2;\n  /**\n   * The local translation unit axis in bodyA.\n   */\n  localAxisA: Vec2;\n  /**\n   * referenceAngle The constrained angle between the bodies:\n   * bodyB_angle - bodyA_angle.\n   */\n  referenceAngle: number;\n}\n\nconst DEFAULTS = {\n  enableLimit : false,\n  lowerTranslation : 0.0,\n  upperTranslation : 0.0,\n  enableMotor : false,\n  maxMotorForce : 0.0,\n  motorSpeed : 0.0\n};\n\n/**\n * A prismatic joint. This joint provides one degree of freedom: translation\n * along an axis fixed in bodyA. Relative rotation is prevented. You can use a\n * joint limit to restrict the range of motion and a joint motor to drive the\n * motion or to model joint friction.\n */\nexport class PrismaticJoint extends Joint {\n  static TYPE = 'prismatic-joint' as const;\n\n  /** @internal */ m_type: 'prismatic-joint';\n  /** @internal */ m_localAnchorA: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n  /** @internal */ m_localXAxisA: Vec2;\n  /** @internal */ m_localYAxisA: Vec2;\n  /** @internal */ m_referenceAngle: number;\n  /** @internal */ m_impulse: Vec3;\n  /** @internal */ m_motorMass: number;\n  /** @internal */ m_motorImpulse: number;\n  /** @internal */ m_lowerTranslation: number;\n  /** @internal */ m_upperTranslation: number;\n  /** @internal */ m_maxMotorForce: number;\n  /** @internal */ m_motorSpeed: number;\n  /** @internal */ m_enableLimit: boolean;\n  /** @internal */ m_enableMotor: boolean;\n  /** @internal */ m_limitState: number; // TODO enum\n  /** @internal */ m_axis: Vec2;\n  /** @internal */ m_perp: Vec2;\n  // Solver temp\n  /** @internal */ m_localCenterA: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_invMassA: number;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIA: number;\n  /** @internal */ m_invIB: number;\n  /** @internal */ m_s1: number;\n  /** @internal */ m_s2: number;\n  /** @internal */ m_a1: number;\n  /** @internal */ m_a2: number;\n  /** @internal */ m_K: Mat33;\n\n  constructor(def: PrismaticJointDef);\n  constructor(def: PrismaticJointOpt, bodyA: Body, bodyB: Body, anchor: Vec2, axis: Vec2);\n  constructor(def: PrismaticJointDef, bodyA?: Body, bodyB?: Body, anchor?: Vec2, axis?: Vec2) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof PrismaticJoint)) {\n      return new PrismaticJoint(def, bodyA, bodyB, anchor, axis);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = PrismaticJoint.TYPE;\n\n    this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n    this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n    this.m_localXAxisA = Vec2.clone(axis ? bodyA.getLocalVector(axis) : def.localAxisA || Vec2.neo(1.0, 0.0));\n    this.m_localXAxisA.normalize();\n    this.m_localYAxisA = Vec2.crossNumVec2(1.0, this.m_localXAxisA);\n    this.m_referenceAngle = Math.isFinite(def.referenceAngle) ? def.referenceAngle : bodyB.getAngle() - bodyA.getAngle();\n\n    this.m_impulse = new Vec3();\n    this.m_motorMass = 0.0;\n    this.m_motorImpulse = 0.0;\n\n    this.m_lowerTranslation = def.lowerTranslation;\n    this.m_upperTranslation = def.upperTranslation;\n    this.m_maxMotorForce = def.maxMotorForce;\n    this.m_motorSpeed = def.motorSpeed;\n    this.m_enableLimit = def.enableLimit;\n    this.m_enableMotor = def.enableMotor;\n    this.m_limitState = inactiveLimit;\n\n    this.m_axis = Vec2.zero();\n    this.m_perp = Vec2.zero();\n\n    this.m_K = new Mat33();\n\n    // Linear constraint (point-to-line)\n    // d = p2 - p1 = x2 + r2 - x1 - r1\n    // C = dot(perp, d)\n    // Cdot = dot(d, cross(w1, perp)) + dot(perp, v2 + cross(w2, r2) - v1 -\n    // cross(w1, r1))\n    // = -dot(perp, v1) - dot(cross(d + r1, perp), w1) + dot(perp, v2) +\n    // dot(cross(r2, perp), v2)\n    // J = [-perp, -cross(d + r1, perp), perp, cross(r2,perp)]\n    //\n    // Angular constraint\n    // C = a2 - a1 + a_initial\n    // Cdot = w2 - w1\n    // J = [0 0 -1 0 0 1]\n    //\n    // K = J * invM * JT\n    //\n    // J = [-a -s1 a s2]\n    // [0 -1 0 1]\n    // a = perp\n    // s1 = cross(d + r1, a) = cross(p2 - x1, a)\n    // s2 = cross(r2, a) = cross(p2 - x2, a)\n\n    // Motor/Limit linear constraint\n    // C = dot(ax1, d)\n    // Cdot = = -dot(ax1, v1) - dot(cross(d + r1, ax1), w1) + dot(ax1, v2) +\n    // dot(cross(r2, ax1), v2)\n    // J = [-ax1 -cross(d+r1,ax1) ax1 cross(r2,ax1)]\n\n    // Block Solver\n    // We develop a block solver that includes the joint limit. This makes the\n    // limit stiff (inelastic) even\n    // when the mass has poor distribution (leading to large torques about the\n    // joint anchor points).\n    //\n    // The Jacobian has 3 rows:\n    // J = [-uT -s1 uT s2] // linear\n    // [0 -1 0 1] // angular\n    // [-vT -a1 vT a2] // limit\n    //\n    // u = perp\n    // v = axis\n    // s1 = cross(d + r1, u), s2 = cross(r2, u)\n    // a1 = cross(d + r1, v), a2 = cross(r2, v)\n\n    // M * (v2 - v1) = JT * df\n    // J * v2 = bias\n    //\n    // v2 = v1 + invM * JT * df\n    // J * (v1 + invM * JT * df) = bias\n    // K * df = bias - J * v1 = -Cdot\n    // K = J * invM * JT\n    // Cdot = J * v1 - bias\n    //\n    // Now solve for f2.\n    // df = f2 - f1\n    // K * (f2 - f1) = -Cdot\n    // f2 = invK * (-Cdot) + f1\n    //\n    // Clamp accumulated limit impulse.\n    // lower: f2(3) = max(f2(3), 0)\n    // upper: f2(3) = min(f2(3), 0)\n    //\n    // Solve for correct f2(1:2)\n    // K(1:2, 1:2) * f2(1:2) = -Cdot(1:2) - K(1:2,3) * f2(3) + K(1:2,1:3) * f1\n    // = -Cdot(1:2) - K(1:2,3) * f2(3) + K(1:2,1:2) * f1(1:2) + K(1:2,3) * f1(3)\n    // K(1:2, 1:2) * f2(1:2) = -Cdot(1:2) - K(1:2,3) * (f2(3) - f1(3)) +\n    // K(1:2,1:2) * f1(1:2)\n    // f2(1:2) = invK(1:2,1:2) * (-Cdot(1:2) - K(1:2,3) * (f2(3) - f1(3))) +\n    // f1(1:2)\n    //\n    // Now compute impulse to be applied:\n    // df = f2 - f1\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      lowerTranslation: this.m_lowerTranslation,\n      upperTranslation: this.m_upperTranslation,\n      maxMotorForce: this.m_maxMotorForce,\n      motorSpeed: this.m_motorSpeed,\n      enableLimit: this.m_enableLimit,\n      enableMotor: this.m_enableMotor,\n\n      localAnchorA: this.m_localAnchorA,\n      localAnchorB: this.m_localAnchorB,\n      localAxisA: this.m_localXAxisA,\n      referenceAngle: this.m_referenceAngle,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): PrismaticJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    data.localAxisA = Vec2.clone(data.localAxisA);\n    const joint = new PrismaticJoint(data);\n    return joint;\n  }\n\n  /** @internal */\n  _setAnchors(def: {\n    anchorA?: Vec2,\n    localAnchorA?: Vec2,\n    anchorB?: Vec2,\n    localAnchorB?: Vec2,\n    localAxisA?: Vec2,\n  }): void {\n    if (def.anchorA) {\n      this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n    } else if (def.localAnchorA) {\n      this.m_localAnchorA.setVec2(def.localAnchorA);\n    }\n\n    if (def.anchorB) {\n      this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n    } else if (def.localAnchorB) {\n      this.m_localAnchorB.setVec2(def.localAnchorB);\n    }\n\n    if (def.localAxisA) {\n      this.m_localXAxisA.setVec2(def.localAxisA);\n      this.m_localYAxisA.setVec2(Vec2.crossNumVec2(1.0, def.localAxisA));\n    }\n  }\n\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  getLocalAnchorA(): Vec2 {\n    return this.m_localAnchorA;\n  }\n\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  getLocalAnchorB(): Vec2 {\n    return this.m_localAnchorB;\n  }\n\n  /**\n   * The local joint axis relative to bodyA.\n   */\n  getLocalAxisA(): Vec2 {\n    return this.m_localXAxisA;\n  }\n\n  /**\n   * Get the reference angle.\n   */\n  getReferenceAngle(): number {\n    return this.m_referenceAngle;\n  }\n\n  /**\n   * Get the current joint translation, usually in meters.\n   */\n  getJointTranslation(): number {\n    const pA = this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n    const pB = this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n    const d = Vec2.sub(pB, pA);\n    const axis = this.m_bodyA.getWorldVector(this.m_localXAxisA);\n\n    const translation = Vec2.dot(d, axis);\n    return translation;\n  }\n\n  /**\n   * Get the current joint translation speed, usually in meters per second.\n   */\n  getJointSpeed(): number {\n    const bA = this.m_bodyA;\n    const bB = this.m_bodyB;\n\n    const rA = Rot.mulVec2(bA.m_xf.q, Vec2.sub(this.m_localAnchorA, bA.m_sweep.localCenter)); // Vec2\n    const rB = Rot.mulVec2(bB.m_xf.q, Vec2.sub(this.m_localAnchorB, bB.m_sweep.localCenter)); // Vec2\n    const p1 = Vec2.add(bA.m_sweep.c, rA); // Vec2\n    const p2 = Vec2.add(bB.m_sweep.c, rB); // Vec2\n    const d = Vec2.sub(p2, p1); // Vec2\n    const axis = Rot.mulVec2(bA.m_xf.q, this.m_localXAxisA); // Vec2\n\n    const vA = bA.m_linearVelocity; // Vec2\n    const vB = bB.m_linearVelocity; // Vec2\n    const wA = bA.m_angularVelocity; // float\n    const wB = bB.m_angularVelocity; // float\n\n    const speed = Vec2.dot(d, Vec2.crossNumVec2(wA, axis))\n        + Vec2.dot(axis, Vec2.sub(Vec2.addCrossNumVec2(vB, wB, rB), Vec2.addCrossNumVec2(vA, wA, rA))); // float\n    return speed;\n  }\n\n  /**\n   * Is the joint limit enabled?\n   */\n  isLimitEnabled(): boolean {\n    return this.m_enableLimit;\n  }\n\n  /**\n   * Enable/disable the joint limit.\n   */\n  enableLimit(flag: boolean): void {\n    if (flag != this.m_enableLimit) {\n      this.m_bodyA.setAwake(true);\n      this.m_bodyB.setAwake(true);\n      this.m_enableLimit = flag;\n      this.m_impulse.z = 0.0;\n    }\n  }\n\n  /**\n   * Get the lower joint limit, usually in meters.\n   */\n  getLowerLimit(): number {\n    return this.m_lowerTranslation;\n  }\n\n  /**\n   * Get the upper joint limit, usually in meters.\n   */\n  getUpperLimit(): number {\n    return this.m_upperTranslation;\n  }\n\n  /**\n   * Set the joint limits, usually in meters.\n   */\n  setLimits(lower: number, upper: number): void {\n    _ASSERT && console.assert(lower <= upper);\n    if (lower != this.m_lowerTranslation || upper != this.m_upperTranslation) {\n      this.m_bodyA.setAwake(true);\n      this.m_bodyB.setAwake(true);\n      this.m_lowerTranslation = lower;\n      this.m_upperTranslation = upper;\n      this.m_impulse.z = 0.0;\n    }\n  }\n\n  /**\n   * Is the joint motor enabled?\n   */\n  isMotorEnabled(): boolean {\n    return this.m_enableMotor;\n  }\n\n  /**\n   * Enable/disable the joint motor.\n   */\n  enableMotor(flag: boolean): void {\n    if (flag == this.m_enableMotor) return;\n    this.m_bodyA.setAwake(true);\n    this.m_bodyB.setAwake(true);\n    this.m_enableMotor = flag;\n  }\n\n  /**\n   * Set the motor speed, usually in meters per second.\n   */\n  setMotorSpeed(speed: number): void {\n    if (speed == this.m_motorSpeed) return;\n    this.m_bodyA.setAwake(true);\n    this.m_bodyB.setAwake(true);\n    this.m_motorSpeed = speed;\n  }\n\n  /**\n   * Set the maximum motor force, usually in N.\n   */\n  setMaxMotorForce(force: number): void {\n    if (force == this.m_maxMotorForce) return;\n    this.m_bodyA.setAwake(true);\n    this.m_bodyB.setAwake(true);\n    this.m_maxMotorForce = force;\n  }\n\n  getMaxMotorForce(): number {\n    return this.m_maxMotorForce;\n  }\n\n  /**\n   * Get the motor speed, usually in meters per second.\n   */\n  getMotorSpeed(): number {\n    return this.m_motorSpeed;\n  }\n\n  /**\n   * Get the current motor force given the inverse time step, usually in N.\n   */\n  getMotorForce(inv_dt: number): number {\n    return inv_dt * this.m_motorImpulse;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.combine(this.m_impulse.x, this.m_perp, this.m_motorImpulse + this.m_impulse.z, this.m_axis).mul(inv_dt);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return inv_dt * this.m_impulse.y;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassA = this.m_bodyA.m_invMass;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIA = this.m_bodyA.m_invI;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const cA = this.m_bodyA.c_position.c;\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const cB = this.m_bodyB.c_position.c;\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    // Compute the effective masses.\n    const rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    const rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n    const d = Vec2.zero();\n    d.addCombine(1, cB, 1, rB);\n    d.subCombine(1, cA, 1, rA);\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    // Compute motor Jacobian and effective mass.\n    {\n      this.m_axis = Rot.mulVec2(qA, this.m_localXAxisA);\n      this.m_a1 = Vec2.crossVec2Vec2(Vec2.add(d, rA), this.m_axis);\n      this.m_a2 = Vec2.crossVec2Vec2(rB, this.m_axis);\n\n      this.m_motorMass = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2\n          * this.m_a2;\n      if (this.m_motorMass > 0.0) {\n        this.m_motorMass = 1.0 / this.m_motorMass;\n      }\n    }\n\n    // Prismatic constraint.\n    {\n      this.m_perp = Rot.mulVec2(qA, this.m_localYAxisA);\n\n      this.m_s1 = Vec2.crossVec2Vec2(Vec2.add(d, rA), this.m_perp);\n      this.m_s2 = Vec2.crossVec2Vec2(rB, this.m_perp);\n\n      const s1test = Vec2.crossVec2Vec2(rA, this.m_perp);\n\n      const k11 = mA + mB + iA * this.m_s1 * this.m_s1 + iB * this.m_s2 * this.m_s2;\n      const k12 = iA * this.m_s1 + iB * this.m_s2;\n      const k13 = iA * this.m_s1 * this.m_a1 + iB * this.m_s2 * this.m_a2;\n      let k22 = iA + iB;\n      if (k22 == 0.0) {\n        // For bodies with fixed rotation.\n        k22 = 1.0;\n      }\n      const k23 = iA * this.m_a1 + iB * this.m_a2;\n      const k33 = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2 * this.m_a2;\n\n      this.m_K.ex.set(k11, k12, k13);\n      this.m_K.ey.set(k12, k22, k23);\n      this.m_K.ez.set(k13, k23, k33);\n    }\n\n    // Compute motor and limit terms.\n    if (this.m_enableLimit) {\n\n      const jointTranslation = Vec2.dot(this.m_axis, d); // float\n      if (Math.abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * Settings.linearSlop) {\n        this.m_limitState = equalLimits;\n\n      } else if (jointTranslation <= this.m_lowerTranslation) {\n        if (this.m_limitState != atLowerLimit) {\n          this.m_limitState = atLowerLimit;\n          this.m_impulse.z = 0.0;\n        }\n\n      } else if (jointTranslation >= this.m_upperTranslation) {\n        if (this.m_limitState != atUpperLimit) {\n          this.m_limitState = atUpperLimit;\n          this.m_impulse.z = 0.0;\n        }\n\n      } else {\n        this.m_limitState = inactiveLimit;\n        this.m_impulse.z = 0.0;\n      }\n\n    } else {\n      this.m_limitState = inactiveLimit;\n      this.m_impulse.z = 0.0;\n    }\n\n    if (this.m_enableMotor == false) {\n      this.m_motorImpulse = 0.0;\n    }\n\n    if (step.warmStarting) {\n      // Account for variable time step.\n      this.m_impulse.mul(step.dtRatio);\n      this.m_motorImpulse *= step.dtRatio;\n\n      const P = Vec2.combine(this.m_impulse.x, this.m_perp, this.m_motorImpulse\n          + this.m_impulse.z, this.m_axis);\n      const LA = this.m_impulse.x * this.m_s1 + this.m_impulse.y\n          + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1;\n      const LB = this.m_impulse.x * this.m_s2 + this.m_impulse.y\n          + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;\n\n      vA.subMul(mA, P);\n      wA -= iA * LA;\n\n      vB.addMul(mB, P);\n      wB += iB * LB;\n    } else {\n      this.m_impulse.setZero();\n      this.m_motorImpulse = 0.0;\n    }\n\n    this.m_bodyA.c_velocity.v.setVec2(vA);\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v.setVec2(vB);\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    // Solve linear motor constraint.\n    if (this.m_enableMotor && this.m_limitState != equalLimits) {\n      const Cdot = Vec2.dot(this.m_axis, Vec2.sub(vB, vA)) + this.m_a2 * wB\n          - this.m_a1 * wA;\n      let impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);\n      const oldImpulse = this.m_motorImpulse;\n      const maxImpulse = step.dt * this.m_maxMotorForce;\n      this.m_motorImpulse = Math.clamp(this.m_motorImpulse + impulse,\n          -maxImpulse, maxImpulse);\n      impulse = this.m_motorImpulse - oldImpulse;\n\n      const P = Vec2.mulNumVec2(impulse, this.m_axis);\n      const LA = impulse * this.m_a1;\n      const LB = impulse * this.m_a2;\n\n      vA.subMul(mA, P);\n      wA -= iA * LA;\n\n      vB.addMul(mB, P);\n      wB += iB * LB;\n    }\n\n    const Cdot1 = Vec2.zero();\n    Cdot1.x += Vec2.dot(this.m_perp, vB) + this.m_s2 * wB;\n    Cdot1.x -= Vec2.dot(this.m_perp, vA) + this.m_s1 * wA;\n    Cdot1.y = wB - wA;\n\n    if (this.m_enableLimit && this.m_limitState != inactiveLimit) {\n      // Solve prismatic and limit constraint in block form.\n      let Cdot2 = 0;\n      Cdot2 += Vec2.dot(this.m_axis, vB) + this.m_a2 * wB;\n      Cdot2 -= Vec2.dot(this.m_axis, vA) + this.m_a1 * wA;\n\n      const Cdot = new Vec3(Cdot1.x, Cdot1.y, Cdot2);\n\n      const f1 = Vec3.clone(this.m_impulse);\n      let df = this.m_K.solve33(Vec3.neg(Cdot)); // Vec3\n      this.m_impulse.add(df);\n\n      if (this.m_limitState == atLowerLimit) {\n        this.m_impulse.z = Math.max(this.m_impulse.z, 0.0);\n      } else if (this.m_limitState == atUpperLimit) {\n        this.m_impulse.z = Math.min(this.m_impulse.z, 0.0);\n      }\n\n      // f2(1:2) = invK(1:2,1:2) * (-Cdot(1:2) - K(1:2,3) * (f2(3) - f1(3))) +\n      // f1(1:2)\n      const b = Vec2.combine(-1, Cdot1, -(this.m_impulse.z - f1.z), Vec2.neo(this.m_K.ez.x, this.m_K.ez.y)); // Vec2\n      const f2r = Vec2.add(this.m_K.solve22(b), Vec2.neo(f1.x, f1.y)); // Vec2\n      this.m_impulse.x = f2r.x;\n      this.m_impulse.y = f2r.y;\n\n      df = Vec3.sub(this.m_impulse, f1);\n\n      const P = Vec2.combine(df.x, this.m_perp, df.z, this.m_axis); // Vec2\n      const LA = df.x * this.m_s1 + df.y + df.z * this.m_a1; // float\n      const LB = df.x * this.m_s2 + df.y + df.z * this.m_a2; // float\n\n      vA.subMul(mA, P);\n      wA -= iA * LA;\n\n      vB.addMul(mB, P);\n      wB += iB * LB;\n    } else {\n      // Limit is inactive, just solve the prismatic constraint in block form.\n      const df = this.m_K.solve22(Vec2.neg(Cdot1)); // Vec2\n      this.m_impulse.x += df.x;\n      this.m_impulse.y += df.y;\n\n      const P = Vec2.mulNumVec2(df.x, this.m_perp); // Vec2\n      const LA = df.x * this.m_s1 + df.y; // float\n      const LB = df.x * this.m_s2 + df.y; // float\n\n      vA.subMul(mA, P);\n      wA -= iA * LA;\n\n      vB.addMul(mB, P);\n      wB += iB * LB;\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    const cA = this.m_bodyA.c_position.c;\n    let aA = this.m_bodyA.c_position.a;\n    const cB = this.m_bodyB.c_position.c;\n    let aB = this.m_bodyB.c_position.a;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    // Compute fresh Jacobians\n    const rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA)); // Vec2\n    const rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB)); // Vec2\n    const d = Vec2.sub(Vec2.add(cB, rB), Vec2.add(cA, rA)); // Vec2\n\n    const axis = Rot.mulVec2(qA, this.m_localXAxisA); // Vec2\n    const a1 = Vec2.crossVec2Vec2(Vec2.add(d, rA), axis); // float\n    const a2 = Vec2.crossVec2Vec2(rB, axis); // float\n    const perp = Rot.mulVec2(qA, this.m_localYAxisA); // Vec2\n\n    const s1 = Vec2.crossVec2Vec2(Vec2.add(d, rA), perp); // float\n    const s2 = Vec2.crossVec2Vec2(rB, perp); // float\n\n    let impulse = new Vec3();\n    const C1 = Vec2.zero(); // Vec2\n    C1.x = Vec2.dot(perp, d);\n    C1.y = aB - aA - this.m_referenceAngle;\n\n    let linearError = Math.abs(C1.x); // float\n    const angularError = Math.abs(C1.y); // float\n\n    const linearSlop = Settings.linearSlop;\n    const maxLinearCorrection = Settings.maxLinearCorrection;\n\n    let active = false; // bool\n    let C2 = 0.0; // float\n    if (this.m_enableLimit) {\n\n      const translation = Vec2.dot(axis, d); // float\n      if (Math.abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * linearSlop) {\n        // Prevent large angular corrections\n        C2 = Math.clamp(translation, -maxLinearCorrection, maxLinearCorrection);\n        linearError = Math.max(linearError, Math.abs(translation));\n        active = true;\n\n      } else if (translation <= this.m_lowerTranslation) {\n        // Prevent large linear corrections and allow some slop.\n        C2 = Math.clamp(translation - this.m_lowerTranslation + linearSlop,\n            -maxLinearCorrection, 0.0);\n        linearError = Math\n            .max(linearError, this.m_lowerTranslation - translation);\n        active = true;\n\n      } else if (translation >= this.m_upperTranslation) {\n        // Prevent large linear corrections and allow some slop.\n        C2 = Math.clamp(translation - this.m_upperTranslation - linearSlop, 0.0,\n            maxLinearCorrection);\n        linearError = Math\n            .max(linearError, translation - this.m_upperTranslation);\n        active = true;\n      }\n    }\n\n    if (active) {\n      const k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2; // float\n      const k12 = iA * s1 + iB * s2; // float\n      const k13 = iA * s1 * a1 + iB * s2 * a2; // float\n      let k22 = iA + iB; // float\n      if (k22 == 0.0) {\n        // For fixed rotation\n        k22 = 1.0;\n      }\n      const k23 = iA * a1 + iB * a2; // float\n      const k33 = mA + mB + iA * a1 * a1 + iB * a2 * a2; // float\n\n      const K = new Mat33();\n      K.ex.set(k11, k12, k13);\n      K.ey.set(k12, k22, k23);\n      K.ez.set(k13, k23, k33);\n\n      const C = new Vec3();\n      C.x = C1.x;\n      C.y = C1.y;\n      C.z = C2;\n\n      impulse = K.solve33(Vec3.neg(C));\n    } else {\n      const k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2; // float\n      const k12 = iA * s1 + iB * s2; // float\n      let k22 = iA + iB; // float\n      if (k22 == 0.0) {\n        k22 = 1.0;\n      }\n\n      const K = new Mat22();\n      K.ex.setNum(k11, k12);\n      K.ey.setNum(k12, k22);\n\n      const impulse1 = K.solve(Vec2.neg(C1)); // Vec2\n      impulse.x = impulse1.x;\n      impulse.y = impulse1.y;\n      impulse.z = 0.0;\n    }\n\n    const P = Vec2.combine(impulse.x, perp, impulse.z, axis); // Vec2\n    const LA = impulse.x * s1 + impulse.y + impulse.z * a1; // float\n    const LB = impulse.x * s2 + impulse.y + impulse.z * a2; // float\n\n    cA.subMul(mA, P);\n    aA -= iA * LA;\n    cB.addMul(mB, P);\n    aB += iB * LB;\n\n    this.m_bodyA.c_position.c = cA;\n    this.m_bodyA.c_position.a = aA;\n    this.m_bodyB.c_position.c = cB;\n    this.m_bodyB.c_position.a = aB;\n\n    return linearError <= Settings.linearSlop\n        && angularError <= Settings.angularSlop;\n  }\n\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { options } from '../../util/options';\nimport { SettingsInternal as Settings } from '../../Settings';\nimport { math as Math } from '../../common/Math';\nimport { Vec2 } from '../../common/Vec2';\nimport { Rot } from '../../common/Rot';\nimport { Joint, JointOpt, JointDef } from '../Joint';\nimport { Body } from '../Body';\nimport { RevoluteJoint } from './RevoluteJoint';\nimport { PrismaticJoint } from './PrismaticJoint';\nimport { TimeStep } from \"../Solver\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\nconst _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\n/**\n * Gear joint definition.\n */\nexport interface GearJointOpt extends JointOpt {\n  /**\n   * The gear ratio. See {@link GearJoint} for explanation.\n   */\n  ratio?: number;\n}\n/**\n * Gear joint definition.\n */\nexport interface GearJointDef extends JointDef, GearJointOpt {\n  /**\n   * The first revolute/prismatic joint attached to the gear joint.\n   */\n  joint1: RevoluteJoint | PrismaticJoint;\n  /**\n   * The second prismatic/revolute joint attached to the gear joint.\n   */\n  joint2: RevoluteJoint | PrismaticJoint;\n}\n\nconst DEFAULTS = {\n  ratio : 1.0\n};\n\n/**\n * A gear joint is used to connect two joints together. Either joint can be a\n * revolute or prismatic joint. You specify a gear ratio to bind the motions\n * together: coordinate1 + ratio * coordinate2 = constant\n *\n * The ratio can be negative or positive. If one joint is a revolute joint and\n * the other joint is a prismatic joint, then the ratio will have units of\n * length or units of 1/length. Warning: You have to manually destroy the gear\n * joint if joint1 or joint2 is destroyed.\n *\n * This definition requires two existing revolute or prismatic joints (any\n * combination will work).\n */\nexport class GearJoint extends Joint {\n  static TYPE = 'gear-joint' as const;\n\n  /** @internal */ m_type: 'gear-joint';\n  /** @internal */ m_joint1: RevoluteJoint | PrismaticJoint;\n  /** @internal */ m_joint2: RevoluteJoint | PrismaticJoint;\n  /** @internal */ m_type1: 'revolute-joint' | 'prismatic-joint';\n  /** @internal */ m_type2: 'revolute-joint' | 'prismatic-joint';\n  /** @internal */ m_bodyC: Body;\n  /** @internal */ m_localAnchorC: Vec2;\n  /** @internal */ m_localAnchorA: Vec2;\n  /** @internal */ m_referenceAngleA: number;\n  /** @internal */ m_localAxisC: Vec2;\n  /** @internal */ m_bodyD: Body;\n  /** @internal */ m_localAnchorD: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n  /** @internal */ m_referenceAngleB: number;\n  /** @internal */ m_localAxisD: Vec2;\n  /** @internal */ m_ratio: number;\n  /** @internal */ m_constant: number;\n  /** @internal */ m_impulse: number;\n\n  // Solver temp\n  /** @internal */ m_lcA: Vec2;\n  /** @internal */ m_lcB: Vec2;\n  /** @internal */ m_lcC: Vec2;\n  /** @internal */ m_lcD: Vec2;\n  /** @internal */ m_mA: number;\n  /** @internal */ m_mB: number;\n  /** @internal */ m_mC: number;\n  /** @internal */ m_mD: number;\n  /** @internal */ m_iA: number;\n  /** @internal */ m_iB: number;\n  /** @internal */ m_iC: number;\n  /** @internal */ m_iD: number;\n  /** @internal */ m_JvAC: Vec2;\n  /** @internal */ m_JvBD: Vec2;\n  /** @internal */ m_JwA: number;\n  /** @internal */ m_JwB: number;\n  /** @internal */ m_JwC: number;\n  /** @internal */ m_JwD: number;\n  /** @internal */ m_mass: number;\n\n  constructor(def: GearJointDef);\n  constructor(def: GearJointOpt, bodyA: Body, bodyB: Body, joint1: RevoluteJoint | PrismaticJoint, joint2: RevoluteJoint | PrismaticJoint, ratio?: number);\n  constructor(def: GearJointDef, bodyA?: Body, bodyB?: Body, joint1?: RevoluteJoint | PrismaticJoint, joint2?: RevoluteJoint | PrismaticJoint, ratio?: number) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof GearJoint)) {\n      return new GearJoint(def, bodyA, bodyB, joint1, joint2, ratio);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = GearJoint.TYPE;\n\n    _ASSERT && console.assert(joint1.m_type === RevoluteJoint.TYPE\n        || joint1.m_type === PrismaticJoint.TYPE);\n    _ASSERT && console.assert(joint2.m_type === RevoluteJoint.TYPE\n        || joint2.m_type === PrismaticJoint.TYPE);\n\n    this.m_joint1 = joint1 ? joint1 : def.joint1;\n    this.m_joint2 = joint2 ? joint2 : def.joint2;\n    this.m_ratio = Math.isFinite(ratio) ? ratio : def.ratio;\n\n    this.m_type1 = this.m_joint1.getType() as 'revolute-joint' | 'prismatic-joint';\n    this.m_type2 = this.m_joint2.getType() as 'revolute-joint' | 'prismatic-joint';\n\n    // joint1 connects body A to body C\n    // joint2 connects body B to body D\n\n    let coordinateA: number;\n    let coordinateB: number;\n\n    // TODO_ERIN there might be some problem with the joint edges in Joint.\n\n    this.m_bodyC = this.m_joint1.getBodyA();\n    this.m_bodyA = this.m_joint1.getBodyB();\n\n    // Get geometry of joint1\n    const xfA = this.m_bodyA.m_xf;\n    const aA = this.m_bodyA.m_sweep.a;\n    const xfC = this.m_bodyC.m_xf;\n    const aC = this.m_bodyC.m_sweep.a;\n\n    if (this.m_type1 === RevoluteJoint.TYPE) {\n      const revolute = this.m_joint1 as RevoluteJoint;\n      this.m_localAnchorC = revolute.m_localAnchorA;\n      this.m_localAnchorA = revolute.m_localAnchorB;\n      this.m_referenceAngleA = revolute.m_referenceAngle;\n      this.m_localAxisC = Vec2.zero();\n\n      coordinateA = aA - aC - this.m_referenceAngleA;\n    } else {\n      const prismatic = this.m_joint1 as PrismaticJoint;\n      this.m_localAnchorC = prismatic.m_localAnchorA;\n      this.m_localAnchorA = prismatic.m_localAnchorB;\n      this.m_referenceAngleA = prismatic.m_referenceAngle;\n      this.m_localAxisC = prismatic.m_localXAxisA;\n\n      const pC = this.m_localAnchorC;\n      const pA = Rot.mulTVec2(xfC.q, Vec2.add(Rot.mulVec2(xfA.q, this.m_localAnchorA), Vec2.sub(xfA.p, xfC.p)));\n      coordinateA = Vec2.dot(pA, this.m_localAxisC) - Vec2.dot(pC, this.m_localAxisC);\n    }\n\n    this.m_bodyD = this.m_joint2.getBodyA();\n    this.m_bodyB = this.m_joint2.getBodyB();\n\n    // Get geometry of joint2\n    const xfB = this.m_bodyB.m_xf;\n    const aB = this.m_bodyB.m_sweep.a;\n    const xfD = this.m_bodyD.m_xf;\n    const aD = this.m_bodyD.m_sweep.a;\n\n    if (this.m_type2 === RevoluteJoint.TYPE) {\n      const revolute = this.m_joint2 as RevoluteJoint;\n      this.m_localAnchorD = revolute.m_localAnchorA;\n      this.m_localAnchorB = revolute.m_localAnchorB;\n      this.m_referenceAngleB = revolute.m_referenceAngle;\n      this.m_localAxisD = Vec2.zero();\n\n      coordinateB = aB - aD - this.m_referenceAngleB;\n    } else {\n      const prismatic = this.m_joint2 as PrismaticJoint;\n      this.m_localAnchorD = prismatic.m_localAnchorA;\n      this.m_localAnchorB = prismatic.m_localAnchorB;\n      this.m_referenceAngleB = prismatic.m_referenceAngle;\n      this.m_localAxisD = prismatic.m_localXAxisA;\n\n      const pD = this.m_localAnchorD;\n      const pB = Rot.mulTVec2(xfD.q, Vec2.add(Rot.mulVec2(xfB.q, this.m_localAnchorB), Vec2.sub(xfB.p, xfD.p)));\n      coordinateB = Vec2.dot(pB, this.m_localAxisD) - Vec2.dot(pD, this.m_localAxisD);\n    }\n\n    this.m_constant = coordinateA + this.m_ratio * coordinateB;\n\n    this.m_impulse = 0.0;\n\n    // Gear Joint:\n    // C0 = (coordinate1 + ratio * coordinate2)_initial\n    // C = (coordinate1 + ratio * coordinate2) - C0 = 0\n    // J = [J1 ratio * J2]\n    // K = J * invM * JT\n    // = J1 * invM1 * J1T + ratio * ratio * J2 * invM2 * J2T\n    //\n    // Revolute:\n    // coordinate = rotation\n    // Cdot = angularVelocity\n    // J = [0 0 1]\n    // K = J * invM * JT = invI\n    //\n    // Prismatic:\n    // coordinate = dot(p - pg, ug)\n    // Cdot = dot(v + cross(w, r), ug)\n    // J = [ug cross(r, ug)]\n    // K = J * invM * JT = invMass + invI * cross(r, ug)^2\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      joint1: this.m_joint1,\n      joint2: this.m_joint2,\n      ratio: this.m_ratio,\n\n      // _constant: this.m_constant,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): GearJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    data.joint1 = restore(Joint, data.joint1, world);\n    data.joint2 = restore(Joint, data.joint2, world);\n    const joint = new GearJoint(data);\n    // if (data._constant) joint.m_constant = data._constant;\n    return joint;\n  }\n\n  /**\n   * Get the first joint.\n   */\n  getJoint1(): Joint {\n    return this.m_joint1;\n  }\n\n  /**\n   * Get the second joint.\n   */\n  getJoint2(): Joint {\n    return this.m_joint2;\n  }\n\n  /**\n   * Set the gear ratio.\n   */\n  setRatio(ratio: number): void {\n    _ASSERT && console.assert(Math.isFinite(ratio));\n    this.m_ratio = ratio;\n  }\n\n  /**\n   * Get the gear ratio.\n   */\n  getRatio(): number {\n    return this.m_ratio;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.mulNumVec2(this.m_impulse, this.m_JvAC).mul(inv_dt);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    const L = this.m_impulse * this.m_JwA; // float\n    return inv_dt * L;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_lcA = this.m_bodyA.m_sweep.localCenter;\n    this.m_lcB = this.m_bodyB.m_sweep.localCenter;\n    this.m_lcC = this.m_bodyC.m_sweep.localCenter;\n    this.m_lcD = this.m_bodyD.m_sweep.localCenter;\n    this.m_mA = this.m_bodyA.m_invMass;\n    this.m_mB = this.m_bodyB.m_invMass;\n    this.m_mC = this.m_bodyC.m_invMass;\n    this.m_mD = this.m_bodyD.m_invMass;\n    this.m_iA = this.m_bodyA.m_invI;\n    this.m_iB = this.m_bodyB.m_invI;\n    this.m_iC = this.m_bodyC.m_invI;\n    this.m_iD = this.m_bodyD.m_invI;\n\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const aC = this.m_bodyC.c_position.a;\n    const vC = this.m_bodyC.c_velocity.v;\n    let wC = this.m_bodyC.c_velocity.w;\n\n    const aD = this.m_bodyD.c_position.a;\n    const vD = this.m_bodyD.c_velocity.v;\n    let wD = this.m_bodyD.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n    const qC = Rot.neo(aC);\n    const qD = Rot.neo(aD);\n\n    this.m_mass = 0.0;\n\n    if (this.m_type1 == RevoluteJoint.TYPE) {\n      this.m_JvAC = Vec2.zero();\n      this.m_JwA = 1.0;\n      this.m_JwC = 1.0;\n      this.m_mass += this.m_iA + this.m_iC;\n    } else {\n      const u = Rot.mulVec2(qC, this.m_localAxisC); // Vec2\n      const rC = Rot.mulSub(qC, this.m_localAnchorC, this.m_lcC); // Vec2\n      const rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_lcA); // Vec2\n      this.m_JvAC = u;\n      this.m_JwC = Vec2.crossVec2Vec2(rC, u);\n      this.m_JwA = Vec2.crossVec2Vec2(rA, u);\n      this.m_mass += this.m_mC + this.m_mA + this.m_iC * this.m_JwC * this.m_JwC + this.m_iA * this.m_JwA * this.m_JwA;\n    }\n\n    if (this.m_type2 == RevoluteJoint.TYPE) {\n      this.m_JvBD = Vec2.zero();\n      this.m_JwB = this.m_ratio;\n      this.m_JwD = this.m_ratio;\n      this.m_mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);\n    } else {\n      const u = Rot.mulVec2(qD, this.m_localAxisD); // Vec2\n      const rD = Rot.mulSub(qD, this.m_localAnchorD, this.m_lcD); // Vec2\n      const rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_lcB); // Vec2\n      this.m_JvBD = Vec2.mulNumVec2(this.m_ratio, u);\n      this.m_JwD = this.m_ratio * Vec2.crossVec2Vec2(rD, u);\n      this.m_JwB = this.m_ratio * Vec2.crossVec2Vec2(rB, u);\n      this.m_mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * this.m_JwD * this.m_JwD + this.m_iB * this.m_JwB * this.m_JwB;\n    }\n\n    // Compute effective mass.\n    this.m_mass = this.m_mass > 0.0 ? 1.0 / this.m_mass : 0.0;\n\n    if (step.warmStarting) {\n      vA.addMul(this.m_mA * this.m_impulse, this.m_JvAC);\n      wA += this.m_iA * this.m_impulse * this.m_JwA;\n\n      vB.addMul(this.m_mB * this.m_impulse, this.m_JvBD);\n      wB += this.m_iB * this.m_impulse * this.m_JwB;\n\n      vC.subMul(this.m_mC * this.m_impulse, this.m_JvAC);\n      wC -= this.m_iC * this.m_impulse * this.m_JwC;\n\n      vD.subMul(this.m_mD * this.m_impulse, this.m_JvBD);\n      wD -= this.m_iD * this.m_impulse * this.m_JwD;\n\n    } else {\n      this.m_impulse = 0.0;\n    }\n\n    this.m_bodyA.c_velocity.v.setVec2(vA);\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v.setVec2(vB);\n    this.m_bodyB.c_velocity.w = wB;\n    this.m_bodyC.c_velocity.v.setVec2(vC);\n    this.m_bodyC.c_velocity.w = wC;\n    this.m_bodyD.c_velocity.v.setVec2(vD);\n    this.m_bodyD.c_velocity.w = wD;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n    const vC = this.m_bodyC.c_velocity.v;\n    let wC = this.m_bodyC.c_velocity.w;\n    const vD = this.m_bodyD.c_velocity.v;\n    let wD = this.m_bodyD.c_velocity.w;\n\n    let Cdot = Vec2.dot(this.m_JvAC, vA) - Vec2.dot(this.m_JvAC, vC)\n        + Vec2.dot(this.m_JvBD, vB) - Vec2.dot(this.m_JvBD, vD); // float\n    Cdot += (this.m_JwA * wA - this.m_JwC * wC)\n        + (this.m_JwB * wB - this.m_JwD * wD);\n\n    const impulse = -this.m_mass * Cdot; // float\n    this.m_impulse += impulse;\n\n    vA.addMul(this.m_mA * impulse, this.m_JvAC);\n    wA += this.m_iA * impulse * this.m_JwA;\n    vB.addMul(this.m_mB * impulse, this.m_JvBD);\n    wB += this.m_iB * impulse * this.m_JwB;\n    vC.subMul(this.m_mC * impulse, this.m_JvAC);\n    wC -= this.m_iC * impulse * this.m_JwC;\n    vD.subMul(this.m_mD * impulse, this.m_JvBD);\n    wD -= this.m_iD * impulse * this.m_JwD;\n\n    this.m_bodyA.c_velocity.v.setVec2(vA);\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v.setVec2(vB);\n    this.m_bodyB.c_velocity.w = wB;\n    this.m_bodyC.c_velocity.v.setVec2(vC);\n    this.m_bodyC.c_velocity.w = wC;\n    this.m_bodyD.c_velocity.v.setVec2(vD);\n    this.m_bodyD.c_velocity.w = wD;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    const cA = this.m_bodyA.c_position.c;\n    let aA = this.m_bodyA.c_position.a;\n    const cB = this.m_bodyB.c_position.c;\n    let aB = this.m_bodyB.c_position.a;\n    const cC = this.m_bodyC.c_position.c;\n    let aC = this.m_bodyC.c_position.a;\n    const cD = this.m_bodyD.c_position.c;\n    let aD = this.m_bodyD.c_position.a;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n    const qC = Rot.neo(aC);\n    const qD = Rot.neo(aD);\n\n    const linearError = 0.0;\n\n    let coordinateA: number;\n    let coordinateB: number;\n\n    let JvAC: Vec2;\n    let JvBD: Vec2;\n    let JwA: number;\n    let JwB: number;\n    let JwC: number;\n    let JwD: number;\n    let mass = 0.0;\n\n    if (this.m_type1 == RevoluteJoint.TYPE) {\n      JvAC = Vec2.zero();\n      JwA = 1.0;\n      JwC = 1.0;\n      mass += this.m_iA + this.m_iC;\n\n      coordinateA = aA - aC - this.m_referenceAngleA;\n    } else {\n      const u = Rot.mulVec2(qC, this.m_localAxisC); // Vec2\n      const rC = Rot.mulSub(qC, this.m_localAnchorC, this.m_lcC); // Vec2\n      const rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_lcA); // Vec2\n      JvAC = u;\n      JwC = Vec2.crossVec2Vec2(rC, u);\n      JwA = Vec2.crossVec2Vec2(rA, u);\n      mass += this.m_mC + this.m_mA + this.m_iC * JwC * JwC + this.m_iA * JwA * JwA;\n\n      const pC = Vec2.sub(this.m_localAnchorC, this.m_lcC); // Vec2\n      const pA = Rot.mulTVec2(qC, Vec2.add(rA, Vec2.sub(cA, cC))); // Vec2\n      coordinateA = Vec2.dot(Vec2.sub(pA, pC), this.m_localAxisC);\n    }\n\n    if (this.m_type2 == RevoluteJoint.TYPE) {\n      JvBD = Vec2.zero();\n      JwB = this.m_ratio;\n      JwD = this.m_ratio;\n      mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);\n\n      coordinateB = aB - aD - this.m_referenceAngleB;\n    } else {\n      const u = Rot.mulVec2(qD, this.m_localAxisD);\n      const rD = Rot.mulSub(qD, this.m_localAnchorD, this.m_lcD);\n      const rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_lcB);\n      JvBD = Vec2.mulNumVec2(this.m_ratio, u);\n      JwD = this.m_ratio * Vec2.crossVec2Vec2(rD, u);\n      JwB = this.m_ratio * Vec2.crossVec2Vec2(rB, u);\n      mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD\n          * JwD * JwD + this.m_iB * JwB * JwB;\n\n      const pD = Vec2.sub(this.m_localAnchorD, this.m_lcD); // Vec2\n      const pB = Rot.mulTVec2(qD, Vec2.add(rB, Vec2.sub(cB, cD))); // Vec2\n      coordinateB = Vec2.dot(pB, this.m_localAxisD)\n          - Vec2.dot(pD, this.m_localAxisD);\n    }\n\n    const C = (coordinateA + this.m_ratio * coordinateB) - this.m_constant; // float\n\n    let impulse = 0.0; // float\n    if (mass > 0.0) {\n      impulse = -C / mass;\n    }\n\n    cA.addMul(this.m_mA * impulse, JvAC);\n    aA += this.m_iA * impulse * JwA;\n    cB.addMul(this.m_mB * impulse, JvBD);\n    aB += this.m_iB * impulse * JwB;\n    cC.subMul(this.m_mC * impulse, JvAC);\n    aC -= this.m_iC * impulse * JwC;\n    cD.subMul(this.m_mD * impulse, JvBD);\n    aD -= this.m_iD * impulse * JwD;\n\n    this.m_bodyA.c_position.c.setVec2(cA);\n    this.m_bodyA.c_position.a = aA;\n    this.m_bodyB.c_position.c.setVec2(cB);\n    this.m_bodyB.c_position.a = aB;\n    this.m_bodyC.c_position.c.setVec2(cC);\n    this.m_bodyC.c_position.a = aC;\n    this.m_bodyD.c_position.c.setVec2(cD);\n    this.m_bodyD.c_position.a = aD;\n\n    // TODO_ERIN not implemented\n    return linearError < Settings.linearSlop;\n  }\n\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { options } from '../../util/options';\nimport { math as Math } from '../../common/Math';\nimport { Vec2 } from '../../common/Vec2';\nimport { Mat22 } from '../../common/Mat22';\nimport { Rot } from '../../common/Rot';\nimport { Joint, JointOpt, JointDef } from '../Joint';\nimport { Body } from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\nconst _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\n/**\n * Motor joint definition.\n */\nexport interface MotorJointOpt extends JointOpt {\n  /**\n   * The bodyB angle minus bodyA angle in radians.\n   */\n  angularOffset?: number;\n  /**\n   * The maximum motor force in N.\n   */\n  maxForce?: number;\n  /**\n   * The maximum motor torque in N-m.\n   */\n  maxTorque?: number;\n  /**\n   * Position correction factor in the range [0,1].\n   */\n  correctionFactor?: number;\n  /**\n   * Position of bodyB minus the position of bodyA, in bodyA's frame, in meters.\n   */\n  linearOffset?: Vec2;\n}\n/**\n * Motor joint definition.\n */\nexport interface MotorJointDef extends JointDef, MotorJointOpt {\n}\n\nconst DEFAULTS = {\n  maxForce : 1.0,\n  maxTorque : 1.0,\n  correctionFactor : 0.3\n};\n\n/**\n * A motor joint is used to control the relative motion between two bodies. A\n * typical usage is to control the movement of a dynamic body with respect to\n * the ground.\n */\nexport class MotorJoint extends Joint {\n  static TYPE = 'motor-joint' as const;\n\n  /** @internal */ m_type: 'motor-joint';\n  /** @internal */ m_linearOffset: Vec2;\n  /** @internal */ m_angularOffset: number;\n  /** @internal */ m_linearImpulse: Vec2;\n  /** @internal */ m_angularImpulse: number;\n  /** @internal */ m_maxForce: number;\n  /** @internal */ m_maxTorque: number;\n  /** @internal */ m_correctionFactor: number;\n\n  // Solver temp\n  /** @internal */ m_rA: Vec2;\n  /** @internal */ m_rB: Vec2;\n  /** @internal */ m_localCenterA: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_linearError: Vec2;\n  /** @internal */ m_angularError: number;\n  /** @internal */ m_invMassA: number;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIA: number;\n  /** @internal */ m_invIB: number;\n  /** @internal */ m_linearMass: Mat22;\n  /** @internal */ m_angularMass: number;\n\n  constructor(def: MotorJointDef);\n  constructor(def: MotorJointOpt, bodyA: Body, bodyB: Body);\n  constructor(def: MotorJointDef | MotorJointOpt, bodyA?: Body, bodyB?: Body) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof MotorJoint)) {\n      return new MotorJoint(def, bodyA, bodyB);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = MotorJoint.TYPE;\n\n    this.m_linearOffset = Math.isFinite(def.linearOffset) ? def.linearOffset : bodyA.getLocalPoint(bodyB.getPosition());\n    this.m_angularOffset = Math.isFinite(def.angularOffset) ? def.angularOffset : bodyB.getAngle() - bodyA.getAngle();\n\n    this.m_linearImpulse = Vec2.zero();\n    this.m_angularImpulse = 0.0;\n\n    this.m_maxForce = def.maxForce;\n    this.m_maxTorque = def.maxTorque;\n    this.m_correctionFactor = def.correctionFactor;\n\n    // Point-to-point constraint\n    // Cdot = v2 - v1\n    // = v2 + cross(w2, r2) - v1 - cross(w1, r1)\n    // J = [-I -r1_skew I r2_skew ]\n    // Identity used:\n    // w k % (rx i + ry j) = w * (-ry i + rx j)\n    //\n    // r1 = offset - c1\n    // r2 = -c2\n\n    // Angle constraint\n    // Cdot = w2 - w1\n    // J = [0 0 -1 0 0 1]\n    // K = invI1 + invI2\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      maxForce: this.m_maxForce,\n      maxTorque: this.m_maxTorque,\n      correctionFactor: this.m_correctionFactor,\n\n      linearOffset: this.m_linearOffset,\n      angularOffset: this.m_angularOffset,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): MotorJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    const joint = new MotorJoint(data);\n    return joint;\n  }\n\n  /** @internal */\n  _setAnchors(def: {}): void {\n  }\n\n  /**\n   * Set the maximum friction force in N.\n   */\n  setMaxForce(force: number): void {\n    _ASSERT && console.assert(Math.isFinite(force) && force >= 0.0);\n    this.m_maxForce = force;\n  }\n\n  /**\n   * Get the maximum friction force in N.\n   */\n  getMaxForce(): number {\n    return this.m_maxForce;\n  }\n\n  /**\n   * Set the maximum friction torque in N*m.\n   */\n  setMaxTorque(torque: number): void {\n    _ASSERT && console.assert(Math.isFinite(torque) && torque >= 0.0);\n    this.m_maxTorque = torque;\n  }\n\n  /**\n   * Get the maximum friction torque in N*m.\n   */\n  getMaxTorque(): number {\n    return this.m_maxTorque;\n  }\n\n  /**\n   * Set the position correction factor in the range [0,1].\n   */\n  setCorrectionFactor(factor: number): void {\n    _ASSERT && console.assert(Math.isFinite(factor) && 0.0 <= factor && factor <= 1.0);\n    this.m_correctionFactor = factor;\n  }\n\n  /**\n   * Get the position correction factor in the range [0,1].\n   */\n  getCorrectionFactor(): number {\n    return this.m_correctionFactor;\n  }\n\n  /**\n   * Set/get the target linear offset, in frame A, in meters.\n   */\n  setLinearOffset(linearOffset: Vec2): void {\n    if (linearOffset.x != this.m_linearOffset.x\n        || linearOffset.y != this.m_linearOffset.y) {\n      this.m_bodyA.setAwake(true);\n      this.m_bodyB.setAwake(true);\n      this.m_linearOffset = linearOffset;\n    }\n  }\n\n  getLinearOffset(): Vec2 {\n    return this.m_linearOffset;\n  }\n\n  /**\n   * Set/get the target angular offset, in radians.\n   */\n  setAngularOffset(angularOffset: number): void {\n    if (angularOffset != this.m_angularOffset) {\n      this.m_bodyA.setAwake(true);\n      this.m_bodyB.setAwake(true);\n      this.m_angularOffset = angularOffset;\n    }\n  }\n\n  getAngularOffset(): number {\n    return this.m_angularOffset;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getPosition();\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getPosition();\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.mulNumVec2(inv_dt, this.m_linearImpulse);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return inv_dt * this.m_angularImpulse;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassA = this.m_bodyA.m_invMass;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIA = this.m_bodyA.m_invI;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const cA = this.m_bodyA.c_position.c;\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const cB = this.m_bodyB.c_position.c;\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    // Compute the effective mass matrix.\n    this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_linearOffset, this.m_localCenterA));\n    this.m_rB = Rot.mulVec2(qB, Vec2.neg(this.m_localCenterB));\n\n    // J = [-I -r1_skew I r2_skew]\n    // r_skew = [-ry; rx]\n\n    // Matlab\n    // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]\n    // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]\n    // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    // Upper 2 by 2 of K for point to point\n    const K = new Mat22();\n    K.ex.x = mA + mB + iA * this.m_rA.y * this.m_rA.y + iB * this.m_rB.y * this.m_rB.y;\n    K.ex.y = -iA * this.m_rA.x * this.m_rA.y - iB * this.m_rB.x * this.m_rB.y;\n    K.ey.x = K.ex.y;\n    K.ey.y = mA + mB + iA * this.m_rA.x * this.m_rA.x + iB * this.m_rB.x * this.m_rB.x;\n\n    this.m_linearMass = K.getInverse();\n\n    this.m_angularMass = iA + iB;\n    if (this.m_angularMass > 0.0) {\n      this.m_angularMass = 1.0 / this.m_angularMass;\n    }\n\n    this.m_linearError = Vec2.zero();\n    this.m_linearError.addCombine(1, cB, 1, this.m_rB);\n    this.m_linearError.subCombine(1, cA, 1, this.m_rA);\n\n    this.m_angularError = aB - aA - this.m_angularOffset;\n\n    if (step.warmStarting) {\n      // Scale impulses to support a variable time step.\n      this.m_linearImpulse.mul(step.dtRatio);\n      this.m_angularImpulse *= step.dtRatio;\n\n      const P = Vec2.neo(this.m_linearImpulse.x, this.m_linearImpulse.y);\n\n      vA.subMul(mA, P);\n      wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + this.m_angularImpulse);\n\n      vB.addMul(mB, P);\n      wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + this.m_angularImpulse);\n\n    } else {\n      this.m_linearImpulse.setZero();\n      this.m_angularImpulse = 0.0;\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    const h = step.dt;\n    const inv_h = step.inv_dt;\n\n    // Solve angular friction\n    {\n      const Cdot = wB - wA + inv_h * this.m_correctionFactor * this.m_angularError;\n      let impulse = -this.m_angularMass * Cdot;\n\n      const oldImpulse = this.m_angularImpulse;\n      const maxImpulse = h * this.m_maxTorque;\n      this.m_angularImpulse = Math.clamp(this.m_angularImpulse + impulse,\n          -maxImpulse, maxImpulse);\n      impulse = this.m_angularImpulse - oldImpulse;\n\n      wA -= iA * impulse;\n      wB += iB * impulse;\n    }\n\n    // Solve linear friction\n    {\n      const Cdot = Vec2.zero();\n      Cdot.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, this.m_rB));\n      Cdot.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, this.m_rA));\n      Cdot.addMul(inv_h * this.m_correctionFactor, this.m_linearError);\n\n      let impulse = Vec2.neg(Mat22.mulVec2(this.m_linearMass, Cdot));\n      const oldImpulse = Vec2.clone(this.m_linearImpulse);\n      this.m_linearImpulse.add(impulse);\n\n      const maxImpulse = h * this.m_maxForce;\n\n      this.m_linearImpulse.clamp(maxImpulse);\n\n      impulse = Vec2.sub(this.m_linearImpulse, oldImpulse);\n\n      vA.subMul(mA, impulse);\n      wA -= iA * Vec2.crossVec2Vec2(this.m_rA, impulse);\n\n      vB.addMul(mB, impulse);\n      wB += iB * Vec2.crossVec2Vec2(this.m_rB, impulse);\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    return true;\n  }\n\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { options } from '../../util/options';\nimport { math as Math } from '../../common/Math';\nimport { Vec2, Vec2Value } from '../../common/Vec2';\nimport { Mat22 } from '../../common/Mat22';\nimport { Rot } from '../../common/Rot';\nimport { Transform } from '../../common/Transform';\nimport { Joint, JointOpt, JointDef } from '../Joint';\nimport { Body } from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\nconst _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\n/**\n * Mouse joint definition. This requires a world target point, tuning\n * parameters, and the time step.\n */\nexport interface MouseJointOpt extends JointOpt {\n  /**\n   * [maxForce = 0.0] The maximum constraint force that can be exerted to move\n   * the candidate body. Usually you will express as some multiple of the\n   * weight (multiplier * mass * gravity).\n   */\n  maxForce?: number;\n  /**\n   * [frequencyHz = 5.0] The response speed.\n   */\n  frequencyHz?: number;\n  /**\n   * [dampingRatio = 0.7] The damping ratio. 0 = no damping, 1 = critical\n   * damping.\n   */\n  dampingRatio?: number;\n}\n/**\n * Mouse joint definition. This requires a world target point, tuning\n * parameters, and the time step.\n */\nexport interface MouseJointDef extends JointDef, MouseJointOpt {\n  /**\n   * The initial world target point. This is assumed to coincide with the body\n   * anchor initially.\n   */\n  target: Vec2Value;\n}\n\nconst DEFAULTS = {\n  maxForce : 0.0,\n  frequencyHz : 5.0,\n  dampingRatio : 0.7\n};\n\n/**\n * A mouse joint is used to make a point on a body track a specified world\n * point. This a soft constraint with a maximum force. This allows the\n * constraint to stretch and without applying huge forces.\n *\n * NOTE: this joint is not documented in the manual because it was developed to\n * be used in the testbed. If you want to learn how to use the mouse joint, look\n * at the testbed.\n */\nexport class MouseJoint extends Joint {\n  static TYPE = 'mouse-joint' as const;\n\n  /** @internal */ m_type: 'mouse-joint';\n  /** @internal */ m_targetA: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n  /** @internal */ m_maxForce: number;\n  /** @internal */ m_impulse: Vec2;\n  /** @internal */ m_frequencyHz: number;\n  /** @internal */ m_dampingRatio: number;\n  /** @internal */ m_beta: number;\n  /** @internal */ m_gamma: number;\n  // Solver temp\n  /** @internal */ m_rB: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIB: number;\n  /** @internal */ m_mass: Mat22;\n  /** @internal */ m_C: Vec2;\n\n  constructor(def: MouseJointDef);\n  constructor(def: MouseJointOpt, bodyA: Body, bodyB: Body, target: Vec2);\n  constructor(def: MouseJointDef, bodyA?: Body, bodyB?: Body, target?: Vec2) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof MouseJoint)) {\n      return new MouseJoint(def, bodyA, bodyB, target);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = MouseJoint.TYPE;\n\n    _ASSERT && console.assert(Math.isFinite(def.maxForce) && def.maxForce >= 0.0);\n    _ASSERT && console.assert(Math.isFinite(def.frequencyHz) && def.frequencyHz >= 0.0);\n    _ASSERT && console.assert(Math.isFinite(def.dampingRatio) && def.dampingRatio >= 0.0);\n\n    if (Vec2.isValid(target)) {\n      this.m_targetA = Vec2.clone(target);\n    } else if (Vec2.isValid(def.target)) {\n      this.m_targetA = Vec2.clone(def.target);\n    } else {\n      this.m_targetA = Vec2.zero();\n    }\n\n    this.m_localAnchorB = Transform.mulTVec2(bodyB.getTransform(), this.m_targetA);\n\n    this.m_maxForce = def.maxForce;\n    this.m_impulse = Vec2.zero();\n\n    this.m_frequencyHz = def.frequencyHz;\n    this.m_dampingRatio = def.dampingRatio;\n\n    this.m_beta = 0.0;\n    this.m_gamma = 0.0;\n\n    // Solver temp\n    this.m_rB = Vec2.zero();\n    this.m_localCenterB = Vec2.zero();\n    this.m_invMassB = 0.0;\n    this.m_invIB = 0.0;\n    this.m_mass = new Mat22();\n    this.m_C = Vec2.zero();\n\n    // p = attached point, m = mouse point\n    // C = p - m\n    // Cdot = v\n    // = v + cross(w, r)\n    // J = [I r_skew]\n    // Identity used:\n    // w k % (rx i + ry j) = w * (-ry i + rx j)\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      target: this.m_targetA,\n      maxForce: this.m_maxForce,\n      frequencyHz: this.m_frequencyHz,\n      dampingRatio: this.m_dampingRatio,\n\n      _localAnchorB: this.m_localAnchorB,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): MouseJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    data.target = Vec2.clone(data.target);\n    const joint = new MouseJoint(data);\n    if (data._localAnchorB) {\n      joint.m_localAnchorB = data._localAnchorB;\n    }\n    return joint;\n  }\n\n  /**\n   * Use this to update the target point.\n   */\n  setTarget(target: Vec2Value): void {\n    if (Vec2.areEqual(target, this.m_targetA)) return;\n    this.m_bodyB.setAwake(true);\n    this.m_targetA = Vec2.clone(target);\n  }\n\n  getTarget(): Vec2 {\n    return this.m_targetA;\n  }\n\n  /**\n   * Set the maximum force in Newtons.\n   */\n  setMaxForce(force: number): void {\n    this.m_maxForce = force;\n  }\n\n  /**\n   * Get the maximum force in Newtons.\n   */\n  getMaxForce(): number {\n    return this.m_maxForce;\n  }\n\n  /**\n   * Set the frequency in Hertz.\n   */\n  setFrequency(hz: number): void {\n    this.m_frequencyHz = hz;\n  }\n\n  /**\n   * Get the frequency in Hertz.\n   */\n  getFrequency(): number {\n    return this.m_frequencyHz;\n  }\n\n  /**\n   * Set the damping ratio (dimensionless).\n   */\n  setDampingRatio(ratio: number): void {\n    this.m_dampingRatio = ratio;\n  }\n\n  /**\n   * Get the damping ratio (dimensionless).\n   */\n  getDampingRatio(): number {\n    return this.m_dampingRatio;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return Vec2.clone(this.m_targetA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.mulNumVec2(inv_dt, this.m_impulse);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return inv_dt * 0.0;\n  }\n\n  /**\n   * Shift the origin for any points stored in world coordinates.\n   */\n  shiftOrigin(newOrigin: Vec2Value): void {\n    this.m_targetA.sub(newOrigin);\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const position = this.m_bodyB.c_position;\n    const velocity = this.m_bodyB.c_velocity;\n\n    const cB = position.c;\n    const aB = position.a;\n    const vB = velocity.v;\n    let wB = velocity.w;\n\n    const qB = Rot.neo(aB);\n\n    const mass = this.m_bodyB.getMass();\n\n    // Frequency\n    const omega = 2.0 * Math.PI * this.m_frequencyHz;\n\n    // Damping coefficient\n    const d = 2.0 * mass * this.m_dampingRatio * omega;\n\n    // Spring stiffness\n    const k = mass * (omega * omega);\n\n    // magic formulas\n    // gamma has units of inverse mass.\n    // beta has units of inverse time.\n    const h = step.dt;\n    _ASSERT && console.assert(d + h * k > Math.EPSILON);\n    this.m_gamma = h * (d + h * k);\n    if (this.m_gamma != 0.0) {\n      this.m_gamma = 1.0 / this.m_gamma;\n    }\n    this.m_beta = h * k * this.m_gamma;\n\n    // Compute the effective mass matrix.\n    this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n\n    // K = [(1/m1 + 1/m2) * eye(2) - skew(r1) * invI1 * skew(r1) - skew(r2) *\n    // invI2 * skew(r2)]\n    // = [1/m1+1/m2 0 ] + invI1 * [r1.y*r1.y -r1.x*r1.y] + invI2 * [r1.y*r1.y\n    // -r1.x*r1.y]\n    // [ 0 1/m1+1/m2] [-r1.x*r1.y r1.x*r1.x] [-r1.x*r1.y r1.x*r1.x]\n    const K = new Mat22();\n    K.ex.x = this.m_invMassB + this.m_invIB * this.m_rB.y * this.m_rB.y\n        + this.m_gamma;\n    K.ex.y = -this.m_invIB * this.m_rB.x * this.m_rB.y;\n    K.ey.x = K.ex.y;\n    K.ey.y = this.m_invMassB + this.m_invIB * this.m_rB.x * this.m_rB.x\n        + this.m_gamma;\n\n    this.m_mass = K.getInverse();\n\n    this.m_C.setVec2(cB);\n    this.m_C.addCombine(1, this.m_rB, -1, this.m_targetA);\n    this.m_C.mul(this.m_beta);\n\n    // Cheat with some damping\n    wB *= 0.98;\n\n    if (step.warmStarting) {\n      this.m_impulse.mul(step.dtRatio);\n      vB.addMul(this.m_invMassB, this.m_impulse);\n      wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, this.m_impulse);\n\n    } else {\n      this.m_impulse.setZero();\n    }\n\n    velocity.v.setVec2(vB);\n    velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const velocity = this.m_bodyB.c_velocity;\n    const vB = Vec2.clone(velocity.v);\n    let wB = velocity.w;\n\n    // Cdot = v + cross(w, r)\n\n    const Cdot = Vec2.crossNumVec2(wB, this.m_rB);\n    Cdot.add(vB);\n\n    Cdot.addCombine(1, this.m_C, this.m_gamma, this.m_impulse);\n    Cdot.neg();\n\n    let impulse = Mat22.mulVec2(this.m_mass, Cdot);\n\n    const oldImpulse = Vec2.clone(this.m_impulse);\n    this.m_impulse.add(impulse);\n    const maxImpulse = step.dt * this.m_maxForce;\n    this.m_impulse.clamp(maxImpulse);\n    impulse = Vec2.sub(this.m_impulse, oldImpulse);\n\n    vB.addMul(this.m_invMassB, impulse);\n    wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, impulse);\n\n    velocity.v.setVec2(vB);\n    velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    return true;\n  }\n\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { options } from '../../util/options';\nimport { SettingsInternal as Settings } from '../../Settings';\nimport { math as Math } from '../../common/Math';\nimport { Vec2 } from '../../common/Vec2';\nimport { Rot } from '../../common/Rot';\nimport { Joint, JointOpt, JointDef } from '../Joint';\nimport { Body } from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\nconst _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\n/**\n * Pulley joint definition. This requires two ground anchors, two dynamic body\n * anchor points, and a pulley ratio.\n */\n// tslint:disable-next-line:no-empty-interface\nexport interface PulleyJointOpt extends JointOpt {\n}\n/**\n * Pulley joint definition. This requires two ground anchors, two dynamic body\n * anchor points, and a pulley ratio.\n */\nexport interface PulleyJointDef extends JointDef, PulleyJointOpt {\n  /**\n   * The first ground anchor in world coordinates. This point never moves.\n   */\n  groundAnchorA: Vec2;\n  /**\n   * The second ground anchor in world coordinates. This point never moves.\n   */\n  groundAnchorB: Vec2;\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  localAnchorA: Vec2;\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  localAnchorB: Vec2;\n  /**\n   * The reference length for the segment attached to bodyA.\n   */\n  lengthA: number;\n  /**\n   * The reference length for the segment attached to bodyB.\n   */\n  lengthB: number;\n  /**\n   * The pulley ratio, used to simulate a block-and-tackle.\n   */\n  ratio: number;\n}\n\nconst DEFAULTS = {\n  collideConnected : true\n};\n\n/**\n * The pulley joint is connected to two bodies and two fixed ground points. The\n * pulley supports a ratio such that: length1 + ratio * length2 <= constant\n *\n * Yes, the force transmitted is scaled by the ratio.\n *\n * Warning: the pulley joint can get a bit squirrelly by itself. They often work\n * better when combined with prismatic joints. You should also cover the the\n * anchor points with static shapes to prevent one side from going to zero\n * length.\n */\nexport class PulleyJoint extends Joint {\n  static TYPE = 'pulley-joint' as const;\n  // static MIN_PULLEY_LENGTH: number = 2.0; // TODO where this is used?\n\n  /** @internal */ m_type: 'pulley-joint';\n  /** @internal */ m_groundAnchorA: Vec2;\n  /** @internal */ m_groundAnchorB: Vec2;\n  /** @internal */ m_localAnchorA: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n  /** @internal */ m_lengthA: number;\n  /** @internal */ m_lengthB: number;\n  /** @internal */ m_ratio: number;\n  /** @internal */ m_constant: number;\n  /** @internal */ m_impulse: number;\n\n  // Solver temp\n  /** @internal */ m_uA: Vec2;\n  /** @internal */ m_uB: Vec2;\n  /** @internal */ m_rA: Vec2;\n  /** @internal */ m_rB: Vec2;\n  /** @internal */ m_localCenterA: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_invMassA: number;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIA: number;\n  /** @internal */ m_invIB: number;\n  /** @internal */ m_mass: number;\n\n  constructor(def: PulleyJointDef);\n  constructor(def: PulleyJointOpt, bodyA: Body, bodyB: Body, groundA: Vec2, groundB: Vec2, anchorA: Vec2, anchorB: Vec2, ratio: number);\n  constructor(def: PulleyJointDef, bodyA?: Body, bodyB?: Body, groundA?: Vec2, groundB?: Vec2, anchorA?: Vec2, anchorB?: Vec2, ratio?: number) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof PulleyJoint)) {\n      return new PulleyJoint(def, bodyA, bodyB, groundA, groundB, anchorA, anchorB, ratio);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = PulleyJoint.TYPE;\n    this.m_groundAnchorA = groundA ? groundA : def.groundAnchorA || Vec2.neo(-1.0, 1.0);\n    this.m_groundAnchorB = groundB ? groundB : def.groundAnchorB || Vec2.neo(1.0, 1.0);\n    this.m_localAnchorA = anchorA ? bodyA.getLocalPoint(anchorA) : def.localAnchorA || Vec2.neo(-1.0, 0.0);\n    this.m_localAnchorB = anchorB ? bodyB.getLocalPoint(anchorB) : def.localAnchorB || Vec2.neo(1.0, 0.0);\n    this.m_lengthA = Math.isFinite(def.lengthA) ? def.lengthA : Vec2.distance(anchorA, groundA);\n    this.m_lengthB = Math.isFinite(def.lengthB) ? def.lengthB : Vec2.distance(anchorB, groundB);\n    this.m_ratio = Math.isFinite(ratio) ? ratio : def.ratio;\n\n    _ASSERT && console.assert(ratio > Math.EPSILON);\n\n    this.m_constant = this.m_lengthA + this.m_ratio * this.m_lengthB;\n\n    this.m_impulse = 0.0;\n\n    // Pulley:\n    // length1 = norm(p1 - s1)\n    // length2 = norm(p2 - s2)\n    // C0 = (length1 + ratio * length2)_initial\n    // C = C0 - (length1 + ratio * length2)\n    // u1 = (p1 - s1) / norm(p1 - s1)\n    // u2 = (p2 - s2) / norm(p2 - s2)\n    // Cdot = -dot(u1, v1 + cross(w1, r1)) - ratio * dot(u2, v2 + cross(w2, r2))\n    // J = -[u1 cross(r1, u1) ratio * u2 ratio * cross(r2, u2)]\n    // K = J * invM * JT\n    // = invMass1 + invI1 * cross(r1, u1)^2 + ratio^2 * (invMass2 + invI2 *\n    // cross(r2, u2)^2)\n  }\n\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      groundAnchorA: this.m_groundAnchorA,\n      groundAnchorB: this.m_groundAnchorB,\n      localAnchorA: this.m_localAnchorA,\n      localAnchorB: this.m_localAnchorB,\n      lengthA: this.m_lengthA,\n      lengthB: this.m_lengthB,\n      ratio: this.m_ratio,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): PulleyJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    const joint = new PulleyJoint(data);\n    return joint;\n  }\n\n  /**\n   * Get the first ground anchor.\n   */\n  getGroundAnchorA(): Vec2 {\n    return this.m_groundAnchorA;\n  }\n\n  /**\n   * Get the second ground anchor.\n   */\n  getGroundAnchorB(): Vec2 {\n    return this.m_groundAnchorB;\n  }\n\n  /**\n   * Get the current length of the segment attached to bodyA.\n   */\n  getLengthA(): number {\n    return this.m_lengthA;\n  }\n\n  /**\n   * Get the current length of the segment attached to bodyB.\n   */\n  getLengthB(): number {\n    return this.m_lengthB;\n  }\n\n  /**\n   * Get the pulley ratio.\n   */\n  getRatio(): number {\n    return this.m_ratio;\n  }\n\n  /**\n   * Get the current length of the segment attached to bodyA.\n   */\n  getCurrentLengthA(): number {\n    const p = this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n    const s = this.m_groundAnchorA;\n    return Vec2.distance(p, s);\n  }\n\n  /**\n   * Get the current length of the segment attached to bodyB.\n   */\n  getCurrentLengthB(): number {\n    const p = this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n    const s = this.m_groundAnchorB;\n    return Vec2.distance(p, s);\n  }\n\n  /**\n   * Shift the origin for any points stored in world coordinates.\n   *\n   * @param newOrigin\n   */\n  shiftOrigin(newOrigin: Vec2): void {\n    this.m_groundAnchorA.sub(newOrigin);\n    this.m_groundAnchorB.sub(newOrigin);\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.mulNumVec2(this.m_impulse, this.m_uB).mul(inv_dt);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return 0.0;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassA = this.m_bodyA.m_invMass;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIA = this.m_bodyA.m_invI;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const cA = this.m_bodyA.c_position.c;\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const cB = this.m_bodyB.c_position.c;\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n\n    // Get the pulley axes.\n    this.m_uA = Vec2.sub(Vec2.add(cA, this.m_rA), this.m_groundAnchorA);\n    this.m_uB = Vec2.sub(Vec2.add(cB, this.m_rB), this.m_groundAnchorB);\n\n    const lengthA = this.m_uA.length();\n    const lengthB = this.m_uB.length();\n\n    if (lengthA > 10.0 * Settings.linearSlop) {\n      this.m_uA.mul(1.0 / lengthA);\n    } else {\n      this.m_uA.setZero();\n    }\n\n    if (lengthB > 10.0 * Settings.linearSlop) {\n      this.m_uB.mul(1.0 / lengthB);\n    } else {\n      this.m_uB.setZero();\n    }\n\n    // Compute effective mass.\n    const ruA = Vec2.crossVec2Vec2(this.m_rA, this.m_uA); // float\n    const ruB = Vec2.crossVec2Vec2(this.m_rB, this.m_uB); // float\n\n    const mA = this.m_invMassA + this.m_invIA * ruA * ruA; // float\n    const mB = this.m_invMassB + this.m_invIB * ruB * ruB; // float\n\n    this.m_mass = mA + this.m_ratio * this.m_ratio * mB;\n\n    if (this.m_mass > 0.0) {\n      this.m_mass = 1.0 / this.m_mass;\n    }\n\n    if (step.warmStarting) {\n      // Scale impulses to support variable time steps.\n      this.m_impulse *= step.dtRatio;\n\n      // Warm starting.\n      const PA = Vec2.mulNumVec2(-this.m_impulse, this.m_uA);\n      const PB = Vec2.mulNumVec2(-this.m_ratio * this.m_impulse, this.m_uB);\n\n      vA.addMul(this.m_invMassA, PA);\n      wA += this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, PA);\n\n      vB.addMul(this.m_invMassB, PB);\n      wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, PB);\n\n    } else {\n      this.m_impulse = 0.0;\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const vpA = Vec2.add(vA, Vec2.crossNumVec2(wA, this.m_rA));\n    const vpB = Vec2.add(vB, Vec2.crossNumVec2(wB, this.m_rB));\n\n    const Cdot = -Vec2.dot(this.m_uA, vpA) - this.m_ratio\n        * Vec2.dot(this.m_uB, vpB); // float\n    const impulse = -this.m_mass * Cdot; // float\n    this.m_impulse += impulse;\n\n    const PA = Vec2.mulNumVec2(-impulse, this.m_uA); // Vec2\n    const PB = Vec2.mulNumVec2(-this.m_ratio * impulse, this.m_uB); // Vec2\n    vA.addMul(this.m_invMassA, PA);\n    wA += this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, PA);\n    vB.addMul(this.m_invMassB, PB);\n    wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, PB);\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    const cA = this.m_bodyA.c_position.c;\n    let aA = this.m_bodyA.c_position.a;\n    const cB = this.m_bodyB.c_position.c;\n    let aB = this.m_bodyB.c_position.a;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    const rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    const rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n\n    // Get the pulley axes.\n    const uA = Vec2.sub(Vec2.add(cA, this.m_rA), this.m_groundAnchorA);\n    const uB = Vec2.sub(Vec2.add(cB, this.m_rB), this.m_groundAnchorB);\n\n    const lengthA = uA.length();\n    const lengthB = uB.length();\n\n    if (lengthA > 10.0 * Settings.linearSlop) {\n      uA.mul(1.0 / lengthA);\n    } else {\n      uA.setZero();\n    }\n\n    if (lengthB > 10.0 * Settings.linearSlop) {\n      uB.mul(1.0 / lengthB);\n    } else {\n      uB.setZero();\n    }\n\n    // Compute effective mass.\n    const ruA = Vec2.crossVec2Vec2(rA, uA);\n    const ruB = Vec2.crossVec2Vec2(rB, uB);\n\n    const mA = this.m_invMassA + this.m_invIA * ruA * ruA; // float\n    const mB = this.m_invMassB + this.m_invIB * ruB * ruB; // float\n\n    let mass = mA + this.m_ratio * this.m_ratio * mB; // float\n\n    if (mass > 0.0) {\n      mass = 1.0 / mass;\n    }\n\n    const C = this.m_constant - lengthA - this.m_ratio * lengthB; // float\n    const linearError = Math.abs(C); // float\n\n    const impulse = -mass * C; // float\n\n    const PA = Vec2.mulNumVec2(-impulse, uA); // Vec2\n    const PB = Vec2.mulNumVec2(-this.m_ratio * impulse, uB); // Vec2\n\n    cA.addMul(this.m_invMassA, PA);\n    aA += this.m_invIA * Vec2.crossVec2Vec2(rA, PA);\n    cB.addMul(this.m_invMassB, PB);\n    aB += this.m_invIB * Vec2.crossVec2Vec2(rB, PB);\n\n    this.m_bodyA.c_position.c = cA;\n    this.m_bodyA.c_position.a = aA;\n    this.m_bodyB.c_position.c = cB;\n    this.m_bodyB.c_position.a = aB;\n\n    return linearError < Settings.linearSlop;\n  }\n\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { options } from '../../util/options';\nimport { SettingsInternal as Settings } from '../../Settings';\nimport { math as Math } from '../../common/Math';\nimport { Vec2 } from '../../common/Vec2';\nimport { Rot } from '../../common/Rot';\nimport { Joint, JointOpt, JointDef } from '../Joint';\nimport { Body } from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\nconst _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\nconst inactiveLimit = 0;\nconst atLowerLimit = 1;\nconst atUpperLimit = 2;\nconst equalLimits = 3;\n\n/**\n * Rope joint definition. This requires two body anchor points and a maximum\n * lengths. Note: by default the connected objects will not collide. see\n * collideConnected in JointDef.\n */\nexport interface RopeJointOpt extends JointOpt {\n  /**\n   * The maximum length of the rope.\n   * Warning: this must be larger than linearSlop or the joint will have no effect.\n   */\n  maxLength?: number;\n}\n/**\n * Rope joint definition. This requires two body anchor points and a maximum\n * lengths. Note: by default the connected objects will not collide. see\n * collideConnected in JointDef.\n */\nexport interface RopeJointDef extends JointDef, RopeJointOpt {\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  localAnchorA: Vec2;\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  localAnchorB: Vec2;\n}\n\nconst DEFAULTS = {\n  maxLength : 0.0,\n};\n\n/**\n * A rope joint enforces a maximum distance between two points on two bodies. It\n * has no other effect.\n *\n * Warning: if you attempt to change the maximum length during the simulation\n * you will get some non-physical behavior.\n *\n * A model that would allow you to dynamically modify the length would have some\n * sponginess, so I chose not to implement it that way. See {@link DistanceJoint} if you\n * want to dynamically control length.\n */\nexport class RopeJoint extends Joint {\n  static TYPE = 'rope-joint' as const;\n\n  /** @internal */ m_type: 'rope-joint';\n  /** @internal */ m_localAnchorA: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n\n  /** @internal */ m_maxLength: number;\n\n  /** @internal */ m_mass: number;\n  /** @internal */ m_impulse: number;\n  /** @internal */ m_length: number;\n  /** @internal */ m_state: number; // TODO enum\n\n  // Solver temp\n  /** @internal */ m_u: Vec2;\n  /** @internal */ m_rA: Vec2;\n  /** @internal */ m_rB: Vec2;\n  /** @internal */ m_localCenterA: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_invMassA: number;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIA: number;\n  /** @internal */ m_invIB: number;\n\n  constructor(def: RopeJointDef);\n  constructor(def: RopeJointOpt, bodyA: Body, bodyB: Body, anchor: Vec2);\n  constructor(def: RopeJointDef, bodyA?: Body, bodyB?: Body, anchor?: Vec2) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof RopeJoint)) {\n      return new RopeJoint(def, bodyA, bodyB, anchor);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = RopeJoint.TYPE;\n    this.m_localAnchorA = anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.neo(-1.0, 0.0);\n    this.m_localAnchorB = anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.neo(1.0, 0.0);\n\n    this.m_maxLength = def.maxLength;\n\n    this.m_mass = 0.0;\n    this.m_impulse = 0.0;\n    this.m_length = 0.0;\n    this.m_state = inactiveLimit;\n\n    // Limit:\n    // C = norm(pB - pA) - L\n    // u = (pB - pA) / norm(pB - pA)\n    // Cdot = dot(u, vB + cross(wB, rB) - vA - cross(wA, rA))\n    // J = [-u -cross(rA, u) u cross(rB, u)]\n    // K = J * invM * JT\n    // = invMassA + invIA * cross(rA, u)^2 + invMassB + invIB * cross(rB, u)^2\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      localAnchorA: this.m_localAnchorA,\n      localAnchorB: this.m_localAnchorB,\n      maxLength: this.m_maxLength,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): RopeJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    const joint = new RopeJoint(data);\n    return joint;\n  }\n\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  getLocalAnchorA(): Vec2 {\n    return this.m_localAnchorA;\n  }\n\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  getLocalAnchorB(): Vec2 {\n    return this.m_localAnchorB;\n  }\n\n  /**\n   * Set the maximum length of the rope.\n   */\n  setMaxLength(length: number): void {\n    this.m_maxLength = length;\n  }\n\n  /**\n   * Get the maximum length of the rope.\n   */\n  getMaxLength(): number {\n    return this.m_maxLength;\n  }\n\n  getLimitState(): number {\n    // TODO LimitState\n    return this.m_state;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.mulNumVec2(this.m_impulse, this.m_u).mul(inv_dt);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return 0.0;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassA = this.m_bodyA.m_invMass;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIA = this.m_bodyA.m_invI;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const cA = this.m_bodyA.c_position.c;\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const cB = this.m_bodyB.c_position.c;\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    this.m_rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);\n    this.m_rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);\n    this.m_u = Vec2.zero();\n    this.m_u.addCombine(1, cB, 1, this.m_rB);\n    this.m_u.subCombine(1, cA, 1, this.m_rA); // Vec2\n\n    this.m_length = this.m_u.length();\n\n    const C = this.m_length - this.m_maxLength; // float\n    if (C > 0.0) {\n      this.m_state = atUpperLimit;\n    } else {\n      this.m_state = inactiveLimit;\n    }\n\n    if (this.m_length > Settings.linearSlop) {\n      this.m_u.mul(1.0 / this.m_length);\n    } else {\n      this.m_u.setZero();\n      this.m_mass = 0.0;\n      this.m_impulse = 0.0;\n      return;\n    }\n\n    // Compute effective mass.\n    const crA = Vec2.crossVec2Vec2(this.m_rA, this.m_u); // float\n    const crB = Vec2.crossVec2Vec2(this.m_rB, this.m_u); // float\n    const invMass = this.m_invMassA + this.m_invIA * crA * crA + this.m_invMassB\n        + this.m_invIB * crB * crB; // float\n\n    this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;\n\n    if (step.warmStarting) {\n      // Scale the impulse to support a variable time step.\n      this.m_impulse *= step.dtRatio;\n\n      const P = Vec2.mulNumVec2(this.m_impulse, this.m_u);\n\n      vA.subMul(this.m_invMassA, P);\n      wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P);\n\n      vB.addMul(this.m_invMassB, P);\n      wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P);\n\n    } else {\n      this.m_impulse = 0.0;\n    }\n\n    this.m_bodyA.c_velocity.v.setVec2(vA);\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v.setVec2(vB);\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    // Cdot = dot(u, v + cross(w, r))\n    const vpA = Vec2.addCrossNumVec2(vA, wA, this.m_rA); // Vec2\n    const vpB = Vec2.addCrossNumVec2(vB, wB, this.m_rB); // Vec2\n    const C = this.m_length - this.m_maxLength; // float\n    let Cdot = Vec2.dot(this.m_u, Vec2.sub(vpB, vpA)); // float\n\n    // Predictive constraint.\n    if (C < 0.0) {\n      Cdot += step.inv_dt * C;\n    }\n\n    let impulse = -this.m_mass * Cdot; // float\n    const oldImpulse = this.m_impulse; // float\n    this.m_impulse = Math.min(0.0, this.m_impulse + impulse);\n    impulse = this.m_impulse - oldImpulse;\n\n    const P = Vec2.mulNumVec2(impulse, this.m_u); // Vec2\n    vA.subMul(this.m_invMassA, P);\n    wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P);\n    vB.addMul(this.m_invMassB, P);\n    wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P);\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    const cA = this.m_bodyA.c_position.c; // Vec2\n    let aA = this.m_bodyA.c_position.a; // float\n    const cB = this.m_bodyB.c_position.c; // Vec2\n    let aB = this.m_bodyB.c_position.a; // float\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    const rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);\n    const rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);\n    const u = Vec2.zero();\n    u.addCombine(1, cB, 1, rB);\n    u.subCombine(1, cA, 1, rA); // Vec2\n\n    const length = u.normalize(); // float\n    let C = length - this.m_maxLength; // float\n\n    C = Math.clamp(C, 0.0, Settings.maxLinearCorrection);\n\n    const impulse = -this.m_mass * C; // float\n    const P = Vec2.mulNumVec2(impulse, u); // Vec2\n\n    cA.subMul(this.m_invMassA, P);\n    aA -= this.m_invIA * Vec2.crossVec2Vec2(rA, P);\n    cB.addMul(this.m_invMassB, P);\n    aB += this.m_invIB * Vec2.crossVec2Vec2(rB, P);\n\n    this.m_bodyA.c_position.c.setVec2(cA);\n    this.m_bodyA.c_position.a = aA;\n    this.m_bodyB.c_position.c.setVec2(cB);\n    this.m_bodyB.c_position.a = aB;\n\n    return length - this.m_maxLength < Settings.linearSlop;\n  }\n\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { options } from '../../util/options';\nimport { SettingsInternal as Settings } from '../../Settings';\nimport { math as Math } from '../../common/Math';\nimport { Vec2 } from '../../common/Vec2';\nimport { Vec3 } from '../../common/Vec3';\nimport { Mat33 } from '../../common/Mat33';\nimport { Rot } from '../../common/Rot';\nimport { Joint, JointOpt, JointDef } from '../Joint';\nimport { Body } from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\nconst _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\n/**\n * Weld joint definition. You need to specify local anchor points where they are\n * attached and the relative body angle. The position of the anchor points is\n * important for computing the reaction torque.\n *\n * @prop {float} frequencyHz\n * @prop {float} dampingRatio\n *\n * @prop {Vec2} localAnchorA\n * @prop {Vec2} localAnchorB\n * @prop {float} referenceAngle\n */\nexport interface WeldJointOpt extends JointOpt {\n  /**\n   * The mass-spring-damper frequency in Hertz. Rotation only. Disable softness\n   * with a value of 0.\n   */\n  frequencyHz?: number;\n  /**\n   * The damping ratio. 0 = no damping, 1 = critical damping.\n   */\n  dampingRatio?: number;\n  /**\n   * The bodyB angle minus bodyA angle in the reference state (radians).\n   */\n  referenceAngle?: number;\n}\n/**\n * Weld joint definition. You need to specify local anchor points where they are\n * attached and the relative body angle. The position of the anchor points is\n * important for computing the reaction torque.\n */\nexport interface WeldJointDef extends JointDef, WeldJointOpt {\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  localAnchorA: Vec2;\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  localAnchorB: Vec2;\n}\n\nconst DEFAULTS = {\n  frequencyHz : 0.0,\n  dampingRatio : 0.0,\n};\n\n/**\n * A weld joint essentially glues two bodies together. A weld joint may distort\n * somewhat because the island constraint solver is approximate.\n */\nexport class WeldJoint extends Joint {\n  static TYPE = 'weld-joint' as const\n\n  /** @internal */ m_type: 'weld-joint';\n  /** @internal */ m_localAnchorA: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n  /** @internal */ m_referenceAngle: number;\n\n  /** @internal */ m_frequencyHz: number;\n  /** @internal */ m_dampingRatio: number;\n\n  /** @internal */ m_impulse: Vec3;\n\n  /** @internal */ m_bias: number;\n  /** @internal */ m_gamma: number;\n\n  // Solver temp\n  /** @internal */ m_rA: Vec2;\n  /** @internal */ m_rB: Vec2;\n  /** @internal */ m_localCenterA: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_invMassA: number;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIA: number;\n  /** @internal */ m_invIB: number;\n  /** @internal */ m_mass: Mat33;\n\n  constructor(def: WeldJointDef);\n  constructor(def: WeldJointOpt, bodyA: Body, bodyB: Body, anchor: Vec2);\n  constructor(def: WeldJointDef, bodyA?: Body, bodyB?: Body, anchor?: Vec2) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof WeldJoint)) {\n      return new WeldJoint(def, bodyA, bodyB, anchor);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = WeldJoint.TYPE;\n\n    this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n    this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n    this.m_referenceAngle = Math.isFinite(def.referenceAngle) ? def.referenceAngle : bodyB.getAngle() - bodyA.getAngle();\n\n    this.m_frequencyHz = def.frequencyHz;\n    this.m_dampingRatio = def.dampingRatio;\n\n    this.m_impulse = new Vec3();\n\n    this.m_bias = 0.0;\n    this.m_gamma = 0.0;\n\n    // Solver temp\n    this.m_rA; // Vec2\n    this.m_rB; // Vec2\n    this.m_localCenterA; // Vec2\n    this.m_localCenterB; // Vec2\n    this.m_invMassA; // float\n    this.m_invMassB; // float\n    this.m_invIA; // float\n    this.m_invIB; // float\n    this.m_mass = new Mat33();\n\n    // Point-to-point constraint\n    // C = p2 - p1\n    // Cdot = v2 - v1\n    // / = v2 + cross(w2, r2) - v1 - cross(w1, r1)\n    // J = [-I -r1_skew I r2_skew ]\n    // Identity used:\n    // w k % (rx i + ry j) = w * (-ry i + rx j)\n\n    // Angle constraint\n    // C = angle2 - angle1 - referenceAngle\n    // Cdot = w2 - w1\n    // J = [0 0 -1 0 0 1]\n    // K = invI1 + invI2\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      frequencyHz: this.m_frequencyHz,\n      dampingRatio: this.m_dampingRatio,\n\n      localAnchorA: this.m_localAnchorA,\n      localAnchorB: this.m_localAnchorB,\n      referenceAngle: this.m_referenceAngle,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): WeldJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    const joint = new WeldJoint(data);\n    return joint;\n  }\n\n  /** @internal */\n  _setAnchors(def: {\n    anchorA?: Vec2,\n    localAnchorA?: Vec2,\n    anchorB?: Vec2,\n    localAnchorB?: Vec2,\n  }): void {\n    if (def.anchorA) {\n      this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n    } else if (def.localAnchorA) {\n      this.m_localAnchorA.setVec2(def.localAnchorA);\n    }\n\n    if (def.anchorB) {\n      this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n    } else if (def.localAnchorB) {\n      this.m_localAnchorB.setVec2(def.localAnchorB);\n    }\n  }\n\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  getLocalAnchorA(): Vec2 {\n    return this.m_localAnchorA;\n  }\n\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  getLocalAnchorB(): Vec2 {\n    return this.m_localAnchorB;\n  }\n\n  /**\n   * Get the reference angle.\n   */\n  getReferenceAngle(): number {\n    return this.m_referenceAngle;\n  }\n\n  /**\n   * Set frequency in Hz.\n   */\n  setFrequency(hz: number): void {\n    this.m_frequencyHz = hz;\n  }\n\n  /**\n   * Get frequency in Hz.\n   */\n  getFrequency(): number {\n    return this.m_frequencyHz;\n  }\n\n  /**\n   * Set damping ratio.\n   */\n  setDampingRatio(ratio: number): void {\n    this.m_dampingRatio = ratio;\n  }\n\n  /**\n   * Get damping ratio.\n   */\n  getDampingRatio(): number {\n    return this.m_dampingRatio;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.neo(this.m_impulse.x, this.m_impulse.y).mul(inv_dt);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return inv_dt * this.m_impulse.z;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassA = this.m_bodyA.m_invMass;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIA = this.m_bodyA.m_invI;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n\n    // J = [-I -r1_skew I r2_skew]\n    // [ 0 -1 0 1]\n    // r_skew = [-ry; rx]\n\n    // Matlab\n    // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]\n    // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]\n    // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    const K = new Mat33();\n    K.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y * this.m_rB.y\n        * iB;\n    K.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y * this.m_rB.x * iB;\n    K.ez.x = -this.m_rA.y * iA - this.m_rB.y * iB;\n    K.ex.y = K.ey.x;\n    K.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x * this.m_rB.x\n        * iB;\n    K.ez.y = this.m_rA.x * iA + this.m_rB.x * iB;\n    K.ex.z = K.ez.x;\n    K.ey.z = K.ez.y;\n    K.ez.z = iA + iB;\n\n    if (this.m_frequencyHz > 0.0) {\n      K.getInverse22(this.m_mass);\n\n      let invM = iA + iB; // float\n      const m = invM > 0.0 ? 1.0 / invM : 0.0; // float\n\n      const C = aB - aA - this.m_referenceAngle; // float\n\n      // Frequency\n      const omega = 2.0 * Math.PI * this.m_frequencyHz; // float\n\n      // Damping coefficient\n      const d = 2.0 * m * this.m_dampingRatio * omega; // float\n\n      // Spring stiffness\n      const k = m * omega * omega; // float\n\n      // magic formulas\n      const h = step.dt; // float\n      this.m_gamma = h * (d + h * k);\n      this.m_gamma = this.m_gamma != 0.0 ? 1.0 / this.m_gamma : 0.0;\n      this.m_bias = C * h * k * this.m_gamma;\n\n      invM += this.m_gamma;\n      this.m_mass.ez.z = invM != 0.0 ? 1.0 / invM : 0.0;\n    } else if (K.ez.z == 0.0) {\n      K.getInverse22(this.m_mass);\n      this.m_gamma = 0.0;\n      this.m_bias = 0.0;\n    } else {\n      K.getSymInverse33(this.m_mass);\n      this.m_gamma = 0.0;\n      this.m_bias = 0.0;\n    }\n\n    if (step.warmStarting) {\n      // Scale impulses to support a variable time step.\n      this.m_impulse.mul(step.dtRatio);\n\n      const P = Vec2.neo(this.m_impulse.x, this.m_impulse.y);\n\n      vA.subMul(mA, P);\n      wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + this.m_impulse.z);\n\n      vB.addMul(mB, P);\n      wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + this.m_impulse.z);\n\n    } else {\n      this.m_impulse.setZero();\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB; // float\n    const iA = this.m_invIA;\n    const iB = this.m_invIB; // float\n\n    if (this.m_frequencyHz > 0.0) {\n      const Cdot2 = wB - wA; // float\n\n      const impulse2 = -this.m_mass.ez.z\n          * (Cdot2 + this.m_bias + this.m_gamma * this.m_impulse.z); // float\n      this.m_impulse.z += impulse2;\n\n      wA -= iA * impulse2;\n      wB += iB * impulse2;\n\n      const Cdot1 = Vec2.zero();\n      Cdot1.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, this.m_rB));\n      Cdot1.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, this.m_rA)); // Vec2\n\n      const impulse1 = Vec2.neg(Mat33.mulVec2(this.m_mass, Cdot1)); // Vec2\n      this.m_impulse.x += impulse1.x;\n      this.m_impulse.y += impulse1.y;\n\n      const P = Vec2.clone(impulse1); // Vec2\n\n      vA.subMul(mA, P);\n      wA -= iA * Vec2.crossVec2Vec2(this.m_rA, P);\n\n      vB.addMul(mB, P);\n      wB += iB * Vec2.crossVec2Vec2(this.m_rB, P);\n    } else {\n      const Cdot1 = Vec2.zero();\n      Cdot1.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, this.m_rB));\n      Cdot1.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, this.m_rA)); // Vec2\n      const Cdot2 = wB - wA; // float\n      const Cdot = new Vec3(Cdot1.x, Cdot1.y, Cdot2); // Vec3\n\n      const impulse = Vec3.neg(Mat33.mulVec3(this.m_mass, Cdot)); // Vec3\n      this.m_impulse.add(impulse);\n\n      const P = Vec2.neo(impulse.x, impulse.y);\n\n      vA.subMul(mA, P);\n      wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + impulse.z);\n\n      vB.addMul(mB, P);\n      wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + impulse.z);\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    const cA = this.m_bodyA.c_position.c;\n    let aA = this.m_bodyA.c_position.a;\n    const cB = this.m_bodyB.c_position.c;\n    let aB = this.m_bodyB.c_position.a;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    const rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    const rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n\n    let positionError: number;\n    let angularError: number;\n\n    const K = new Mat33();\n    K.ex.x = mA + mB + rA.y * rA.y * iA + rB.y * rB.y * iB;\n    K.ey.x = -rA.y * rA.x * iA - rB.y * rB.x * iB;\n    K.ez.x = -rA.y * iA - rB.y * iB;\n    K.ex.y = K.ey.x;\n    K.ey.y = mA + mB + rA.x * rA.x * iA + rB.x * rB.x * iB;\n    K.ez.y = rA.x * iA + rB.x * iB;\n    K.ex.z = K.ez.x;\n    K.ey.z = K.ez.y;\n    K.ez.z = iA + iB;\n\n    if (this.m_frequencyHz > 0.0) {\n      const C1 = Vec2.zero();\n      C1.addCombine(1, cB, 1, rB);\n      C1.subCombine(1, cA, 1, rA); // Vec2\n\n      positionError = C1.length();\n      angularError = 0.0;\n\n      const P = Vec2.neg(K.solve22(C1)); // Vec2\n\n      cA.subMul(mA, P);\n      aA -= iA * Vec2.crossVec2Vec2(rA, P);\n\n      cB.addMul(mB, P);\n      aB += iB * Vec2.crossVec2Vec2(rB, P);\n    } else {\n      const C1 = Vec2.zero();\n      C1.addCombine(1, cB, 1, rB);\n      C1.subCombine(1, cA, 1, rA);\n\n      const C2 = aB - aA - this.m_referenceAngle; // float\n\n      positionError = C1.length();\n      angularError = Math.abs(C2);\n\n      const C = new Vec3(C1.x, C1.y, C2);\n\n      let impulse = new Vec3();\n      if (K.ez.z > 0.0) {\n        impulse = Vec3.neg(K.solve33(C));\n      } else {\n        const impulse2 = Vec2.neg(K.solve22(C1));\n        impulse.set(impulse2.x, impulse2.y, 0.0);\n      }\n\n      const P = Vec2.neo(impulse.x, impulse.y);\n\n      cA.subMul(mA, P);\n      aA -= iA * (Vec2.crossVec2Vec2(rA, P) + impulse.z);\n\n      cB.addMul(mB, P);\n      aB += iB * (Vec2.crossVec2Vec2(rB, P) + impulse.z);\n    }\n\n    this.m_bodyA.c_position.c = cA;\n    this.m_bodyA.c_position.a = aA;\n    this.m_bodyB.c_position.c = cB;\n    this.m_bodyB.c_position.a = aB;\n\n    return positionError <= Settings.linearSlop && angularError <= Settings.angularSlop;\n  }\n\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { options } from '../../util/options';\nimport { SettingsInternal as Settings } from '../../Settings';\nimport { math as Math } from '../../common/Math';\nimport { Vec2 } from '../../common/Vec2';\nimport { Rot } from '../../common/Rot';\nimport { Joint, JointOpt, JointDef } from '../Joint';\nimport { Body } from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\nconst _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\n/**\n * Wheel joint definition. This requires defining a line of motion using an axis\n * and an anchor point. The definition uses local anchor points and a local axis\n * so that the initial configuration can violate the constraint slightly. The\n * joint translation is zero when the local anchor points coincide in world\n * space. Using local anchors and a local axis helps when saving and loading a\n * game.\n */\nexport interface WheelJointOpt extends JointOpt {\n  /**\n   * Enable/disable the joint motor.\n   */\n  enableMotor?: boolean;\n  /**\n   * The maximum motor torque, usually in N-m.\n   */\n  maxMotorTorque?: number;\n  /**\n   * The desired motor speed in radians per second.\n   */\n  motorSpeed?: number;\n  /**\n   * Suspension frequency, zero indicates no suspension.\n   */\n  frequencyHz?: number;\n  /**\n   * Suspension damping ratio, one indicates critical damping.\n   */\n  dampingRatio?: number;\n}\n/**\n * Wheel joint definition. This requires defining a line of motion using an axis\n * and an anchor point. The definition uses local anchor points and a local axis\n * so that the initial configuration can violate the constraint slightly. The\n * joint translation is zero when the local anchor points coincide in world\n * space. Using local anchors and a local axis helps when saving and loading a\n * game.\n */\nexport interface WheelJointDef extends JointDef, WheelJointOpt {\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  localAnchorA: Vec2;\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  localAnchorB: Vec2;\n  /**\n   * The local translation axis in bodyA.\n   */\n  localAxisA: Vec2;\n}\n\nconst DEFAULTS = {\n  enableMotor : false,\n  maxMotorTorque : 0.0,\n  motorSpeed : 0.0,\n  frequencyHz : 2.0,\n  dampingRatio : 0.7,\n};\n\n/**\n * A wheel joint. This joint provides two degrees of freedom: translation along\n * an axis fixed in bodyA and rotation in the plane. In other words, it is a\n * point to line constraint with a rotational motor and a linear spring/damper.\n * This joint is designed for vehicle suspensions.\n */\nexport class WheelJoint extends Joint {\n  static TYPE = 'wheel-joint' as const;\n\n  /** @internal */ m_type: 'wheel-joint';\n  /** @internal */ m_localAnchorA: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n  /** @internal */ m_localXAxisA: Vec2;\n  /** @internal */ m_localYAxisA: Vec2;\n\n  /** @internal */ m_mass: number;\n  /** @internal */ m_impulse: number;\n  /** @internal */ m_motorMass: number;\n  /** @internal */ m_motorImpulse: number;\n  /** @internal */ m_springMass: number;\n  /** @internal */ m_springImpulse: number;\n\n  /** @internal */ m_maxMotorTorque: number;\n  /** @internal */ m_motorSpeed: number;\n  /** @internal */ m_enableMotor: boolean;\n\n  /** @internal */ m_frequencyHz: number;\n  /** @internal */ m_dampingRatio: number;\n\n  /** @internal */ m_bias: number;\n  /** @internal */ m_gamma: number;\n\n  // Solver temp\n  /** @internal */ m_localCenterA: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_invMassA: number;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIA: number;\n  /** @internal */ m_invIB: number;\n\n  /** @internal */ m_ax: Vec2 = Vec2.zero();\n  /** @internal */ m_ay: Vec2 = Vec2.zero();\n  /** @internal */ m_sAx: number;\n  /** @internal */ m_sBx: number;\n  /** @internal */ m_sAy: number;\n  /** @internal */ m_sBy: number;\n\n  constructor(def: WheelJointDef);\n  constructor(def: WheelJointOpt, bodyA: Body, bodyB: Body, anchor: Vec2, axis: Vec2);\n  // @ts-ignore\n  constructor(def: WheelJointDef, bodyA?: Body, bodyB?: Body, anchor?: Vec2, axis?: Vec2) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof WheelJoint)) {\n      return new WheelJoint(def, bodyA, bodyB, anchor, axis);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = WheelJoint.TYPE;\n\n    this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n    this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n    // @ts-ignore localAxis\n    this.m_localXAxisA = Vec2.clone(axis ? bodyA.getLocalVector(axis) : def.localAxisA || def.localAxis || Vec2.neo(1.0, 0.0));\n    this.m_localYAxisA = Vec2.crossNumVec2(1.0, this.m_localXAxisA);\n\n    this.m_mass = 0.0;\n    this.m_impulse = 0.0;\n    this.m_motorMass = 0.0;\n    this.m_motorImpulse = 0.0;\n    this.m_springMass = 0.0;\n    this.m_springImpulse = 0.0;\n\n    this.m_maxMotorTorque = def.maxMotorTorque;\n    this.m_motorSpeed = def.motorSpeed;\n    this.m_enableMotor = def.enableMotor;\n\n    this.m_frequencyHz = def.frequencyHz;\n    this.m_dampingRatio = def.dampingRatio;\n\n    this.m_bias = 0.0;\n    this.m_gamma = 0.0;\n\n    // Linear constraint (point-to-line)\n    // d = pB - pA = xB + rB - xA - rA\n    // C = dot(ay, d)\n    // Cdot = dot(d, cross(wA, ay)) + dot(ay, vB + cross(wB, rB) - vA - cross(wA,\n    // rA))\n    // = -dot(ay, vA) - dot(cross(d + rA, ay), wA) + dot(ay, vB) + dot(cross(rB,\n    // ay), vB)\n    // J = [-ay, -cross(d + rA, ay), ay, cross(rB, ay)]\n\n    // Spring linear constraint\n    // C = dot(ax, d)\n    // Cdot = = -dot(ax, vA) - dot(cross(d + rA, ax), wA) + dot(ax, vB) +\n    // dot(cross(rB, ax), vB)\n    // J = [-ax -cross(d+rA, ax) ax cross(rB, ax)]\n\n    // Motor rotational constraint\n    // Cdot = wB - wA\n    // J = [0 0 -1 0 0 1]\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      enableMotor: this.m_enableMotor,\n      maxMotorTorque: this.m_maxMotorTorque,\n      motorSpeed: this.m_motorSpeed,\n      frequencyHz: this.m_frequencyHz,\n      dampingRatio: this.m_dampingRatio,\n\n      localAnchorA: this.m_localAnchorA,\n      localAnchorB: this.m_localAnchorB,\n      localAxisA: this.m_localXAxisA,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): WheelJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    const joint = new WheelJoint(data);\n    return joint;\n  }\n\n  /** @internal */\n  _setAnchors(def: {\n    anchorA?: Vec2,\n    localAnchorA?: Vec2,\n    anchorB?: Vec2,\n    localAnchorB?: Vec2,\n    localAxisA?: Vec2,\n  }): void {\n    if (def.anchorA) {\n      this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n    } else if (def.localAnchorA) {\n      this.m_localAnchorA.setVec2(def.localAnchorA);\n    }\n\n    if (def.anchorB) {\n      this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n    } else if (def.localAnchorB) {\n      this.m_localAnchorB.setVec2(def.localAnchorB);\n    }\n\n    if (def.localAxisA) {\n      this.m_localXAxisA.setVec2(def.localAxisA);\n      this.m_localYAxisA.setVec2(Vec2.crossNumVec2(1.0, def.localAxisA));\n    }\n  }\n\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  getLocalAnchorA(): Vec2 {\n    return this.m_localAnchorA;\n  }\n\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  getLocalAnchorB(): Vec2 {\n    return this.m_localAnchorB;\n  }\n\n  /**\n   * The local joint axis relative to bodyA.\n   */\n  getLocalAxisA(): Vec2 {\n    return this.m_localXAxisA;\n  }\n\n  /**\n   * Get the current joint translation, usually in meters.\n   */\n  getJointTranslation(): number {\n    const bA = this.m_bodyA;\n    const bB = this.m_bodyB;\n\n    const pA = bA.getWorldPoint(this.m_localAnchorA); // Vec2\n    const pB = bB.getWorldPoint(this.m_localAnchorB); // Vec2\n    const d = Vec2.sub(pB, pA); // Vec2\n    const axis = bA.getWorldVector(this.m_localXAxisA); // Vec2\n\n    const translation = Vec2.dot(d, axis); // float\n    return translation;\n  }\n\n  /**\n   * Get the current joint translation speed, usually in meters per second.\n   */\n  getJointSpeed(): number {\n    const wA = this.m_bodyA.m_angularVelocity;\n    const wB = this.m_bodyB.m_angularVelocity;\n    return wB - wA;\n  }\n\n  /**\n   * Is the joint motor enabled?\n   */\n  isMotorEnabled(): boolean {\n    return this.m_enableMotor;\n  }\n\n  /**\n   * Enable/disable the joint motor.\n   */\n  enableMotor(flag: boolean): void {\n    if (flag == this.m_enableMotor) return;\n    this.m_bodyA.setAwake(true);\n    this.m_bodyB.setAwake(true);\n    this.m_enableMotor = flag;\n  }\n\n  /**\n   * Set the motor speed, usually in radians per second.\n   */\n  setMotorSpeed(speed: number): void {\n    if (speed == this.m_motorSpeed) return;\n    this.m_bodyA.setAwake(true);\n    this.m_bodyB.setAwake(true);\n    this.m_motorSpeed = speed;\n  }\n\n  /**\n   * Get the motor speed, usually in radians per second.\n   */\n  getMotorSpeed(): number {\n    return this.m_motorSpeed;\n  }\n\n  /**\n   * Set/Get the maximum motor force, usually in N-m.\n   */\n  setMaxMotorTorque(torque: number): void {\n    if (torque == this.m_maxMotorTorque) return;\n    this.m_bodyA.setAwake(true);\n    this.m_bodyB.setAwake(true);\n    this.m_maxMotorTorque = torque;\n  }\n\n  getMaxMotorTorque(): number {\n    return this.m_maxMotorTorque;\n  }\n\n  /**\n   * Get the current motor torque given the inverse time step, usually in N-m.\n   */\n  getMotorTorque(inv_dt: number): number {\n    return inv_dt * this.m_motorImpulse;\n  }\n\n  /**\n   * Set/Get the spring frequency in hertz. Setting the frequency to zero disables\n   * the spring.\n   */\n  setSpringFrequencyHz(hz: number): void {\n    this.m_frequencyHz = hz;\n  }\n\n  getSpringFrequencyHz(): number {\n    return this.m_frequencyHz;\n  }\n\n  /**\n   * Set/Get the spring damping ratio\n   */\n  setSpringDampingRatio(ratio: number): void {\n    this.m_dampingRatio = ratio;\n  }\n\n  getSpringDampingRatio(): number {\n    return this.m_dampingRatio;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.combine(this.m_impulse, this.m_ay, this.m_springImpulse, this.m_ax).mul(inv_dt);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return inv_dt * this.m_motorImpulse;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassA = this.m_bodyA.m_invMass;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIA = this.m_bodyA.m_invI;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB; // float\n    const iA = this.m_invIA;\n    const iB = this.m_invIB; // float\n\n    const cA = this.m_bodyA.c_position.c;\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const cB = this.m_bodyB.c_position.c;\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    // Compute the effective masses.\n    const rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    const rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n    const d = Vec2.zero();\n    d.addCombine(1, cB, 1, rB);\n    d.subCombine(1, cA, 1, rA); // Vec2\n\n    // Point to line constraint\n    {\n      this.m_ay = Rot.mulVec2(qA, this.m_localYAxisA);\n      this.m_sAy = Vec2.crossVec2Vec2(Vec2.add(d, rA), this.m_ay);\n      this.m_sBy = Vec2.crossVec2Vec2(rB, this.m_ay);\n\n      this.m_mass = mA + mB + iA * this.m_sAy * this.m_sAy + iB * this.m_sBy\n          * this.m_sBy;\n\n      if (this.m_mass > 0.0) {\n        this.m_mass = 1.0 / this.m_mass;\n      }\n    }\n\n    // Spring constraint\n    this.m_springMass = 0.0;\n    this.m_bias = 0.0;\n    this.m_gamma = 0.0;\n    if (this.m_frequencyHz > 0.0) {\n      this.m_ax = Rot.mulVec2(qA, this.m_localXAxisA);\n      this.m_sAx = Vec2.crossVec2Vec2(Vec2.add(d, rA), this.m_ax);\n      this.m_sBx = Vec2.crossVec2Vec2(rB, this.m_ax);\n\n      const invMass = mA + mB + iA * this.m_sAx * this.m_sAx + iB * this.m_sBx\n          * this.m_sBx; // float\n\n      if (invMass > 0.0) {\n        this.m_springMass = 1.0 / invMass;\n\n        const C = Vec2.dot(d, this.m_ax); // float\n\n        // Frequency\n        const omega = 2.0 * Math.PI * this.m_frequencyHz; // float\n\n        // Damping coefficient\n        const damp = 2.0 * this.m_springMass * this.m_dampingRatio * omega; // float\n\n        // Spring stiffness\n        const k = this.m_springMass * omega * omega; // float\n\n        // magic formulas\n        const h = step.dt; // float\n        this.m_gamma = h * (damp + h * k);\n        if (this.m_gamma > 0.0) {\n          this.m_gamma = 1.0 / this.m_gamma;\n        }\n\n        this.m_bias = C * h * k * this.m_gamma;\n\n        this.m_springMass = invMass + this.m_gamma;\n        if (this.m_springMass > 0.0) {\n          this.m_springMass = 1.0 / this.m_springMass;\n        }\n      }\n    } else {\n      this.m_springImpulse = 0.0;\n    }\n\n    // Rotational motor\n    if (this.m_enableMotor) {\n      this.m_motorMass = iA + iB;\n      if (this.m_motorMass > 0.0) {\n        this.m_motorMass = 1.0 / this.m_motorMass;\n      }\n    } else {\n      this.m_motorMass = 0.0;\n      this.m_motorImpulse = 0.0;\n    }\n\n    if (step.warmStarting) {\n      // Account for variable time step.\n      this.m_impulse *= step.dtRatio;\n      this.m_springImpulse *= step.dtRatio;\n      this.m_motorImpulse *= step.dtRatio;\n\n      const P = Vec2.combine(this.m_impulse, this.m_ay, this.m_springImpulse, this.m_ax);\n      const LA = this.m_impulse * this.m_sAy + this.m_springImpulse * this.m_sAx + this.m_motorImpulse;\n      const LB = this.m_impulse * this.m_sBy + this.m_springImpulse * this.m_sBx + this.m_motorImpulse;\n\n      vA.subMul(this.m_invMassA, P);\n      wA -= this.m_invIA * LA;\n\n      vB.addMul(this.m_invMassB, P);\n      wB += this.m_invIB * LB;\n\n    } else {\n      this.m_impulse = 0.0;\n      this.m_springImpulse = 0.0;\n      this.m_motorImpulse = 0.0;\n    }\n\n    this.m_bodyA.c_velocity.v.setVec2(vA);\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v.setVec2(vB);\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB; // float\n    const iA = this.m_invIA;\n    const iB = this.m_invIB; // float\n\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    // Solve spring constraint\n    {\n      const Cdot = Vec2.dot(this.m_ax, vB) - Vec2.dot(this.m_ax, vA) + this.m_sBx\n          * wB - this.m_sAx * wA; // float\n      const impulse = -this.m_springMass\n          * (Cdot + this.m_bias + this.m_gamma * this.m_springImpulse); // float\n      this.m_springImpulse += impulse;\n\n      const P = Vec2.mulNumVec2(impulse, this.m_ax); // Vec2\n      const LA = impulse * this.m_sAx; // float\n      const LB = impulse * this.m_sBx; // float\n\n      vA.subMul(mA, P);\n      wA -= iA * LA;\n\n      vB.addMul(mB, P);\n      wB += iB * LB;\n    }\n\n    // Solve rotational motor constraint\n    {\n      const Cdot = wB - wA - this.m_motorSpeed; // float\n      let impulse = -this.m_motorMass * Cdot; // float\n\n      const oldImpulse = this.m_motorImpulse; // float\n      const maxImpulse = step.dt * this.m_maxMotorTorque; // float\n      this.m_motorImpulse = Math.clamp(this.m_motorImpulse + impulse,\n          -maxImpulse, maxImpulse);\n      impulse = this.m_motorImpulse - oldImpulse;\n\n      wA -= iA * impulse;\n      wB += iB * impulse;\n    }\n\n    // Solve point to line constraint\n    {\n      const Cdot = Vec2.dot(this.m_ay, vB) - Vec2.dot(this.m_ay, vA) + this.m_sBy\n          * wB - this.m_sAy * wA; // float\n      const impulse = -this.m_mass * Cdot; // float\n      this.m_impulse += impulse;\n\n      const P = Vec2.mulNumVec2(impulse, this.m_ay); // Vec2\n      const LA = impulse * this.m_sAy; // float\n      const LB = impulse * this.m_sBy; // float\n\n      vA.subMul(mA, P);\n      wA -= iA * LA;\n\n      vB.addMul(mB, P);\n      wB += iB * LB;\n    }\n\n    this.m_bodyA.c_velocity.v.setVec2(vA);\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v.setVec2(vB);\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    const cA = this.m_bodyA.c_position.c;\n    let aA = this.m_bodyA.c_position.a;\n    const cB = this.m_bodyB.c_position.c;\n    let aB = this.m_bodyB.c_position.a;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    const rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    const rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n    const d = Vec2.zero();\n    d.addCombine(1, cB, 1, rB);\n    d.subCombine(1, cA, 1, rA);\n\n    const ay = Rot.mulVec2(qA, this.m_localYAxisA);\n\n    const sAy = Vec2.crossVec2Vec2(Vec2.add(d, rA), ay); // float\n    const sBy = Vec2.crossVec2Vec2(rB, ay); // float\n\n    const C = Vec2.dot(d, ay); // float\n\n    const k = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_sAy\n        * this.m_sAy + this.m_invIB * this.m_sBy * this.m_sBy; // float\n\n    let impulse; // float\n    if (k != 0.0) {\n      impulse = -C / k;\n    } else {\n      impulse = 0.0;\n    }\n\n    const P = Vec2.mulNumVec2(impulse, ay); // Vec2\n    const LA = impulse * sAy; // float\n    const LB = impulse * sBy; // float\n\n    cA.subMul(this.m_invMassA, P);\n    aA -= this.m_invIA * LA;\n    cB.addMul(this.m_invMassB, P);\n    aB += this.m_invIB * LB;\n\n    this.m_bodyA.c_position.c.setVec2(cA);\n    this.m_bodyA.c_position.a = aA;\n    this.m_bodyB.c_position.c.setVec2(cB);\n    this.m_bodyB.c_position.a = aB;\n\n    return Math.abs(C) <= Settings.linearSlop;\n  }\n\n}\n","// tslint:disable:typedef\nimport { World } from '../dynamics/World';\nimport { Body } from '../dynamics/Body';\nimport { Joint } from '../dynamics/Joint';\nimport { Fixture } from '../dynamics/Fixture';\nimport { Shape } from '../collision/Shape';\nimport { Vec2 } from '../common/Vec2';\nimport { Vec3 } from '../common/Vec3';\nimport { ChainShape } from \"../collision/shape/ChainShape\";\nimport { BoxShape } from \"../collision/shape/BoxShape\";\nimport { EdgeShape } from \"../collision/shape/EdgeShape\";\nimport { PolygonShape } from \"../collision/shape/PolygonShape\";\nimport { CircleShape } from \"../collision/shape/CircleShape\";\nimport { DistanceJoint } from \"../dynamics/joint/DistanceJoint\";\nimport { FrictionJoint } from \"../dynamics/joint/FrictionJoint\";\nimport { GearJoint } from \"../dynamics/joint/GearJoint\";\nimport { MotorJoint } from \"../dynamics/joint/MotorJoint\";\nimport { MouseJoint } from \"../dynamics/joint/MouseJoint\";\nimport { PrismaticJoint } from \"../dynamics/joint/PrismaticJoint\";\nimport { PulleyJoint } from \"../dynamics/joint/PulleyJoint\";\nimport { RevoluteJoint } from \"../dynamics/joint/RevoluteJoint\";\nimport { RopeJoint } from \"../dynamics/joint/RopeJoint\";\nimport { WeldJoint } from \"../dynamics/joint/WeldJoint\";\nimport { WheelJoint } from \"../dynamics/joint/WheelJoint\";\n\nlet SID = 0;\n\nexport function Serializer(opts?) {\n  opts = opts || {};\n\n  const rootClass = opts.rootClass || World;\n\n  const preSerialize = opts.preSerialize || function(obj) { return obj; };\n  const postSerialize = opts.postSerialize || function(data, obj) { return data; };\n\n  const preDeserialize = opts.preDeserialize || function(data) { return data; };\n  const postDeserialize = opts.postDeserialize || function(obj, data) { return obj; };\n\n  // This is used to create ref objects during serialize\n  const refTypes = {\n    World,\n    Body,\n    Joint,\n    Fixture,\n    Shape,\n  };\n\n  // This is used by restore to deserialize objects and refs\n  const restoreTypes = {\n    Vec2,\n    Vec3,\n    ...refTypes\n  };\n\n  const CLASS_BY_TYPE_PROP = {\n    [Body.STATIC]: Body,\n    [Body.DYNAMIC]: Body,\n    [Body.KINEMATIC]: Body,\n    [ChainShape.TYPE]: ChainShape,\n    [BoxShape.TYPE]: BoxShape,\n    [EdgeShape.TYPE]: EdgeShape,\n    [PolygonShape.TYPE]: PolygonShape,\n    [CircleShape.TYPE]: CircleShape,\n    [DistanceJoint.TYPE]: DistanceJoint,\n    [FrictionJoint.TYPE]: FrictionJoint,\n    [GearJoint.TYPE]: GearJoint,\n    [MotorJoint.TYPE]: MotorJoint,\n    [MouseJoint.TYPE]: MouseJoint,\n    [PrismaticJoint.TYPE]: PrismaticJoint,\n    [PulleyJoint.TYPE]: PulleyJoint,\n    [RevoluteJoint.TYPE]: RevoluteJoint,\n    [RopeJoint.TYPE]: RopeJoint,\n    [WeldJoint.TYPE]: WeldJoint,\n    [WheelJoint.TYPE]: WheelJoint,\n  }\n\n  this.toJson = function(root) {\n    const json = [];\n\n    const queue = [root];\n    const refMap = {};\n\n    function storeRef(value, typeName) {\n      value.__sid = value.__sid || ++SID;\n      if (!refMap[value.__sid]) {\n        queue.push(value);\n        const index = json.length + queue.length;\n        const ref = {\n          refIndex: index,\n          refType: typeName\n        };\n        refMap[value.__sid] = ref;\n      }\n      return refMap[value.__sid];\n    }\n\n    function serialize(obj) {\n      obj = preSerialize(obj);\n      let data = obj._serialize();\n      data = postSerialize(data, obj);\n      return data;\n    }\n\n    function toJson(value, top?) {\n      if (typeof value !== 'object' || value === null) {\n        return value;\n      }\n      if (typeof value._serialize === 'function') {\n        if (value !== top) {\n          // tslint:disable-next-line:no-for-in\n          for (const typeName in refTypes) {\n            if (value instanceof refTypes[typeName]) {\n              return storeRef(value, typeName);\n            }\n          }\n        }\n        value = serialize(value);\n      }\n      if (Array.isArray(value)) {\n        const newValue = [];\n        for (let key = 0; key < value.length; key++) {\n          newValue[key] = toJson(value[key]);\n        }\n        value = newValue;\n\n      } else {\n        const newValue = {};\n        // tslint:disable-next-line:no-for-in\n        for (const key in value) {\n          if (value.hasOwnProperty(key)) {\n            newValue[key] = toJson(value[key]);\n          }\n        }\n        value = newValue;\n      }\n      return value;\n    }\n\n    while (queue.length) {\n      const obj = queue.shift();\n      const str = toJson(obj, obj);\n      json.push(str);\n    }\n\n    return json;\n  };\n\n  this.fromJson = function(json: object) {\n    const refMap = {};\n\n    function findDeserilizer(data, cls) {\n      if (!cls || !cls._deserialize) {\n        cls = CLASS_BY_TYPE_PROP[data.type]\n      }\n      return cls && cls._deserialize;\n    }\n\n    /**\n     * Deserialize a data object.\n     */\n    function deserialize(cls, data, ctx) {\n      const deserializer = findDeserilizer(data, cls);\n      if (!deserializer) {\n        return;\n      }\n      data = preDeserialize(data);\n      let obj = deserializer(data, ctx, restoreRef);\n      obj = postDeserialize(obj, data);\n      return obj;\n    }\n\n    /**\n     * Restore a ref object or deserialize a data object.\n     *\n     * This is passed as callback to class deserializers.\n     */\n    function restoreRef(cls, ref, ctx) {\n      if (!ref.refIndex) {\n        return cls && cls._deserialize && deserialize(cls, ref, ctx);\n      }\n      cls = restoreTypes[ref.refType] || cls;\n      const index = ref.refIndex;\n      if (!refMap[index]) {\n        const data = json[index];\n        const obj = deserialize(cls, data, ctx);\n        refMap[index] = obj;\n      }\n      return refMap[index];\n    }\n\n    const root = rootClass._deserialize(json[0], null, restoreRef);\n\n    return root;\n  };\n}\n\nconst serializer = new Serializer();\n\nSerializer.toJson = serializer.toJson;\nSerializer.fromJson = serializer.fromJson;\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n\nimport * as matrix from '../../common/Matrix';\nimport { Transform } from '../../common/Transform';\nimport { Contact } from '../../dynamics/Contact';\nimport { CircleShape } from './CircleShape';\nimport { Manifold, ContactFeatureType, ManifoldType } from \"../Manifold\";\nimport { Fixture } from \"../../dynamics/Fixture\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nContact.addType(CircleShape.TYPE, CircleShape.TYPE, CircleCircleContact);\n\nfunction CircleCircleContact(manifold: Manifold, xfA: Transform, fixtureA: Fixture, indexA: number, xfB: Transform, fixtureB: Fixture, indexB: number): void {\n  _ASSERT && console.assert(fixtureA.getType() == CircleShape.TYPE);\n  _ASSERT && console.assert(fixtureB.getType() == CircleShape.TYPE);\n  CollideCircles(manifold, fixtureA.getShape() as CircleShape, xfA, fixtureB.getShape() as CircleShape, xfB);\n}\n\nconst pA = matrix.vec2(0, 0);\nconst pB = matrix.vec2(0, 0);\n\nexport const CollideCircles = function (manifold: Manifold, circleA: CircleShape, xfA: Transform, circleB: CircleShape, xfB: Transform): void {\n  manifold.pointCount = 0;\n\n  matrix.transformVec2(pA, xfA, circleA.m_p);\n  matrix.transformVec2(pB, xfB, circleB.m_p);\n\n  const distSqr = matrix.distSqrVec2(pB, pA);\n  const rA = circleA.m_radius;\n  const rB = circleB.m_radius;\n  const radius = rA + rB;\n  if (distSqr > radius * radius) {\n    return;\n  }\n\n  manifold.type = ManifoldType.e_circles;\n  matrix.copyVec2(manifold.localPoint, circleA.m_p);\n  matrix.zeroVec2(manifold.localNormal)\n  manifold.pointCount = 1;\n  matrix.copyVec2(manifold.points[0].localPoint, circleB.m_p);\n\n  // manifold.points[0].id.key = 0;\n  manifold.points[0].id.setFeatures(0, ContactFeatureType.e_vertex, 0, ContactFeatureType.e_vertex)\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { TransformValue } from '../../common/Transform';\nimport * as matrix from '../../common/Matrix';\nimport { Contact } from '../../dynamics/Contact';\nimport { EdgeShape } from './EdgeShape';\nimport { ChainShape } from './ChainShape';\nimport { CircleShape } from './CircleShape';\nimport { Manifold, ContactFeatureType, ManifoldType } from \"../Manifold\";\nimport { Fixture } from \"../../dynamics/Fixture\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nContact.addType(EdgeShape.TYPE, CircleShape.TYPE, EdgeCircleContact);\nContact.addType(ChainShape.TYPE, CircleShape.TYPE, ChainCircleContact);\n\nfunction EdgeCircleContact(manifold: Manifold, xfA: TransformValue, fixtureA: Fixture, indexA: number, xfB: TransformValue, fixtureB: Fixture, indexB: number): void {\n  _ASSERT && console.assert(fixtureA.getType() == EdgeShape.TYPE);\n  _ASSERT && console.assert(fixtureB.getType() == CircleShape.TYPE);\n\n  const shapeA = fixtureA.getShape() as EdgeShape;\n  const shapeB = fixtureB.getShape() as CircleShape;\n\n  CollideEdgeCircle(manifold, shapeA, xfA, shapeB, xfB);\n}\n\nfunction ChainCircleContact(manifold: Manifold, xfA: TransformValue, fixtureA: Fixture, indexA: number, xfB: TransformValue, fixtureB: Fixture, indexB: number): void {\n  _ASSERT && console.assert(fixtureA.getType() == ChainShape.TYPE);\n  _ASSERT && console.assert(fixtureB.getType() == CircleShape.TYPE);\n\n  const chain = fixtureA.getShape() as ChainShape;\n  const edge = new EdgeShape();\n  chain.getChildEdge(edge, indexA);\n\n  const shapeA = edge;\n  const shapeB = fixtureB.getShape() as CircleShape;\n\n  CollideEdgeCircle(manifold, shapeA, xfA, shapeB, xfB);\n}\n\nconst e = matrix.vec2(0, 0);\nconst temp = matrix.vec2(0, 0);\nconst e1 = matrix.vec2(0, 0);\nconst e2 = matrix.vec2(0, 0);\nconst Q = matrix.vec2(0, 0);\nconst P = matrix.vec2(0, 0);\nconst n = matrix.vec2(0, 0);\n\n// Compute contact points for edge versus circle.\n// This accounts for edge connectivity.\nexport const CollideEdgeCircle = function (manifold: Manifold, edgeA: EdgeShape, xfA: TransformValue, circleB: CircleShape, xfB: TransformValue): void {\n  manifold.pointCount = 0;\n\n  // Compute circle in frame of edge\n  matrix.retransformVec2(Q, xfB, xfA, circleB.m_p);\n\n  const A = edgeA.m_vertex1;\n  const B = edgeA.m_vertex2;\n  matrix.diffVec2(e, B, A);\n\n  // Barycentric coordinates\n  const u = matrix.dotVec2(e, B) - matrix.dotVec2(e, Q);\n  const v = matrix.dotVec2(e, Q) - matrix.dotVec2(e, A);\n\n  const radius = edgeA.m_radius + circleB.m_radius;\n\n  // Region A\n  if (v <= 0.0) {\n    matrix.copyVec2(P, A);\n    const dd = matrix.distSqrVec2(Q, A);\n    if (dd > radius * radius) {\n      return;\n    }\n\n    // Is there an edge connected to A?\n    if (edgeA.m_hasVertex0) {\n      const A1 = edgeA.m_vertex0;\n      const B1 = A;\n      matrix.diffVec2(e1, B1, A1);\n      const u1 = matrix.dotVec2(e1, B1) - matrix.dotVec2(e1, Q);\n\n      // Is the circle in Region AB of the previous edge?\n      if (u1 > 0.0) {\n        return;\n      }\n    }\n\n    manifold.type = ManifoldType.e_circles;\n    matrix.zeroVec2(manifold.localNormal)\n    matrix.copyVec2(manifold.localPoint, P);\n    manifold.pointCount = 1;\n    matrix.copyVec2(manifold.points[0].localPoint, circleB.m_p);\n\n    // manifold.points[0].id.key = 0;\n    manifold.points[0].id.setFeatures(0, ContactFeatureType.e_vertex, 0, ContactFeatureType.e_vertex);\n    return;\n  }\n\n  // Region B\n  if (u <= 0.0) {\n    matrix.copyVec2(P, B);\n    const dd = matrix.distSqrVec2(Q, P);\n    if (dd > radius * radius) {\n      return;\n    }\n\n    // Is there an edge connected to B?\n    if (edgeA.m_hasVertex3) {\n      const B2 = edgeA.m_vertex3;\n      const A2 = B;\n      matrix.diffVec2(e2, B2, A2);\n      const v2 = matrix.dotVec2(e2, Q) - matrix.dotVec2(e2, A2);\n\n      // Is the circle in Region AB of the next edge?\n      if (v2 > 0.0) {\n        return;\n      }\n    }\n\n    manifold.type = ManifoldType.e_circles;\n    matrix.zeroVec2(manifold.localNormal)\n    matrix.copyVec2(manifold.localPoint, P);\n    manifold.pointCount = 1;\n    matrix.copyVec2(manifold.points[0].localPoint, circleB.m_p);\n\n    // manifold.points[0].id.key = 0;\n    manifold.points[0].id.setFeatures(1, ContactFeatureType.e_vertex, 0, ContactFeatureType.e_vertex);\n\n    return;\n  }\n\n  // Region AB\n  const den = matrix.lengthSqrVec2(e);\n  _ASSERT && console.assert(den > 0.0);\n  matrix.combineVec2(P, u / den, A, v / den, B);\n  const dd = matrix.distSqrVec2(Q, P);\n  if (dd > radius * radius) {\n    return;\n  }\n\n  matrix.crossNumVec2(n, 1, e);\n  if (matrix.dotVec2(n, Q) - matrix.dotVec2(n, A) < 0.0) {\n    matrix.negVec2(n);\n  }\n  matrix.normalizeVec2(n);\n\n  manifold.type = ManifoldType.e_faceA;\n  matrix.copyVec2(manifold.localNormal, n);\n  matrix.copyVec2(manifold.localPoint, A);\n  manifold.pointCount = 1;\n  matrix.copyVec2(manifold.points[0].localPoint, circleB.m_p);\n\n  // manifold.points[0].id.key = 0;\n  manifold.points[0].id.setFeatures(0, ContactFeatureType.e_face, 0, ContactFeatureType.e_vertex);\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { TransformValue } from '../../common/Transform';\nimport * as matrix from '../../common/Matrix';\nimport { SettingsInternal as Settings } from '../../Settings';\nimport { Manifold, clipSegmentToLine, ClipVertex, ContactFeatureType, ManifoldType } from '../Manifold';\nimport { Contact } from '../../dynamics/Contact';\nimport { PolygonShape } from './PolygonShape';\nimport { Fixture } from \"../../dynamics/Fixture\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\nconst incidentEdge = [ new ClipVertex(), new ClipVertex() ];\nconst clipPoints1 = [ new ClipVertex(), new ClipVertex() ];\nconst clipPoints2 = [ new ClipVertex(), new ClipVertex() ];\nconst clipSegmentToLineNormal = matrix.vec2(0, 0);\nconst v1 = matrix.vec2(0, 0);\nconst n = matrix.vec2(0, 0);\nconst xf = matrix.transform(0, 0, 0);\nconst temp = matrix.vec2(0, 0);\nconst v11 = matrix.vec2(0, 0);\nconst v12 = matrix.vec2(0, 0);\nconst localTangent = matrix.vec2(0, 0);\nconst localNormal = matrix.vec2(0, 0);\nconst planePoint = matrix.vec2(0, 0);\nconst tangent = matrix.vec2(0, 0);\nconst normal = matrix.vec2(0, 0);\nconst normal1 = matrix.vec2(0, 0);\n\n\nContact.addType(PolygonShape.TYPE, PolygonShape.TYPE, PolygonContact);\n\nfunction PolygonContact(\n  manifold: Manifold,\n  xfA: TransformValue,\n  fixtureA: Fixture,\n  indexA: number,\n  xfB: TransformValue,\n  fixtureB: Fixture,\n  indexB: number,\n): void {\n  _ASSERT && console.assert(fixtureA.getType() == PolygonShape.TYPE);\n  _ASSERT && console.assert(fixtureB.getType() == PolygonShape.TYPE);\n  CollidePolygons(manifold, fixtureA.getShape() as PolygonShape, xfA, fixtureB.getShape() as PolygonShape, xfB);\n}\n\ninterface MaxSeparation {\n  maxSeparation: number;\n  bestIndex: number;\n}\n\n/**\n * Find the max separation between poly1 and poly2 using edge normals from\n * poly1.\n */\nfunction findMaxSeparation(\n  poly1: PolygonShape,\n  xf1: TransformValue,\n  poly2: PolygonShape,\n  xf2: TransformValue,\n  output: MaxSeparation,\n): void {\n  const count1 = poly1.m_count;\n  const count2 = poly2.m_count;\n  const n1s = poly1.m_normals;\n  const v1s = poly1.m_vertices;\n  const v2s = poly2.m_vertices;\n\n  matrix.invTransformTransform(xf, xf2, xf1);\n\n  let bestIndex = 0;\n  let maxSeparation = -Infinity;\n  for (let i = 0; i < count1; ++i) {\n    // Get poly1 normal in frame2.\n    matrix.rotVec2(n, xf.q, n1s[i]);\n    matrix.transformVec2(v1, xf, v1s[i]);\n\n    // Find deepest point for normal i.\n    let si = Infinity;\n    for (let j = 0; j < count2; ++j) {\n      const sij = matrix.dotVec2(n, v2s[j]) - matrix.dotVec2(n, v1);\n      if (sij < si) {\n        si = sij;\n      }\n    }\n\n    if (si > maxSeparation) {\n      maxSeparation = si;\n      bestIndex = i;\n    }\n  }\n\n  // used to keep last FindMaxSeparation call values\n  output.maxSeparation = maxSeparation;\n  output.bestIndex = bestIndex;\n}\n\nfunction findIncidentEdge(\n  clipVertex: ClipVertex[],\n  poly1: PolygonShape,\n  xf1: TransformValue,\n  edge1: number,\n  poly2: PolygonShape,\n  xf2: TransformValue,\n): void {\n  const normals1 = poly1.m_normals;\n\n  const count2 = poly2.m_count;\n  const vertices2 = poly2.m_vertices;\n  const normals2 = poly2.m_normals;\n\n  _ASSERT && console.assert(0 <= edge1 && edge1 < poly1.m_count);\n\n  // Get the normal of the reference edge in poly2's frame.\n  matrix.rerotVec2(normal1, xf2.q, xf1.q, normals1[edge1]);\n\n  // Find the incident edge on poly2.\n  let index = 0;\n  let minDot = Infinity;\n  for (let i = 0; i < count2; ++i) {\n    const dot = matrix.dotVec2(normal1, normals2[i]);\n    if (dot < minDot) {\n      minDot = dot;\n      index = i;\n    }\n  }\n\n  // Build the clip vertices for the incident edge.\n  const i1 = index;\n  const i2 = i1 + 1 < count2 ? i1 + 1 : 0;\n\n  matrix.transformVec2(clipVertex[0].v, xf2, vertices2[i1]);\n  clipVertex[0].id.setFeatures(edge1, ContactFeatureType.e_face, i1, ContactFeatureType.e_vertex);\n\n  matrix.transformVec2(clipVertex[1].v, xf2, vertices2[i2]);\n  clipVertex[1].id.setFeatures(edge1, ContactFeatureType.e_face, i2, ContactFeatureType.e_vertex);\n}\n\nconst maxSeparation = {\n  maxSeparation: 0,\n  bestIndex: 0,\n};\n\n/**\n *\n * Find edge normal of max separation on A - return if separating axis is found<br>\n * Find edge normal of max separation on B - return if separation axis is found<br>\n * Choose reference edge as min(minA, minB)<br>\n * Find incident edge<br>\n * Clip\n *\n * The normal points from 1 to 2\n */\nexport const CollidePolygons = function (\n  manifold: Manifold,\n  polyA: PolygonShape,\n  xfA: TransformValue,\n  polyB: PolygonShape,\n  xfB: TransformValue,\n): void {\n  manifold.pointCount = 0;\n  const totalRadius = polyA.m_radius + polyB.m_radius;\n\n  findMaxSeparation(polyA, xfA, polyB, xfB, maxSeparation);\n  const edgeA = maxSeparation.bestIndex;\n  const separationA = maxSeparation.maxSeparation;\n  if (separationA > totalRadius)\n    return;\n\n  findMaxSeparation(polyB, xfB, polyA, xfA, maxSeparation);\n  const edgeB = maxSeparation.bestIndex;\n  const separationB = maxSeparation.maxSeparation;\n  if (separationB > totalRadius)\n    return;\n\n  let poly1: PolygonShape; // reference polygon\n  let poly2: PolygonShape; // incident polygon\n  let xf1: TransformValue;\n  let xf2: TransformValue;\n  let edge1: number; // reference edge\n  let flip: boolean;\n  const k_tol = 0.1 * Settings.linearSlop;\n\n  if (separationB > separationA + k_tol) {\n    poly1 = polyB;\n    poly2 = polyA;\n    xf1 = xfB;\n    xf2 = xfA;\n    edge1 = edgeB;\n    manifold.type = ManifoldType.e_faceB;\n    flip = true;\n  } else {\n    poly1 = polyA;\n    poly2 = polyB;\n    xf1 = xfA;\n    xf2 = xfB;\n    edge1 = edgeA;\n    manifold.type = ManifoldType.e_faceA;\n    flip = false;\n  }\n\n  incidentEdge[0].recycle(), incidentEdge[1].recycle();\n  findIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);\n\n  const count1 = poly1.m_count;\n  const vertices1 = poly1.m_vertices;\n\n  const iv1 = edge1;\n  const iv2 = edge1 + 1 < count1 ? edge1 + 1 : 0;\n\n  matrix.copyVec2(v11, vertices1[iv1]);\n  matrix.copyVec2(v12, vertices1[iv2]);\n\n  matrix.diffVec2(localTangent, v12, v11);\n  matrix.normalizeVec2(localTangent);\n\n  matrix.crossVec2Num(localNormal, localTangent, 1.0);\n  matrix.combineVec2(planePoint, 0.5, v11, 0.5, v12);\n\n  matrix.rotVec2(tangent, xf1.q, localTangent);\n  matrix.crossVec2Num(normal, tangent, 1.0);\n\n  matrix.transformVec2(v11, xf1, v11);\n  matrix.transformVec2(v12, xf1, v12);\n\n  // Face offset.\n  const frontOffset = matrix.dotVec2(normal, v11);\n\n  // Side offsets, extended by polytope skin thickness.\n  const sideOffset1 = -matrix.dotVec2(tangent, v11) + totalRadius;\n  const sideOffset2 = matrix.dotVec2(tangent, v12) + totalRadius;\n\n  // Clip incident edge against extruded edge1 side edges.\n  clipPoints1[0].recycle(), clipPoints1[1].recycle();\n  clipPoints2[0].recycle(), clipPoints2[1].recycle();\n\n  // Clip to box side 1\n  matrix.setVec2(clipSegmentToLineNormal, -tangent.x, -tangent.y);\n  const np1 = clipSegmentToLine(clipPoints1, incidentEdge, clipSegmentToLineNormal, sideOffset1, iv1);\n\n  if (np1 < 2) {\n    return;\n  }\n\n  // Clip to negative box side 1\n  matrix.setVec2(clipSegmentToLineNormal, tangent.x, tangent.y);\n  const np2 = clipSegmentToLine(clipPoints2, clipPoints1, clipSegmentToLineNormal, sideOffset2, iv2);\n\n  if (np2 < 2) {\n    return;\n  }\n\n  // Now clipPoints2 contains the clipped points.\n  matrix.copyVec2(manifold.localNormal, localNormal);\n  matrix.copyVec2(manifold.localPoint, planePoint);\n\n  let pointCount = 0;\n  for (let i = 0; i < clipPoints2.length/* maxManifoldPoints */; ++i) {\n    const separation = matrix.dotVec2(normal, clipPoints2[i].v) - frontOffset;\n\n    if (separation <= totalRadius) {\n      const cp = manifold.points[pointCount];\n      matrix.invTransformVec2(cp.localPoint, xf2, clipPoints2[i].v);\n      cp.id.set(clipPoints2[i].id);\n      if (flip) {\n        // Swap features\n        cp.id.swapFeatures();\n      }\n      ++pointCount;\n    }\n  }\n\n  manifold.pointCount = pointCount;\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport * as matrix from '../../common/Matrix';\nimport { math as Math } from '../../common/Math';\nimport { TransformValue } from '../../common/Transform';\nimport { Contact } from '../../dynamics/Contact';\nimport { CircleShape } from './CircleShape';\nimport { PolygonShape } from './PolygonShape';\nimport { Manifold, ContactFeatureType, ManifoldType } from \"../Manifold\";\nimport { Fixture } from \"../../dynamics/Fixture\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nContact.addType(PolygonShape.TYPE, CircleShape.TYPE, PolygonCircleContact);\n\nfunction PolygonCircleContact(manifold: Manifold, xfA: TransformValue, fixtureA: Fixture, indexA: number, xfB: TransformValue, fixtureB: Fixture, indexB: number): void {\n  _ASSERT && console.assert(fixtureA.getType() == PolygonShape.TYPE);\n  _ASSERT && console.assert(fixtureB.getType() == CircleShape.TYPE);\n  CollidePolygonCircle(manifold, fixtureA.getShape() as PolygonShape, xfA, fixtureB.getShape() as CircleShape, xfB);\n}\n\nconst cLocal = matrix.vec2(0, 0);\nconst faceCenter = matrix.vec2(0, 0);\n\nexport const CollidePolygonCircle = function (manifold: Manifold, polygonA: PolygonShape, xfA: TransformValue, circleB: CircleShape, xfB: TransformValue): void {\n  manifold.pointCount = 0;\n\n  // Compute circle position in the frame of the polygon.\n  matrix.retransformVec2(cLocal, xfB, xfA, circleB.m_p);\n\n  // Find the min separating edge.\n  let normalIndex = 0;\n  let separation = -Infinity;\n  const radius = polygonA.m_radius + circleB.m_radius;\n  const vertexCount = polygonA.m_count;\n  const vertices = polygonA.m_vertices;\n  const normals = polygonA.m_normals;\n\n  for (let i = 0; i < vertexCount; ++i) {\n    const s = matrix.dotVec2(normals[i], cLocal) - matrix.dotVec2(normals[i], vertices[i]);\n\n    if (s > radius) {\n      // Early out.\n      return;\n    }\n\n    if (s > separation) {\n      separation = s;\n      normalIndex = i;\n    }\n  }\n\n  // Vertices that subtend the incident face.\n  const vertIndex1 = normalIndex;\n  const vertIndex2 = vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0;\n  const v1 = vertices[vertIndex1];\n  const v2 = vertices[vertIndex2];\n\n  // If the center is inside the polygon ...\n  if (separation < Math.EPSILON) {\n    manifold.pointCount = 1;\n    manifold.type = ManifoldType.e_faceA;\n    matrix.copyVec2(manifold.localNormal, normals[normalIndex]);\n    matrix.combineVec2(manifold.localPoint, 0.5, v1, 0.5, v2);\n    matrix.copyVec2(manifold.points[0].localPoint, circleB.m_p);\n\n    // manifold.points[0].id.key = 0;\n    manifold.points[0].id.setFeatures(0, ContactFeatureType.e_vertex, 0, ContactFeatureType.e_vertex);\n    return;\n  }\n\n  // Compute barycentric coordinates\n  // u1 = (cLocal - v1) dot (v2 - v1))\n  const u1 = matrix.dotVec2(cLocal, v2) - matrix.dotVec2(cLocal, v1) - matrix.dotVec2(v1, v2) + matrix.dotVec2(v1, v1);\n  // u2 = (cLocal - v2) dot (v1 - v2)\n  const u2 = matrix.dotVec2(cLocal, v1) - matrix.dotVec2(cLocal, v2) - matrix.dotVec2(v2, v1) + matrix.dotVec2(v2, v2);\n  if (u1 <= 0.0) {\n    if (matrix.distSqrVec2(cLocal, v1) > radius * radius) {\n      return;\n    }\n\n    manifold.pointCount = 1;\n    manifold.type = ManifoldType.e_faceA;\n    matrix.diffVec2(manifold.localNormal, cLocal, v1);\n    matrix.normalizeVec2(manifold.localNormal);\n    matrix.copyVec2(manifold.localPoint, v1);\n    matrix.copyVec2(manifold.points[0].localPoint, circleB.m_p);\n\n    // manifold.points[0].id.key = 0;\n    manifold.points[0].id.setFeatures(0, ContactFeatureType.e_vertex, 0, ContactFeatureType.e_vertex);\n  } else if (u2 <= 0.0) {\n    if (matrix.distSqrVec2(cLocal, v2) > radius * radius) {\n      return;\n    }\n\n    manifold.pointCount = 1;\n    manifold.type = ManifoldType.e_faceA;\n    matrix.diffVec2(manifold.localNormal, cLocal, v2);\n    matrix.normalizeVec2(manifold.localNormal);\n    matrix.copyVec2(manifold.localPoint, v2);\n    matrix.copyVec2(manifold.points[0].localPoint, circleB.m_p);\n\n    // manifold.points[0].id.key = 0;\n    manifold.points[0].id.setFeatures(0, ContactFeatureType.e_vertex, 0, ContactFeatureType.e_vertex);\n  } else {\n    matrix.combineVec2(faceCenter, 0.5, v1, 0.5, v2);\n    const separation = matrix.dotVec2(cLocal, normals[vertIndex1]) - matrix.dotVec2(faceCenter, normals[vertIndex1]);\n    if (separation > radius) {\n      return;\n    }\n\n    manifold.pointCount = 1;\n    manifold.type = ManifoldType.e_faceA;\n    matrix.copyVec2(manifold.localNormal, normals[vertIndex1]);\n    matrix.copyVec2(manifold.localPoint, faceCenter);\n    matrix.copyVec2(manifold.points[0].localPoint, circleB.m_p);\n\n    // manifold.points[0].id.key = 0;\n    manifold.points[0].id.setFeatures(0, ContactFeatureType.e_vertex, 0, ContactFeatureType.e_vertex);\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport * as matrix from '../../common/Matrix';\nimport { TransformValue } from '../../common/Transform';\nimport { Vec2, Vec2Value } from '../../common/Vec2';\nimport { SettingsInternal as Settings } from '../../Settings';\nimport { Contact } from '../../dynamics/Contact';\nimport { Manifold, clipSegmentToLine, ClipVertex, ContactFeatureType, ManifoldType } from '../Manifold';\nimport { EdgeShape } from './EdgeShape';\nimport { ChainShape } from './ChainShape';\nimport { PolygonShape } from './PolygonShape';\nimport { Fixture } from \"../../dynamics/Fixture\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nContact.addType(EdgeShape.TYPE, PolygonShape.TYPE, EdgePolygonContact);\nContact.addType(ChainShape.TYPE, PolygonShape.TYPE, ChainPolygonContact);\n\nfunction EdgePolygonContact(manifold: Manifold, xfA: TransformValue, fA: Fixture, indexA: number, xfB: TransformValue, fB: Fixture, indexB: number): void {\n  _ASSERT && console.assert(fA.getType() == EdgeShape.TYPE);\n  _ASSERT && console.assert(fB.getType() == PolygonShape.TYPE);\n\n  CollideEdgePolygon(manifold, fA.getShape() as EdgeShape, xfA, fB.getShape() as PolygonShape, xfB);\n}\n\n// reused\nconst edge_reuse = new EdgeShape();\n\nfunction ChainPolygonContact(manifold: Manifold, xfA: TransformValue, fA: Fixture, indexA: number, xfB: TransformValue, fB: Fixture, indexB: number): void {\n  _ASSERT && console.assert(fA.getType() == ChainShape.TYPE);\n  _ASSERT && console.assert(fB.getType() == PolygonShape.TYPE);\n\n  const chain = fA.getShape() as ChainShape;\n  chain.getChildEdge(edge_reuse, indexA);\n\n  CollideEdgePolygon(manifold, edge_reuse, xfA, fB.getShape() as PolygonShape, xfB);\n}\n\nenum EPAxisType {\n  e_unknown = -1,\n  e_edgeA = 1,\n  e_edgeB = 2,\n}\n\n// unused?\nenum VertexType {\n e_isolated = 0,\n e_concave = 1,\n e_convex = 2,\n}\n\n/**\n * This structure is used to keep track of the best separating axis.\n */\nclass EPAxis {\n  type: EPAxisType;\n  index: number;\n  separation: number;\n}\n\n/**\n * This holds polygon B expressed in frame A.\n */\nclass TempPolygon {\n  vertices: Vec2Value[] = []; // [Settings.maxPolygonVertices]\n  normals: Vec2Value[] = []; // [Settings.maxPolygonVertices];\n  count: number = 0;\n  constructor() {\n    for (let i = 0; i < Settings.maxPolygonVertices; i++) {\n      this.vertices.push(matrix.vec2(0, 0));\n      this.normals.push(matrix.vec2(0, 0));\n    }\n  }\n}\n\n/**\n * Reference face used for clipping\n */\nclass ReferenceFace {\n  i1: number;\n  i2: number;\n  readonly v1 = matrix.vec2(0 ,0);\n  readonly v2 = matrix.vec2(0 ,0);\n  readonly normal = matrix.vec2(0 ,0);\n  readonly sideNormal1 = matrix.vec2(0 ,0);\n  sideOffset1: number;\n  readonly sideNormal2 = matrix.vec2(0 ,0);\n  sideOffset2: number;\n  recycle() {\n    matrix.zeroVec2(this.v1)\n    matrix.zeroVec2(this.v2)\n    matrix.zeroVec2(this.normal)\n    matrix.zeroVec2(this.sideNormal1)\n    matrix.zeroVec2(this.sideNormal2)\n  }\n}\n\n// reused\nconst clipPoints1 = [ new ClipVertex(), new ClipVertex() ];\nconst clipPoints2 = [ new ClipVertex(), new ClipVertex() ];\nconst ie = [ new ClipVertex(), new ClipVertex() ];\nconst edgeAxis = new EPAxis();\nconst polygonAxis = new EPAxis();\nconst polygonBA = new TempPolygon();\nconst rf = new ReferenceFace();\nconst centroidB = matrix.vec2(0, 0);\nconst edge0 = matrix.vec2(0, 0);\nconst edge1 = matrix.vec2(0, 0);\nconst edge2 = matrix.vec2(0, 0);\nconst xf = matrix.transform(0, 0, 0);\nconst normal = matrix.vec2(0, 0);\nconst normal0 = matrix.vec2(0, 0);\nconst normal1 = matrix.vec2(0, 0);\nconst normal2 = matrix.vec2(0, 0);\nconst lowerLimit = matrix.vec2(0, 0);\nconst upperLimit = matrix.vec2(0, 0);\nconst perp = matrix.vec2(0, 0);\nconst n = matrix.vec2(0, 0);\n\n/**\n * This function collides and edge and a polygon, taking into account edge\n * adjacency.\n */\nexport const CollideEdgePolygon = function (manifold: Manifold, edgeA: EdgeShape, xfA: TransformValue, polygonB: PolygonShape, xfB: TransformValue): void {\n  // Algorithm:\n  // 1. Classify v1 and v2\n  // 2. Classify polygon centroid as front or back\n  // 3. Flip normal if necessary\n  // 4. Initialize normal range to [-pi, pi] about face normal\n  // 5. Adjust normal range according to adjacent edges\n  // 6. Visit each separating axes, only accept axes within the range\n  // 7. Return if _any_ axis indicates separation\n  // 8. Clip\n\n  // let m_type1: VertexType;\n  // let m_type2: VertexType;\n\n  matrix.invTransformTransform(xf, xfA, xfB);\n  matrix.transformVec2(centroidB, xf, polygonB.m_centroid);\n\n  const v0 = edgeA.m_vertex0;\n  const v1 = edgeA.m_vertex1;\n  const v2 = edgeA.m_vertex2;\n  const v3 = edgeA.m_vertex3;\n\n  const hasVertex0 = edgeA.m_hasVertex0;\n  const hasVertex3 = edgeA.m_hasVertex3;\n\n  matrix.diffVec2(edge1, v2, v1);\n  matrix.normalizeVec2(edge1);\n  matrix.setVec2(normal1, edge1.y, -edge1.x)\n  const offset1 = matrix.dotVec2(normal1, centroidB) - matrix.dotVec2(normal1, v1);\n  let offset0 = 0.0;\n  let offset2 = 0.0;\n  let convex1 = false;\n  let convex2 = false;\n\n  matrix.zeroVec2(normal0);\n  matrix.zeroVec2(normal2);\n\n  // Is there a preceding edge?\n  if (hasVertex0) {\n    matrix.diffVec2(edge0, v1, v0);\n    matrix.normalizeVec2(edge0);\n    matrix.setVec2(normal0, edge0.y, -edge0.x);\n    convex1 = matrix.crossVec2Vec2(edge0, edge1) >= 0.0;\n    offset0 = Vec2.dot(normal0, centroidB) - Vec2.dot(normal0, v0);\n  }\n\n  // Is there a following edge?\n  if (hasVertex3) {\n    matrix.diffVec2(edge2, v3, v2);\n    matrix.normalizeVec2(edge2);\n    matrix.setVec2(normal2, edge2.y, -edge2.x);\n    convex2 = Vec2.crossVec2Vec2(edge1, edge2) > 0.0;\n    offset2 = Vec2.dot(normal2, centroidB) - Vec2.dot(normal2, v2);\n  }\n\n  let front: boolean;\n  matrix.zeroVec2(normal);\n  matrix.zeroVec2(lowerLimit);\n  matrix.zeroVec2(upperLimit);\n\n  // Determine front or back collision. Determine collision normal limits.\n  if (hasVertex0 && hasVertex3) {\n    if (convex1 && convex2) {\n      front = offset0 >= 0.0 || offset1 >= 0.0 || offset2 >= 0.0;\n      if (front) {\n        matrix.copyVec2(normal, normal1);\n        matrix.copyVec2(lowerLimit, normal0);\n        matrix.copyVec2(upperLimit, normal2);\n      } else {\n        matrix.setMulVec2(normal, -1, normal1);\n        matrix.setMulVec2(lowerLimit, -1, normal1);\n        matrix.setMulVec2(upperLimit, -1, normal1);\n      }\n    } else if (convex1) {\n      front = offset0 >= 0.0 || (offset1 >= 0.0 && offset2 >= 0.0);\n      if (front) {\n        matrix.copyVec2(normal, normal1);\n        matrix.copyVec2(lowerLimit, normal0);\n        matrix.copyVec2(upperLimit, normal1);\n      } else {\n        matrix.setMulVec2(normal, -1, normal1);\n        matrix.setMulVec2(lowerLimit, -1, normal2);\n        matrix.setMulVec2(upperLimit, -1, normal1);\n      }\n    } else if (convex2) {\n      front = offset2 >= 0.0 || (offset0 >= 0.0 && offset1 >= 0.0);\n      if (front) {\n        matrix.copyVec2(normal, normal1);\n        matrix.copyVec2(lowerLimit, normal1);\n        matrix.copyVec2(upperLimit, normal2);\n      } else {\n        matrix.setMulVec2(normal, -1, normal1);\n        matrix.setMulVec2(lowerLimit, -1, normal1);\n        matrix.setMulVec2(upperLimit, -1, normal0);\n      }\n    } else {\n      front = offset0 >= 0.0 && offset1 >= 0.0 && offset2 >= 0.0;\n      if (front) {\n        matrix.copyVec2(normal, normal1);\n        matrix.copyVec2(lowerLimit, normal1);\n        matrix.copyVec2(upperLimit, normal1);\n      } else {\n        matrix.setMulVec2(normal, -1, normal1);\n        matrix.setMulVec2(lowerLimit, -1, normal2);\n        matrix.setMulVec2(upperLimit, -1, normal0);\n      }\n    }\n  } else if (hasVertex0) {\n    if (convex1) {\n      front = offset0 >= 0.0 || offset1 >= 0.0;\n      if (front) {\n        matrix.copyVec2(normal, normal1);\n        matrix.copyVec2(lowerLimit, normal0);\n        matrix.setMulVec2(upperLimit, -1, normal1);\n      } else {\n        matrix.setMulVec2(normal, -1, normal1);\n        matrix.copyVec2(lowerLimit, normal1);\n        matrix.setMulVec2(upperLimit, -1, normal1);\n      }\n    } else {\n      front = offset0 >= 0.0 && offset1 >= 0.0;\n      if (front) {\n        matrix.copyVec2(normal, normal1);\n        matrix.copyVec2(lowerLimit, normal1);\n        matrix.setMulVec2(upperLimit, -1, normal1);\n      } else {\n        matrix.setMulVec2(normal, -1, normal1);\n        matrix.copyVec2(lowerLimit, normal1);\n        matrix.setMulVec2(upperLimit, -1, normal0);\n      }\n    }\n  } else if (hasVertex3) {\n    if (convex2) {\n      front = offset1 >= 0.0 || offset2 >= 0.0;\n      if (front) {\n        matrix.copyVec2(normal, normal1);\n        matrix.setMulVec2(lowerLimit, -1, normal1);\n        matrix.copyVec2(upperLimit, normal2);\n      } else {\n        matrix.setMulVec2(normal, -1, normal1);\n        matrix.setMulVec2(lowerLimit, -1, normal1);\n        matrix.copyVec2(upperLimit, normal1);\n      }\n    } else {\n      front = offset1 >= 0.0 && offset2 >= 0.0;\n      if (front) {\n        matrix.copyVec2(normal, normal1);\n        matrix.setMulVec2(lowerLimit, -1, normal1);\n        matrix.copyVec2(upperLimit, normal1);\n      } else {\n        matrix.setMulVec2(normal, -1, normal1);\n        matrix.setMulVec2(lowerLimit, -1, normal2);\n        matrix.copyVec2(upperLimit, normal1);\n      }\n    }\n  } else {\n    front = offset1 >= 0.0;\n    if (front) {\n      matrix.copyVec2(normal, normal1);\n      matrix.setMulVec2(lowerLimit, -1, normal1);\n      matrix.setMulVec2(upperLimit, -1, normal1);\n    } else {\n      matrix.setMulVec2(normal, -1, normal1);\n      matrix.copyVec2(lowerLimit, normal1);\n      matrix.copyVec2(upperLimit, normal1);\n    }\n  }\n\n  // Get polygonB in frameA\n  polygonBA.count = polygonB.m_count;\n  for (let i = 0; i < polygonB.m_count; ++i) {\n    matrix.transformVec2(polygonBA.vertices[i], xf, polygonB.m_vertices[i]);\n    matrix.rotVec2(polygonBA.normals[i], xf.q, polygonB.m_normals[i]);\n  }\n\n  const radius = polygonB.m_radius + edgeA.m_radius;\n\n  manifold.pointCount = 0;\n\n  { // ComputeEdgeSeparation\n    edgeAxis.type = EPAxisType.e_edgeA;\n    edgeAxis.index = front ? 0 : 1;\n    edgeAxis.separation = Infinity;\n\n    for (let i = 0; i < polygonBA.count; ++i) {\n      const v = polygonBA.vertices[i];\n      const s = matrix.dotVec2(normal, v) - matrix.dotVec2(normal, v1);\n      if (s < edgeAxis.separation) {\n        edgeAxis.separation = s;\n      }\n    }\n  }\n\n  // If no valid normal can be found than this edge should not collide.\n  // @ts-ignore\n  if (edgeAxis.type == EPAxisType.e_unknown) {\n    return;\n  }\n\n  if (edgeAxis.separation > radius) {\n    return;\n  }\n\n  { // ComputePolygonSeparation\n    polygonAxis.type = EPAxisType.e_unknown;\n    polygonAxis.index = -1;\n    polygonAxis.separation = -Infinity;\n\n    matrix.setVec2(perp, -normal.y, normal.x);\n\n    for (let i = 0; i < polygonBA.count; ++i) {\n      matrix.setMulVec2(n, -1, polygonBA.normals[i]);\n\n      const s1 = matrix.dotVec2(n, polygonBA.vertices[i]) - matrix.dotVec2(n, v1);\n      const s2 = matrix.dotVec2(n, polygonBA.vertices[i]) - matrix.dotVec2(n, v2);\n      const s = Math.min(s1, s2);\n\n      if (s > radius) {\n        // No collision\n        polygonAxis.type = EPAxisType.e_edgeB;\n        polygonAxis.index = i;\n        polygonAxis.separation = s;\n        break;\n      }\n\n      // Adjacency\n      if (matrix.dotVec2(n, perp) >= 0.0) {\n        if (matrix.dotVec2(n, normal) - matrix.dotVec2(upperLimit, normal) < -Settings.angularSlop) {\n          continue;\n        }\n      } else {\n        if (matrix.dotVec2(n, normal) - matrix.dotVec2(lowerLimit, normal) < -Settings.angularSlop) {\n          continue;\n        }\n      }\n\n      if (s > polygonAxis.separation) {\n        polygonAxis.type = EPAxisType.e_edgeB;\n        polygonAxis.index = i;\n        polygonAxis.separation = s;\n      }\n    }\n  }\n\n  if (polygonAxis.type != EPAxisType.e_unknown && polygonAxis.separation > radius) {\n    return;\n  }\n\n  // Use hysteresis for jitter reduction.\n  const k_relativeTol = 0.98;\n  const k_absoluteTol = 0.001;\n\n  let primaryAxis: EPAxis;\n  if (polygonAxis.type == EPAxisType.e_unknown) {\n    primaryAxis = edgeAxis;\n  } else if (polygonAxis.separation > k_relativeTol * edgeAxis.separation + k_absoluteTol) {\n    primaryAxis = polygonAxis;\n  } else {\n    primaryAxis = edgeAxis;\n  }\n\n  ie[0].recycle(), ie[1].recycle();\n\n  if (primaryAxis.type == EPAxisType.e_edgeA) {\n    manifold.type = ManifoldType.e_faceA;\n\n    // Search for the polygon normal that is most anti-parallel to the edge\n    // normal.\n    let bestIndex = 0;\n    let bestValue = matrix.dotVec2(normal, polygonBA.normals[0]);\n    for (let i = 1; i < polygonBA.count; ++i) {\n      const value = matrix.dotVec2(normal, polygonBA.normals[i]);\n      if (value < bestValue) {\n        bestValue = value;\n        bestIndex = i;\n      }\n    }\n\n    const i1 = bestIndex;\n    const i2 = i1 + 1 < polygonBA.count ? i1 + 1 : 0;\n\n    matrix.copyVec2(ie[0].v, polygonBA.vertices[i1]);\n    ie[0].id.setFeatures(0, ContactFeatureType.e_face, i1, ContactFeatureType.e_vertex);\n\n    matrix.copyVec2(ie[1].v, polygonBA.vertices[i2]);\n    ie[1].id.setFeatures(0, ContactFeatureType.e_face, i2, ContactFeatureType.e_vertex);\n\n    if (front) {\n      rf.i1 = 0;\n      rf.i2 = 1;\n      matrix.copyVec2(rf.v1, v1);\n      matrix.copyVec2(rf.v2, v2);\n      matrix.copyVec2(rf.normal, normal1);\n    } else {\n      rf.i1 = 1;\n      rf.i2 = 0;\n      matrix.copyVec2(rf.v1, v2);\n      matrix.copyVec2(rf.v2, v1);\n      matrix.setMulVec2(rf.normal, -1, normal1);\n    }\n  } else {\n    manifold.type = ManifoldType.e_faceB;\n\n    matrix.copyVec2(ie[0].v, v1);\n    ie[0].id.setFeatures(0, ContactFeatureType.e_vertex, primaryAxis.index, ContactFeatureType.e_face);\n\n    matrix.copyVec2(ie[1].v, v2);\n    ie[1].id.setFeatures(0, ContactFeatureType.e_vertex, primaryAxis.index, ContactFeatureType.e_face);\n\n    rf.i1 = primaryAxis.index;\n    rf.i2 = rf.i1 + 1 < polygonBA.count ? rf.i1 + 1 : 0;\n    matrix.copyVec2(rf.v1, polygonBA.vertices[rf.i1]);\n    matrix.copyVec2(rf.v2, polygonBA.vertices[rf.i2]);\n    matrix.copyVec2(rf.normal, polygonBA.normals[rf.i1]);\n  }\n\n  matrix.setVec2(rf.sideNormal1, rf.normal.y, -rf.normal.x);\n  matrix.setVec2(rf.sideNormal2, -rf.sideNormal1.x, -rf.sideNormal1.y);\n  rf.sideOffset1 = matrix.dotVec2(rf.sideNormal1, rf.v1);\n  rf.sideOffset2 = matrix.dotVec2(rf.sideNormal2, rf.v2);\n\n  // Clip incident edge against extruded edge1 side edges.\n  clipPoints1[0].recycle(), clipPoints1[1].recycle();\n  clipPoints2[0].recycle(), clipPoints2[1].recycle();\n\n  // Clip to box side 1\n  const np1 = clipSegmentToLine(clipPoints1, ie, rf.sideNormal1, rf.sideOffset1, rf.i1);\n\n  if (np1 < Settings.maxManifoldPoints) {\n    return;\n  }\n\n  // Clip to negative box side 1\n  const np2 = clipSegmentToLine(clipPoints2, clipPoints1, rf.sideNormal2, rf.sideOffset2, rf.i2);\n\n  if (np2 < Settings.maxManifoldPoints) {\n    return;\n  }\n\n  // Now clipPoints2 contains the clipped points.\n  if (primaryAxis.type == EPAxisType.e_edgeA) {\n    matrix.copyVec2(manifold.localNormal, rf.normal);\n    matrix.copyVec2(manifold.localPoint, rf.v1);\n  } else {\n    matrix.copyVec2(manifold.localNormal, polygonB.m_normals[rf.i1]);\n    matrix.copyVec2(manifold.localPoint, polygonB.m_vertices[rf.i1]);\n  }\n\n  let pointCount = 0;\n  for (let i = 0; i < Settings.maxManifoldPoints; ++i) {\n    const separation = matrix.dotVec2(rf.normal, clipPoints2[i].v) - matrix.dotVec2(rf.normal, rf.v1);\n\n    if (separation <= radius) {\n      const cp = manifold.points[pointCount]; // ManifoldPoint\n\n      if (primaryAxis.type == EPAxisType.e_edgeA) {\n        matrix.invTransformVec2(cp.localPoint, xf, clipPoints2[i].v);\n        cp.id.set(clipPoints2[i].id);\n      } else {\n        matrix.copyVec2(cp.localPoint, clipPoints2[i].v);\n        cp.id.set(clipPoints2[i].id);\n        cp.id.swapFeatures();\n      }\n\n      ++pointCount;\n    }\n  }\n\n  manifold.pointCount = pointCount;\n}\n","export * from './serializer/index';\n\nexport * from './common/Math';\n\nexport * from './common/Vec2';\nexport * from './common/Vec3';\nexport * from './common/Mat22';\nexport * from './common/Mat33';\nexport * from './common/Transform';\nexport * from './common/Rot';\n\nexport * from './collision/AABB';\n\nexport * from './collision/Shape';\nexport * from './dynamics/Fixture';\nexport * from './dynamics/Body';\nexport * from './dynamics/Contact';\nexport * from './dynamics/Joint';\nexport * from './dynamics/World';\n\nexport * from './collision/shape/CircleShape';\nexport * from './collision/shape/EdgeShape';\nexport * from './collision/shape/PolygonShape';\nexport * from './collision/shape/ChainShape';\nexport * from './collision/shape/BoxShape';\n\nexport * from './collision/shape/CollideCircle';\nexport * from './collision/shape/CollideEdgeCircle';\nexport * from './collision/shape/CollidePolygon';\nexport * from './collision/shape/CollideCirclePolygon';\nexport * from './collision/shape/CollideEdgePolygon';\n\nexport * from './dynamics/joint/DistanceJoint';\nexport * from './dynamics/joint/FrictionJoint';\nexport * from './dynamics/joint/GearJoint';\nexport * from './dynamics/joint/MotorJoint';\nexport * from './dynamics/joint/MouseJoint';\nexport * from './dynamics/joint/PrismaticJoint';\nexport * from './dynamics/joint/PulleyJoint';\nexport * from './dynamics/joint/RevoluteJoint';\nexport * from './dynamics/joint/RopeJoint';\nexport * from './dynamics/joint/WeldJoint';\nexport * from './dynamics/joint/WheelJoint';\n\nexport * from './Settings';\n\nexport * from './common/Sweep';\nexport * from './collision/Manifold';\nexport * from './collision/Distance';\nexport * from './collision/TimeOfImpact';\nexport * from './collision/DynamicTree';\nexport * from './util/stats';\n\nimport { math } from './common/Math';\n\nexport const Math = math;\n\nimport { CollidePolygons } from './collision/shape/CollidePolygon';\nimport { SettingsInternal as Settings } from './Settings';\nimport { Sweep } from './common/Sweep';\nimport { DynamicTree } from './collision/DynamicTree';\nimport { Manifold } from './collision/Manifold';\nimport { Distance } from './collision/Distance';\nimport { TimeOfImpact } from './collision/TimeOfImpact';\nimport { stats } from './util/stats';\n\n/** @deprecated Merged with main namespace */\nexport const internal = {\n  CollidePolygons,\n  Settings,\n  Sweep,\n  Manifold,\n  Distance,\n  TimeOfImpact,\n  DynamicTree,\n  stats\n};\n","import Stage from 'stage-js';\n\nexport * from '../src/index';\n\nimport {\n  AABB,\n  MouseJoint,\n  Vec2,\n} from '../src';\n\nimport type {\n  Body,\n  Fixture,\n  Joint,\n  World,\n  EdgeShape,\n  PolygonShape,\n  ChainShape,\n  CircleShape,\n} from '../src';\n\ninterface Point {\n  x: number;\n  y: number;\n}\n\ninterface Style {\n  stroke?: string;\n  fill?: string;\n}\n\nconst getStyle = function(obj: Body | Fixture | Joint): Style {\n  return obj['render'] ?? obj['style'] ?? {};\n};\n\ninterface Options {\n  speed: number;\n  hz: number;\n  scaleY: number;\n  ratio: number;\n  lineWidth: number;\n  stroke: string | undefined;\n  fill: string | undefined;\n}\n\ntype KEY = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' |\n  '8' | '9' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' |\n  'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' |\n  'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' |\n  'Z' | 'right' | 'left' | 'up' | 'down' | 'fire';\n\nexport type ActiveKeys = { [key in KEY]?: boolean };\n\nfunction findBody(world: World, point: Point) {\n  let body: Body | null = null;\n  const aabb = new AABB(point, point);\n  world.queryAABB(aabb, (fixture: Fixture) => {\n    if (!fixture.getBody().isDynamic() || !fixture.testPoint(point)) {\n      return true;\n    }\n    body = fixture.getBody();\n    return false;\n  });\n  return body;\n}\n\n// status.innerText = '';\n// info.innerText = '';\n\nexport class Testbed {\n  // camera position\n\n  /** World viewbox width. */\n  width: number = 80;\n\n  /** World viewbox height. */\n  height: number = 60;\n\n  /** World viewbox center vertical offset. */\n  x: number = 0;\n\n  /** World viewbox center horizontal offset. */\n  y: number = -10;\n\n  scaleY: number = -1;\n\n  /** World simulation step frequency */\n  hz: number = 60;\n\n  /** World simulation speed, default is 1 */\n  speed: number = 1;\n\n  ratio: number = 16;\n  background: string = '#222222';\n\n  mouseForce?: number;\n  activeKeys: ActiveKeys = {};\n\n  /** callback, to be implemented by user */\n  step = (dt: number, t: number): void => {\n    return;\n  };\n\n  /** callback, to be implemented by user */\n  keydown = (keyCode: number, label: string): void => {\n    return;\n  };\n\n  /** callback, to be implemented by user */\n  keyup = (keyCode: number, label: string): void => {\n    return;\n  };\n\n  private canvas: any;\n  private stage: any;\n  private paused: boolean = false;\n  private lastDrawHash = \"\";\n  private newDrawHash = \"\";\n  private buffer: ((context: CanvasRenderingContext2D, ratio: number)=> void)[] = [];\n\n  start = (world: World) => {\n    const stage = this.stage = Stage.mount();\n    const canvas = this.canvas = stage.dom as HTMLCanvasElement;\n\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const testbed = this;\n    this.canvas = canvas;\n\n    stage.on(Stage.Mouse.START, () => {\n      window.focus();\n      // @ts-ignore\n      document.activeElement?.blur();\n      canvas.focus();\n    });\n\n    (stage as any).MAX_ELAPSE = 1000 / 30;\n\n    stage.on('resume', () => {\n      this.paused = false;\n      this._resume();\n    });\n    stage.on('pause', () => {\n      this.paused = true;\n      this._pause();\n    });\n\n    const drawingTexture = new Stage.Texture();\n    stage.append(Stage.sprite(drawingTexture));\n    stage.tick(() => {\n      this.buffer.length = 0;\n    }, true);\n\n    drawingTexture.draw = (ctx: CanvasRenderingContext2D) => {\n      ctx.save();\n      ctx.transform(1, 0, 0, this.scaleY, -this.x, -this.y);\n      ctx.lineWidth = 2  / this.ratio;\n      ctx.lineCap = 'round';\n      for (let drawing = this.buffer.shift(); drawing; drawing = this.buffer.shift()) {\n        drawing(ctx, this.ratio);\n      }\n      ctx.restore();\n    };\n\n    const worldNode = new PlanckStageNode(world, this);\n\n    let lastX = 0;\n    let lastY = 0;\n    stage.tick((dt: number, t: number) => {\n      // update camera position\n      if (lastX !== this.x || lastY !== this.y) {\n        worldNode.offset(-this.x, -this.y);\n        lastX = this.x;\n        lastY = this.y;\n      }\n    });\n\n    worldNode.tick((dt: number, t: number) => {\n      this.step(dt, t);\n\n      if (targetBody) {\n        this.drawSegment(targetBody.getPosition(), mouseMove, 'rgba(255,255,255,0.2)');\n      }\n\n      if (this.lastDrawHash !== this.newDrawHash) {\n        this.lastDrawHash = this.newDrawHash;\n        stage.touch();\n      }\n      this.newDrawHash = \"\";\n\n      return true;\n    });\n\n    // stage.empty();\n    stage.background(this.background);\n    stage.viewbox(this.width, this.height);\n    stage.pin('alignX', -0.5);\n    stage.pin('alignY', -0.5);\n    stage.prepend(worldNode);\n\n    const mouseGround = world.createBody();\n    let mouseJoint: MouseJoint | null = null;\n    let targetBody: Body | null = null;\n    const mouseMove = {x: 0, y: 0};\n\n    worldNode.attr('spy', true);\n\n    worldNode.on(Stage.Mouse.START, (point: Point) => {\n      point = { x: point.x, y: testbed.scaleY * point.y };\n      if (targetBody) {\n        return;\n      }\n\n      const body = findBody(world, point);\n      if (!body) {\n        return;\n      }\n\n      if (this.mouseForce) {\n        targetBody = body;\n\n      } else {\n        mouseJoint = new MouseJoint({maxForce: 1000}, mouseGround, body, Vec2.clone(point));\n        world.createJoint(mouseJoint);\n      }\n    });\n\n    worldNode.on(Stage.Mouse.MOVE, (point: Point) => {\n      point = { x: point.x, y: testbed.scaleY * point.y };\n      if (mouseJoint) {\n        mouseJoint.setTarget(point);\n      }\n\n      mouseMove.x = point.x;\n      mouseMove.y = point.y;\n    });\n\n    worldNode.on(Stage.Mouse.END, (point: Point) => {\n      point = { x: point.x, y: testbed.scaleY * point.y };\n      if (mouseJoint) {\n        world.destroyJoint(mouseJoint);\n        mouseJoint = null;\n      }\n      if (targetBody && this.mouseForce) {\n        const force = Vec2.sub(point, targetBody.getPosition());\n        targetBody.applyForceToCenter(force.mul(this.mouseForce), true);\n        targetBody = null;\n      }\n    });\n\n    worldNode.on(Stage.Mouse.CANCEL, (point: Point) => {\n      point = { x: point.x, y: testbed.scaleY * point.y };\n      if (mouseJoint) {\n        world.destroyJoint(mouseJoint);\n        mouseJoint = null;\n      }\n      if (targetBody) {\n        targetBody = null;\n      }\n    });\n\n    window.addEventListener(\"keydown\", (e: KeyboardEvent) => {\n      switch (e.keyCode) {\n        case 'P'.charCodeAt(0):\n          this.togglePause();\n          break;\n      }\n    }, false);\n\n    const activeKeys = testbed.activeKeys;\n    const downKeys: Record<number, boolean> = {};\n    function updateActiveKeys(keyCode: number, down: boolean) {\n      const char = String.fromCharCode(keyCode) as KEY;\n      if (/\\w/.test(char)) {\n        activeKeys[char] = down;\n      }\n      activeKeys.right = downKeys[39] || activeKeys['D'];\n      activeKeys.left = downKeys[37] || activeKeys['A'];\n      activeKeys.up = downKeys[38] || activeKeys['W'];\n      activeKeys.down = downKeys[40] || activeKeys['S'];\n      activeKeys.fire = downKeys[32] || downKeys[13] ;\n    }\n\n    window.addEventListener(\"keydown\", function(e) {\n      const keyCode = e.keyCode;\n      downKeys[keyCode] = true;\n      updateActiveKeys(keyCode, true);\n      testbed.keydown && testbed.keydown(keyCode, String.fromCharCode(keyCode));\n    });\n    window.addEventListener(\"keyup\", function(e) {\n      const keyCode = e.keyCode;\n      downKeys[keyCode] = false;\n      updateActiveKeys(keyCode, false);\n      testbed.keyup && testbed.keyup(keyCode, String.fromCharCode(keyCode));\n    });\n\n    this.resume();\n  }\n\n  /** @private @internal */\n  focus = () => {\n    // @ts-ignore\n    document.activeElement && document.activeElement.blur();\n    this.canvas.focus();\n  };\n\n  /** @internal */\n  _pause = () => {\n  };\n\n  /** @internal */\n  _resume = () => {\n  };\n\n  /** @internal */\n  _status = (string: string) => {\n  };\n\n  /** @internal */  \n  _info = (text: string) => {\n  };\n\n  /** @internal */\n  isPaused = () => {\n    return this.paused;\n  };\n\n  /** @internal */\n  togglePause = () => {\n    this.paused ? this.resume() : this.pause();\n  };\n\n  /** @internal */\n  pause = () => {\n    this.stage.pause();\n  };\n\n  /** @internal */\n  resume = () => {\n    this.stage.resume();\n    this.focus();\n  };\n\n  statusText = '';\n  statusMap: Record<string, any> = {};\n\n  private statusSet(name: string, value: string | number | boolean) {\n    if (typeof value !== 'function' && typeof value !== 'object') {\n      this.statusMap[name] = value;\n    }\n  }\n\n  status(name: string, value: any): void;\n  status(value: object | string): void;\n  status(a: any, b?: any) {\n    if (typeof b !== 'undefined') {\n      this.statusSet(a, b);\n    } else if (a && typeof a === 'object') {\n      // tslint:disable-next-line:no-for-in\n      for (const key in a) {\n        this.statusSet(key, a[key]);\n      }\n    } else if (typeof a === 'string') {\n      this.statusText = a;\n    }\n\n    var newline = '\\n';\n    var text = this.statusText || '';\n    for (var key in this.statusMap) {\n      var value = this.statusMap[key];\n      if (typeof value === 'function') continue;\n      text += (text && newline) + key + ': ' + value;\n    }\n\n    this._status(text);\n  }\n\n  info = (text: string): void => {\n    this._info(text);\n  };\n\n  drawPoint = (p: {x: number, y: number}, r: any, color: string): void => {\n    this.buffer.push(function(ctx, ratio) {\n      ctx.beginPath();\n      ctx.arc(p.x, p.y, 5  / ratio, 0, 2 * Math.PI);\n      ctx.strokeStyle = color;\n      ctx.stroke();\n    });\n    this.newDrawHash += \"point\" + p.x + ',' + p.y + ',' + r + ',' + color;\n  };\n\n  drawCircle = (p: {x: number, y: number}, r: number, color: string): void => {\n    this.buffer.push(function(ctx) {\n      ctx.beginPath();\n      ctx.arc(p.x, p.y, r, 0, 2 * Math.PI);\n      ctx.strokeStyle = color;\n      ctx.stroke();\n    });\n    this.newDrawHash += \"circle\" + p.x + ',' + p.y + ',' + r + ',' + color;\n  };\n\n  drawEdge = (a: {x: number, y: number}, b: {x: number, y: number}, color: string): void => {\n    this.buffer.push(function(ctx) {\n      ctx.beginPath();\n      ctx.moveTo(a.x, a.y);\n      ctx.lineTo(b.x, b.y);\n      ctx.strokeStyle = color;\n      ctx.stroke();\n    });\n    this.newDrawHash += \"segment\" + a.x + ',' + a.y + ',' + b.x + ',' + b.y + ',' + color;\n  };\n\n  drawSegment = this.drawEdge;\n\n  drawPolygon = (points: Array<{x: number, y: number}>, color: string): void => {\n    if (!points || !points.length) {\n      return;\n    }\n    this.buffer.push(function(ctx) {\n      ctx.beginPath();\n      ctx.moveTo(points[0].x, points[0].y);\n      for (let i = 1; i < points.length; i++) {\n        ctx.lineTo(points[i].x, points[i].y);\n      }\n      ctx.strokeStyle = color;\n      ctx.closePath();\n      ctx.stroke();\n    });\n    this.newDrawHash += \"segment\";\n    for (let i = 1; i < points.length; i++) {\n      this.newDrawHash += points[i].x + ',' + points[i].y + ',';\n    }\n    this.newDrawHash += color;\n  };\n\n  drawAABB = (aabb: AABB, color: string): void => {\n    this.buffer.push(function(ctx) {\n      ctx.beginPath();\n      ctx.moveTo(aabb.lowerBound.x, aabb.lowerBound.y);\n      ctx.lineTo(aabb.upperBound.x, aabb.lowerBound.y);\n      ctx.lineTo(aabb.upperBound.x, aabb.upperBound.y);\n      ctx.lineTo(aabb.lowerBound.x, aabb.upperBound.y);\n      ctx.strokeStyle = color;\n      ctx.closePath();\n      ctx.stroke();\n    });\n    this.newDrawHash += \"aabb\";\n    this.newDrawHash += aabb.lowerBound.x + ',' + aabb.lowerBound.y + ',';\n    this.newDrawHash += aabb.upperBound.x + ',' + aabb.upperBound.y + ',';\n    this.newDrawHash += color;\n  };\n\n  color = function(r: number, g: number, b: number): string {\n    r = r * 256 | 0;\n    g = g * 256 | 0;\n    b = b * 256 | 0;\n    return 'rgb(' + r + ', ' + g + ', ' + b + ')';\n  };\n\n  findOne = (query: string): (Body | Joint | Fixture | null) => {\n    // todo: implement\n    return null;\n  };\n\n  findAll = (query: string): (Body | Joint | Fixture)[] => {\n    // todo: implement\n    return [];\n  };\n}\n\nclass PlanckStageNode extends Stage.Node {\n  private nodes = new WeakMap<Body | Fixture | Joint, Stage.Node>();\n\n  private options: Options = {\n    speed: 1,\n    hz: 60,\n    scaleY: -1,\n    ratio: 16,\n    lineWidth: 1,\n    stroke: undefined,\n    fill: undefined\n  };\n\n  private world: World;\n\n  constructor(world: World, opts: Partial<Options> = {}) {\n    super();\n    this.label('Planck');\n\n    this.options.speed = opts.speed ?? this.options.speed;\n    this.options.hz = opts.hz ?? this.options.speed;\n    if (Math.abs(this.options.hz) < 1) {\n      this.options.hz = 1 / this.options.hz;\n    }\n    this.options.scaleY = opts.scaleY ?? this.options.scaleY;\n    this.options.ratio = opts.ratio ?? this.options.ratio;\n    this.options.lineWidth = 2 / this.options.ratio;\n\n    this.world = world;\n\n    const timeStep = 1 / this.options.hz;\n    let elapsedTime = 0;\n    let errored = false;\n    this.tick((dt: number) => {\n      if (errored) {\n        return false;\n      }\n      try {\n        dt = dt * 0.001 * this.options.speed;\n        elapsedTime += dt;\n        while (elapsedTime > timeStep) {\n          world.step(timeStep);\n          elapsedTime -= timeStep;\n        }\n        this.renderWorld();\n        return true;          \n      } catch (error) {\n        errored = true;\n        console.error(error);\n        return false;\n      }\n    }, true);\n\n    world.on('remove-fixture', (obj: Fixture) => {\n      this.nodes.get(obj)?.remove();\n    });\n\n    world.on('remove-joint', (obj: Joint) => {\n      this.nodes.get(obj)?.remove();\n    });\n  }\n\n  renderWorld = () => {\n    const world = this.world;\n    const options = this.options;\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const viewer = this;\n\n    for (let b = world.getBodyList(); b; b = b.getNext()) {\n      for (let f = b.getFixtureList(); f; f = f.getNext()) {\n\n        let node = this.nodes.get(f);\n        const fstyle = getStyle(f);\n        const bstyle = getStyle(b);\n        if (!node) {\n          if (fstyle && fstyle.stroke) {\n            options.stroke = fstyle.stroke;\n          } else if (bstyle && bstyle.stroke) {\n            options.stroke = bstyle.stroke;\n          } else if (b.isDynamic()) {\n            options.stroke = 'rgba(255,255,255,0.9)';\n          } else if (b.isKinematic()) {\n            options.stroke = 'rgba(255,255,255,0.7)';\n          } else if (b.isStatic()) {\n            options.stroke = 'rgba(255,255,255,0.5)';\n          }\n\n          if (fstyle && fstyle.fill) {\n            options.fill = fstyle.fill;\n          } else if (bstyle && bstyle.fill) {\n            options.fill = bstyle.fill;\n          } else {\n            options.fill = '';\n          }\n\n          const type = f.getType();\n          const shape = f.getShape();\n          if (type == 'circle') {\n            node = viewer.drawCircle(shape as CircleShape, options);\n          }\n          if (type == 'edge') {\n            node = viewer.drawEdge(shape as EdgeShape, options);\n          }\n          if (type == 'polygon') {\n            node = viewer.drawPolygon(shape as PolygonShape, options);\n          }\n          if (type == 'chain') {\n            node = viewer.drawChain(shape as ChainShape, options);\n          }\n\n          if (node) {\n            node.appendTo(viewer);\n            this.nodes.set(f, node);\n          }\n        }\n\n        if (node) {\n          const p = b.getPosition();\n          const r = b.getAngle();\n          // @ts-ignore\n          const isChanged = node.__lastX !== p.x || node.__lastY !== p.y || node.__lastR !== r;\n          if (isChanged) {\n            // @ts-ignore\n            node.__lastX = p.x;\n            // @ts-ignore\n            node.__lastY = p.y;\n            // @ts-ignore\n            node.__lastR = r;\n            node.offset(p.x, options.scaleY * p.y);\n            node.rotate(options.scaleY * r);\n          }\n        }\n\n      }\n    }\n\n    for (let j = world.getJointList(); j; j = j.getNext()) {\n      const type = j.getType();\n      const a = j.getAnchorA();\n      const b = j.getAnchorB();\n\n      let node = this.nodes.get(j);\n      if (!node) {\n        options.stroke = 'rgba(255,255,255,0.2)';\n\n        node = viewer.drawJoint(j, options);\n        node.pin('handle', 0.5);\n        node.appendTo(viewer);\n        this.nodes.set(j, node);\n      }\n\n      if (node) {\n        const cx = (a.x + b.x) * 0.5;\n        const cy = options.scaleY * (a.y + b.y) * 0.5;\n        const dx = a.x - b.x;\n        const dy = options.scaleY * (a.y - b.y);\n        const d = Math.sqrt(dx * dx + dy * dy);\n        node.width(d);\n        node.rotate(Math.atan2(dy, dx));\n        node.offset(cx, cy);\n      }\n    }\n  }\n\n  drawJoint = (joint: Joint, options: Options) => {\n    const lw = options.lineWidth;\n    const ratio = options.ratio;\n\n    const length = 10;\n\n    const texture = Stage.canvas(function (ctx) {\n      // @ts-ignore\n      this.size(length + 2 * lw, 2 * lw, ratio);\n\n      ctx.scale(ratio, ratio);\n      ctx.beginPath();\n      ctx.moveTo(lw, lw);\n      ctx.lineTo(lw + length, lw);\n\n      ctx.lineCap = 'round';\n      ctx.lineWidth = options.lineWidth;\n      ctx.strokeStyle = options.stroke ?? '';\n      ctx.stroke();\n    });\n\n    const image = Stage.sprite(texture).stretch();\n    return image;\n  }\n\n  drawCircle = (shape: CircleShape, options: Options) => {\n    const lw = options.lineWidth;\n    const ratio = options.ratio;\n\n    const r = shape.m_radius;\n    const cx = r + lw;\n    const cy = r + lw;\n    const w = r * 2 + lw * 2;\n    const h = r * 2 + lw * 2;\n\n    const texture = Stage.canvas(function (ctx) {\n      // @ts-ignore\n      this.size(w, h, ratio);\n\n      ctx.scale(ratio, ratio);\n      ctx.arc(cx, cy, r, 0, 2 * Math.PI);\n      if (options.fill) {\n        ctx.fillStyle = options.fill;\n        ctx.fill();\n      }\n      ctx.lineTo(cx, cy);\n      ctx.lineWidth = options.lineWidth;\n      ctx.strokeStyle = options.stroke ?? '';\n      ctx.stroke();\n    });\n    const image = Stage.sprite(texture)\n      .offset(shape.m_p.x - cx, options.scaleY * shape.m_p.y - cy);\n    const node = Stage.create().append(image);\n    return node;\n  }\n\n  drawEdge = (edge: EdgeShape, options: Options) => {\n    const lw = options.lineWidth;\n    const ratio = options.ratio;\n\n    const v1 = edge.m_vertex1;\n    const v2 = edge.m_vertex2;\n\n    const dx = v2.x - v1.x;\n    const dy = v2.y - v1.y;\n\n    const length = Math.sqrt(dx * dx + dy * dy);\n\n    const texture = Stage.canvas(function (ctx) {\n      // @ts-ignore\n      this.size(length + 2 * lw, 2 * lw, ratio);\n\n      ctx.scale(ratio, ratio);\n      ctx.beginPath();\n      ctx.moveTo(lw, lw);\n      ctx.lineTo(lw + length, lw);\n\n      ctx.lineCap = 'round';\n      ctx.lineWidth = options.lineWidth;\n      ctx.strokeStyle = options.stroke ?? '';\n      ctx.stroke();\n    });\n\n    const minX = Math.min(v1.x, v2.x);\n    const minY = Math.min(options.scaleY * v1.y, options.scaleY * v2.y);\n\n    const image = Stage.sprite(texture);\n    image.rotate(options.scaleY * Math.atan2(dy, dx));\n    image.offset(minX - lw, minY - lw);\n    const node = Stage.create().append(image);\n    return node;\n  }\n\n  drawPolygon = (shape: PolygonShape, options: Options) => {\n    const lw = options.lineWidth;\n    const ratio = options.ratio;\n\n    const vertices = shape.m_vertices;\n\n    if (!vertices.length) {\n      return;\n    }\n\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n    for (let i = 0; i < vertices.length; ++i) {\n      const v = vertices[i];\n      minX = Math.min(minX, v.x);\n      maxX = Math.max(maxX, v.x);\n      minY = Math.min(minY, options.scaleY * v.y);\n      maxY = Math.max(maxY, options.scaleY * v.y);\n    }\n\n    const width = maxX - minX;\n    const height = maxY - minY;\n\n    const texture = Stage.canvas(function (ctx: CanvasRenderingContext2D) {\n      // @ts-ignore\n      this.size(width + 2 * lw, height + 2 * lw, ratio);\n\n      ctx.scale(ratio, ratio);\n      ctx.beginPath();\n      for (let i = 0; i < vertices.length; ++i) {\n        const v = vertices[i];\n        const x = v.x - minX + lw;\n        const y = options.scaleY * v.y - minY + lw;\n        if (i == 0)\n          ctx.moveTo(x, y);\n\n        else\n          ctx.lineTo(x, y);\n      }\n\n      if (vertices.length > 2) {\n        ctx.closePath();\n      }\n\n      if (options.fill) {\n        ctx.fillStyle = options.fill;\n        ctx.fill();\n        ctx.closePath();\n      }\n\n      ctx.lineCap = 'round';\n      ctx.lineWidth = options.lineWidth;\n      ctx.strokeStyle = options.stroke ?? '';\n      ctx.stroke();\n    });\n\n    const image = Stage.sprite(texture);\n    image.offset(minX - lw, minY - lw);\n    const node = Stage.create().append(image);\n    return node;\n  }\n\n  drawChain = (shape: ChainShape, options: Options) => {\n    const lw = options.lineWidth;\n    const ratio = options.ratio;\n\n    const vertices = shape.m_vertices;\n\n    if (!vertices.length) {\n      return;\n    }\n\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n    for (let i = 0; i < vertices.length; ++i) {\n      const v = vertices[i];\n      minX = Math.min(minX, v.x);\n      maxX = Math.max(maxX, v.x);\n      minY = Math.min(minY, options.scaleY * v.y);\n      maxY = Math.max(maxY, options.scaleY * v.y);\n    }\n\n    const width = maxX - minX;\n    const height = maxY - minY;\n\n    const texture = Stage.canvas(function (ctx) {\n      // @ts-ignore\n      this.size(width + 2 * lw, height + 2 * lw, ratio);\n\n      ctx.scale(ratio, ratio);\n      ctx.beginPath();\n      for (let i = 0; i < vertices.length; ++i) {\n        const v = vertices[i];\n        const x = v.x - minX + lw;\n        const y = options.scaleY * v.y - minY + lw;\n        if (i == 0)\n          ctx.moveTo(x, y);\n\n        else\n          ctx.lineTo(x, y);\n      }\n\n      // TODO: if loop\n      if (vertices.length > 2) {\n        // ctx.closePath();\n      }\n\n      if (options.fill) {\n        ctx.fillStyle = options.fill;\n        ctx.fill();\n        ctx.closePath();\n      }\n\n      ctx.lineCap = 'round';\n      ctx.lineWidth = options.lineWidth;\n      ctx.strokeStyle = options.stroke ?? '';\n      ctx.stroke();\n    });\n\n    const image = Stage.sprite(texture);\n    image.offset(minX - lw, minY - lw);\n    const node = Stage.create().append(image);\n    return node;\n  }\n}\n\nconst tb = new Testbed();\n\ntype TestbedOptions = string | Record<string, any>;\n\n/** @deprecated */\ntype TestbedCallback = (testbed?: Testbed) => (World | undefined);\n\n/** @deprecated */\nexport function testbed(callback: TestbedCallback): void;\n/** @deprecated */\nexport function testbed(options: TestbedOptions, callback: TestbedCallback): void;\nexport function testbed(options?: TestbedOptions): Testbed;\nexport function testbed(a?: any, b?: any) {\n  let callback: TestbedCallback | undefined;\n  let options;\n  if (typeof a === 'function') {\n    callback = a;\n    options = b;\n  } else if (typeof b === 'function') {\n    callback = b;\n    options = a;\n  } else {\n    options = a ?? b;\n  }\n  if (callback) {\n    // this is for backwards compatibility\n    const world = callback(tb);\n    tb.start(world);\n  } else {\n    return tb;\n  }\n}\n"],"names":["__defProp","Object","defineProperty","__publicField","obj","key","value","enumerable","configurable","writable","__defNormalProp","stats","create","tick","node","draw","fps","Matrix","[object Object]","a","b","c","d","e","f","this","reset","_dirty","angle","u","Math","cos","v","sin","x","y","m","n","inverted","z","p","q","iid$1","Pin","owner","_owner","_parent","_relativeMatrix","_absoluteMatrix","prototype","_textureAlpha","_alpha","_width","_height","_scaleX","_scaleY","_skewX","_skewY","_rotation","_pivoted","_pivotX","_pivotY","_handled","_handleX","_handleY","_aligned","_alignX","_alignY","_offsetX","_offsetY","_boxX","_boxY","_boxWidth","_boxHeight","_ts_translate","_ts_transform","_ts_matrix","_update","_pin","_mo_handle","_mo_align","toString","absoluteMatrix","ts","max","_mo_abs","abs2","relativeMatrix","concat","_mo_rel","rel2","identity","translate","scale","skew","rotate","_x","_y","get","getters","set","setters","_ts_pin","touch","alpha","pin","textureAlpha","width","height","boxWidth","boxHeight","scaleX","scaleY","skewX","skewY","rotation","pivotX","pivotY","offsetX","offsetY","alignX","alignY","handleX","handleY","_width_","_height_","pivot","offset","align","handle","resizeMode","all","scaleTo","resizeWidth","resizeHeight","scaleMode","scaleWidth","scaleHeight","matrix","mode","w","h","min","_add_shortcuts","size","ta","iid","assertType","Node","append","parent","child","remove","_last","_next","_prev","_first","_flag","_ts_parent","_ts_children","prepend","insertBefore","self","next","prev","insertAfter","relative","_label","_visible","_attrs","_flags","id","label","attr","name","visible","hide","show","first","last","visit","visitor","data","reverse","start","end","more","Array","isArray","i","length","arguments","appendTo","prependTo","insertNext","sibling","insertPrev","empty","_ts_touch","type","hitTest","hit","_textures","render","context","setTransform","globalAlpha","_tickBefore","_tickAfter","MAX_ELAPSE","Infinity","_tick","elapsed","now","ticked","call","ticker","before","push","untick","indexOf","splice","timeout","fn","time","setTimeout","timer","t","clearTimeout","_listeners","_event_callback","on","types","listener","join","match","off","index","listeners","publish","args","l","apply","trigger","native","math","random","math$1","wrap","num","clamp","sqrt","limit","isFn","str","isHash","constructor","Texture","texture2","ratio","src","drawable","_image","_sx","_dx","_sy","_dy","_sw","_dw","_sh","_dh","x1","y1","x2","y2","x3","y3","x4","y4","sx","sy","sw","sh","dx","dy","dw","dh","drawImage","ex","_draw_failed","console","log","NO_TEXTURE","super","NO_SELECTION","Selection","_atlases_map","_atlases_arr","Atlas","def","atlas2","deprecated","map","filter","ppu","trim","textures","factory","cutouts","sprites","make","def2","assign","top","bottom","left","right","pipe","find","query","result","string","startsWith","subquery","select","found","link","result2","one","array","arr","texture","slice","error","hash","msg","replace","M","Mouse","event","preventDefault","locate","lookup","clicklist","cancellist","elem","touches","clientX","clientY","rect","getBoundingClientRect","clientLeft","clientTop","collect","root","stage","visitStart","visitEnd","targets","timeStamp","Date","shift","rel","raw","abs","inverse","cancel","viewport","addEventListener","handleStart","handleEnd","handleMove","handleCancel","document","window","removeEventListener","defineValue","IDENTITY","_cache","_modes","_easings","Easing","token","fallback","exec","easing","params","fc","split","names","add","PI","pow","s","asin","tween","options","duration","delay","_tweens","ticktime","ignore","head","finish","unshift","Tween","_end","_duration","_delay","_time","_start","ended","_easing","_ending","forEach","callback","_hide","_remove","pinning","done","forward","_stages","Root","configs","canvas","getElementById","HTMLCanvasElement","createElement","style","position","display","body","firstChild","dom","getContext","devicePixelRatio","backingStoreRatio","webkitBackingStorePixelRatio","mozBackingStorePixelRatio","msBackingStorePixelRatio","oBackingStorePixelRatio","backingStorePixelRatio","pixelRatio","mounted","requestFrame","onFrame","frameRequested","requestAnimationFrame","newPixelWidth","clientWidth","newPixelHeight","clientHeight","pixelWidth","pixelHeight","drawingWidth","drawingHeight","lastTime","paused","sleep","tickRequest","_mo_touch","clearRect","_a","mouse","unmount","color","backgroundColor","_viewport","viewbox","_viewbox","rescale","_camera","camera","viewportWidth","viewportHeight","viewboxMode","test","viewboxWidth","viewboxHeight","viewboxX","viewboxY","cameraZoom","cameraX","cameraY","sprite","frame","sprite2","Sprite","_super","tile","inner","_repeat","stretch","insert","repeat2","dest","_repeatTicker","_mo_stretch","img","owidth","oheight","r","repeat","image","Image$1","Anim","_fps","_ft","_index","_frames","moveFrame","stop","_callback","setFrames","frames","gotoFrame","resize","move","play","Str","setFont","_item","setValue","_value","_spacing","row","column","_padding","_layoutTiker","_mo_seq","alignChildren","_mo_seqAlign","box","_mo_box","layer","padding","pad","spacing","space","Stage$1","freeze","__proto__","Image","anim","anim2","atlas","async","url","imagePath","imageRatio","image2","Promise","resolve","reject","onload","onerror","attributes","plotter","canvas2","memoizeDraw","memoKey","PIXEL_RATIO","lastSelection","lastRatio","Stage","newRatio","rationChange","newSelection","__timestamp","mount","pause","resume","Symbol","toStringTag","input","defaults","output","hasOwnProperty","getOwnPropertySymbols","symbols","symbol","propertyIsEnumerable","EPSILON","isFinite","isNaN","assert","nextPowerOfTwo","isPowerOfTwo","mod","Vec2","neo","JSON","stringify","o","clone","setCombine","setMul","addCombine","addMul","subCombine","subMul","lengthOf","lengthSquared","invLength","combine","mulNumVec2","zero","lengthSqr","AABB","lower","upper","lowerBound","upperBound","setVec2","isValid","sub","lowerA","upperA","lowerB","upperB","lowerX","lowerY","upperX","upperY","setNum","aabb","extend","out","d1x","d2x","d1y","d2y","areEqual","wD","hD","tmin","tmax","p1","p2","absD","normal","inv_d","t1","t2","temp","setZero","maxFraction","fraction","lx","ly","Settings","polygonRadius","linearSlop","lengthUnitsPerMeter","maxManifoldPoints","maxPolygonVertices","aabbExtension","aabbMultiplier","angularSlop","maxSubSteps","maxTOIContacts","maxTOIIterations","maxDistnceIterations","velocityThreshold","maxLinearCorrection","maxAngularCorrection","maxTranslation","maxRotation","baumgarte","toiBaugarte","timeToSleep","linearSleepTolerance","angularSleepTolerance","SettingsInternal","linearSlopSquared","maxTranslationSquared","maxRotationSquared","linearSleepToleranceSqr","angularSleepToleranceSqr","Pool","opts","_list","_max","_hasCreateFn","_createCount","_hasAllocateFn","_allocateCount","_hasReleaseFn","_releaseCount","_hasDisposeFn","_disposeCount","_createFn","_allocateFn","allocate","_releaseFn","release","_disposeFn","dispose","item","TreeNode","userData","child1","child2","poolTreeNode","undefined","DynamicTree","inputPool","stack","stackPool","iteratorPool","Iterator","iterator","close","m_root","m_nodes","m_lastProxyId","allocateNode","insertLeaf","removeLeaf","freeNode","contains","leaf","leafAABB","isLeaf","area","getPerimeter","combinedArea","combinedPerimeter","cost","inheritanceCost","cost1","cost2","oldParent","newParent","balance","grandParent","iA","A","B","C","F","G","D","E","rootArea","totalArea","it","preorder","height1","computeHeight","height2","validateStructure","validateMetrics","maxBalance","nodes","count","minCost","iMin","jMin","aabbi","j","aabbj","newOrigin","queryCallback","pop","testOverlap","rayCastCallback","normalize","crossNumVec2","abs_v","segmentAABB","combinePoints","subInput","getCenter","getExtents","dot","parents","states","BroadPhase","m_tree","m_moveBuffer","proxyId","m_queryProxyId","proxyIdA","proxyIdB","userDataA","getUserData","userDataB","m_callback","aabbA","getFatAABB","aabbB","getHeight","getMaxBalance","getAreaRatio","rayCast","shiftOrigin","createProxy","bufferMove","unbufferMove","destroyProxy","displacement","moveProxy","addPairCallback","fatAABB","vec2","copyVec2","zeroVec2","negVec2","addVec2","subVec2","diffVec2","scaleVec2","setMulVec2","addMulVec2","subMulVec2","combineVec2","am","bm","normalizeVec2","crossVec2Num","crossVec2Vec2","dotVec2","lengthSqrVec2","distVec2","distSqrVec2","rotVec2","invRotVec2","transform","copyTransform","transformVec2","xf","invTransformVec2","px","py","retransformVec2","from","to","x0","y0","invTransformTransform","Rot","setAngle","setRot","setIdentity","rot","atan2","qr","matrix.vec2","Sweep","localCenter","alpha0","c0","a0","matrix.zeroVec2","matrix.transformVec2","matrix.copyVec2","beta","matrix.setRotAngle","matrix.combineVec2","matrix.subVec2","matrix.rotVec2","that","Transform","mul","mulVec2","mulXf","mulRot","mulTVec2","mulTXf","mulTRot","Velocity","Position","getTransform","Shape","m_type","m_radius","synchronize_aabb1","synchronize_aabb2","FixtureDefDefault","friction","restitution","density","isSensor","filterGroupIndex","filterCategoryBits","filterMaskBits","FixtureProxy","fixture","childIndex","Fixture","shape","m_body","m_friction","m_restitution","m_density","m_isSensor","m_filterGroupIndex","m_filterCategoryBits","m_filterMaskBits","m_shape","m_next","m_proxies","childCount","getChildCount","m_userData","getBody","broadPhase","m_world","m_broadPhase","destroyProxies","_reset","createProxies","m_xf","resetMassData","restore","sensor","setAwake","testPoint","massData","computeMass","proxy","computeAABB","xf1","xf2","matrix.diffVec2","groupIndex","categoryBits","maskBits","refilter","edge","getContactList","contact","fixtureA","getFixtureA","fixtureB","getFixtureB","flagForFiltering","world","getWorld","touchProxy","collideA","collideB","STATIC","KINEMATIC","DYNAMIC","oldCenter","matrix.transform","BodyDefDefault","linearVelocity","angularVelocity","linearDamping","angularDamping","fixedRotation","bullet","gravityScale","allowSleep","awake","active","MassData","mass","center","I","Body","m_awakeFlag","m_autoSleepFlag","m_bulletFlag","m_fixedRotationFlag","m_activeFlag","m_islandFlag","m_toiFlag","m_mass","m_invMass","m_I","m_invI","m_sweep","c_velocity","c_position","m_force","m_torque","m_linearVelocity","m_angularVelocity","m_linearDamping","m_angularDamping","m_gravityScale","m_sleepTime","m_jointList","m_contactList","m_fixtureList","m_prev","m_destroyed","fixtures","getAngle","_addFixture","isLocked","setType","isWorldLocked","synchronizeFixtures","ce","ce0","destroyContact","flag","synchronize","advance","worldPoint","localPoint","getLinearVelocityFromWorldPoint","getWorldPoint","getInertia","isStatic","isKinematic","getMassData","matrix.addMulVec2","matrix.setMulVec2","matrix.dotVec2","setLocalCenter","matrix.crossNumVec2","force","point","wake","torque","impulse","jn","other","joint","m_collideConnected","m_newFixture","fixdef","localVector","worldVector","JointEdge","Joint","bodyA","bodyB","m_edgeA","m_edgeB","m_bodyA","m_bodyB","collideConnected","isActive","gjkCalls","gjkIters","gjkMaxIters","toiTime","toiMaxTime","toiCalls","toiIters","toiMaxIters","toiRootIters","toiMaxRootIters","newline","Timer","e12","e13","e23","temp1","temp2","DistanceInput","proxyA","DistanceProxy","proxyB","transformA","transformB","useRadii","recycle","DistanceOutput","pointA","pointB","distance","iterations","SimplexCache","metric","indexA","indexB","Distance","cache","xfA","xfB","simplex","readCache","vertices","m_v","k_maxIters","saveA","saveB","saveCount","iter","m_count","solve","getSearchDirection","matrix.lengthSqrVec2","vertex","getSupport","matrix.invRotVec2","wA","getVertex","wB","duplicate","getWitnessPoints","matrix.distVec2","writeCache","rA","rB","matrix.normalizeVec2","matrix.subMulVec2","m_vertices","bestIndex","bestValue","computeDistanceProxy","radius","SimplexVertex","searchDirection_reuse","closestPoint_reuse","Simplex","m_v1","m_v2","m_v3","wALocal","wBLocal","metric1","metric2","getMetric","v1","v2","matrix.setVec2","matrix.crossVec2Vec2","pA","pB","v3","solve2","solve3","w1","w2","d12_2","d12_1","inv_d12","w3","w1e12","w1e13","d13_1","d13_2","w2e23","d23_1","d23_2","n123","d123_1","d123_2","d123_3","inv_d13","inv_d23","inv_d123","shapeA","shapeB","matrix.copyTransform","Input","Output","Proxy","Cache","ShapeCastInput","translationB","ShapeCastOutput","lambda","ShapeCast","radiusA","neg","sigma","tolerance","vp","vr","getClosestPoint","TOIInput","sweepA","sweepB","tMax","TOIOutputState","exports","TOIOutput","state","e_unset","distanceInput","distanceOutput","axisA","axisB","localPointA","localPointB","TimeOfImpact","e_unknown","totalRadius","target","k_maxIterations","setVertices","e_overlapped","e_touching","separationFunction","initialize","pushBackIter","s2","findMinSeparation","e_separated","s1","evaluate","e_failed","rootIterCount","a1","a2","SeparationFunctionType","m_proxyA","m_proxyB","m_sweepA","m_sweepB","m_localPoint","m_axis","e_points","matrix.normalizeVec2Length","e_faceB","localPointB1","localPointB2","matrix.crossVec2Num","matrix.negVec2","e_faceA","localPointA1","localPointA2","compute","TimeStep","dt","inv_dt","velocityIterations","positionIterations","warmStarting","blockSolve","inv_dt0","dtRatio","s_subStep","translation","backup","backup1","backup2","ContactImpulse","normals","tangents","normalImpulses","v_points","normalImpulse","tangentImpulses","tangentImpulse","Solver","m_stack","m_bodies","m_contacts","m_joints","step","m_bodyList","seed","isAwake","clear","addBody","isEnabled","isTouching","sensorA","m_fixtureA","sensorB","m_fixtureB","addContact","je","addJoint","solveIsland","gravity","m_gravity","m_allowSleep","isDynamic","initConstraint","initVelocityConstraint","warmStartConstraint","initVelocityConstraints","solveVelocityConstraints","solveVelocityConstraint","storeConstraintImpulses","translationLengthSqr","matrix.scaleVec2","positionSolved","minSeparation","separation","solvePositionConstraint","contactsOkay","jointsOkay","jointOkay","solvePositionConstraints","synchronizeTransform","postSolveIsland","minSleepTime","linTolSqr","angTolSqr","m_stepComplete","m_toiCount","m_toi","minContact","minAlpha","fA","fB","bA","bB","activeA","activeB","isBullet","getChildIndexA","getChildIndexB","getShape","update","setEnabled","bodies","solveIslandTOI","findNewContacts","m_subStepping","subStep","toiA","toiB","solvePositionConstraintTOI","postSolve","m_impulse","Mat22","ey","det","imx","mx","c1","c2","mx1","mx2","cA","cB","dist","planePoint","clipPoint","ManifoldType","ContactFeatureType","PointState","ClipVertex","ContactID","Manifold","localNormal","points","ManifoldPoint","pointCount","wm","radiusB","WorldManifold","separations","e_circles","manifoldPoint","clipSegmentToLine","getPointStates","typeA","typeB","state1","state2","manifold1","manifold2","removeState","persistState","addState","vOut","vIn","vertexIndexA","numOut","distance0","distance1","interp","setFeatures","e_vertex","e_face","contactPool","Contact","oldManifold","worldManifold","ContactEdge","mixFriction","friction1","friction2","mixRestitution","restitution1","restitution2","s_registers","VelocityConstraintPoint","normalMass","tangentMass","velocityBias","vA","vB","tangent","P","dv","dv1","dv2","P1","P2","m_nodeA","m_nodeB","m_indexA","m_indexB","m_evaluateFcn","m_manifold","m_tangentSpeed","m_enabledFlag","m_touchingFlag","m_filterFlag","m_bulletHitFlag","v_normal","v_normalMass","v_K","v_pointCount","v_tangentSpeed","v_friction","v_restitution","v_invMassA","v_invMassB","v_invIA","v_invIB","p_localPoints","p_localNormal","p_localPoint","p_localCenterA","p_localCenterB","p_type","p_radiusA","p_radiusB","p_pointCount","p_invMassA","p_invMassB","p_invIA","p_invIB","evaluateFcn","manifold","cp","vcp","getWorldManifold","speed","touching","wasTouching","nmp","omp","hasListener","beginContact","endContact","preSolve","_solvePositionConstraint","toi","positionA","positionB","localCenterA","localCenterB","mA","mB","iB","aA","aB","rnA","rnB","K","velocityA","velocityB","wmp","kNormal","rtA","rtB","kTangent","vRel","vcp1","vcp2","rn1A","rn1B","rn2A","rn2B","k11","k22","k12","matrix.addVec2","vt","maxFriction","newImpulse","vn","vn1","vn2","type1","type2","WorldDefDefault","continuousPhysics","subStepping","World","s_step","m_solver","m_contactCount","m_bodyCount","m_jointCount","m_clearForces","m_locked","m_warmStarting","m_continuousPhysics","m_blockSolve","m_velocityIterations","m_positionIterations","m_t","joints","getBodyList","getNext","getJointList","_serialize","_addBody","createJoint","point1","point2","getProxyCount","getTreeHeight","getTreeBalance","getTreeQuality","arg1","arg2","createBody","je0","destroyJoint","f0","timeStep","updateContacts","solveWorld","solveWorldTOI","clearForces","updatePairs","createContact","shouldCollide","next_c","destroy","arg3","Vec3","EdgeShape","TYPE","m_vertex1","m_vertex2","m_vertex0","m_vertex3","m_hasVertex0","m_hasVertex3","vertex1","vertex2","vertex0","vertex3","hasVertex0","hasVertex3","setPrevVertex","setNextVertex","numerator","denominator","rr","Edge","ChainShape","loop","m_prevVertex","m_nextVertex","m_hasPrevVertex","m_hasNextVertex","m_isLoop","_createLoop","_createChain","isLoop","hasPrevVertex","hasNextVertex","prevVertex","nextVertex","Chain","e1","e2","PolygonShape","m_centroid","m_normals","_set","_setAsBox","ps","unique","distanceSquared","i0","hull","ih","ie","i1","i2","vs","pRef","inv3","p3","triangleArea","ComputeCentroid","hx","hy","pLocal","matrix.invTransformVec2","minX","minY","maxX","maxY","k_inv3","ex1","ey1","ex2","ey2","matrix.sumVec2","Polygon","BoxShape","Box","CircleShape","m_p","matrix.distSqrVec2","Circle","DEFAULTS","frequencyHz","dampingRatio","DistanceJoint","anchorA","anchorB","m_localAnchorA","getLocalPoint","localAnchorA","m_localAnchorB","localAnchorB","m_length","m_frequencyHz","m_dampingRatio","m_gamma","m_bias","gamma","bias","hz","m_u","m_localCenterA","m_localCenterB","m_invMassA","m_invMassB","m_invIA","m_invIB","qA","qB","m_rA","m_rB","crAu","crBu","invMass","omega","k","vpA","vpB","Cdot","mulSub","maxForce","maxTorque","FrictionJoint","anchor","m_linearImpulse","m_angularImpulse","m_maxForce","m_maxTorque","m_linearMass","getInverse","m_angularMass","oldImpulse","maxImpulse","Mat33","ez","cross_x","cross_y","cross_z","a11","a12","a21","a22","cross","a13","a23","a33","lowerAngle","upperAngle","maxMotorTorque","motorSpeed","enableLimit","enableMotor","RevoluteJoint","m_limitState","m_referenceAngle","referenceAngle","m_motorImpulse","m_lowerAngle","m_upperAngle","m_maxMotorTorque","m_motorSpeed","m_enableLimit","m_enableMotor","m_motorMass","jointAngle","Cdot1","Cdot2","solve33","rhs","reduced","solve22","angularError","positionError","limitImpulse","lowerTranslation","upperTranslation","maxMotorForce","PrismaticJoint","axis","m_localXAxisA","getLocalVector","localAxisA","m_localYAxisA","m_lowerTranslation","m_upperTranslation","m_maxMotorForce","m_perp","m_K","getWorldVector","addCrossNumVec2","m_a1","m_a2","m_s1","m_s2","k13","k23","k33","jointTranslation","LA","LB","f1","df","f2r","perp","C1","linearError","C2","impulse1","GearJoint","joint1","joint2","coordinateA","coordinateB","m_joint1","m_joint2","m_ratio","m_type1","getType","m_type2","m_bodyC","getBodyA","getBodyB","xfC","aC","revolute","m_localAnchorC","m_referenceAngleA","m_localAxisC","prismatic","pC","m_bodyD","xfD","aD","m_localAnchorD","m_referenceAngleB","m_localAxisD","pD","m_constant","m_JvAC","m_JwA","m_lcA","m_lcB","m_lcC","m_lcD","m_mA","m_mB","m_mC","m_mD","m_iA","m_iB","m_iC","m_iD","vC","wC","vD","qC","qD","m_JwC","rC","m_JvBD","m_JwB","m_JwD","rD","cC","cD","JvAC","JvBD","JwA","JwB","JwC","JwD","correctionFactor","MotorJoint","m_linearOffset","linearOffset","getPosition","m_angularOffset","angularOffset","m_correctionFactor","factor","m_linearError","m_angularError","inv_h","MouseJoint","m_targetA","m_beta","m_C","_localAnchorB","velocity","getMass","PulleyJoint","groundA","groundB","m_groundAnchorA","groundAnchorA","m_groundAnchorB","groundAnchorB","m_lengthA","lengthA","m_lengthB","lengthB","m_uB","m_uA","ruA","ruB","PA","PB","uA","uB","maxLength","RopeJoint","m_maxLength","m_state","crA","crB","WeldJoint","getInverse22","invM","getSymInverse33","impulse2","mulVec3","WheelJoint","m_ax","m_ay","localAxis","m_springMass","m_springImpulse","m_sAy","m_sBy","m_sAx","m_sBx","damp","ay","sAy","sBy","SID","Serializer","rootClass","preSerialize","postSerialize","preDeserialize","postDeserialize","refTypes","restoreTypes","CLASS_BY_TYPE_PROP","toJson","json","queue","refMap","storeRef","typeName","__sid","ref","refIndex","refType","serialize","newValue","fromJson","deserialize","cls","ctx","deserializer","_deserialize","findDeserilizer","restoreRef","serializer","addType","CollideCircles","circleA","circleB","distSqr","CollideEdgeCircle","chain","getChildEdge","Q","edgeA","matrix.retransformVec2","A1","B1","B2","A2","den","incidentEdge","clipPoints1","clipPoints2","clipSegmentToLineNormal","v11","v12","localTangent","normal1","findMaxSeparation","poly1","poly2","count1","count2","n1s","v1s","v2s","matrix.invTransformTransform","maxSeparation","si","sij","CollidePolygons","polyA","polyB","separationA","separationB","edge1","flip","clipVertex","normals1","vertices2","normals2","after","matrix.rerotVec2","minDot","findIncidentEdge","vertices1","iv1","iv2","frontOffset","sideOffset1","sideOffset2","swapFeatures","CollidePolygonCircle","cLocal","faceCenter","polygonA","normalIndex","vertexCount","vertIndex1","vertIndex2","u1","u2","CollideEdgePolygon","edge_reuse","EPAxisType","VertexType","EPAxis","edgeAxis","polygonAxis","polygonBA","rf","sideNormal1","sideNormal2","centroidB","edge0","edge2","normal0","normal2","lowerLimit","upperLimit","polygonB","v0","offset1","front","offset0","offset2","convex1","convex2","e_edgeA","e_edgeB","primaryAxis","internal","getStyle","_b","Testbed","background","activeKeys","keydown","keyCode","keyup","lastDrawHash","newDrawHash","buffer","testbed","START","focus","activeElement","blur","_resume","_pause","drawingTexture","save","lineWidth","lineCap","drawing","worldNode","PlanckStageNode","lastX","lastY","targetBody","drawSegment","mouseMove","mouseGround","mouseJoint","queryAABB","findBody","mouseForce","MOVE","setTarget","END","applyForceToCenter","CANCEL","charCodeAt","togglePause","downKeys","updateActiveKeys","down","char","String","fromCharCode","up","fire","_status","_info","text","isPaused","statusText","statusMap","info","drawPoint","beginPath","arc","strokeStyle","stroke","drawCircle","drawEdge","moveTo","lineTo","drawPolygon","closePath","drawAABB","g","findOne","findAll","statusSet","WeakMap","fill","renderWorld","viewer","getFixtureList","fstyle","bstyle","drawChain","__lastX","__lastY","__lastR","getAnchorA","getAnchorB","drawJoint","cx","cy","lw","fillStyle","_c","_d","elapsedTime","errored","tb"],"mappings":"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"}