{"version":3,"file":"planck.min.js","sources":["../src/util/options.ts","../src/common/Math.ts","../src/common/Vec2.ts","../src/collision/AABB.ts","../src/Settings.ts","../src/util/Pool.ts","../src/collision/DynamicTree.ts","../src/collision/BroadPhase.ts","../src/common/Matrix.ts","../src/common/Rot.ts","../src/common/Sweep.ts","../src/common/Transform.ts","../src/dynamics/Velocity.ts","../src/dynamics/Position.ts","../src/collision/Shape.ts","../src/dynamics/Fixture.ts","../src/dynamics/Body.ts","../src/dynamics/Joint.ts","../src/util/stats.ts","../src/util/Timer.ts","../src/collision/Distance.ts","../src/collision/TimeOfImpact.ts","../src/dynamics/Solver.ts","../src/common/Mat22.ts","../src/collision/Manifold.ts","../src/dynamics/Contact.ts","../src/dynamics/World.ts","../src/common/Vec3.ts","../src/collision/shape/EdgeShape.ts","../src/collision/shape/ChainShape.ts","../src/collision/shape/PolygonShape.ts","../src/collision/shape/BoxShape.ts","../src/collision/shape/CircleShape.ts","../src/dynamics/joint/DistanceJoint.ts","../src/dynamics/joint/FrictionJoint.ts","../src/common/Mat33.ts","../src/dynamics/joint/RevoluteJoint.ts","../src/dynamics/joint/PrismaticJoint.ts","../src/dynamics/joint/GearJoint.ts","../src/dynamics/joint/MotorJoint.ts","../src/dynamics/joint/MouseJoint.ts","../src/dynamics/joint/PulleyJoint.ts","../src/dynamics/joint/RopeJoint.ts","../src/dynamics/joint/WeldJoint.ts","../src/dynamics/joint/WheelJoint.ts","../src/serializer/index.ts","../src/collision/shape/CollideCircle.ts","../src/collision/shape/CollideEdgeCircle.ts","../src/collision/shape/CollidePolygon.ts","../src/collision/shape/CollideCirclePolygon.ts","../src/collision/shape/CollideEdgePolygon.ts","../src/index.ts"],"sourcesContent":["export const options = function<T>(input: T, defaults: object): T {\n  if (input === null || typeof input === 'undefined') {\n    // tslint:disable-next-line:no-object-literal-type-assertion\n    input = {} as T;\n  }\n\n  const output = {...input};\n\n  // tslint:disable-next-line:no-for-in\n  for (const key in defaults) {\n    if (defaults.hasOwnProperty(key) && typeof input[key] === 'undefined') {\n      output[key] = defaults[key];\n    }\n  }\n\n  if (typeof Object.getOwnPropertySymbols === 'function') {\n    const symbols = Object.getOwnPropertySymbols(defaults);\n    for (let i = 0; i < symbols.length; i++) {\n      const symbol = symbols[i];\n      if (defaults.propertyIsEnumerable(symbol) && typeof input[symbol] === 'undefined') {\n        output[symbol] = defaults[symbol];\n      }\n    }\n  }\n\n  return output;\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\nexport const math = Object.assign(Object.create(Math) as typeof Math, {\n  EPSILON: 1e-9, // TODO\n\n  /**\n   * This function is used to ensure that a floating point number is not a NaN or\n   * infinity.\n   */\n  isFinite: function(x: unknown): boolean {\n    return (typeof x === 'number') && isFinite(x) && !isNaN(x);\n  },\n\n  assert: function(x: any): void {\n    _ASSERT && console.assert(!math.isFinite(x), 'Invalid Number!', x);\n  },\n\n  /**\n   * Next Largest Power of 2 Given a binary integer value x, the next largest\n   * power of 2 can be computed by a SWAR algorithm that recursively \"folds\" the\n   * upper bits into the lower bits. This process yields a bit vector with the\n   * same most significant 1 as x, but all 1's below it. Adding 1 to that value\n   * yields the next largest power of 2. For a 32-bit value:\n   */\n  nextPowerOfTwo: function(x: number): number {\n    // TODO\n    x |= (x >> 1);\n    x |= (x >> 2);\n    x |= (x >> 4);\n    x |= (x >> 8);\n    x |= (x >> 16);\n    return x + 1;\n  },\n\n  isPowerOfTwo: function(x: number): boolean {\n    return x > 0 && (x & (x - 1)) === 0;\n  },\n\n  mod: function(num: number, min?: number, max?: number): number {\n    if (typeof min === 'undefined') {\n      max = 1;\n      min = 0;\n    } else if (typeof max === 'undefined') {\n      max = min;\n      min = 0;\n    }\n    if (max > min) {\n      num = (num - min) % (max - min);\n      return num + (num < 0 ? max : min);\n    } else {\n      num = (num - max) % (min - max);\n      return num + (num <= 0 ? min : max);\n    }\n  },\n  /**\n   * Returns a min if num is less than min, and max if more than max, otherwise returns num.\n   */\n  clamp: function(num: number, min: number, max: number): number {\n    if (num < min) {\n      return min;\n    } else if (num > max) {\n      return max;\n    } else {\n      return num;\n    }\n  },\n  /**\n   * Returns a random number between min and max when two arguments are provided.\n   * If one arg is provided between 0 to max.\n   * If one arg is passed between 0 to 1.\n   */\n  random: function(min?: number, max?: number): number {\n    if (typeof min === 'undefined') {\n      max = 1;\n      min = 0;\n    } else if (typeof max === 'undefined') {\n      max = min;\n      min = 0;\n    }\n    return min === max ? min : Math.random() * (max - min) + min;\n  }\n});\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport * as matrix from './Matrix';\nimport { math as Math } from './Math';\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\nconst _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\nexport interface Vec2Value {\n  x: number;\n  y: number;\n}\n\nexport class Vec2 {\n  x: number;\n  y: number;\n\n  constructor(x: number, y: number);\n  constructor(obj: { x: number, y: number });\n  constructor();\n  // tslint:disable-next-line:typedef\n  constructor(x?, y?) {\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof Vec2)) {\n      return new Vec2(x, y);\n    }\n    if (typeof x === 'undefined') {\n      this.x = 0;\n      this.y = 0;\n    } else if (typeof x === 'object') {\n      this.x = x.x;\n      this.y = x.y;\n    } else {\n      this.x = x;\n      this.y = y;\n    }\n    _ASSERT && Vec2.assert(this);\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      x: this.x,\n      y: this.y\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any): Vec2 {\n    const obj = Object.create(Vec2.prototype);\n    obj.x = data.x;\n    obj.y = data.y;\n    return obj;\n  }\n\n  static zero(): Vec2 {\n    const obj = Object.create(Vec2.prototype);\n    obj.x = 0;\n    obj.y = 0;\n    return obj;\n  }\n\n  /** @internal */\n  static neo(x: number, y: number): Vec2 {\n    const obj = Object.create(Vec2.prototype);\n    obj.x = x;\n    obj.y = y;\n    return obj;\n  }\n\n  static clone(v: Vec2Value): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    return Vec2.neo(v.x, v.y);\n  }\n\n  /** @internal */\n  toString(): string {\n    return JSON.stringify(this);\n  }\n\n  /**\n   * Does this vector contain finite coordinates?\n   */\n  static isValid(obj: any): boolean {\n    if (obj === null || typeof obj === 'undefined') {\n      return false;\n    }\n    return Math.isFinite(obj.x) && Math.isFinite(obj.y);\n  }\n\n  static assert(o: any): void {\n    _ASSERT && console.assert(!Vec2.isValid(o), 'Invalid Vec2!', o);\n  }\n\n  clone(): Vec2 {\n    return Vec2.clone(this);\n  }\n\n  /**\n   * Set this vector to all zeros.\n   *\n   * @returns this\n   */\n  setZero(): Vec2 {\n    this.x = 0.0;\n    this.y = 0.0;\n    return this;\n  }\n\n  set(x: number, y: number): Vec2;\n  set(value: Vec2Value): Vec2;\n  /**\n   * Set this vector to some specified coordinates.\n   *\n   * @returns this\n   */\n  // tslint:disable-next-line:typedef\n  set(x, y?) {\n    if (typeof x === 'object') {\n      _ASSERT && Vec2.assert(x);\n      this.x = x.x;\n      this.y = x.y;\n    } else {\n      _ASSERT && Math.assert(x);\n      _ASSERT && Math.assert(y);\n      this.x = x;\n      this.y = y;\n    }\n    return this;\n  }\n\n  /**\n   * Set this vector to some specified coordinates.\n   *\n   * @returns this\n   */\n   setNum(x: number, y: number) {\n    _ASSERT && Math.assert(x);\n    _ASSERT && Math.assert(y);\n    this.x = x;\n    this.y = y;\n\n    return this;\n  }\n\n  /**\n   * Set this vector to some specified coordinates.\n   *\n   * @returns this\n   */\n  setVec2(value: Vec2Value) {\n    _ASSERT && Vec2.assert(value);\n    this.x = value.x;\n    this.y = value.y;\n\n    return this;\n  }\n\n  /**\n   * @internal\n   * @deprecated Use setCombine or setMul\n   */\n  wSet(a: number, v: Vec2Value, b?: number, w?: Vec2Value): Vec2 {\n    if (typeof b !== 'undefined' || typeof w !== 'undefined') {\n      return this.setCombine(a, v, b, w);\n    } else {\n      return this.setMul(a, v);\n    }\n  }\n\n  /**\n   * Set linear combination of v and w: `a * v + b * w`\n   */\n  setCombine(a: number, v: Vec2Value, b: number, w: Vec2Value): Vec2 {\n    _ASSERT && Math.assert(a);\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Math.assert(b);\n    _ASSERT && Vec2.assert(w);\n    const x = a * v.x + b * w.x;\n    const y = a * v.y + b * w.y;\n\n    // `this` may be `w`\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n\n  setMul(a: number, v: Vec2Value): Vec2 {\n    _ASSERT && Math.assert(a);\n    _ASSERT && Vec2.assert(v);\n    const x = a * v.x;\n    const y = a * v.y;\n\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n\n  /**\n   * Add a vector to this vector.\n   *\n   * @returns this\n   */\n  add(w: Vec2Value): Vec2 {\n    _ASSERT && Vec2.assert(w);\n    this.x += w.x;\n    this.y += w.y;\n    return this;\n  }\n\n  /**\n   * @internal\n   * @deprecated Use addCombine or addMul\n   */\n  wAdd(a: number, v: Vec2Value, b?: number, w?: Vec2Value): Vec2 {\n    if (typeof b !== 'undefined' || typeof w !== 'undefined') {\n      return this.addCombine(a, v, b, w);\n    } else {\n      return this.addMul(a, v);\n    }\n  }\n\n  /**\n   * Add linear combination of v and w: `a * v + b * w`\n   */\n  addCombine(a: number, v: Vec2Value, b: number, w: Vec2Value): Vec2 {\n    _ASSERT && Math.assert(a);\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Math.assert(b);\n    _ASSERT && Vec2.assert(w);\n\n    const x = a * v.x + b * w.x;\n    const y = a * v.y + b * w.y;\n\n    // `this` may be `w`\n    this.x += x;\n    this.y += y;\n    return this;\n  }\n\n  addMul(a: number, v: Vec2Value): Vec2 {\n    _ASSERT && Math.assert(a);\n    _ASSERT && Vec2.assert(v);\n    const x = a * v.x;\n    const y = a * v.y;\n\n    this.x += x;\n    this.y += y;\n    return this;\n  }\n\n  /**\n   * @deprecated Use subCombine or subMul\n   */\n  wSub(a: number, v: Vec2Value, b?: number, w?: Vec2Value): Vec2 {\n    if (typeof b !== 'undefined' || typeof w !== 'undefined') {\n      return this.subCombine(a, v, b, w);\n    } else {\n      return this.subMul(a, v);\n    }}\n\n  /**\n   * Subtract linear combination of v and w: `a * v + b * w`\n   */\n  subCombine(a: number, v: Vec2Value, b: number, w: Vec2Value): Vec2 {\n    _ASSERT && Math.assert(a);\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Math.assert(b);\n    _ASSERT && Vec2.assert(w);\n    const x = a * v.x + b * w.x;\n    const y = a * v.y + b * w.y;\n\n    // `this` may be `w`\n    this.x -= x;\n    this.y -= y;\n    return this;\n  }\n\n  subMul(a: number, v: Vec2Value): Vec2 {\n    _ASSERT && Math.assert(a);\n    _ASSERT && Vec2.assert(v);\n    const x = a * v.x;\n    const y = a * v.y;\n\n    this.x -= x;\n    this.y -= y;\n    return this;\n  }\n\n  /**\n   * Subtract a vector from this vector\n   *\n   * @returns this\n   */\n  sub(w: Vec2Value): Vec2 {\n    _ASSERT && Vec2.assert(w);\n    this.x -= w.x;\n    this.y -= w.y;\n    return this;\n  }\n\n  /**\n   * Multiply this vector by a scalar.\n   *\n   * @returns this\n   */\n  mul(m: number): Vec2 {\n    _ASSERT && Math.assert(m);\n    this.x *= m;\n    this.y *= m;\n    return this;\n  }\n\n  /**\n   * Get the length of this vector (the norm).\n   *\n   * For performance, use this instead of lengthSquared (if possible).\n   */\n  length(): number {\n    return Vec2.lengthOf(this);\n  }\n\n  /**\n   * Get the length squared.\n   */\n  lengthSquared(): number {\n    return Vec2.lengthSquared(this);\n  }\n\n  /**\n   * Convert this vector into a unit vector.\n   *\n   * @returns old length\n   */\n  normalize(): number {\n    const length = this.length();\n    if (length < Math.EPSILON) {\n      return 0.0;\n    }\n    const invLength = 1.0 / length;\n    this.x *= invLength;\n    this.y *= invLength;\n    return length;\n  }\n\n  /**\n   * Get the length of this vector (the norm).\n   *\n   * For performance, use this instead of lengthSquared (if possible).\n   */\n  static lengthOf(v: Vec2Value): number {\n    _ASSERT && Vec2.assert(v);\n    return Math.sqrt(v.x * v.x + v.y * v.y);\n  }\n\n  /**\n   * Get the length squared.\n   */\n  static lengthSquared(v: Vec2Value): number {\n    _ASSERT && Vec2.assert(v);\n    return v.x * v.x + v.y * v.y;\n  }\n\n  static distance(v: Vec2Value, w: Vec2Value): number {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    const dx = v.x - w.x;\n    const dy = v.y - w.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  static distanceSquared(v: Vec2Value, w: Vec2Value): number {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    const dx = v.x - w.x;\n    const dy = v.y - w.y;\n    return dx * dx + dy * dy;\n  }\n\n  static areEqual(v: Vec2Value, w: Vec2Value): boolean {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return v === w || typeof w === 'object' && w !== null && v.x === w.x && v.y === w.y;\n  }\n\n  /**\n   * Get the skew vector such that dot(skew_vec, other) == cross(vec, other)\n   */\n  static skew(v: Vec2Value): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    return Vec2.neo(-v.y, v.x);\n  }\n\n  /**\n   * Perform the dot product on two vectors.\n   */\n  static dot(v: Vec2Value, w: Vec2Value): number {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return v.x * w.x + v.y * w.y;\n  }\n\n  static cross(v: Vec2Value, w: Vec2Value): number;\n  static cross(v: Vec2Value, w: number): Vec2;\n  static cross(v: number, w: Vec2Value): Vec2;\n  /**\n   * Perform the cross product on two vectors. In 2D this produces a scalar.\n   *\n   * Perform the cross product on a vector and a scalar. In 2D this produces a\n   * vector.\n   */\n  // tslint:disable-next-line:typedef\n  static cross(v, w) {\n    if (typeof w === 'number') {\n      _ASSERT && Vec2.assert(v);\n      _ASSERT && Math.assert(w);\n      return Vec2.neo(w * v.y, -w * v.x);\n\n    } else if (typeof v === 'number') {\n      _ASSERT && Math.assert(v);\n      _ASSERT && Vec2.assert(w);\n      return Vec2.neo(-v * w.y, v * w.x);\n\n    } else {\n      _ASSERT && Vec2.assert(v);\n      _ASSERT && Vec2.assert(w);\n      return v.x * w.y - v.y * w.x;\n    }\n  }\n\n  /**\n   * Perform the cross product on two vectors. In 2D this produces a scalar.\n   */\n  static crossVec2Vec2(v: Vec2Value, w: Vec2Value): number {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return v.x * w.y - v.y * w.x;\n  }\n\n  /**\n   * Perform the cross product on a vector and a scalar. In 2D this produces a\n   * vector.\n   */\n  static crossVec2Num(v: Vec2Value, w: number): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Math.assert(w);\n    return Vec2.neo(w * v.y, -w * v.x);\n  }\n\n  /**\n   * Perform the cross product on a vector and a scalar. In 2D this produces a\n   * vector.\n   */\n  static crossNumVec2(v: number, w: Vec2Value): Vec2 {\n    _ASSERT && Math.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return Vec2.neo(-v * w.y, v * w.x);\n  }\n\n  static addCross(a: Vec2Value, v: Vec2Value, w: number): Vec2;\n  static addCross(a: Vec2Value, v: number, w: Vec2Value): Vec2;\n  /**\n   * Returns `a + (v x w)`\n   */\n  // tslint:disable-next-line:typedef\n  static addCross(a, v, w) {\n    if (typeof w === 'number') {\n      _ASSERT && Vec2.assert(v);\n      _ASSERT && Math.assert(w);\n      return Vec2.neo(w * v.y + a.x, -w * v.x + a.y);\n\n    } else if (typeof v === 'number') {\n      _ASSERT && Math.assert(v);\n      _ASSERT && Vec2.assert(w);\n      return Vec2.neo(-v * w.y + a.x, v * w.x + a.y);\n    }\n\n    _ASSERT && console.assert(false);\n  }\n\n  /**\n   * Returns `a + (v x w)`\n   */\n  static addCrossVec2Num(a: Vec2Value, v: Vec2Value, w: number): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Math.assert(w);\n    return Vec2.neo(w * v.y + a.x, -w * v.x + a.y);\n  }\n\n  /**\n   * Returns `a + (v x w)`\n   */\n  static addCrossNumVec2(a: Vec2Value, v: number, w: Vec2Value): Vec2 {\n    _ASSERT && Math.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return Vec2.neo(-v * w.y + a.x, v * w.x + a.y);\n  }\n\n  static add(v: Vec2Value, w: Vec2Value): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return Vec2.neo(v.x + w.x, v.y + w.y);\n  }\n\n  /** @internal @deprecated */\n  static wAdd(a: number, v: Vec2, b: number, w: Vec2): Vec2 {\n    if (typeof b !== 'undefined' || typeof w !== 'undefined') {\n      return Vec2.combine(a, v, b, w);\n    } else {\n      return Vec2.mulNumVec2(a, v);\n    }\n  }\n\n  static combine(a: number, v: Vec2, b: number, w: Vec2): Vec2 {\n    return Vec2.zero().setCombine(a, v, b, w);\n  }\n\n  static sub(v: Vec2Value, w: Vec2Value): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return Vec2.neo(v.x - w.x, v.y - w.y);\n  }\n\n  static mul(a: Vec2Value, b: number): Vec2;\n  static mul(a: number, b: Vec2Value): Vec2;\n  // tslint:disable-next-line:typedef\n  static mul(a, b) {\n    if (typeof a === 'object') {\n      _ASSERT && Vec2.assert(a);\n      _ASSERT && Math.assert(b);\n      return Vec2.neo(a.x * b, a.y * b);\n\n    } else if (typeof b === 'object') {\n      _ASSERT && Math.assert(a);\n      _ASSERT && Vec2.assert(b);\n      return Vec2.neo(a * b.x, a * b.y);\n    }\n  }\n\n  static mulVec2Num(a: Vec2Value, b: number): Vec2 {\n    _ASSERT && Vec2.assert(a);\n    _ASSERT && Math.assert(b);\n    return Vec2.neo(a.x * b, a.y * b);\n  }\n\n  static mulNumVec2(a: number, b: Vec2Value): Vec2 {\n    _ASSERT && Math.assert(a);\n    _ASSERT && Vec2.assert(b);\n    return Vec2.neo(a * b.x, a * b.y);\n  }\n\n  neg(): Vec2 {\n    this.x = -this.x;\n    this.y = -this.y;\n    return this;\n  }\n\n  static neg(v: Vec2Value): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    return Vec2.neo(-v.x, -v.y);\n  }\n\n  static abs(v: Vec2Value): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    return Vec2.neo(Math.abs(v.x), Math.abs(v.y));\n  }\n\n  static mid(v: Vec2Value, w: Vec2Value): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return Vec2.neo((v.x + w.x) * 0.5, (v.y + w.y) * 0.5);\n  }\n\n  static upper(v: Vec2Value, w: Vec2Value): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return Vec2.neo(Math.max(v.x, w.x), Math.max(v.y, w.y));\n  }\n\n  static lower(v: Vec2Value, w: Vec2Value): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return Vec2.neo(Math.min(v.x, w.x), Math.min(v.y, w.y));\n  }\n\n  clamp(max: number): Vec2 {\n    const lengthSqr = this.x * this.x + this.y * this.y;\n    if (lengthSqr > max * max) {\n      const scale = max / Math.sqrt(lengthSqr);\n      this.x *= scale;\n      this.y *= scale;\n    }\n    return this;\n  }\n\n  static clamp(v: Vec2Value, max: number): Vec2 {\n    const r = Vec2.neo(v.x, v.y);\n    r.clamp(max);\n    return r;\n  }\n\n  /**  @internal @deprecated */\n  // tslint:disable-next-line:typedef\n  static scaleFn(x: number, y: number) {\n    return function(v: Vec2): Vec2 {\n      return Vec2.neo(v.x * x, v.y * y);\n    };\n  }\n\n  /**  @internal @deprecated */\n  // tslint:disable-next-line:typedef\n  static translateFn(x: number, y: number) {\n    return function(v: Vec2): Vec2 {\n      return Vec2.neo(v.x + x, v.y + y);\n    };\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport * as matrix from '../common/Matrix';\nimport { math as Math } from '../common/Math';\nimport { Vec2, Vec2Value } from '../common/Vec2';\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\nconst _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\n/**\n * Ray-cast input data. The ray extends from `p1` to `p1 + maxFraction * (p2 - p1)`.\n */\nexport interface RayCastInput {\n  p1: Vec2;\n  p2: Vec2;\n  maxFraction: number;\n}\n\nexport type RayCastCallback = (subInput: RayCastInput, id: number) => number;\n\n/**\n * Ray-cast output data. The ray hits at `p1 + fraction * (p2 - p1)`,\n * where `p1` and `p2` come from RayCastInput.\n */\nexport interface RayCastOutput {\n  normal: Vec2;\n  fraction: number;\n}\n\nexport interface AABBValue {\n  lowerBound: Vec2Value;\n  upperBound: Vec2Value;\n}\n\nexport class AABB {\n  lowerBound: Vec2;\n  upperBound: Vec2;\n\n  constructor(lower?: Vec2Value, upper?: Vec2Value) {\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof AABB)) {\n      return new AABB(lower, upper);\n    }\n\n    this.lowerBound = Vec2.zero();\n    this.upperBound = Vec2.zero();\n\n    if (typeof lower === 'object') {\n      this.lowerBound.setVec2(lower);\n    }\n    if (typeof upper === 'object') {\n      this.upperBound.setVec2(upper);\n    } else if (typeof lower === 'object') {\n      this.upperBound.setVec2(lower);\n    }\n  }\n\n  /**\n   * Verify that the bounds are sorted.\n   */\n  isValid(): boolean {\n    return AABB.isValid(this);\n  }\n\n  static isValid(obj: any): boolean {\n    if (obj === null || typeof obj === 'undefined') {\n      return false;\n    }\n    return Vec2.isValid(obj.lowerBound) && Vec2.isValid(obj.upperBound) && Vec2.sub(obj.upperBound, obj.lowerBound).lengthSquared() >= 0;\n  }\n\n  static assert(o: any): void {\n    _ASSERT && console.assert(!AABB.isValid(o), 'Invalid AABB!', o);\n  }\n\n  /**\n   * Get the center of the AABB.\n   */\n  getCenter(): Vec2 {\n    return Vec2.neo((this.lowerBound.x + this.upperBound.x) * 0.5, (this.lowerBound.y + this.upperBound.y) * 0.5);\n  }\n\n  /**\n   * Get the extents of the AABB (half-widths).\n   */\n  getExtents(): Vec2 {\n    return Vec2.neo((this.upperBound.x - this.lowerBound.x) * 0.5, (this.upperBound.y - this.lowerBound.y) * 0.5);\n  }\n\n  /**\n   * Get the perimeter length.\n   */\n  getPerimeter(): number {\n    return 2.0 * (this.upperBound.x - this.lowerBound.x + this.upperBound.y - this.lowerBound.y);\n  }\n\n  /**\n   * Combine one or two AABB into this one.\n   */\n  combine(a: AABB, b?: AABB): void {\n    b = b || this;\n\n    const lowerA = a.lowerBound;\n    const upperA = a.upperBound;\n    const lowerB = b.lowerBound;\n    const upperB = b.upperBound;\n\n    const lowerX = Math.min(lowerA.x, lowerB.x);\n    const lowerY = Math.min(lowerA.y, lowerB.y);\n    const upperX = Math.max(upperB.x, upperA.x);\n    const upperY = Math.max(upperB.y, upperA.y);\n\n    this.lowerBound.setNum(lowerX, lowerY);\n    this.upperBound.setNum(upperX, upperY);\n  }\n\n  combinePoints(a: Vec2Value, b: Vec2Value): void {\n    this.lowerBound.setNum(Math.min(a.x, b.x), Math.min(a.y, b.y));\n    this.upperBound.setNum(Math.max(a.x, b.x), Math.max(a.y, b.y));\n  }\n\n  set(aabb: AABB): void {\n    this.lowerBound.setNum(aabb.lowerBound.x, aabb.lowerBound.y);\n    this.upperBound.setNum(aabb.upperBound.x, aabb.upperBound.y);\n  }\n\n  contains(aabb: AABB): boolean {\n    let result = true;\n    result = result && this.lowerBound.x <= aabb.lowerBound.x;\n    result = result && this.lowerBound.y <= aabb.lowerBound.y;\n    result = result && aabb.upperBound.x <= this.upperBound.x;\n    result = result && aabb.upperBound.y <= this.upperBound.y;\n    return result;\n  }\n\n  extend(value: number): AABB {\n    AABB.extend(this, value);\n    return this;\n  }\n\n  static extend(out: AABBValue, value: number): AABBValue {\n    out.lowerBound.x -= value;\n    out.lowerBound.y -= value;\n    out.upperBound.x += value;\n    out.upperBound.y += value;\n    return out;\n  }\n\n  static testOverlap(a: AABB, b: AABB): boolean {\n    const d1x = b.lowerBound.x - a.upperBound.x;\n    const d2x = a.lowerBound.x - b.upperBound.x;\n\n    const d1y = b.lowerBound.y - a.upperBound.y;\n    const d2y = a.lowerBound.y - b.upperBound.y;\n\n    if (d1x > 0 || d1y > 0 || d2x > 0 || d2y > 0) {\n      return false;\n    }\n    return true;\n  }\n\n  static areEqual(a: AABB, b: AABB): boolean {\n    return Vec2.areEqual(a.lowerBound, b.lowerBound) && Vec2.areEqual(a.upperBound, b.upperBound);\n  }\n\n  static diff(a: AABB, b: AABB): number {\n    const wD = Math.max(0, Math.min(a.upperBound.x, b.upperBound.x) - Math.max(b.lowerBound.x, a.lowerBound.x));\n    const hD = Math.max(0, Math.min(a.upperBound.y, b.upperBound.y) - Math.max(b.lowerBound.y, a.lowerBound.y));\n\n    const wA = a.upperBound.x - a.lowerBound.x;\n    const hA = a.upperBound.y - a.lowerBound.y;\n\n    const wB = b.upperBound.x - b.lowerBound.x;\n    const hB = b.upperBound.y - b.lowerBound.y;\n\n    return wA * hA + wB * hB - wD * hD;\n  }\n\n  rayCast(output: RayCastOutput, input: RayCastInput): boolean {\n    // From Real-time Collision Detection, p179.\n\n    let tmin = -Infinity;\n    let tmax = Infinity;\n\n    const p = input.p1;\n    const d = Vec2.sub(input.p2, input.p1);\n    const absD = Vec2.abs(d);\n\n    const normal = Vec2.zero();\n\n    for (let f: 'x' | 'y' = 'x'; f !== null; f = (f === 'x' ? 'y' : null)) {\n      if (absD.x < Math.EPSILON) {\n        // Parallel.\n        if (p[f] < this.lowerBound[f] || this.upperBound[f] < p[f]) {\n          return false;\n        }\n      } else {\n        const inv_d = 1.0 / d[f];\n        let t1 = (this.lowerBound[f] - p[f]) * inv_d;\n        let t2 = (this.upperBound[f] - p[f]) * inv_d;\n\n        // Sign of the normal vector.\n        let s = -1.0;\n\n        if (t1 > t2) {\n          const temp = t1;\n          t1 = t2;\n          t2 = temp;\n          s = 1.0;\n        }\n\n        // Push the min up\n        if (t1 > tmin) {\n          normal.setZero();\n          normal[f] = s;\n          tmin = t1;\n        }\n\n        // Pull the max down\n        tmax = Math.min(tmax, t2);\n\n        if (tmin > tmax) {\n          return false;\n        }\n      }\n    }\n\n    // Does the ray start inside the box?\n    // Does the ray intersect beyond the max fraction?\n    if (tmin < 0.0 || input.maxFraction < tmin) {\n      return false;\n    }\n\n    // Intersection.\n    output.fraction = tmin;\n    output.normal = normal;\n    return true;\n  }\n\n  /** @internal */\n  toString(): string {\n    return JSON.stringify(this);\n  }\n\n  static combinePoints(out: AABBValue, a: Vec2Value, b: Vec2Value): AABBValue {\n    out.lowerBound.x = Math.min(a.x, b.x);\n    out.lowerBound.y = Math.min(a.y, b.y);\n    out.upperBound.x = Math.max(a.x, b.x);\n    out.upperBound.y = Math.max(a.y, b.y);\n    return out;\n  }\n\n  static combinedPerimeter(a: AABBValue, b: AABBValue) {\n    const lx = Math.min(a.lowerBound.x, b.lowerBound.x);\n    const ly = Math.min(a.lowerBound.y, b.lowerBound.y);\n    const ux = Math.max(a.upperBound.x, b.upperBound.x);\n    const uy = Math.max(a.upperBound.y, b.upperBound.y);\n    return 2.0 * (ux - lx + uy - ly);  \n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n/**\n * Tuning constants based on meters-kilograms-seconds (MKS) units.\n */\nexport class Settings {\n  /**\n   * You can use this to change the length scale used by your game.\n   * \n   * For example for inches you could use 39.4.\n   */\n  static lengthUnitsPerMeter = 1.0;\n  \n  // Collision\n  /**\n   * The maximum number of contact points between two convex shapes. Do not change\n   * this value.\n   */\n  static maxManifoldPoints: number = 2;\n\n  /**\n   * The maximum number of vertices on a convex polygon. You cannot increase this\n   * too much because BlockAllocator has a maximum object size.\n   */\n  static maxPolygonVertices: number = 12;\n\n  /**\n   * This is used to fatten AABBs in the dynamic tree. This allows proxies to move\n   * by a small amount without triggering a tree adjustment. This is in meters.\n   */\n  static aabbExtension: number = 0.1;\n\n  /**\n   * This is used to fatten AABBs in the dynamic tree. This is used to predict the\n   * future position based on the current displacement. This is a dimensionless\n   * multiplier.\n   */\n  static aabbMultiplier: number = 2.0;\n\n  /**\n   * A small length used as a collision and constraint tolerance. Usually it is\n   * chosen to be numerically significant, but visually insignificant.\n   */\n  static linearSlop: number = 0.005;\n\n  /**\n   * A small angle used as a collision and constraint tolerance. Usually it is\n   * chosen to be numerically significant, but visually insignificant.\n   */\n  static angularSlop: number = (2.0 / 180.0 * Math.PI);\n\n  /**\n   * The radius of the polygon/edge shape skin. This should not be modified.\n   * Making this smaller means polygons will have an insufficient buffer for\n   * continuous collision. Making it larger may create artifacts for vertex\n   * collision.\n   */\n  static get polygonRadius(): number { return 2.0 * Settings.linearSlop; }\n\n  /**\n   * Maximum number of sub-steps per contact in continuous physics simulation.\n   */\n  static maxSubSteps: number = 8;\n\n// Dynamics\n\n  /**\n   * Maximum number of contacts to be handled to solve a TOI impact.\n   */\n  static maxTOIContacts: number = 32;\n\n  /**\n   * Maximum iterations to solve a TOI.\n   */\n  static maxTOIIterations: number = 20;\n\n  /**\n   * Maximum iterations to find Distance.\n   */\n  static maxDistnceIterations: number = 20;\n\n  /**\n   * A velocity threshold for elastic collisions. Any collision with a relative\n   * linear velocity below this threshold will be treated as inelastic.\n   */\n  static velocityThreshold: number = 1.0;\n\n  /**\n   * The maximum linear position correction used when solving constraints. This\n   * helps to prevent overshoot.\n   */\n  static maxLinearCorrection: number = 0.2;\n\n  /**\n   * The maximum angular position correction used when solving constraints. This\n   * helps to prevent overshoot.\n   */\n  static maxAngularCorrection: number = (8.0 / 180.0 * Math.PI);\n\n  /**\n   * The maximum linear velocity of a body. This limit is very large and is used\n   * to prevent numerical problems. You shouldn't need to adjust Settings.\n   */\n  static maxTranslation: number = 2.0;\n\n  /**\n   * The maximum angular velocity of a body. This limit is very large and is used\n   * to prevent numerical problems. You shouldn't need to adjust Settings.\n   */\n  static maxRotation: number = (0.5 * Math.PI);\n\n  /**\n   * This scale factor controls how fast overlap is resolved. Ideally this would\n   * be 1 so that overlap is removed in one time step. However using values close\n   * to 1 often lead to overshoot.\n   */\n  static baumgarte: number = 0.2;\n  static toiBaugarte: number = 0.75;\n\n  // Sleep\n\n  /**\n   * The time that a body must be still before it will go to sleep.\n   */\n  static timeToSleep: number = 0.5;\n\n  /**\n   * A body cannot sleep if its linear velocity is above this tolerance.\n   */\n  static linearSleepTolerance: number = 0.01;\n\n  /**\n   * A body cannot sleep if its angular velocity is above this tolerance.\n   */\n  static angularSleepTolerance: number = (2.0 / 180.0 * Math.PI);\n}\n\n/** @internal */\nexport class SettingsInternal {\n  static get maxManifoldPoints() {\n    return Settings.maxManifoldPoints;\n  }\n  static get maxPolygonVertices() {\n    return Settings.maxPolygonVertices;\n  }\n  static get aabbExtension() {\n    return Settings.aabbExtension * Settings.lengthUnitsPerMeter;\n  }\n  static get aabbMultiplier() {\n    return Settings.aabbMultiplier;\n  }\n  static get linearSlop() {\n    return Settings.linearSlop * Settings.lengthUnitsPerMeter;\n  }\n  static get linearSlopSquared() {\n    return Settings.linearSlop * Settings.lengthUnitsPerMeter * Settings.linearSlop * Settings.lengthUnitsPerMeter;\n  }\n  static get angularSlop() {\n    return Settings.angularSlop;\n  }\n  static get polygonRadius() {\n    return 2.0 * Settings.linearSlop;\n  }\n  static get maxSubSteps() {\n    return Settings.maxSubSteps;\n  }\n  static get maxTOIContacts() {\n    return Settings.maxTOIContacts;\n  }\n  static get maxTOIIterations() {\n    return Settings.maxTOIIterations;\n  }\n  static get maxDistnceIterations() {\n    return Settings.maxDistnceIterations;\n  }\n  static get velocityThreshold() {\n    return Settings.velocityThreshold * Settings.lengthUnitsPerMeter;\n  }\n  static get maxLinearCorrection() {\n    return Settings.maxLinearCorrection * Settings.lengthUnitsPerMeter;\n  }\n  static get maxAngularCorrection() {\n    return Settings.maxAngularCorrection;\n  }\n  static get maxTranslation() {\n    return Settings.maxTranslation * Settings.lengthUnitsPerMeter;\n  }\n  static get maxTranslationSquared() {\n    return Settings.maxTranslation * Settings.lengthUnitsPerMeter * Settings.maxTranslation * Settings.lengthUnitsPerMeter;\n  }\n  static get maxRotation() {\n    return Settings.maxRotation;\n  }\n  static get maxRotationSquared() {\n    return Settings.maxRotation * Settings.maxRotation;\n  }\n  static get baumgarte() {\n    return Settings.baumgarte;\n  }\n  static get toiBaugarte() {\n    return Settings.toiBaugarte;\n  }\n  static get timeToSleep() {\n    return Settings.timeToSleep;\n  }\n  static get linearSleepTolerance() {\n    return Settings.linearSleepTolerance * Settings.lengthUnitsPerMeter;\n  }\n  static get linearSleepToleranceSqr() {\n    return Settings.linearSleepTolerance * Settings.lengthUnitsPerMeter * Settings.linearSleepTolerance * Settings.lengthUnitsPerMeter;\n  }\n  static get angularSleepTolerance() {\n    return Settings.angularSleepTolerance;\n  }\n  static get angularSleepToleranceSqr() {\n    return Settings.angularSleepTolerance * Settings.angularSleepTolerance;\n  }\n}\n","/*\n * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js\n *\n * This software is provided 'as-is', without any express or implied\n * warranty.  In no event will the authors be held liable for any damages\n * arising from the use of this software.\n * Permission is granted to anyone to use this software for any purpose,\n * including commercial applications, and to alter it and redistribute it\n * freely, subject to the following restrictions:\n * 1. The origin of this software must not be misrepresented; you must not\n * claim that you wrote the original software. If you use this software\n * in a product, an acknowledgment in the product documentation would be\n * appreciated but is not required.\n * 2. Altered source versions must be plainly marked as such, and must not be\n * misrepresented as being the original software.\n * 3. This notice may not be removed or altered from any source distribution.\n */\n\nexport interface PoolOptions<T> {\n  max?: number,\n  create?: () => T,\n  /** Called when an object is being re-allocated. */\n  allocate?: (item: T) => void,\n  /** Called when an object is returned to pool. */\n  release?: (item: T) => void,\n  /** Called when an object is returned to the pool but will be disposed from pool. */\n  dispose?: (item: T) => T,\n}\n\nexport class Pool<T> {\n  _list: T[] = [];\n  _max: number = Infinity;\n\n  _createFn: () => T;\n  _hasCreateFn: boolean = false;\n  _createCount: number = 0;\n\n  _allocateFn: (item: T) => void;\n  _hasAllocateFn: boolean = false;\n  _allocateCount: number = 0;\n\n  _releaseFn: (item: T) => void;\n  _hasReleaseFn: boolean = false;\n  _releaseCount: number = 0;\n\n  _disposeFn: (item: T) => T;\n  _hasDisposeFn: boolean = false;\n  _disposeCount: number = 0;\n\n  constructor(opts: PoolOptions<T>) {\n    this._list = [];\n    this._max = opts.max || this._max;\n\n    this._createFn = opts.create;\n    this._hasCreateFn = typeof this._createFn === 'function';\n    this._allocateFn = opts.allocate;\n    this._hasAllocateFn = typeof this._allocateFn === 'function';\n    this._releaseFn = opts.release;\n    this._hasReleaseFn = typeof this._releaseFn === 'function';\n    this._disposeFn = opts.dispose;\n    this._hasDisposeFn = typeof this._disposeFn === 'function';\n  }\n\n  max(n?: number): number | Pool<T> {\n    if (typeof n === 'number') {\n      this._max = n;\n      return this;\n    }\n    return this._max;\n  }\n\n  size(): number {\n    return this._list.length;\n  }\n\n  allocate(): T {\n    let item: T;\n    if (this._list.length > 0) {\n      item = this._list.shift();\n    } else {\n      this._createCount++;\n      if (this._hasCreateFn) {\n        item = this._createFn();\n      } else {\n        // tslint:disable-next-line:no-object-literal-type-assertion\n        item = {} as T;\n      }\n    }\n    this._allocateCount++;\n    if (this._hasAllocateFn) {\n      this._allocateFn(item);\n    }\n    return item;\n  }\n\n  release(item: T): void {\n    if (this._list.length < this._max) {\n      this._releaseCount++;\n      if (this._hasReleaseFn) {\n        this._releaseFn(item);\n      }\n      this._list.push(item);\n    } else {\n      this._disposeCount++;\n      if (this._hasDisposeFn) {\n        item = this._disposeFn(item);\n      }\n    }\n  }\n\n  /** @internal */\n  toString(): string {\n    return \" +\" + this._createCount + \" >\" + this._allocateCount + \" <\" + this._releaseCount + \" -\"\n      + this._disposeCount + \" =\" + this._list.length + \"/\" + this._max;\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { SettingsInternal as Settings } from '../Settings';\nimport { Pool } from '../util/Pool';\nimport { Vec2, Vec2Value } from '../common/Vec2';\nimport { AABB, RayCastCallback, RayCastInput } from './AABB';\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nexport type DynamicTreeQueryCallback = (nodeId: number) => boolean;\n\n/**\n * A node in the dynamic tree. The client does not interact with this directly.\n */\nexport class TreeNode<T> {\n  id: number;\n  /** Enlarged AABB */\n  aabb: AABB = new AABB();\n  userData: T = null;\n  parent: TreeNode<T> = null;\n  child1: TreeNode<T> = null;\n  child2: TreeNode<T> = null;\n  /** 0: leaf, -1: free node */\n  height: number = -1;\n\n  constructor(id?: number) {\n    this.id = id;\n  }\n\n  /** @internal */\n  toString(): string {\n    return this.id + \": \" + this.userData;\n  }\n\n  isLeaf(): boolean {\n    return this.child1 == null;\n  }\n}\n\nconst poolTreeNode = new Pool<TreeNode<any>>({\n  create(): TreeNode<any> {\n    return new TreeNode();\n  },\n  release(node: TreeNode<any>) {\n    node.userData = null;\n    node.parent = null;\n    node.child1 = null;\n    node.child2 = null;\n    node.height = -1;\n    node.id = undefined;\n  }\n});\n\n/**\n * A dynamic AABB tree broad-phase, inspired by Nathanael Presson's btDbvt. A\n * dynamic tree arranges data in a binary tree to accelerate queries such as\n * volume queries and ray casts. Leafs are proxies with an AABB. In the tree we\n * expand the proxy AABB by `aabbExtension` so that the proxy AABB is bigger\n * than the client object. This allows the client object to move by small\n * amounts without triggering a tree update.\n *\n * Nodes are pooled and relocatable, so we use node indices rather than\n * pointers.\n */\nexport class DynamicTree<T> {\n  m_root: TreeNode<T>;\n  m_lastProxyId: number;\n  m_nodes: {\n    [id: number]: TreeNode<T>\n  };\n\n  constructor() {\n    this.m_root = null;\n    this.m_nodes = {};\n    this.m_lastProxyId = 0;\n  }\n\n  /**\n   * Get proxy user data.\n   *\n   * @return the proxy user data or 0 if the id is invalid.\n   */\n  getUserData(id: number): T {\n    const node = this.m_nodes[id];\n    _ASSERT && console.assert(!!node);\n    return node.userData;\n  }\n\n  /**\n   * Get the fat AABB for a node id.\n   *\n   * @return the proxy user data or 0 if the id is invalid.\n   */\n  getFatAABB(id: number): AABB {\n    const node = this.m_nodes[id];\n    _ASSERT && console.assert(!!node);\n    return node.aabb;\n  }\n\n  allocateNode(): TreeNode<T> {\n    const node = poolTreeNode.allocate();\n    node.id = ++this.m_lastProxyId;\n    this.m_nodes[node.id] = node;\n    return node;\n  }\n\n  freeNode(node: TreeNode<T>): void {\n    // tslint:disable-next-line:no-dynamic-delete\n    delete this.m_nodes[node.id];\n    poolTreeNode.release(node);\n  }\n\n  /**\n   * Create a proxy in the tree as a leaf node. We return the index of the node\n   * instead of a pointer so that we can grow the node pool.\n   *\n   * Create a proxy. Provide a tight fitting AABB and a userData pointer.\n   */\n  createProxy(aabb: AABB, userData: T): number {\n    _ASSERT && console.assert(AABB.isValid(aabb));\n\n    const node = this.allocateNode();\n\n    node.aabb.set(aabb);\n\n    // Fatten the aabb.\n    AABB.extend(node.aabb, Settings.aabbExtension);\n\n    node.userData = userData;\n    node.height = 0;\n\n    this.insertLeaf(node);\n\n    return node.id;\n  }\n\n  /**\n   * Destroy a proxy. This asserts if the id is invalid.\n   */\n  destroyProxy(id: number): void {\n    const node = this.m_nodes[id];\n\n    _ASSERT && console.assert(!!node);\n    _ASSERT && console.assert(node.isLeaf());\n\n    this.removeLeaf(node);\n    this.freeNode(node);\n  }\n\n  /**\n   * Move a proxy with a swepted AABB. If the proxy has moved outside of its\n   * fattened AABB, then the proxy is removed from the tree and re-inserted.\n   * Otherwise the function returns immediately.\n   *\n   * @param d Displacement\n   *\n   * @return true if the proxy was re-inserted.\n   */\n  moveProxy(id: number, aabb: AABB, d: Vec2Value): boolean {\n    _ASSERT && console.assert(AABB.isValid(aabb));\n    _ASSERT && console.assert(!d || Vec2.isValid(d));\n\n    const node = this.m_nodes[id];\n\n    _ASSERT && console.assert(!!node);\n    _ASSERT && console.assert(node.isLeaf());\n\n    if (node.aabb.contains(aabb)) {\n      return false;\n    }\n\n    this.removeLeaf(node);\n\n    node.aabb.set(aabb);\n\n    // Extend AABB.\n    aabb = node.aabb;\n    AABB.extend(aabb, Settings.aabbExtension);\n\n    // Predict AABB displacement.\n    // const d = Vec2.mul(Settings.aabbMultiplier, displacement);\n\n    if (d.x < 0.0) {\n      aabb.lowerBound.x += d.x * Settings.aabbMultiplier;\n    } else {\n      aabb.upperBound.x += d.x * Settings.aabbMultiplier;\n    }\n\n    if (d.y < 0.0) {\n      aabb.lowerBound.y += d.y * Settings.aabbMultiplier;\n    } else {\n      aabb.upperBound.y += d.y * Settings.aabbMultiplier;\n    }\n\n    this.insertLeaf(node);\n\n    return true;\n  }\n\n  insertLeaf(leaf: TreeNode<T>): void {\n    _ASSERT && console.assert(AABB.isValid(leaf.aabb));\n\n    if (this.m_root == null) {\n      this.m_root = leaf;\n      this.m_root.parent = null;\n      return;\n    }\n\n    // Find the best sibling for this node\n    const leafAABB = leaf.aabb;\n    let index = this.m_root;\n    while (!index.isLeaf()) {\n      const child1 = index.child1;\n      const child2 = index.child2;\n\n      const area = index.aabb.getPerimeter();\n\n      const combinedArea = AABB.combinedPerimeter(index.aabb, leafAABB);\n\n      // Cost of creating a new parent for this node and the new leaf\n      const cost = 2.0 * combinedArea;\n\n      // Minimum cost of pushing the leaf further down the tree\n      const inheritanceCost = 2.0 * (combinedArea - area);\n\n      // Cost of descending into child1\n      const newArea1 = AABB.combinedPerimeter(leafAABB, child1.aabb);\n      let cost1 = newArea1 + inheritanceCost;\n      if (!child1.isLeaf()) {\n        const oldArea = child1.aabb.getPerimeter();\n        cost1 -= oldArea;\n      }\n\n      // Cost of descending into child2\n      const newArea2 = AABB.combinedPerimeter(leafAABB, child2.aabb);\n      let cost2 = newArea2 + inheritanceCost;\n      if (!child2.isLeaf()) {\n        const oldArea = child2.aabb.getPerimeter();\n        cost2 -= oldArea;\n      }\n\n      // Descend according to the minimum cost.\n      if (cost < cost1 && cost < cost2) {\n        break;\n      }\n\n      // Descend\n      if (cost1 < cost2) {\n        index = child1;\n      } else {\n        index = child2;\n      }\n    }\n\n    const sibling = index;\n\n    // Create a new parent.\n    const oldParent = sibling.parent;\n    const newParent = this.allocateNode();\n    newParent.parent = oldParent;\n    newParent.userData = null;\n    newParent.aabb.combine(leafAABB, sibling.aabb);\n    newParent.height = sibling.height + 1;\n\n    if (oldParent != null) {\n      // The sibling was not the root.\n      if (oldParent.child1 === sibling) {\n        oldParent.child1 = newParent;\n      } else {\n        oldParent.child2 = newParent;\n      }\n\n      newParent.child1 = sibling;\n      newParent.child2 = leaf;\n      sibling.parent = newParent;\n      leaf.parent = newParent;\n    } else {\n      // The sibling was the root.\n      newParent.child1 = sibling;\n      newParent.child2 = leaf;\n      sibling.parent = newParent;\n      leaf.parent = newParent;\n      this.m_root = newParent;\n    }\n\n    // Walk back up the tree fixing heights and AABBs\n    index = leaf.parent;\n    while (index != null) {\n      index = this.balance(index);\n\n      const child1 = index.child1;\n      const child2 = index.child2;\n\n      _ASSERT && console.assert(child1 != null);\n      _ASSERT && console.assert(child2 != null);\n\n      index.height = 1 + Math.max(child1.height, child2.height);\n      index.aabb.combine(child1.aabb, child2.aabb);\n\n      index = index.parent;\n    }\n\n    // validate();\n  }\n\n  removeLeaf(leaf: TreeNode<T>): void {\n    if (leaf === this.m_root) {\n      this.m_root = null;\n      return;\n    }\n\n    const parent = leaf.parent;\n    const grandParent = parent.parent;\n    let sibling;\n    if (parent.child1 === leaf) {\n      sibling = parent.child2;\n    } else {\n      sibling = parent.child1;\n    }\n\n    if (grandParent != null) {\n      // Destroy parent and connect sibling to grandParent.\n      if (grandParent.child1 === parent) {\n        grandParent.child1 = sibling;\n      } else {\n        grandParent.child2 = sibling;\n      }\n      sibling.parent = grandParent;\n      this.freeNode(parent);\n\n      // Adjust ancestor bounds.\n      let index = grandParent;\n      while (index != null) {\n        index = this.balance(index);\n\n        const child1 = index.child1;\n        const child2 = index.child2;\n\n        index.aabb.combine(child1.aabb, child2.aabb);\n        index.height = 1 + Math.max(child1.height, child2.height);\n\n        index = index.parent;\n      }\n    } else {\n      this.m_root = sibling;\n      sibling.parent = null;\n      this.freeNode(parent);\n    }\n\n    // validate();\n  }\n\n  /**\n   * Perform a left or right rotation if node A is imbalanced. Returns the new\n   * root index.\n   */\n  balance(iA: TreeNode<T>): TreeNode<T> {\n    _ASSERT && console.assert(iA != null);\n\n    const A = iA;\n    if (A.isLeaf() || A.height < 2) {\n      return iA;\n    }\n\n    const B = A.child1;\n    const C = A.child2;\n\n    const balance = C.height - B.height;\n\n    // Rotate C up\n    if (balance > 1) {\n      const F = C.child1;\n      const G = C.child2;\n\n      // Swap A and C\n      C.child1 = A;\n      C.parent = A.parent;\n      A.parent = C;\n\n      // A's old parent should point to C\n      if (C.parent != null) {\n        if (C.parent.child1 === iA) {\n          C.parent.child1 = C;\n        } else {\n          C.parent.child2 = C;\n        }\n      } else {\n        this.m_root = C;\n      }\n\n      // Rotate\n      if (F.height > G.height) {\n        C.child2 = F;\n        A.child2 = G;\n        G.parent = A;\n        A.aabb.combine(B.aabb, G.aabb);\n        C.aabb.combine(A.aabb, F.aabb);\n\n        A.height = 1 + Math.max(B.height, G.height);\n        C.height = 1 + Math.max(A.height, F.height);\n      } else {\n        C.child2 = G;\n        A.child2 = F;\n        F.parent = A;\n        A.aabb.combine(B.aabb, F.aabb);\n        C.aabb.combine(A.aabb, G.aabb);\n\n        A.height = 1 + Math.max(B.height, F.height);\n        C.height = 1 + Math.max(A.height, G.height);\n      }\n\n      return C;\n    }\n\n    // Rotate B up\n    if (balance < -1) {\n      const D = B.child1;\n      const E = B.child2;\n\n      // Swap A and B\n      B.child1 = A;\n      B.parent = A.parent;\n      A.parent = B;\n\n      // A's old parent should point to B\n      if (B.parent != null) {\n        if (B.parent.child1 === A) {\n          B.parent.child1 = B;\n        } else {\n          B.parent.child2 = B;\n        }\n      } else {\n        this.m_root = B;\n      }\n\n      // Rotate\n      if (D.height > E.height) {\n        B.child2 = D;\n        A.child1 = E;\n        E.parent = A;\n        A.aabb.combine(C.aabb, E.aabb);\n        B.aabb.combine(A.aabb, D.aabb);\n\n        A.height = 1 + Math.max(C.height, E.height);\n        B.height = 1 + Math.max(A.height, D.height);\n      } else {\n        B.child2 = E;\n        A.child1 = D;\n        D.parent = A;\n        A.aabb.combine(C.aabb, D.aabb);\n        B.aabb.combine(A.aabb, E.aabb);\n\n        A.height = 1 + Math.max(C.height, D.height);\n        B.height = 1 + Math.max(A.height, E.height);\n      }\n\n      return B;\n    }\n\n    return A;\n  }\n\n  /**\n   * Compute the height of the binary tree in O(N) time. Should not be called\n   * often.\n   */\n  getHeight(): number {\n    if (this.m_root == null) {\n      return 0;\n    }\n\n    return this.m_root.height;\n  }\n\n  /**\n   * Get the ratio of the sum of the node areas to the root area.\n   */\n  getAreaRatio(): number {\n    if (this.m_root == null) {\n      return 0.0;\n    }\n\n    const root = this.m_root;\n    const rootArea = root.aabb.getPerimeter();\n\n    let totalArea = 0.0;\n    let node;\n    const it = this.iteratorPool.allocate().preorder(this.m_root);\n    while (node = it.next()) {\n      if (node.height < 0) {\n        // Free node in pool\n        continue;\n      }\n\n      totalArea += node.aabb.getPerimeter();\n    }\n\n    this.iteratorPool.release(it);\n\n    return totalArea / rootArea;\n  }\n\n  /**\n   * Compute the height of a sub-tree.\n   */\n  computeHeight(id?: number): number {\n    let node;\n    if (typeof id !== 'undefined') {\n      node = this.m_nodes[id];\n    } else {\n      node = this.m_root;\n    }\n\n    // _ASSERT && console.assert(0 <= id && id < this.m_nodeCapacity);\n\n    if (node.isLeaf()) {\n      return 0;\n    }\n\n    const height1 = this.computeHeight(node.child1.id);\n    const height2 = this.computeHeight(node.child2.id);\n    return 1 + Math.max(height1, height2);\n  }\n\n  validateStructure(node: TreeNode<T>): void {\n    if (node == null) {\n      return;\n    }\n\n    if (node === this.m_root) {\n      _ASSERT && console.assert(node.parent == null);\n    }\n\n    const child1 = node.child1;\n    const child2 = node.child2;\n\n    if (node.isLeaf()) {\n      _ASSERT && console.assert(child1 == null);\n      _ASSERT && console.assert(child2 == null);\n      _ASSERT && console.assert(node.height === 0);\n      return;\n    }\n\n    // _ASSERT && console.assert(0 <= child1 && child1 < this.m_nodeCapacity);\n    // _ASSERT && console.assert(0 <= child2 && child2 < this.m_nodeCapacity);\n\n    _ASSERT && console.assert(child1.parent === node);\n    _ASSERT && console.assert(child2.parent === node);\n\n    this.validateStructure(child1);\n    this.validateStructure(child2);\n  }\n\n  validateMetrics(node: TreeNode<T>): void {\n    if (node == null) {\n      return;\n    }\n\n    const child1 = node.child1;\n    const child2 = node.child2;\n\n    if (node.isLeaf()) {\n      _ASSERT && console.assert(child1 == null);\n      _ASSERT && console.assert(child2 == null);\n      _ASSERT && console.assert(node.height === 0);\n      return;\n    }\n\n    // _ASSERT && console.assert(0 <= child1 && child1 < this.m_nodeCapacity);\n    // _ASSERT && console.assert(0 <= child2 && child2 < this.m_nodeCapacity);\n\n    const height1 = child1.height;\n    const height2 = child2.height;\n    const height = 1 + Math.max(height1, height2);\n    _ASSERT && console.assert(node.height === height);\n\n    const aabb = new AABB();\n    aabb.combine(child1.aabb, child2.aabb);\n\n    _ASSERT && console.assert(AABB.areEqual(aabb, node.aabb));\n\n    this.validateMetrics(child1);\n    this.validateMetrics(child2);\n  }\n\n  /**\n   * Validate this tree. For testing.\n   */\n  validate(): void {\n    if (!_ASSERT) return;\n    this.validateStructure(this.m_root);\n    this.validateMetrics(this.m_root);\n\n    console.assert(this.getHeight() === this.computeHeight());\n  }\n\n  /**\n   * Get the maximum balance of an node in the tree. The balance is the difference\n   * in height of the two children of a node.\n   */\n  getMaxBalance(): number {\n    let maxBalance = 0;\n    let node;\n    const it = this.iteratorPool.allocate().preorder(this.m_root);\n    while (node = it.next()) {\n      if (node.height <= 1) {\n        continue;\n      }\n\n      _ASSERT && console.assert(!node.isLeaf());\n\n      const balance = Math.abs(node.child2.height - node.child1.height);\n      maxBalance = Math.max(maxBalance, balance);\n    }\n    this.iteratorPool.release(it);\n\n    return maxBalance;\n  }\n\n  /**\n   * Build an optimal tree. Very expensive. For testing.\n   */\n  rebuildBottomUp(): void {\n    const nodes = [];\n    let count = 0;\n\n    // Build array of leaves. Free the rest.\n    let node;\n    const it = this.iteratorPool.allocate().preorder(this.m_root);\n    while (node = it.next()) {\n      if (node.height < 0) {\n        // free node in pool\n        continue;\n      }\n\n      if (node.isLeaf()) {\n        node.parent = null;\n        nodes[count] = node;\n        ++count;\n      } else {\n        this.freeNode(node);\n      }\n    }\n    this.iteratorPool.release(it);\n\n    while (count > 1) {\n      let minCost = Infinity;\n      let iMin = -1;\n      let jMin = -1;\n      for (let i = 0; i < count; ++i) {\n        const aabbi = nodes[i].aabb;\n        for (let j = i + 1; j < count; ++j) {\n          const aabbj = nodes[j].aabb;\n          const cost = AABB.combinedPerimeter(aabbi, aabbj);\n          if (cost < minCost) {\n            iMin = i;\n            jMin = j;\n            minCost = cost;\n          }\n        }\n      }\n\n      const child1 = nodes[iMin];\n      const child2 = nodes[jMin];\n\n      const parent = this.allocateNode();\n      parent.child1 = child1;\n      parent.child2 = child2;\n      parent.height = 1 + Math.max(child1.height, child2.height);\n      parent.aabb.combine(child1.aabb, child2.aabb);\n      parent.parent = null;\n\n      child1.parent = parent;\n      child2.parent = parent;\n\n      nodes[jMin] = nodes[count - 1];\n      nodes[iMin] = parent;\n      --count;\n    }\n\n    this.m_root = nodes[0];\n\n    _ASSERT && this.validate();\n  }\n\n  /**\n   * Shift the world origin. Useful for large worlds. The shift formula is:\n   * position -= newOrigin\n   *\n   * @param newOrigin The new origin with respect to the old origin\n   */\n  shiftOrigin(newOrigin: Vec2Value): void {\n    // Build array of leaves. Free the rest.\n    let node;\n    const it = this.iteratorPool.allocate().preorder(this.m_root);\n    while (node = it.next()) {\n      const aabb = node.aabb;\n      aabb.lowerBound.x -= newOrigin.x;\n      aabb.lowerBound.y -= newOrigin.y;\n      aabb.upperBound.x -= newOrigin.x;\n      aabb.upperBound.y -= newOrigin.y;\n    }\n    this.iteratorPool.release(it);\n  }\n\n  /**\n   * Query an AABB for overlapping proxies. The callback class is called for each\n   * proxy that overlaps the supplied AABB.\n   */\n  query(aabb: AABB, queryCallback: DynamicTreeQueryCallback): void {\n    _ASSERT && console.assert(typeof queryCallback === 'function');\n    const stack = this.stackPool.allocate();\n\n    stack.push(this.m_root);\n    while (stack.length > 0) {\n      const node = stack.pop();\n      if (node == null) {\n        continue;\n      }\n\n      if (AABB.testOverlap(node.aabb, aabb)) {\n        if (node.isLeaf()) {\n          const proceed = queryCallback(node.id);\n          if (proceed === false) {\n            return;\n          }\n        } else {\n          stack.push(node.child1);\n          stack.push(node.child2);\n        }\n      }\n    }\n\n    this.stackPool.release(stack);\n  }\n\n  /**\n   * Ray-cast against the proxies in the tree. This relies on the callback to\n   * perform a exact ray-cast in the case were the proxy contains a shape. The\n   * callback also performs the any collision filtering. This has performance\n   * roughly equal to k * log(n), where k is the number of collisions and n is the\n   * number of proxies in the tree.\n   *\n   * @param input The ray-cast input data. The ray extends from `p1` to `p1 + maxFraction * (p2 - p1)`.\n   * @param rayCastCallback A function that is called for each proxy that is hit by the ray.\n   */\n  rayCast(input: RayCastInput, rayCastCallback: RayCastCallback): void {\n    // TODO: GC\n    _ASSERT && console.assert(typeof rayCastCallback === 'function');\n    const p1 = input.p1;\n    const p2 = input.p2;\n    const r = Vec2.sub(p2, p1);\n    _ASSERT && console.assert(r.lengthSquared() > 0.0);\n    r.normalize();\n\n    // v is perpendicular to the segment.\n    const v = Vec2.crossNumVec2(1.0, r);\n    const abs_v = Vec2.abs(v);\n\n    // Separating axis for segment (Gino, p80).\n    // |dot(v, p1 - c)| > dot(|v|, h)\n\n    let maxFraction = input.maxFraction;\n\n    // Build a bounding box for the segment.\n    const segmentAABB = new AABB();\n    let t = Vec2.combine((1 - maxFraction), p1, maxFraction, p2);\n    segmentAABB.combinePoints(p1, t);\n\n    const stack = this.stackPool.allocate();\n    const subInput = this.inputPool.allocate();\n\n    stack.push(this.m_root);\n    while (stack.length > 0) {\n      const node = stack.pop();\n      if (node == null) {\n        continue;\n      }\n\n      if (AABB.testOverlap(node.aabb, segmentAABB) === false) {\n        continue;\n      }\n\n      // Separating axis for segment (Gino, p80).\n      // |dot(v, p1 - c)| > dot(|v|, h)\n      const c = node.aabb.getCenter();\n      const h = node.aabb.getExtents();\n      const separation = Math.abs(Vec2.dot(v, Vec2.sub(p1, c))) - Vec2.dot(abs_v, h);\n      if (separation > 0.0) {\n        continue;\n      }\n\n      if (node.isLeaf()) {\n        subInput.p1 = Vec2.clone(input.p1);\n        subInput.p2 = Vec2.clone(input.p2);\n        subInput.maxFraction = maxFraction;\n\n        const value = rayCastCallback(subInput, node.id);\n\n        if (value === 0.0) {\n          // The client has terminated the ray cast.\n          return;\n        }\n\n        if (value > 0.0) {\n          // update segment bounding box.\n          maxFraction = value;\n          t = Vec2.combine((1 - maxFraction), p1, maxFraction, p2);\n          segmentAABB.combinePoints(p1, t);\n        }\n      } else {\n        stack.push(node.child1);\n        stack.push(node.child2);\n      }\n    }\n    this.stackPool.release(stack);\n    this.inputPool.release(subInput);\n  }\n\n  private inputPool: Pool<RayCastInput> = new Pool<RayCastInput>({\n    create(): RayCastInput {\n      // tslint:disable-next-line:no-object-literal-type-assertion\n      return {} as RayCastInput;\n    },\n    release(stack: RayCastInput): void {\n    }\n  });\n\n  private stackPool: Pool<Array<TreeNode<T>>> = new Pool<Array<TreeNode<T>>>({\n    create(): Array<TreeNode<T>> {\n      return [];\n    },\n    release(stack: Array<TreeNode<T>>): void {\n      stack.length = 0;\n    }\n  });\n\n  private iteratorPool: Pool<Iterator<T>> = new Pool<Iterator<T>>({\n    create(): Iterator<T> {\n      return new Iterator();\n    },\n    release(iterator: Iterator<T>): void {\n      iterator.close();\n    }\n  });\n\n}\n\nclass Iterator<T> {\n  parents: Array<TreeNode<T>> = [];\n  states: number[] = [];\n  preorder(root: TreeNode<T>): Iterator<T> {\n    this.parents.length = 0;\n    this.parents.push(root);\n    this.states.length = 0;\n    this.states.push(0);\n    return this;\n  }\n  next(): TreeNode<T> {\n    while (this.parents.length > 0) {\n      const i = this.parents.length - 1;\n      const node = this.parents[i];\n      if (this.states[i] === 0) {\n        this.states[i] = 1;\n        return node;\n      }\n      if (this.states[i] === 1) {\n        this.states[i] = 2;\n        if (node.child1) {\n          this.parents.push(node.child1);\n          this.states.push(1);\n          return node.child1;\n        }\n      }\n      if (this.states[i] === 2) {\n        this.states[i] = 3;\n        if (node.child2) {\n          this.parents.push(node.child2);\n          this.states.push(1);\n          return node.child2;\n        }\n      }\n      this.parents.pop();\n      this.states.pop();\n    }\n  }\n  close(): void {\n    this.parents.length = 0;\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { Vec2Value } from '../common/Vec2';\nimport { AABB, RayCastCallback, RayCastInput } from './AABB';\nimport { DynamicTree, DynamicTreeQueryCallback } from './DynamicTree';\nimport { FixtureProxy } from \"../dynamics/Fixture\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\n/**\n * The broad-phase wraps and extends a dynamic-tree to keep track of moved\n * objects and query them on update.\n */\nexport class BroadPhase {\n  m_tree: DynamicTree<FixtureProxy> = new DynamicTree<FixtureProxy>();\n  m_moveBuffer: number[] = [];\n\n  m_callback: (userDataA: any, userDataB: any) => void;\n  m_queryProxyId: number;\n\n  /**\n   * Get user data from a proxy. Returns null if the id is invalid.\n   */\n  getUserData(proxyId: number): FixtureProxy {\n    return this.m_tree.getUserData(proxyId);\n  }\n\n  /**\n   * Test overlap of fat AABBs.\n   */\n  testOverlap(proxyIdA: number, proxyIdB: number): boolean {\n    const aabbA = this.m_tree.getFatAABB(proxyIdA);\n    const aabbB = this.m_tree.getFatAABB(proxyIdB);\n    return AABB.testOverlap(aabbA, aabbB);\n  }\n\n  /**\n   * Get the fat AABB for a proxy.\n   */\n  getFatAABB(proxyId: number): AABB {\n    return this.m_tree.getFatAABB(proxyId);\n  }\n\n  /**\n   * Get the number of proxies.\n   */\n  getProxyCount(): number {\n    return this.m_moveBuffer.length;\n  }\n\n  /**\n   * Get the height of the embedded tree.\n   */\n  getTreeHeight(): number {\n    return this.m_tree.getHeight();\n  }\n\n  /**\n   * Get the balance (integer) of the embedded tree.\n   */\n  getTreeBalance(): number {\n    return this.m_tree.getMaxBalance();\n  }\n\n  /**\n   * Get the quality metric of the embedded tree.\n   */\n  getTreeQuality(): number {\n    return this.m_tree.getAreaRatio();\n  }\n\n  /**\n   * Query an AABB for overlapping proxies. The callback class is called for each\n   * proxy that overlaps the supplied AABB.\n   */\n  query = (aabb: AABB, queryCallback: DynamicTreeQueryCallback): void => {\n    this.m_tree.query(aabb, queryCallback);\n  }\n\n  /**\n   * Ray-cast against the proxies in the tree. This relies on the callback to\n   * perform a exact ray-cast in the case were the proxy contains a shape. The\n   * callback also performs the any collision filtering. This has performance\n   * roughly equal to k * log(n), where k is the number of collisions and n is the\n   * number of proxies in the tree.\n   *\n   * @param input The ray-cast input data. The ray extends from `p1` to `p1 + maxFraction * (p2 - p1)`.\n   * @param rayCastCallback A function that is called for each proxy that is hit by the ray.\n   */\n  rayCast(input: RayCastInput, rayCastCallback: RayCastCallback): void {\n    this.m_tree.rayCast(input, rayCastCallback);\n  }\n\n  /**\n   * Shift the world origin. Useful for large worlds. The shift formula is:\n   * position -= newOrigin\n   *\n   * @param newOrigin The new origin with respect to the old origin\n   */\n  shiftOrigin(newOrigin: Vec2Value): void {\n    this.m_tree.shiftOrigin(newOrigin);\n  }\n\n  /**\n   * Create a proxy with an initial AABB. Pairs are not reported until UpdatePairs\n   * is called.\n   */\n  createProxy(aabb: AABB, userData: FixtureProxy): number {\n    _ASSERT && console.assert(AABB.isValid(aabb));\n    const proxyId = this.m_tree.createProxy(aabb, userData);\n    this.bufferMove(proxyId);\n    return proxyId;\n  }\n\n  /**\n   * Destroy a proxy. It is up to the client to remove any pairs.\n   */\n  destroyProxy(proxyId: number): void {\n    this.unbufferMove(proxyId);\n    this.m_tree.destroyProxy(proxyId);\n  }\n\n  /**\n   * Call moveProxy as many times as you like, then when you are done call\n   * UpdatePairs to finalized the proxy pairs (for your time step).\n   */\n  moveProxy(proxyId: number, aabb: AABB, displacement: Vec2Value): void {\n    _ASSERT && console.assert(AABB.isValid(aabb));\n    const changed = this.m_tree.moveProxy(proxyId, aabb, displacement);\n    if (changed) {\n      this.bufferMove(proxyId);\n    }\n  }\n\n  /**\n   * Call to trigger a re-processing of it's pairs on the next call to\n   * UpdatePairs.\n   */\n  touchProxy(proxyId: number): void {\n    this.bufferMove(proxyId);\n  }\n\n  bufferMove(proxyId: number): void {\n    this.m_moveBuffer.push(proxyId);\n  }\n\n  unbufferMove(proxyId: number): void {\n    for (let i = 0; i < this.m_moveBuffer.length; ++i) {\n      if (this.m_moveBuffer[i] === proxyId) {\n        this.m_moveBuffer[i] = null;\n      }\n    }\n  }\n\n  /**\n   * Update the pairs. This results in pair callbacks. This can only add pairs.\n   */\n  updatePairs(addPairCallback: (userDataA: FixtureProxy, userDataB: FixtureProxy) => void): void {\n    _ASSERT && console.assert(typeof addPairCallback === 'function');\n    this.m_callback = addPairCallback;\n\n    // Perform tree queries for all moving proxies.\n    while (this.m_moveBuffer.length > 0) {\n      this.m_queryProxyId = this.m_moveBuffer.pop();\n      if (this.m_queryProxyId === null) {\n        continue;\n      }\n\n      // We have to query the tree with the fat AABB so that\n      // we don't fail to create a pair that may touch later.\n      const fatAABB = this.m_tree.getFatAABB(this.m_queryProxyId);\n\n      // Query tree, create pairs and add them pair buffer.\n      this.m_tree.query(fatAABB, this.queryCallback);\n    }\n\n    // Try to keep the tree balanced.\n    // this.m_tree.rebalance(4);\n  }\n\n  queryCallback = (proxyId: number): boolean => {\n    // A proxy cannot form a pair with itself.\n    if (proxyId === this.m_queryProxyId) {\n      return true;\n    }\n\n    const proxyIdA = Math.min(proxyId, this.m_queryProxyId);\n    const proxyIdB = Math.max(proxyId, this.m_queryProxyId);\n\n    // TODO: Skip any duplicate pairs.\n\n    const userDataA = this.m_tree.getUserData(proxyIdA);\n    const userDataB = this.m_tree.getUserData(proxyIdB);\n\n    // Send the pairs back to the client.\n    this.m_callback(userDataA, userDataB);\n\n    return true;\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2023 Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { RotValue } from \"./Rot\";\nimport { TransformValue } from \"./Transform\";\nimport { Vec2Value } from \"./Vec2\";\nimport { Vec3Value } from \"./Vec3\";\n\nexport function vec2(x: number, y: number): Vec2Value {\n  return { x, y };\n}\n\nexport function vec3(x: number, y: number, z: number): Vec3Value {\n  return { x, y, z };\n}\n\nexport function rotation(angle: number): RotValue {\n  return { s: Math.sin(angle), c: Math.cos(angle) };\n}\n\nexport function setVec2(out: Vec2Value, x: number, y: number): Vec2Value {\n  out.x = x;\n  out.y = y;\n  return out;\n}\n\nexport function copyVec2(out: Vec2Value, w: Vec2Value): Vec2Value {\n  out.x = w.x;\n  out.y = w.y;\n  return out;\n}\n\nexport function zeroVec2(out: Vec2Value): Vec2Value {\n  out.x = 0;\n  out.y = 0;\n  return out;\n}\n\nexport function negVec2(out: Vec2Value): Vec2Value {\n  out.x = -out.x;\n  out.y = -out.y;\n  return out;\n}\n\nexport function addVec2(out: Vec2Value, w: Vec2Value): Vec2Value {\n  out.x += w.x;\n  out.y += w.y;\n  return out;\n}\n\nexport function sumVec2(out: Vec2Value, v: Vec2Value, w: Vec2Value): Vec2Value {\n  out.x = v.x + w.x;\n  out.y = v.x + w.y;\n  return out;\n}\n\nexport function subVec2(out: Vec2Value, w: Vec2Value): Vec2Value {\n  out.x -= w.x;\n  out.y -= w.y;\n  return out;\n}\n\nexport function diffVec2(out: Vec2Value, v: Vec2Value, w: Vec2Value): Vec2Value {\n  out.x = v.x - w.x;\n  out.y = v.y - w.y;\n  return out;\n}\n\nexport function scaleVec2(out: Vec2Value, m: number): Vec2Value {\n  out.x *= m;\n  out.y *= m;\n  return out;\n}\n\nexport function setMulVec2(out: Vec2Value, m: number, w: Vec2Value): Vec2Value {\n  out.x = m * w.x;\n  out.y = m * w.y;\n  return out;\n}\n\nexport function addMulVec2(out: Vec2Value, m: number, w: Vec2Value): Vec2Value {\n  out.x += m * w.x;\n  out.y += m * w.y;\n  return out;\n}\n\nexport function subMulVec2(out: Vec2Value, m: number, w: Vec2Value): Vec2Value {\n  out.x -= m * w.x;\n  out.y -= m * w.y;\n  return out;\n}\n\nexport function combineVec2(out: Vec2Value, am: number, a: Vec2Value, bm: number, b: Vec2Value): Vec2Value {\n  out.x = am * a.x + bm * b.x;\n  out.y = am * a.y + bm * b.y;\n  return out;\n}\n\nexport function normalizeVec2Length(out: Vec2Value): number {\n  const length = Math.sqrt(out.x * out.x + out.y * out.y);\n  if (length !== 0) {\n    const invLength = 1 / length;\n    out.x *= invLength;\n    out.y *= invLength;\n  }\n  return length;\n}\n\nexport function normalizeVec2(out: Vec2Value): Vec2Value {\n  const length = Math.sqrt(out.x * out.x + out.y * out.y);\n  if (length > 0) {\n    const invLength = 1 / length;\n    out.x *= invLength;\n    out.y *= invLength;\n  }\n  return out;\n}\n\nexport function crossVec2Num(out: Vec2Value, v: Vec2Value, w: number): Vec2Value {\n  const x = w * v.y;\n  const y = -w * v.x;\n  out.x = x;\n  out.y = y;\n  return out;\n}\n\nexport function crossNumVec2(out: Vec2Value, w: number, v: Vec2Value): Vec2Value {\n  const x = -w * v.y;\n  const y = w * v.x;\n  out.x = x;\n  out.y = y;\n  return out;\n}\n\nexport function crossVec2Vec2(a: Vec2Value, b: Vec2Value): number {\n  return a.x * b.y - a.y * b.x;\n}\n\nexport function dotVec2(a: Vec2Value, b: Vec2Value): number {\n  return a.x * b.x + a.y * b.y;\n}\n\nexport function lengthVec2(a: Vec2Value): number {\n  return Math.sqrt(a.x * a.x + a.y * a.y);\n}\n\nexport function lengthSqrVec2(a: Vec2Value): number {\n  return a.x * a.x + a.y * a.y;\n}\n\nexport function distVec2(a: Vec2Value, b: Vec2Value): number {\n  const dx = a.x - b.x;\n  const dy = a.y - b.y;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nexport function distSqrVec2(a: Vec2Value, b: Vec2Value): number {\n  const dx = a.x - b.x;\n  const dy = a.y - b.y;\n  return dx * dx + dy * dy;\n}\n\nexport function dotVec3(v: Vec3Value, w: Vec3Value): number {\n  return v.x * w.x + v.y * w.y + v.z * w.z;\n}\n\nexport function setRotAngle(out: RotValue, a: number): RotValue {\n  out.c = Math.cos(a);\n  out.s = Math.sin(a);\n  return out;\n}\n\nexport function rotVec2(out: Vec2Value, q: RotValue, v: Vec2Value): Vec2Value {\n  out.x = q.c * v.x - q.s * v.y;\n  out.y = q.s * v.x + q.c * v.y;\n  return out;\n}\n\nexport function invRotVec2(out: Vec2Value, q: RotValue, v: Vec2Value): Vec2Value {\n  const x = q.c * v.x + q.s * v.y;\n  const y = -q.s * v.x + q.c * v.y;\n  out.x = x;\n  out.y = y;\n  return out;\n}\n\nexport function rerotVec2(out: Vec2Value, before: RotValue, after: RotValue, v: Vec2Value): Vec2Value {\n  const x0 = before.c * v.x + before.s * v.y;\n  const y0 = -before.s * v.x + before.c * v.y;\n  const x = after.c * x0 - after.s * y0;\n  const y = after.s * x0 + after.c * y0;\n  out.x = x;\n  out.y = y;\n  return out;\n}\n\nexport function transform(x: number, y: number, a: number): TransformValue {\n  return { p: vec2(x, y), q: rotation(a) };\n}\n\nexport function copyTransform(out: TransformValue, transform: TransformValue): TransformValue {\n  out.p.x = transform.p.x;\n  out.p.y = transform.p.y;\n  out.q.s = transform.q.s;\n  out.q.c = transform.q.c;\n  return out;\n}\n\nexport function transformVec2(out: Vec2Value, xf: TransformValue, v: Vec2Value): Vec2Value {\n  const x = xf.q.c * v.x - xf.q.s * v.y + xf.p.x;\n  const y = xf.q.s * v.x + xf.q.c * v.y + xf.p.y;\n  out.x = x;\n  out.y = y;\n  return out;\n}\n\nexport function invTransformVec2(out: Vec2Value, xf: TransformValue, v: Vec2Value): Vec2Value {\n  const px = v.x - xf.p.x;\n  const py = v.y - xf.p.y;\n  const x = (xf.q.c * px + xf.q.s * py);\n  const y = (-xf.q.s * px + xf.q.c * py);\n  out.x = x;\n  out.y = y;\n  return out;\n}\n\nexport function retransformVec2(out: Vec2Value, from: TransformValue, to: TransformValue, v: Vec2Value): Vec2Value {\n  const x0 = from.q.c * v.x - from.q.s * v.y + from.p.x;\n  const y0 = from.q.s * v.x + from.q.c * v.y + from.p.y;\n  const px = x0 - to.p.x;\n  const py = y0 - to.p.y;\n  const x = to.q.c * px + to.q.s * py;\n  const y = -to.q.s * px + to.q.c * py;\n  out.x = x;\n  out.y = y;\n  return out;\n}\n\nexport function invTransformTransform(out: TransformValue, a: TransformValue, b: TransformValue): TransformValue {\n  const c = a.q.c * b.q.c + a.q.s * b.q.s;\n  const s = a.q.c * b.q.s - a.q.s * b.q.c;\n  const x = a.q.c * (b.p.x - a.p.x) + a.q.s * (b.p.y - a.p.y);\n  const y = -a.q.s * (b.p.x - a.p.x) + a.q.c * (b.p.y - a.p.y);\n  out.q.c = c;\n  out.q.s = s;\n  out.p.x = x;\n  out.p.y = y;\n  return out;\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { Vec2, Vec2Value } from './Vec2';\nimport { math as Math } from './Math';\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\nconst _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\nexport interface RotValue {\n  s: number;\n  c: number;\n}\n\nexport class Rot {\n  s: number;\n  c: number;\n\n  /** Initialize from an angle in radians. */\n  constructor(angle?: number | RotValue) {\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof Rot)) {\n      return new Rot(angle);\n    }\n    if (typeof angle === 'number') {\n      this.setAngle(angle);\n    } else if (typeof angle === 'object') {\n      this.setRot(angle);\n    } else {\n      this.setIdentity();\n    }\n  }\n\n  /** @internal */\n  static neo(angle: number): Rot {\n    const obj = Object.create(Rot.prototype);\n    obj.setAngle(angle);\n    return obj;\n  }\n\n  static clone(rot: RotValue): Rot {\n    _ASSERT && Rot.assert(rot);\n    const obj = Object.create(Rot.prototype);\n    obj.s = rot.s;\n    obj.c = rot.c;\n    return obj;\n  }\n\n  static identity(): Rot {\n    const obj = Object.create(Rot.prototype);\n    obj.s = 0.0;\n    obj.c = 1.0;\n    return obj;\n  }\n\n  static isValid(obj: any): boolean {\n    if (obj === null || typeof obj === 'undefined') {\n      return false;\n    }\n    return Math.isFinite(obj.s) && Math.isFinite(obj.c);\n  }\n\n  static assert(o: any): void {\n    _ASSERT && console.assert(!Rot.isValid(o), 'Invalid Rot!', o);\n  }\n\n  /** Set to the identity rotation. */\n  setIdentity(): void {\n    this.s = 0.0;\n    this.c = 1.0;\n  }\n\n  set(angle: number | RotValue): void {\n    if (typeof angle === 'object') {\n      _ASSERT && Rot.assert(angle);\n      this.s = angle.s;\n      this.c = angle.c;\n\n    } else {\n      _ASSERT && Math.assert(angle);\n      // TODO_ERIN optimize\n      this.s = Math.sin(angle);\n      this.c = Math.cos(angle);\n    }\n  }\n\n  setRot(angle: RotValue): void {\n    _ASSERT && Rot.assert(angle);\n    this.s = angle.s;\n    this.c = angle.c;\n  }\n\n  /** Set using an angle in radians. */\n  setAngle(angle: number): void {\n    _ASSERT && Math.assert(angle);\n    // TODO_ERIN optimize\n    this.s = Math.sin(angle);\n    this.c = Math.cos(angle);\n  }\n\n  /** Get the angle in radians. */\n  getAngle(): number {\n    return Math.atan2(this.s, this.c);\n  }\n\n  /** Get the x-axis. */\n  getXAxis(): Vec2 {\n    return Vec2.neo(this.c, this.s);\n  }\n\n  /** Get the u-axis. */\n  getYAxis(): Vec2 {\n    return Vec2.neo(-this.s, this.c);\n  }\n\n  /** Multiply two rotations: q * r */\n  static mul(rot: RotValue, m: RotValue): Rot;\n  /** Rotate a vector */\n  static mul(rot: RotValue, m: Vec2Value): Vec2;\n  // tslint:disable-next-line:typedef\n  static mul(rot, m) {\n    _ASSERT && Rot.assert(rot);\n    if ('c' in m && 's' in m) {\n      _ASSERT && Rot.assert(m);\n      // [qc -qs] * [rc -rs] = [qc*rc-qs*rs -qc*rs-qs*rc]\n      // [qs qc] [rs rc] [qs*rc+qc*rs -qs*rs+qc*rc]\n      // s = qs * rc + qc * rs\n      // c = qc * rc - qs * rs\n      const qr = Rot.identity();\n      qr.s = rot.s * m.c + rot.c * m.s;\n      qr.c = rot.c * m.c - rot.s * m.s;\n      return qr;\n\n    } else if ('x' in m && 'y' in m) {\n      _ASSERT && Vec2.assert(m);\n      return Vec2.neo(rot.c * m.x - rot.s * m.y, rot.s * m.x + rot.c * m.y);\n    }\n  }\n\n  /** Multiply two rotations: q * r */\n  static mulRot(rot: RotValue, m: RotValue): Rot {\n    _ASSERT && Rot.assert(rot);\n    _ASSERT && Rot.assert(m);\n    // [qc -qs] * [rc -rs] = [qc*rc-qs*rs -qc*rs-qs*rc]\n    // [qs qc] [rs rc] [qs*rc+qc*rs -qs*rs+qc*rc]\n    // s = qs * rc + qc * rs\n    // c = qc * rc - qs * rs\n    const qr = Rot.identity();\n    qr.s = rot.s * m.c + rot.c * m.s;\n    qr.c = rot.c * m.c - rot.s * m.s;\n    return qr;\n  }\n\n  /** Rotate a vector */\n  static mulVec2(rot: RotValue, m: Vec2Value): Vec2 {\n    _ASSERT && Rot.assert(rot);\n    _ASSERT && Vec2.assert(m);\n    return Vec2.neo(rot.c * m.x - rot.s * m.y, rot.s * m.x + rot.c * m.y);\n  }\n\n  static mulSub(rot: RotValue, v: Vec2Value, w: Vec2Value): Vec2 {\n    const x = rot.c * (v.x - w.x) - rot.s * (v.y - w.y);\n    const y = rot.s * (v.x - w.x) + rot.c * (v.y - w.y);\n    return Vec2.neo(x, y);\n  }\n\n  /** Transpose multiply two rotations: qT * r */\n  static mulT(rot: RotValue, m: RotValue): Rot;\n  /** Inverse rotate a vector */\n  static mulT(rot: RotValue, m: Vec2Value): Vec2;\n  // tslint:disable-next-line:typedef\n  static mulT(rot, m) {\n    if ('c' in m && 's' in m) {\n      _ASSERT && Rot.assert(m);\n      // [ qc qs] * [rc -rs] = [qc*rc+qs*rs -qc*rs+qs*rc]\n      // [-qs qc] [rs rc] [-qs*rc+qc*rs qs*rs+qc*rc]\n      // s = qc * rs - qs * rc\n      // c = qc * rc + qs * rs\n      const qr = Rot.identity();\n      qr.s = rot.c * m.s - rot.s * m.c;\n      qr.c = rot.c * m.c + rot.s * m.s;\n      return qr;\n\n    } else if ('x' in m && 'y' in m) {\n      _ASSERT && Vec2.assert(m);\n      return Vec2.neo(rot.c * m.x + rot.s * m.y, -rot.s * m.x + rot.c * m.y);\n    }\n  }\n\n  /** Transpose multiply two rotations: qT * r */\n  static mulTRot(rot: RotValue, m: RotValue): Rot {\n    _ASSERT && Rot.assert(m);\n    // [ qc qs] * [rc -rs] = [qc*rc+qs*rs -qc*rs+qs*rc]\n    // [-qs qc] [rs rc] [-qs*rc+qc*rs qs*rs+qc*rc]\n    // s = qc * rs - qs * rc\n    // c = qc * rc + qs * rs\n    const qr = Rot.identity();\n    qr.s = rot.c * m.s - rot.s * m.c;\n    qr.c = rot.c * m.c + rot.s * m.s;\n    return qr;\n  }\n\n  /** Inverse rotate a vector */\n  static mulTVec2(rot: RotValue, m: Vec2Value): Vec2 {\n    _ASSERT && Vec2.assert(m);\n    return Vec2.neo(rot.c * m.x + rot.s * m.y, -rot.s * m.x + rot.c * m.y);\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport * as matrix from './Matrix';\nimport { math as Math } from './Math';\nimport { Vec2, Vec2Value } from './Vec2';\nimport { TransformValue } from './Transform';\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nconst temp = matrix.vec2(0, 0);\n\n/**\n * This describes the motion of a body/shape for TOI computation. Shapes are\n * defined with respect to the body origin, which may not coincide with the\n * center of mass. However, to support dynamics we must interpolate the center\n * of mass position.\n */\nexport class Sweep {\n  /** Local center of mass position */\n  localCenter = Vec2.zero();\n\n  /** World center position */\n  c = Vec2.zero();\n\n  /** World angle */\n  a = 0;\n\n  /** Fraction of the current time step in the range [0,1], c0 and a0 are c and a at alpha0. */\n  alpha0 = 0;\n\n  c0 = Vec2.zero();\n  a0 = 0;\n\n  /** @internal */\n  recycle() {\n    matrix.zeroVec2(this.localCenter)\n    matrix.zeroVec2(this.c)\n    this.a = 0;\n    this.alpha0 = 0;\n    matrix.zeroVec2(this.c0)\n    this.a0 = 0;\n  }\n\n  setTransform(xf: TransformValue): void {\n    matrix.transformVec2(temp, xf, this.localCenter);\n    matrix.copyVec2(this.c, temp);\n    matrix.copyVec2(this.c0, temp);\n\n    this.a = this.a0 = Math.atan2(xf.q.s, xf.q.c);\n  }\n\n  setLocalCenter(localCenter: Vec2Value, xf: TransformValue): void {\n    matrix.copyVec2(this.localCenter, localCenter);\n\n    matrix.transformVec2(temp, xf, this.localCenter);\n    matrix.copyVec2(this.c, temp);\n    matrix.copyVec2(this.c0, temp);\n  }\n\n  /**\n   * Get the interpolated transform at a specific time.\n   *\n   * @param xf\n   * @param beta A factor in [0,1], where 0 indicates alpha0\n   */\n  getTransform(xf: TransformValue, beta: number = 0): void {\n    matrix.setRotAngle(xf.q, (1.0 - beta) * this.a0 + beta * this.a);\n    matrix.combineVec2(xf.p, (1.0 - beta), this.c0, beta, this.c);\n\n    // shift to origin\n    matrix.subVec2(xf.p, matrix.rotVec2(temp, xf.q, this.localCenter));\n  }\n\n  /**\n   * Advance the sweep forward, yielding a new initial state.\n   *\n   * @param alpha The new initial time\n   */\n  advance(alpha: number): void {\n    _ASSERT && console.assert(this.alpha0 < 1.0);\n    const beta = (alpha - this.alpha0) / (1.0 - this.alpha0);\n    matrix.combineVec2(this.c0, beta, this.c, 1 - beta, this.c0);\n    this.a0 = beta * this.a + (1 - beta) * this.a0;\n    this.alpha0 = alpha;\n  }\n\n  forward(): void {\n    this.a0 = this.a;\n    matrix.copyVec2(this.c0, this.c);\n  }\n\n  /**\n   * normalize the angles in radians to be between -pi and pi.\n   */\n  normalize(): void {\n    const a0 = Math.mod(this.a0, -Math.PI, +Math.PI);\n    this.a -= this.a0 - a0;\n    this.a0 = a0;\n  }\n\n  set(that: Sweep): void {\n    matrix.copyVec2(this.localCenter, that.localCenter);\n    matrix.copyVec2(this.c, that.c);\n    this.a = that.a;\n    this.alpha0 = that.alpha0;\n    matrix.copyVec2(this.c0, that.c0);\n    this.a0 = that.a0;\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { Vec2, Vec2Value } from './Vec2';\nimport { Rot, RotValue } from './Rot';\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\nconst _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\nexport type TransformValue = {\n  p: Vec2Value;\n  q: RotValue;\n};\n\n/**\n * A transform contains translation and rotation. It is used to represent the\n * position and orientation of rigid frames. Initialize using a position vector\n * and a rotation.\n */\nexport class Transform {\n  /** position */\n  p: Vec2;\n\n  /** rotation */\n  q: Rot;\n\n  constructor(position?: Vec2Value, rotation?: number) {\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof Transform)) {\n      return new Transform(position, rotation);\n    }\n    this.p = Vec2.zero();\n    this.q = Rot.identity();\n    if (typeof position !== 'undefined') {\n      this.p.setVec2(position);\n    }\n    if (typeof rotation !== 'undefined') {\n      this.q.setAngle(rotation);\n    }\n  }\n\n  static clone(xf: Transform): Transform {\n    const obj = Object.create(Transform.prototype);\n    obj.p = Vec2.clone(xf.p);\n    obj.q = Rot.clone(xf.q);\n    return obj;\n  }\n\n  /** @internal */\n  static neo(position: Vec2Value, rotation: Rot): Transform {\n    const obj = Object.create(Transform.prototype);\n    obj.p = Vec2.clone(position);\n    obj.q = Rot.clone(rotation);\n    return obj;\n  }\n\n  static identity(): Transform {\n    const obj = Object.create(Transform.prototype);\n    obj.p = Vec2.zero();\n    obj.q = Rot.identity();\n    return obj;\n  }\n\n  /**\n   * Set this to the identity transform.\n   */\n  setIdentity(): void {\n    this.p.setZero();\n    this.q.setIdentity();\n  }\n\n  set(position: Vec2Value, rotation: number): void;\n  set(xf: TransformValue): void;\n  /**\n   * Set this based on the position and angle.\n   */\n  // tslint:disable-next-line:typedef\n  set(a, b?) {\n    if (typeof b === 'undefined') {\n      this.p.set(a.p);\n      this.q.set(a.q);\n    } else {\n      this.p.set(a);\n      this.q.set(b);\n    }\n  }\n\n  /**\n   * Set this based on the position and angle.\n   */\n  setNum(position: Vec2Value, rotation: number) {\n    this.p.setVec2(position);\n    this.q.setAngle(rotation);\n  }\n\n  setTransform(xf: TransformValue): void {\n    this.p.setVec2(xf.p);\n    this.q.setRot(xf.q);\n  }\n\n  static isValid(obj: any): boolean {\n    if (obj === null || typeof obj === 'undefined') {\n      return false;\n    }\n    return Vec2.isValid(obj.p) && Rot.isValid(obj.q);\n  }\n\n  static assert(o: any): void {\n    _ASSERT && console.assert(!Transform.isValid(o), 'Invalid Transform!', o);\n  }\n\n  static mul(a: TransformValue, b: Vec2Value): Vec2;\n  static mul(a: TransformValue, b: TransformValue): Transform;\n  // static mul(a: Transform, b: Vec2Value[]): Vec2[];\n  // static mul(a: Transform, b: Transform[]): Transform[];\n  // tslint:disable-next-line:typedef\n  static mul(a, b) {\n    if (Array.isArray(b)) {\n      _ASSERT && Transform.assert(a);\n      const arr = [];\n      for (let i = 0; i < b.length; i++) {\n        arr[i] = Transform.mul(a, b[i]);\n      }\n      return arr;\n\n    } else if ('x' in b && 'y' in b) {\n      return Transform.mulVec2(a, b);\n\n    } else if ('p' in b && 'q' in b) {\n      return Transform.mulXf(a, b);\n    }\n  }\n\n  static mulAll(a: Transform, b: Vec2Value[]): Vec2[];\n  static mulAll(a: Transform, b: Transform[]): Transform[];\n  // tslint:disable-next-line:typedef\n  static mulAll(a: TransformValue, b) {\n    _ASSERT && Transform.assert(a);\n    const arr = [];\n    for (let i = 0; i < b.length; i++) {\n      arr[i] = Transform.mul(a, b[i]);\n    }\n    return arr;\n  }\n\n  /** @internal @deprecated */\n  // tslint:disable-next-line:typedef\n  static mulFn(a: TransformValue) {\n    _ASSERT && Transform.assert(a);\n    return function(b: Vec2Value): Vec2 {\n      return Transform.mul(a, b);\n    };\n  }\n\n  static mulVec2(a: TransformValue, b: Vec2Value): Vec2 {\n    _ASSERT && Transform.assert(a);\n    _ASSERT && Vec2.assert(b);\n    const x = (a.q.c * b.x - a.q.s * b.y) + a.p.x;\n    const y = (a.q.s * b.x + a.q.c * b.y) + a.p.y;\n    return Vec2.neo(x, y);\n  }\n\n  static mulXf(a: TransformValue, b: TransformValue): Transform {\n    _ASSERT && Transform.assert(a);\n    _ASSERT && Transform.assert(b);\n    // v2 = A.q.Rot(B.q.Rot(v1) + B.p) + A.p\n    // = (A.q * B.q).Rot(v1) + A.q.Rot(B.p) + A.p\n    const xf = Transform.identity();\n    xf.q = Rot.mulRot(a.q, b.q);\n    xf.p = Vec2.add(Rot.mulVec2(a.q, b.p), a.p);\n    return xf;\n  }\n\n  static mulT(a: TransformValue, b: Vec2Value): Vec2;\n  static mulT(a: TransformValue, b: TransformValue): Transform;\n  // tslint:disable-next-line:typedef\n  static mulT(a, b) {\n    if ('x' in b && 'y' in b) {\n      return Transform.mulTVec2(a, b);\n\n    } else if ('p' in b && 'q' in b) {\n      return Transform.mulTXf(a, b);\n    }\n  }\n\n  static mulTVec2(a: TransformValue, b: Vec2Value): Vec2 {\n    _ASSERT && Transform.assert(a);\n    _ASSERT && Vec2.assert(b);\n    const px = b.x - a.p.x;\n    const py = b.y - a.p.y;\n    const x = (a.q.c * px + a.q.s * py);\n    const y = (-a.q.s * px + a.q.c * py);\n    return Vec2.neo(x, y);\n  }\n\n  static mulTXf(a: TransformValue, b: TransformValue): Transform {\n    _ASSERT && Transform.assert(a);\n    _ASSERT && Transform.assert(b);\n    // v2 = A.q' * (B.q * v1 + B.p - A.p)\n    // = A.q' * B.q * v1 + A.q' * (B.p - A.p)\n    const xf = Transform.identity();\n    xf.q.setRot(Rot.mulTRot(a.q, b.q));\n    xf.p.setVec2(Rot.mulTVec2(a.q, Vec2.sub(b.p, a.p)));\n    return xf;\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { Vec2 } from '../common/Vec2';\n\nexport class Velocity {\n  /** linear */\n  v = Vec2.zero();\n\n  /** angular */\n  w = 0;\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { Vec2, Vec2Value } from '../common/Vec2';\nimport { TransformValue } from '../common/Transform';\n\n\nexport class Position {\n  /** location */\n  c = Vec2.zero();\n\n  /** angle */\n  a = 0;\n\n  // todo: cache sin/cos\n  getTransform(xf: TransformValue, p: Vec2Value): TransformValue {\n    // xf.q = rotation(this.a);\n    // xf.p = this.c - xf.q * p\n    xf.q.c = Math.cos(this.a);\n    xf.q.s = Math.sin(this.a);\n    xf.p.x = this.c.x - (xf.q.c * p.x - xf.q.s * p.y);\n    xf.p.y = this.c.y - (xf.q.s * p.x + xf.q.c * p.y);\n    return xf;\n  }\n}\n\nexport function getTransform(xf: TransformValue, p: Vec2Value, c: Vec2Value, a: number): TransformValue {\n  // xf.q = rotation(a);\n  // xf.p = this.c - xf.q * p\n  xf.q.c = Math.cos(a);\n  xf.q.s = Math.sin(a);\n  xf.p.x = c.x - (xf.q.c * p.x - xf.q.s * p.y);\n  xf.p.y = c.y - (xf.q.s * p.x + xf.q.c * p.y);\n  return xf;\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport type { MassData } from '../dynamics/Body';\nimport { RayCastOutput, RayCastInput, AABBValue } from './AABB';\nimport { DistanceProxy } from './Distance';\nimport type { Transform, TransformValue }  from '../common/Transform';\nimport type { Vec2Value }  from '../common/Vec2';\n\n// todo make shape an interface\n\n/**\n * A shape is used for collision detection. You can create a shape however you\n * like. Shapes used for simulation in World are created automatically when a\n * Fixture is created. Shapes may encapsulate one or more child shapes.\n */\nexport abstract class Shape {\n  m_type: ShapeType;\n\n  /**\n   * Radius of a shape. For polygonal shapes this must be b2_polygonRadius.\n   * There is no support for making rounded polygons.\n   */\n  m_radius: number;\n\n  /** @internal */\n  abstract _reset(): void;\n\n  static isValid(obj: any): boolean {\n    if (obj === null || typeof obj === 'undefined') {\n      return false;\n    }\n    return typeof obj.m_type === 'string' && typeof obj.m_radius === 'number';\n  }\n\n  abstract getRadius(): number;\n\n  /**\n   * Get the type of this shape. You can use this to down cast to the concrete\n   * shape.\n   *\n   * @return the shape type.\n   */\n  abstract getType(): ShapeType;\n\n  /**\n   * @internal\n   * @deprecated Shapes should be treated as immutable.\n   *\n   * clone the concrete shape.\n   */\n  abstract _clone(): Shape;\n\n  /**\n   * Get the number of child primitives.\n   */\n  abstract getChildCount(): number;\n\n  /**\n   * Test a point for containment in this shape. This only works for convex\n   * shapes.\n   *\n   * @param xf The shape world transform.\n   * @param p A point in world coordinates.\n   */\n  abstract testPoint(xf: TransformValue, p: Vec2Value): boolean;\n\n  /**\n   * Cast a ray against a child shape.\n   *\n   * @param output The ray-cast results.\n   * @param input The ray-cast input parameters.\n   * @param xf The transform to be applied to the shape.\n   * @param childIndex The child shape index\n   */\n  abstract rayCast(output: RayCastOutput, input: RayCastInput, xf: Transform, childIndex: number): boolean;\n\n  /**\n   * Given a transform, compute the associated axis aligned bounding box for a\n   * child shape.\n   *\n   * @param aabb Returns the axis aligned box.\n   * @param xf The world transform of the shape.\n   * @param childIndex The child shape\n   */\n  abstract computeAABB(aabb: AABBValue, xf: TransformValue, childIndex: number): void;\n\n  /**\n   * Compute the mass properties of this shape using its dimensions and density.\n   * The inertia tensor is computed about the local origin.\n   *\n   * @param massData Returns the mass data for this shape.\n   * @param density The density in kilograms per meter squared.\n   */\n  abstract computeMass(massData: MassData, density?: number): void;\n\n  abstract computeDistanceProxy(proxy: DistanceProxy, childIndex: number): void;\n\n}\n\nexport type ShapeType = \"circle\" | \"edge\" | \"polygon\" | \"chain\";\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport * as matrix from '../common/Matrix';\nimport { options } from '../util/options';\nimport { math as Math } from '../common/Math';\nimport { Vec2Value } from '../common/Vec2';\nimport { AABB, RayCastInput, RayCastOutput } from '../collision/AABB';\nimport { Shape, ShapeType } from '../collision/Shape';\nimport { Body, MassData } from \"./Body\";\nimport { BroadPhase } from \"../collision/BroadPhase\";\nimport { TransformValue } from \"../common/Transform\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\nconst synchronize_aabb1 = new AABB();\nconst synchronize_aabb2 = new AABB();\nconst displacement = matrix.vec2(0, 0);\n\n/**\n * A fixture definition is used to create a fixture. This class defines an\n * abstract fixture definition. You can reuse fixture definitions safely.\n */\nexport interface FixtureOpt {\n  userData?: unknown;\n  /**\n   * The friction coefficient, usually in the range [0,1]\n   */\n  friction?: number;\n  /**\n   * The restitution (elasticity) usually in the range [0,1]\n   */\n  restitution?: number;\n  /**\n   * The density, usually in kg/m^2\n   */\n  density?: number;\n  /**\n   * A sensor shape collects contact information but never generates a collision response.\n   */\n  isSensor?: boolean;\n  /**\n   * Zero, positive or negative collision group.\n   * Fixtures with same positive groupIndex always collide and fixtures with same negative groupIndex never collide.\n   */\n  filterGroupIndex?: number;\n  /**\n   * Collision category bit or bits that this fixture belongs to.\n   * If groupIndex is zero or not matching, then at least one bit in this fixture categoryBits should match other fixture maskBits and vice versa.\n   */\n  filterCategoryBits?: number;\n  /**\n   * Collision category bit or bits that this fixture accept for collision.\n   */\n  filterMaskBits?: number;\n}\n\nexport interface FixtureDef extends FixtureOpt {\n  shape: Shape;\n}\n\nconst FixtureDefDefault: FixtureOpt = {\n  userData : null,\n  friction : 0.2,\n  restitution : 0.0,\n  density : 0.0,\n  isSensor : false,\n\n  filterGroupIndex : 0,\n  filterCategoryBits : 0x0001,\n  filterMaskBits : 0xFFFF\n};\n\n/**\n * This proxy is used internally to connect shape children to the broad-phase.\n */\nexport class FixtureProxy {\n  aabb: AABB;\n  fixture: Fixture;\n  childIndex: number;\n  proxyId: number;\n  constructor(fixture: Fixture, childIndex: number) {\n    this.aabb = new AABB();\n    this.fixture = fixture;\n    this.childIndex = childIndex;\n    this.proxyId;\n  }\n}\n\n/**\n * A fixture is used to attach a shape to a body for collision detection. A\n * fixture inherits its transform from its parent. Fixtures hold additional\n * non-geometric data such as friction, collision filters, etc.\n *\n * To create a new Fixture use {@link Body.createFixture}.\n */\nexport class Fixture {\n  /** @internal */ m_body: Body;\n  /** @internal */ m_friction: number;\n  /** @internal */ m_restitution: number;\n  /** @internal */ m_density: number;\n  /** @internal */ m_isSensor: boolean;\n  /** @internal */ m_filterGroupIndex: number;\n  /** @internal */ m_filterCategoryBits: number;\n  /** @internal */ m_filterMaskBits: number;\n  /** @internal */ m_shape: Shape;\n  /** @internal */ m_next: Fixture | null;\n  /** @internal */ m_proxies: FixtureProxy[];\n  /** @internal */ m_userData: unknown;\n\n  constructor(body: Body, def: FixtureDef);\n  constructor(body: Body, shape: Shape, def?: FixtureOpt);\n  constructor(body: Body, shape: Shape, density?: number);\n  // tslint:disable-next-line:typedef\n  /** @internal */ constructor(body: Body, shape?, def?) {\n    if (shape.shape) {\n      def = shape;\n      shape = shape.shape;\n\n    } else if (typeof def === 'number') {\n      def = {density : def};\n    }\n\n    def = options(def, FixtureDefDefault);\n\n    this.m_body = body;\n\n    this.m_friction = def.friction;\n    this.m_restitution = def.restitution;\n    this.m_density = def.density;\n    this.m_isSensor = def.isSensor;\n\n    this.m_filterGroupIndex = def.filterGroupIndex;\n    this.m_filterCategoryBits = def.filterCategoryBits;\n    this.m_filterMaskBits = def.filterMaskBits;\n\n    // TODO validate shape\n    this.m_shape = shape; // .clone();\n\n    this.m_next = null;\n\n    this.m_proxies = [];\n\n    const childCount = this.m_shape.getChildCount();\n    for (let i = 0; i < childCount; ++i) {\n      this.m_proxies[i] = new FixtureProxy(this, i);\n    }\n\n    this.m_userData = def.userData;\n  }\n\n  /**\n   * Re-setup fixture.\n   * @internal\n   */\n  _reset(): void {\n    const body = this.getBody();\n    const broadPhase = body.m_world.m_broadPhase;\n    this.destroyProxies(broadPhase);\n    if (this.m_shape._reset) {\n      this.m_shape._reset();\n    }\n    const childCount = this.m_shape.getChildCount();\n    for (let i = 0; i < childCount; ++i) {\n      this.m_proxies[i] = new FixtureProxy(this, i);\n    }\n    this.createProxies(broadPhase, body.m_xf);\n    body.resetMassData();\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      friction: this.m_friction,\n      restitution: this.m_restitution,\n      density: this.m_density,\n      isSensor: this.m_isSensor,\n\n      filterGroupIndex: this.m_filterGroupIndex,\n      filterCategoryBits: this.m_filterCategoryBits,\n      filterMaskBits: this.m_filterMaskBits,\n\n      shape: this.m_shape,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, body: any, restore: any): Fixture {\n    const shape = restore(Shape, data.shape);\n    const fixture = shape && new Fixture(body, shape, data);\n    return fixture;\n  }\n\n  /**\n   * Get the type of the child shape. You can use this to down cast to the\n   * concrete shape.\n   */\n  getType(): ShapeType {\n    return this.m_shape.m_type;\n  }\n\n  /**\n   * Get the child shape. You can modify the child shape, however you should not\n   * change the number of vertices because this will crash some collision caching\n   * mechanisms. Manipulating the shape may lead to non-physical behavior.\n   */\n  getShape(): Shape {\n    return this.m_shape;\n  }\n\n  /**\n   * A sensor shape collects contact information but never generates a collision\n   * response.\n   */\n  isSensor(): boolean {\n    return this.m_isSensor;\n  }\n\n  /**\n   * Set if this fixture is a sensor.\n   */\n  setSensor(sensor: boolean): void {\n    if (sensor != this.m_isSensor) {\n      this.m_body.setAwake(true);\n      this.m_isSensor = sensor;\n    }\n  }\n\n  // /**\n  //  * Get the contact filtering data.\n  //  */\n  // getFilterData() {\n  //   return this.m_filter;\n  // }\n\n  /**\n   * Get the user data that was assigned in the fixture definition. Use this to\n   * store your application specific data.\n   */\n  getUserData(): unknown {\n    return this.m_userData;\n  }\n\n  /**\n   * Set the user data. Use this to store your application specific data.\n   */\n  setUserData(data: unknown): void {\n    this.m_userData = data;\n  }\n\n  /**\n   * Get the parent body of this fixture. This is null if the fixture is not\n   * attached.\n   */\n  getBody(): Body {\n    return this.m_body;\n  }\n\n  /**\n   * Get the next fixture in the parent body's fixture list.\n   */\n  getNext(): Fixture | null {\n    return this.m_next;\n  }\n\n  /**\n   * Get the density of this fixture.\n   */\n  getDensity(): number {\n    return this.m_density;\n  }\n\n  /**\n   * Set the density of this fixture. This will _not_ automatically adjust the\n   * mass of the body. You must call Body.resetMassData to update the body's mass.\n   */\n  setDensity(density: number): void {\n    _ASSERT && console.assert(Math.isFinite(density) && density >= 0.0);\n    this.m_density = density;\n  }\n\n  /**\n   * Get the coefficient of friction, usually in the range [0,1].\n   */\n  getFriction(): number {\n    return this.m_friction;\n  }\n\n  /**\n   * Set the coefficient of friction. This will not change the friction of\n   * existing contacts.\n   */\n  setFriction(friction: number): void {\n    this.m_friction = friction;\n  }\n\n  /**\n   * Get the coefficient of restitution.\n   */\n  getRestitution(): number {\n    return this.m_restitution;\n  }\n\n  /**\n   * Set the coefficient of restitution. This will not change the restitution of\n   * existing contacts.\n   */\n  setRestitution(restitution: number): void {\n    this.m_restitution = restitution;\n  }\n\n  /**\n   * Test a point in world coordinates for containment in this fixture.\n   */\n  testPoint(p: Vec2Value): boolean {\n    return this.m_shape.testPoint(this.m_body.getTransform(), p);\n  }\n\n  /**\n   * Cast a ray against this shape.\n   */\n  rayCast(output: RayCastOutput, input: RayCastInput, childIndex: number): boolean {\n    return this.m_shape.rayCast(output, input, this.m_body.getTransform(), childIndex);\n  }\n\n  /**\n   * Get the mass data for this fixture. The mass data is based on the density and\n   * the shape. The rotational inertia is about the shape's origin. This operation\n   * may be expensive.\n   */\n  getMassData(massData: MassData): void {\n    this.m_shape.computeMass(massData, this.m_density);\n  }\n\n  /**\n   * Get the fixture's AABB. This AABB may be enlarge and/or stale. If you need a\n   * more accurate AABB, compute it using the shape and the body transform.\n   */\n  getAABB(childIndex: number): AABB {\n    _ASSERT && console.assert(0 <= childIndex && childIndex < this.m_proxies.length);\n    return this.m_proxies[childIndex].aabb;\n  }\n\n  /**\n   * These support body activation/deactivation.\n   */\n  createProxies(broadPhase: BroadPhase, xf: TransformValue): void {\n    _ASSERT && console.assert(this.m_proxies.length == 0);\n\n    // Create proxies in the broad-phase.\n    const childCount = this.m_shape.getChildCount();\n\n    for (let i = 0; i < childCount; ++i) {\n      const proxy = this.m_proxies[i];\n      this.m_shape.computeAABB(proxy.aabb, xf, i);\n      proxy.proxyId = broadPhase.createProxy(proxy.aabb, proxy);\n    }\n  }\n\n  destroyProxies(broadPhase: BroadPhase): void {\n    // Destroy proxies in the broad-phase.\n    for (let i = 0; i < this.m_proxies.length; ++i) {\n      const proxy = this.m_proxies[i];\n      broadPhase.destroyProxy(proxy.proxyId);\n      proxy.proxyId = null;\n      proxy.fixture = null;\n    }\n\n    this.m_proxies.length = 0;\n  }\n\n  /**\n   * Updates this fixture proxy in broad-phase (with combined AABB of current and\n   * next transformation).\n   */\n  synchronize(broadPhase: BroadPhase, xf1: TransformValue, xf2: TransformValue): void {\n    for (let i = 0; i < this.m_proxies.length; ++i) {\n      const proxy = this.m_proxies[i];\n      // Compute an AABB that covers the swept shape (may miss some rotation\n      // effect).\n      this.m_shape.computeAABB(synchronize_aabb1, xf1, proxy.childIndex);\n      this.m_shape.computeAABB(synchronize_aabb2, xf2, proxy.childIndex);\n\n      proxy.aabb.combine(synchronize_aabb1, synchronize_aabb2);\n\n      matrix.diffVec2(displacement, xf2.p, xf1.p);\n\n      broadPhase.moveProxy(proxy.proxyId, proxy.aabb, displacement);\n    }\n  }\n\n  /**\n   * Set the contact filtering data. This will not update contacts until the next\n   * time step when either parent body is active and awake. This automatically\n   * calls refilter.\n   */\n  setFilterData(filter: { groupIndex: number, categoryBits: number, maskBits: number }): void {\n    this.m_filterGroupIndex = filter.groupIndex;\n    this.m_filterCategoryBits = filter.categoryBits;\n    this.m_filterMaskBits = filter.maskBits;\n    this.refilter();\n  }\n\n  getFilterGroupIndex(): number {\n    return this.m_filterGroupIndex;\n  }\n\n  setFilterGroupIndex(groupIndex: number): void {\n    this.m_filterGroupIndex = groupIndex;\n  }\n\n  getFilterCategoryBits(): number {\n    return this.m_filterCategoryBits;\n  }\n\n  setFilterCategoryBits(categoryBits: number): void {\n    this.m_filterCategoryBits = categoryBits;\n  }\n\n  getFilterMaskBits(): number {\n    return this.m_filterMaskBits;\n  }\n\n  setFilterMaskBits(maskBits: number): void {\n    this.m_filterMaskBits = maskBits;\n  }\n\n  /**\n   * Call this if you want to establish collision that was previously disabled by\n   * ContactFilter.\n   */\n  refilter(): void {\n    if (this.m_body == null) {\n      return;\n    }\n\n    // Flag associated contacts for filtering.\n    let edge = this.m_body.getContactList();\n    while (edge) {\n      const contact = edge.contact;\n      const fixtureA = contact.getFixtureA();\n      const fixtureB = contact.getFixtureB();\n      if (fixtureA == this || fixtureB == this) {\n        contact.flagForFiltering();\n      }\n\n      edge = edge.next;\n    }\n\n    const world = this.m_body.getWorld();\n\n    if (world == null) {\n      return;\n    }\n\n    // Touch each proxy so that new pairs may be created\n    const broadPhase = world.m_broadPhase;\n    for (let i = 0; i < this.m_proxies.length; ++i) {\n      broadPhase.touchProxy(this.m_proxies[i].proxyId);\n    }\n  }\n\n  /**\n   * Implement this method to provide collision filtering, if you want finer\n   * control over contact creation.\n   *\n   * Return true if contact calculations should be performed between these two\n   * fixtures.\n   *\n   * Warning: for performance reasons this is only called when the AABBs begin to\n   * overlap.\n   */\n  shouldCollide(that: Fixture): boolean {\n\n    if (that.m_filterGroupIndex === this.m_filterGroupIndex && that.m_filterGroupIndex !== 0) {\n      return that.m_filterGroupIndex > 0;\n    }\n\n    const collideA = (that.m_filterMaskBits & this.m_filterCategoryBits) !== 0;\n    const collideB = (that.m_filterCategoryBits & this.m_filterMaskBits) !== 0;\n    const collide = collideA && collideB;\n    return collide;\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport * as matrix from '../common/Matrix';\nimport { options } from '../util/options';\nimport { Vec2, Vec2Value } from '../common/Vec2';\nimport { Rot } from '../common/Rot';\nimport { math as Math } from '../common/Math';\nimport { Sweep } from '../common/Sweep';\nimport { Transform } from '../common/Transform';\nimport { Velocity } from './Velocity';\nimport { Position } from './Position';\nimport { Fixture, FixtureDef, FixtureOpt } from './Fixture';\nimport { Shape } from '../collision/Shape';\nimport { JointEdge } from \"./Joint\";\nimport { World } from \"./World\";\nimport { ContactEdge } from \"./Contact\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nexport type BodyType = 'static' | 'kinematic' | 'dynamic';\n\nconst STATIC = 'static';\nconst KINEMATIC = 'kinematic';\nconst DYNAMIC = 'dynamic';\n\nconst oldCenter = matrix.vec2(0, 0);\nconst localCenter = matrix.vec2(0, 0);\nconst shift = matrix.vec2(0, 0);\nconst xf = matrix.transform(0, 0, 0)\n\nexport interface BodyDef {\n  /**\n   * Body types are static, kinematic, or dynamic. Note: if a dynamic\n   * body would have zero mass, the mass is set to one.\n   */\n  type?: BodyType;\n  /**\n   * The world position of the body. Avoid creating bodies at the\n   * origin since this can lead to many overlapping shapes.\n   */\n  position?: Vec2;\n  /**\n   * The world angle of the body in radians.\n   */\n  angle?: number;\n  /**\n   * The linear velocity of the body's origin in world co-ordinates.\n   */\n  linearVelocity?: Vec2;\n  angularVelocity?: number;\n  /**\n   * Linear damping is use to reduce the linear velocity. The\n   * damping parameter can be larger than 1.0 but the damping effect becomes\n   * sensitive to the time step when the damping parameter is large.\n   * Units are 1/time\n   */\n  linearDamping?: number;\n  /**\n   * Angular damping is use to reduce the angular velocity.\n   * The damping parameter can be larger than 1.0 but the damping effect\n   * becomes sensitive to the time step when the damping parameter is large.\n   * Units are 1/time\n   */\n  angularDamping?: number;\n  /**\n   * Should this body be prevented from rotating? Useful for characters.\n   */\n  fixedRotation?: boolean;\n  /**\n   * Is this a fast moving body that should be prevented from\n   * tunneling through other moving bodies? Note that all bodies are\n   * prevented from tunneling through kinematic and static bodies. This\n   * setting is only considered on dynamic bodies. Warning: You should use\n   * this flag sparingly since it increases processing time.\n   */\n  bullet?: boolean;\n  gravityScale?: number;\n  /**\n   * Set this flag to false if this body should never fall asleep. Note that this increases CPU usage.\n   */\n  allowSleep?: boolean;\n  /**\n   * Is this body initially awake or sleeping?\n   */\n  awake?: boolean;\n  /**\n   * Does this body start out active?\n   */\n  active?: boolean;\n  userData?: any;\n}\n\nconst BodyDefDefault: BodyDef = {\n  type : STATIC,\n  position : Vec2.zero(),\n  angle : 0.0,\n\n  linearVelocity : Vec2.zero(),\n  angularVelocity : 0.0,\n\n  linearDamping : 0.0,\n  angularDamping : 0.0,\n\n  fixedRotation : false,\n  bullet : false,\n  gravityScale : 1.0,\n\n  allowSleep : true,\n  awake : true,\n  active : true,\n\n  userData : null\n};\n\n/**\n * MassData This holds the mass data computed for a shape.\n */\nexport class MassData {\n  /** The mass of the shape, usually in kilograms. */\n  mass: number = 0;\n  /** The position of the shape's centroid relative to the shape's origin. */\n  center = Vec2.zero();\n  /** The rotational inertia of the shape about the local origin. */\n  I: number = 0;\n}\n\n/**\n * A rigid body composed of one or more fixtures.\n *\n * To create a new Body use {@link World.createBody}.\n */\nexport class Body {\n  /**\n   * A static body does not move under simulation and behaves as if it has infinite mass.\n   * Internally, zero is stored for the mass and the inverse mass.\n   * Static bodies can be moved manually by the user.\n   * A static body has zero velocity.\n   * Static bodies do not collide with other static or kinematic bodies.\n   */\n  static readonly STATIC: BodyType = 'static';\n  /**\n   * A kinematic body moves under simulation according to its velocity.\n   * Kinematic bodies do not respond to forces.\n   * They can be moved manually by the user, but normally a kinematic body is moved by setting its velocity.\n   * A kinematic body behaves as if it has infinite mass, however, zero is stored for the mass and the inverse mass.\n   * Kinematic bodies do not collide with other kinematic or static bodies.\n   */\n  static readonly KINEMATIC: BodyType = 'kinematic';\n\n  /**\n   * A dynamic body is fully simulated.\n   * They can be moved manually by the user, but normally they move according to forces.\n   * A dynamic body can collide with all body types.\n   * A dynamic body always has finite, non-zero mass.\n   * If you try to set the mass of a dynamic body to zero, it will automatically acquire a mass of one kilogram and it won't rotate.\n   */\n  static readonly DYNAMIC: BodyType = 'dynamic';\n\n  /** @internal */ m_world: World;\n  /** @internal */ m_awakeFlag: boolean;\n  /** @internal */ m_autoSleepFlag: boolean;\n  /** @internal */ m_bulletFlag: boolean;\n  /** @internal */ m_fixedRotationFlag: boolean;\n  /** @internal */ m_activeFlag: boolean;\n  /** @internal */ m_islandFlag: boolean;\n  /** @internal */ m_toiFlag: boolean;\n  /** @internal */ m_userData: unknown;\n  /** @internal */ m_type: BodyType;\n  /** @internal */ m_mass: number;\n  /** @internal */ m_invMass: number;\n  /** @internal Rotational inertia about the center of mass. */\n  m_I: number;\n  /** @internal */ m_invI: number;\n  /** @internal the body origin transform */\n  m_xf: Transform;\n  /** @internal the swept motion for CCD */\n  m_sweep: Sweep;\n  // position and velocity correction\n  /** @internal */ c_velocity: Velocity;\n  /** @internal */ c_position: Position;\n  /** @internal */ m_force: Vec2;\n  /** @internal */ m_torque: number;\n  /** @internal */ m_linearVelocity: Vec2;\n  /** @internal */ m_angularVelocity: number;\n  /** @internal */ m_linearDamping: number;\n  /** @internal */ m_angularDamping: number;\n  /** @internal */ m_gravityScale: number;\n  /** @internal */ m_sleepTime: number;\n  /** @internal */ m_jointList: JointEdge | null;\n  /** @internal */ m_contactList: ContactEdge | null;\n  /** @internal */ m_fixtureList: Fixture | null;\n  /** @internal */ m_prev: Body | null;\n  /** @internal */ m_next: Body | null;\n  /** @internal */ m_destroyed: boolean;\n\n  /** @internal */\n  constructor(world: World, def: BodyDef) {\n    def = options(def, BodyDefDefault);\n\n    _ASSERT && console.assert(Vec2.isValid(def.position));\n    _ASSERT && console.assert(Vec2.isValid(def.linearVelocity));\n    _ASSERT && console.assert(Math.isFinite(def.angle));\n    _ASSERT && console.assert(Math.isFinite(def.angularVelocity));\n    _ASSERT && console.assert(Math.isFinite(def.angularDamping) && def.angularDamping >= 0.0);\n    _ASSERT && console.assert(Math.isFinite(def.linearDamping) && def.linearDamping >= 0.0);\n\n    this.m_world = world;\n\n    this.m_awakeFlag = def.awake;\n    this.m_autoSleepFlag = def.allowSleep;\n    this.m_bulletFlag = def.bullet;\n    this.m_fixedRotationFlag = def.fixedRotation;\n    this.m_activeFlag = def.active;\n\n    this.m_islandFlag = false;\n    this.m_toiFlag = false;\n\n    this.m_userData = def.userData;\n    this.m_type = def.type;\n\n    if (this.m_type == DYNAMIC) {\n      this.m_mass = 1.0;\n      this.m_invMass = 1.0;\n    } else {\n      this.m_mass = 0.0;\n      this.m_invMass = 0.0;\n    }\n\n    // Rotational inertia about the center of mass.\n    this.m_I = 0.0;\n    this.m_invI = 0.0;\n\n    // the body origin transform\n    this.m_xf = Transform.identity();\n    this.m_xf.p.setVec2(def.position);\n    this.m_xf.q.setAngle(def.angle);\n\n    // the swept motion for CCD\n    this.m_sweep = new Sweep();\n    this.m_sweep.setTransform(this.m_xf);\n\n    // position and velocity correction\n    this.c_velocity = new Velocity();\n    this.c_position = new Position();\n\n    this.m_force = Vec2.zero();\n    this.m_torque = 0.0;\n\n    this.m_linearVelocity = Vec2.clone(def.linearVelocity);\n    this.m_angularVelocity = def.angularVelocity;\n\n    this.m_linearDamping = def.linearDamping;\n    this.m_angularDamping = def.angularDamping;\n    this.m_gravityScale = def.gravityScale;\n\n    this.m_sleepTime = 0.0;\n\n    this.m_jointList = null;\n    this.m_contactList = null;\n    this.m_fixtureList = null;\n\n    this.m_prev = null;\n    this.m_next = null;\n\n    this.m_destroyed = false;\n  }\n\n  /** @internal */\n  _serialize(): object {\n    const fixtures = [];\n    for (let f = this.m_fixtureList; f; f = f.m_next) {\n      fixtures.push(f);\n    }\n    return {\n      type: this.m_type,\n      bullet: this.m_bulletFlag,\n      position: this.m_xf.p,\n      angle: this.m_xf.q.getAngle(),\n      linearVelocity: this.m_linearVelocity,\n      angularVelocity: this.m_angularVelocity,\n      fixtures,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): Body {\n    const body = new Body(world, data);\n\n    if (data.fixtures) {\n      for (let i = data.fixtures.length - 1; i >= 0; i--) {\n        const fixture = restore(Fixture, data.fixtures[i], body);\n        body._addFixture(fixture);\n      }\n    }\n    return body;\n  }\n\n  isWorldLocked(): boolean {\n    return this.m_world && this.m_world.isLocked() ? true : false;\n  }\n\n  getWorld(): World {\n    return this.m_world;\n  }\n\n  getNext(): Body | null {\n    return this.m_next;\n  }\n\n  setUserData(data: any): void {\n    this.m_userData = data;\n  }\n\n  getUserData(): unknown {\n    return this.m_userData;\n  }\n\n  getFixtureList(): Fixture | null {\n    return this.m_fixtureList;\n  }\n\n  getJointList(): JointEdge | null {\n    return this.m_jointList;\n  }\n\n  /**\n   * Warning: this list changes during the time step and you may miss some\n   * collisions if you don't use ContactListener.\n   */\n  getContactList(): ContactEdge | null {\n    return this.m_contactList;\n  }\n\n  isStatic(): boolean {\n    return this.m_type == STATIC;\n  }\n\n  isDynamic(): boolean {\n    return this.m_type == DYNAMIC;\n  }\n\n  isKinematic(): boolean {\n    return this.m_type == KINEMATIC;\n  }\n\n  /**\n   * This will alter the mass and velocity.\n   */\n  setStatic(): Body {\n    this.setType(STATIC);\n    return this;\n  }\n\n  setDynamic(): Body {\n    this.setType(DYNAMIC);\n    return this;\n  }\n\n  setKinematic(): Body {\n    this.setType(KINEMATIC);\n    return this;\n  }\n\n  /**\n   * @internal\n   */\n  getType(): BodyType {\n    return this.m_type;\n  }\n\n  /**\n   * @internal\n   */\n  setType(type: BodyType): void {\n    _ASSERT && console.assert(type === STATIC || type === KINEMATIC || type === DYNAMIC);\n    _ASSERT && console.assert(this.isWorldLocked() == false);\n\n    if (this.isWorldLocked() == true) {\n      return;\n    }\n\n    if (this.m_type == type) {\n      return;\n    }\n\n    this.m_type = type;\n\n    this.resetMassData();\n\n    if (this.m_type == STATIC) {\n      this.m_linearVelocity.setZero();\n      this.m_angularVelocity = 0.0;\n      this.m_sweep.forward();\n      this.synchronizeFixtures();\n    }\n\n    this.setAwake(true);\n\n    this.m_force.setZero();\n    this.m_torque = 0.0;\n\n    // Delete the attached contacts.\n    let ce = this.m_contactList;\n    while (ce) {\n      const ce0 = ce;\n      ce = ce.next;\n      this.m_world.destroyContact(ce0.contact);\n    }\n    this.m_contactList = null;\n\n    // Touch the proxies so that new contacts will be created (when appropriate)\n    const broadPhase = this.m_world.m_broadPhase;\n    for (let f = this.m_fixtureList; f; f = f.m_next) {\n      for (let i = 0; i < f.m_proxies.length; ++i) {\n        broadPhase.touchProxy(f.m_proxies[i].proxyId);\n      }\n    }\n  }\n\n  isBullet(): boolean {\n    return this.m_bulletFlag;\n  }\n\n  /**\n   * Should this body be treated like a bullet for continuous collision detection?\n   */\n  setBullet(flag: boolean): void {\n    this.m_bulletFlag = !!flag;\n  }\n\n  isSleepingAllowed(): boolean {\n    return this.m_autoSleepFlag;\n  }\n\n  setSleepingAllowed(flag: boolean): void {\n    this.m_autoSleepFlag = !!flag;\n    if (this.m_autoSleepFlag == false) {\n      this.setAwake(true);\n    }\n  }\n\n  isAwake(): boolean {\n    return this.m_awakeFlag;\n  }\n\n  /**\n   * Set the sleep state of the body. A sleeping body has very low CPU cost.\n   *\n   * @param flag Set to true to wake the body, false to put it to sleep.\n   */\n  setAwake(flag: boolean): void {\n    if (flag) {\n      this.m_awakeFlag = true;\n      this.m_sleepTime = 0.0;\n    } else {\n      this.m_awakeFlag = false;\n      this.m_sleepTime = 0.0;\n      this.m_linearVelocity.setZero();\n      this.m_angularVelocity = 0.0;\n      this.m_force.setZero();\n      this.m_torque = 0.0;\n    }\n  }\n\n  isActive(): boolean {\n    return this.m_activeFlag;\n  }\n\n  /**\n   * Set the active state of the body. An inactive body is not simulated and\n   * cannot be collided with or woken up. If you pass a flag of true, all fixtures\n   * will be added to the broad-phase. If you pass a flag of false, all fixtures\n   * will be removed from the broad-phase and all contacts will be destroyed.\n   * Fixtures and joints are otherwise unaffected.\n   *\n   * You may continue to create/destroy fixtures and joints on inactive bodies.\n   * Fixtures on an inactive body are implicitly inactive and will not participate\n   * in collisions, ray-casts, or queries. Joints connected to an inactive body\n   * are implicitly inactive. An inactive body is still owned by a World object\n   * and remains\n   */\n  setActive(flag: boolean): void {\n    _ASSERT && console.assert(this.isWorldLocked() == false);\n\n    if (flag == this.m_activeFlag) {\n      return;\n    }\n\n    this.m_activeFlag = !!flag;\n\n    if (this.m_activeFlag) {\n      // Create all proxies.\n      const broadPhase = this.m_world.m_broadPhase;\n      for (let f = this.m_fixtureList; f; f = f.m_next) {\n        f.createProxies(broadPhase, this.m_xf);\n      }\n      // Contacts are created the next time step.\n\n    } else {\n      // Destroy all proxies.\n      const broadPhase = this.m_world.m_broadPhase;\n      for (let f = this.m_fixtureList; f; f = f.m_next) {\n        f.destroyProxies(broadPhase);\n      }\n\n      // Destroy the attached contacts.\n      let ce = this.m_contactList;\n      while (ce) {\n        const ce0 = ce;\n        ce = ce.next;\n        this.m_world.destroyContact(ce0.contact);\n      }\n      this.m_contactList = null;\n    }\n  }\n\n  isFixedRotation(): boolean {\n    return this.m_fixedRotationFlag;\n  }\n\n  /**\n   * Set this body to have fixed rotation. This causes the mass to be reset.\n   */\n  setFixedRotation(flag: boolean): void {\n    if (this.m_fixedRotationFlag == flag) {\n      return;\n    }\n\n    this.m_fixedRotationFlag = !!flag;\n\n    this.m_angularVelocity = 0.0;\n\n    this.resetMassData();\n  }\n\n  /**\n   * Get the world transform for the body's origin.\n   */\n  getTransform(): Transform {\n    return this.m_xf;\n  }\n\n  /**\n   * Set the position of the body's origin and rotation. Manipulating a body's\n   * transform may cause non-physical behavior. Note: contacts are updated on the\n   * next call to World.step.\n   *\n   * @param position The world position of the body's local origin.\n   * @param angle The world rotation in radians.\n   */\n  setTransform(position: Vec2, angle: number): void {\n    _ASSERT && console.assert(this.isWorldLocked() == false);\n    if (this.isWorldLocked() == true) {\n      return;\n    }\n\n    this.m_xf.setNum(position, angle);\n    this.m_sweep.setTransform(this.m_xf);\n\n    const broadPhase = this.m_world.m_broadPhase;\n    for (let f = this.m_fixtureList; f; f = f.m_next) {\n      f.synchronize(broadPhase, this.m_xf, this.m_xf);\n    }\n  }\n\n  synchronizeTransform(): void {\n    this.m_sweep.getTransform(this.m_xf, 1);\n  }\n\n  /**\n   * Update fixtures in broad-phase.\n   */\n  synchronizeFixtures(): void {\n    this.m_sweep.getTransform(xf, 0);\n\n    const broadPhase = this.m_world.m_broadPhase;\n    for (let f = this.m_fixtureList; f; f = f.m_next) {\n      f.synchronize(broadPhase, xf, this.m_xf);\n    }\n  }\n\n  /**\n   * Used in TOI.\n   */\n  advance(alpha: number): void {\n    // Advance to the new safe time. This doesn't sync the broad-phase.\n    this.m_sweep.advance(alpha);\n    matrix.copyVec2(this.m_sweep.c, this.m_sweep.c0);\n    this.m_sweep.a = this.m_sweep.a0;\n    this.m_sweep.getTransform(this.m_xf, 1);\n  }\n\n  /**\n   * Get the world position for the body's origin.\n   */\n  getPosition(): Vec2 {\n    return this.m_xf.p;\n  }\n\n  setPosition(p: Vec2): void {\n    this.setTransform(p, this.m_sweep.a);\n  }\n\n  /**\n   * Get the current world rotation angle in radians.\n   */\n  getAngle(): number {\n    return this.m_sweep.a;\n  }\n\n  setAngle(angle: number): void {\n    this.setTransform(this.m_xf.p, angle);\n  }\n\n  /**\n   * Get the world position of the center of mass.\n   */\n  getWorldCenter(): Vec2 {\n    return this.m_sweep.c;\n  }\n\n  /**\n   * Get the local position of the center of mass.\n   */\n  getLocalCenter(): Vec2 {\n    return this.m_sweep.localCenter;\n  }\n\n  /**\n   * Get the linear velocity of the center of mass.\n   *\n   * @return the linear velocity of the center of mass.\n   */\n  getLinearVelocity(): Vec2 {\n    return this.m_linearVelocity;\n  }\n\n  /**\n   * Get the world linear velocity of a world point attached to this body.\n   *\n   * @param worldPoint A point in world coordinates.\n   */\n  getLinearVelocityFromWorldPoint(worldPoint: Vec2): Vec2 {\n    const localCenter = Vec2.sub(worldPoint, this.m_sweep.c);\n    return Vec2.add(this.m_linearVelocity, Vec2.crossNumVec2(this.m_angularVelocity,\n      localCenter));\n  }\n\n  /**\n   * Get the world velocity of a local point.\n   *\n   * @param localPoint A point in local coordinates.\n   */\n  getLinearVelocityFromLocalPoint(localPoint: Vec2): Vec2 {\n    return this.getLinearVelocityFromWorldPoint(this.getWorldPoint(localPoint));\n  }\n\n  /**\n   * Set the linear velocity of the center of mass.\n   *\n   * @param v The new linear velocity of the center of mass.\n   */\n  setLinearVelocity(v: Vec2): void {\n    if (this.m_type == STATIC) {\n      return;\n    }\n    if (Vec2.dot(v, v) > 0.0) {\n      this.setAwake(true);\n    }\n    this.m_linearVelocity.setVec2(v);\n  }\n\n  /**\n   * Get the angular velocity.\n   *\n   * @returns the angular velocity in radians/second.\n   */\n  getAngularVelocity(): number {\n    return this.m_angularVelocity;\n  }\n\n  /**\n   * Set the angular velocity.\n   *\n   * @param omega The new angular velocity in radians/second.\n   */\n  setAngularVelocity(w: number): void {\n    if (this.m_type == STATIC) {\n      return;\n    }\n    if (w * w > 0.0) {\n      this.setAwake(true);\n    }\n    this.m_angularVelocity = w;\n  }\n\n  getLinearDamping(): number {\n    return this.m_linearDamping;\n  }\n\n  setLinearDamping(linearDamping: number): void {\n    this.m_linearDamping = linearDamping;\n  }\n\n  getAngularDamping(): number {\n    return this.m_angularDamping;\n  }\n\n  setAngularDamping(angularDamping: number): void {\n    this.m_angularDamping = angularDamping;\n  }\n\n  getGravityScale(): number {\n    return this.m_gravityScale;\n  }\n\n  /**\n   * Scale the gravity applied to this body.\n   */\n  setGravityScale(scale: number): void {\n    this.m_gravityScale = scale;\n  }\n\n  /**\n   * Get the total mass of the body.\n   *\n   * @returns The mass, usually in kilograms (kg).\n   */\n  getMass(): number {\n    return this.m_mass;\n  }\n\n  /**\n   * Get the rotational inertia of the body about the local origin.\n   *\n   * @return the rotational inertia, usually in kg-m^2.\n   */\n  getInertia(): number {\n    return this.m_I + this.m_mass\n      * Vec2.dot(this.m_sweep.localCenter, this.m_sweep.localCenter);\n  }\n\n  /**\n   * Copy the mass data of the body to data.\n   */\n  getMassData(data: MassData): void {\n    data.mass = this.m_mass;\n    data.I = this.getInertia();\n    data.center.setVec2(this.m_sweep.localCenter);\n  }\n\n  /**\n   * This resets the mass properties to the sum of the mass properties of the\n   * fixtures. This normally does not need to be called unless you called\n   * SetMassData to override the mass and you later want to reset the mass.\n   */\n  resetMassData(): void {\n    // Compute mass data from shapes. Each shape has its own density.\n    this.m_mass = 0.0;\n    this.m_invMass = 0.0;\n    this.m_I = 0.0;\n    this.m_invI = 0.0;\n    matrix.zeroVec2(this.m_sweep.localCenter);\n\n    // Static and kinematic bodies have zero mass.\n    if (this.isStatic() || this.isKinematic()) {\n      matrix.copyVec2(this.m_sweep.c0, this.m_xf.p);\n      matrix.copyVec2(this.m_sweep.c, this.m_xf.p);\n      this.m_sweep.a0 = this.m_sweep.a;\n      return;\n    }\n\n    _ASSERT && console.assert(this.isDynamic());\n\n    // Accumulate mass over all fixtures.\n    matrix.zeroVec2(localCenter);\n    for (let f = this.m_fixtureList; f; f = f.m_next) {\n      if (f.m_density == 0.0) {\n        continue;\n      }\n\n      const massData = new MassData();\n      f.getMassData(massData);\n      this.m_mass += massData.mass;\n      matrix.addMulVec2(localCenter, massData.mass, massData.center)\n      this.m_I += massData.I;\n    }\n\n    // Compute center of mass.\n    if (this.m_mass > 0.0) {\n      this.m_invMass = 1.0 / this.m_mass;\n      matrix.setMulVec2(localCenter, this.m_invMass, localCenter)\n\n    } else {\n      // Force all dynamic bodies to have a positive mass.\n      this.m_mass = 1.0;\n      this.m_invMass = 1.0;\n    }\n\n    if (this.m_I > 0.0 && this.m_fixedRotationFlag == false) {\n      // Center the inertia about the center of mass.\n      this.m_I -= this.m_mass * matrix.dotVec2(localCenter, localCenter);\n      _ASSERT && console.assert(this.m_I > 0.0);\n      this.m_invI = 1.0 / this.m_I;\n\n    } else {\n      this.m_I = 0.0;\n      this.m_invI = 0.0;\n    }\n\n    // Move center of mass.\n    matrix.copyVec2(oldCenter, this.m_sweep.c);\n    this.m_sweep.setLocalCenter(localCenter, this.m_xf);\n\n    // Update center of mass velocity.\n    matrix.diffVec2(shift, this.m_sweep.c, oldCenter);\n    matrix.crossNumVec2(this.m_linearVelocity, this.m_angularVelocity, shift);\n  }\n\n  /**\n   * Set the mass properties to override the mass properties of the fixtures. Note\n   * that this changes the center of mass position. Note that creating or\n   * destroying fixtures can also alter the mass. This function has no effect if\n   * the body isn't dynamic.\n   *\n   * @param massData The mass properties.\n   */\n  setMassData(massData: MassData): void {\n    _ASSERT && console.assert(this.isWorldLocked() == false);\n    if (this.isWorldLocked() == true) {\n      return;\n    }\n\n    if (this.m_type != DYNAMIC) {\n      return;\n    }\n\n    this.m_invMass = 0.0;\n    this.m_I = 0.0;\n    this.m_invI = 0.0;\n\n    this.m_mass = massData.mass;\n    if (this.m_mass <= 0.0) {\n      this.m_mass = 1.0;\n    }\n\n    this.m_invMass = 1.0 / this.m_mass;\n\n    if (massData.I > 0.0 && this.m_fixedRotationFlag == false) {\n      this.m_I = massData.I - this.m_mass * matrix.dotVec2(massData.center, massData.center);\n      _ASSERT && console.assert(this.m_I > 0.0);\n      this.m_invI = 1.0 / this.m_I;\n    }\n\n    // Move center of mass.\n    matrix.copyVec2(oldCenter, this.m_sweep.c);\n    this.m_sweep.setLocalCenter(massData.center, this.m_xf);\n\n    // Update center of mass velocity.\n    matrix.diffVec2(shift, this.m_sweep.c, oldCenter);\n    matrix.crossNumVec2(this.m_linearVelocity, this.m_angularVelocity, shift);\n  }\n\n  /**\n   * Apply a force at a world point. If the force is not applied at the center of\n   * mass, it will generate a torque and affect the angular velocity. This wakes\n   * up the body.\n   *\n   * @param force The world force vector, usually in Newtons (N).\n   * @param point The world position of the point of application.\n   * @param wake Also wake up the body\n   */\n  applyForce(force: Vec2, point: Vec2, wake: boolean = true): void {\n    if (this.m_type != DYNAMIC) {\n      return;\n    }\n    if (wake && this.m_awakeFlag == false) {\n      this.setAwake(true);\n    }\n    // Don't accumulate a force if the body is sleeping.\n    if (this.m_awakeFlag) {\n      this.m_force.add(force);\n      this.m_torque += Vec2.crossVec2Vec2(Vec2.sub(point, this.m_sweep.c), force);\n    }\n  }\n\n  /**\n   * Apply a force to the center of mass. This wakes up the body.\n   *\n   * @param force The world force vector, usually in Newtons (N).\n   * @param wake Also wake up the body\n   */\n  applyForceToCenter(force: Vec2, wake: boolean = true): void {\n    if (this.m_type != DYNAMIC) {\n      return;\n    }\n    if (wake && this.m_awakeFlag == false) {\n      this.setAwake(true);\n    }\n    // Don't accumulate a force if the body is sleeping\n    if (this.m_awakeFlag) {\n      this.m_force.add(force);\n    }\n  }\n\n  /**\n   * Apply a torque. This affects the angular velocity without affecting the\n   * linear velocity of the center of mass. This wakes up the body.\n   *\n   * @param torque About the z-axis (out of the screen), usually in N-m.\n   * @param wake Also wake up the body\n   */\n  applyTorque(torque: number, wake: boolean = true): void {\n    if (this.m_type != DYNAMIC) {\n      return;\n    }\n    if (wake && this.m_awakeFlag == false) {\n      this.setAwake(true);\n    }\n    // Don't accumulate a force if the body is sleeping\n    if (this.m_awakeFlag) {\n      this.m_torque += torque;\n    }\n  }\n\n  /**\n   * Apply an impulse at a point. This immediately modifies the velocity. It also\n   * modifies the angular velocity if the point of application is not at the\n   * center of mass. This wakes up the body.\n   *\n   * @param impulse The world impulse vector, usually in N-seconds or kg-m/s.\n   * @param point The world position of the point of application.\n   * @param wake Also wake up the body\n   */\n  applyLinearImpulse(impulse: Vec2, point: Vec2, wake: boolean = true): void {\n    if (this.m_type != DYNAMIC) {\n      return;\n    }\n    if (wake && this.m_awakeFlag == false) {\n      this.setAwake(true);\n    }\n\n    // Don't accumulate velocity if the body is sleeping\n    if (this.m_awakeFlag) {\n      this.m_linearVelocity.addMul(this.m_invMass, impulse);\n      this.m_angularVelocity += this.m_invI * Vec2.crossVec2Vec2(Vec2.sub(point, this.m_sweep.c), impulse);\n    }\n  }\n\n  /**\n   * Apply an angular impulse.\n   *\n   * @param impulse The angular impulse in units of kg*m*m/s\n   * @param wake Also wake up the body\n   */\n  applyAngularImpulse(impulse: number, wake: boolean = true): void {\n    if (this.m_type != DYNAMIC) {\n      return;\n    }\n\n    if (wake && this.m_awakeFlag == false) {\n      this.setAwake(true);\n    }\n    // Don't accumulate velocity if the body is sleeping\n    if (this.m_awakeFlag) {\n      this.m_angularVelocity += this.m_invI * impulse;\n    }\n  }\n\n  /**\n   * This is used to prevent connected bodies (by joints) from colliding,\n   * depending on the joint's collideConnected flag.\n   */\n  shouldCollide(that: Body): boolean {\n    // At least one body should be dynamic.\n    if (this.m_type != DYNAMIC && that.m_type != DYNAMIC) {\n      return false;\n    }\n    // Does a joint prevent collision?\n    for (let jn = this.m_jointList; jn; jn = jn.next) {\n      if (jn.other == that) {\n        if (jn.joint.m_collideConnected == false) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  /**\n   * @internal Used for deserialize.\n   */\n  _addFixture(fixture: Fixture): Fixture {\n    _ASSERT && console.assert(this.isWorldLocked() == false);\n\n    if (this.isWorldLocked() == true) {\n      return null;\n    }\n\n    if (this.m_activeFlag) {\n      const broadPhase = this.m_world.m_broadPhase;\n      fixture.createProxies(broadPhase, this.m_xf);\n    }\n\n    fixture.m_next = this.m_fixtureList;\n    this.m_fixtureList = fixture;\n\n    // Adjust mass properties if needed.\n    if (fixture.m_density > 0.0) {\n      this.resetMassData();\n    }\n\n    // Let the world know we have a new fixture. This will cause new contacts\n    // to be created at the beginning of the next time step.\n    this.m_world.m_newFixture = true;\n\n    return fixture;\n  }\n\n  /**\n   * Creates a fixture and attach it to this body.\n   *\n   * If the density is non-zero, this function automatically updates the mass of\n   * the body.\n   *\n   * Contacts are not created until the next time step.\n   *\n   * Warning: This function is locked during callbacks.\n   */\n  createFixture(def: FixtureDef): Fixture;\n  createFixture(shape: Shape, opt?: FixtureOpt): Fixture;\n  createFixture(shape: Shape, density?: number): Fixture;\n  // tslint:disable-next-line:typedef\n  createFixture(shape, fixdef?) {\n    _ASSERT && console.assert(this.isWorldLocked() == false);\n\n    if (this.isWorldLocked() == true) {\n      return null;\n    }\n\n    const fixture = new Fixture(this, shape, fixdef);\n    this._addFixture(fixture);\n    return fixture;\n  }\n\n  /**\n   * Destroy a fixture. This removes the fixture from the broad-phase and destroys\n   * all contacts associated with this fixture. This will automatically adjust the\n   * mass of the body if the body is dynamic and the fixture has positive density.\n   * All fixtures attached to a body are implicitly destroyed when the body is\n   * destroyed.\n   *\n   * Warning: This function is locked during callbacks.\n   *\n   * @param fixture The fixture to be removed.\n   */\n  destroyFixture(fixture: Fixture): void {\n    _ASSERT && console.assert(this.isWorldLocked() == false);\n\n    if (this.isWorldLocked() == true) {\n      return;\n    }\n\n    _ASSERT && console.assert(fixture.m_body == this);\n\n    // Remove the fixture from this body's singly linked list.\n    let found = false;\n    if (this.m_fixtureList === fixture) {\n      this.m_fixtureList = fixture.m_next;\n      found = true;\n\n    } else {\n      let node = this.m_fixtureList;\n      while (node != null) {\n        if (node.m_next === fixture) {\n          node.m_next = fixture.m_next;\n          found = true;\n          break;\n        }\n        node = node.m_next;\n      }\n    }\n\n    // You tried to remove a shape that is not attached to this body.\n    _ASSERT && console.assert(found);\n\n    // Destroy any contacts associated with the fixture.\n    let edge = this.m_contactList;\n    while (edge) {\n      const c = edge.contact;\n      edge = edge.next;\n\n      const fixtureA = c.getFixtureA();\n      const fixtureB = c.getFixtureB();\n\n      if (fixture == fixtureA || fixture == fixtureB) {\n        // This destroys the contact and removes it from\n        // this body's contact list.\n        this.m_world.destroyContact(c);\n      }\n    }\n\n    if (this.m_activeFlag) {\n      const broadPhase = this.m_world.m_broadPhase;\n      fixture.destroyProxies(broadPhase);\n    }\n\n    fixture.m_body = null;\n    fixture.m_next = null;\n\n    this.m_world.publish('remove-fixture', fixture);\n\n    // Reset the mass data.\n    this.resetMassData();\n  }\n\n  /**\n   * Get the corresponding world point of a local point.\n   */\n  getWorldPoint(localPoint: Vec2): Vec2 {\n    return Transform.mulVec2(this.m_xf, localPoint);\n  }\n\n  /**\n   * Get the corresponding world vector of a local vector.\n   */\n  getWorldVector(localVector: Vec2): Vec2 {\n    return Rot.mulVec2(this.m_xf.q, localVector);\n  }\n\n  /**\n   * Gets the corresponding local point of a world point.\n   */\n  getLocalPoint(worldPoint: Vec2Value): Vec2 {\n    return Transform.mulTVec2(this.m_xf, worldPoint);\n  }\n\n  /**\n   * Gets the corresponding local vector of a world vector.\n   */\n  getLocalVector(worldVector: Vec2Value): Vec2 {\n    return Rot.mulTVec2(this.m_xf.q, worldVector);\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport type { Vec2 }  from '../common/Vec2';\nimport type { Body }  from './Body';\nimport { TimeStep } from \"./Solver\";\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n/**\n * A joint edge is used to connect bodies and joints together in a joint graph\n * where each body is a node and each joint is an edge. A joint edge belongs to\n * a doubly linked list maintained in each attached body. Each joint has two\n * joint nodes, one for each attached body.\n */\nexport class JointEdge {\n  /**\n   * provides quick access to the other body attached.\n   */\n  other: Body | null = null;\n  /**\n   * the joint\n   */\n  joint: Joint | null = null;\n  /**\n   * prev the previous joint edge in the body's joint list\n   */\n  prev: JointEdge | null = null;\n  /**\n   * the next joint edge in the body's joint list\n   */\n  next: JointEdge | null = null;\n}\n\n/**\n * Joint definitions are used to construct joints.\n */\nexport interface JointOpt {\n  /**\n   * Use this to attach application specific data to your joints.\n   */\n  userData?: any;\n  /**\n   * Set this flag to true if the attached bodies\n   * should collide.\n   */\n  collideConnected?: boolean;\n}\n/**\n * Joint definitions are used to construct joints.\n */\nexport interface JointDef extends JointOpt {\n  /**\n   * The first attached body.\n   */\n  bodyA: Body;\n  /**\n   * The second attached body.\n   */\n  bodyB: Body;\n}\n\nconst DEFAULTS = {\n  userData : null,\n  collideConnected : false\n};\n\n/**\n * The base joint class. Joints are used to constraint two bodies together in\n * various fashions. Some joints also feature limits and motors.\n */\nexport abstract class Joint {\n\n  /** @internal */ m_type: string = 'unknown-joint';\n\n  /** @internal */ m_bodyA: Body;\n  /** @internal */ m_bodyB: Body;\n\n  /** @internal */ m_collideConnected: boolean;\n\n  /** @internal */ m_prev: Joint | null = null;\n  /** @internal */ m_next: Joint | null = null;\n\n  /** @internal */ m_edgeA: JointEdge = new JointEdge();\n  /** @internal */ m_edgeB: JointEdge = new JointEdge();\n\n  /** @internal */ m_islandFlag: boolean = false;\n  /** @internal */ m_userData: unknown;\n\n  constructor(def: JointDef);\n  constructor(def: JointOpt, bodyA: Body, bodyB: Body);\n  constructor(def: JointDef | JointOpt, bodyA?: Body, bodyB?: Body) {\n    bodyA = 'bodyA' in def ? def.bodyA : bodyA;\n    bodyB = 'bodyB' in def ? def.bodyB : bodyB;\n\n    _ASSERT && console.assert(!!bodyA);\n    _ASSERT && console.assert(!!bodyB);\n    _ASSERT && console.assert(bodyA != bodyB);\n\n    this.m_bodyA = bodyA!;\n    this.m_bodyB = bodyB!;\n\n    this.m_collideConnected = !!def.collideConnected;\n    this.m_userData = def.userData;\n  }\n\n  /**\n   * Short-cut function to determine if either body is inactive.\n   */\n  isActive(): boolean {\n    return this.m_bodyA.isActive() && this.m_bodyB.isActive();\n  }\n\n  /**\n   * Get the type of the concrete joint.\n   */\n  getType(): string {\n    return this.m_type;\n  }\n\n  /**\n   * Get the first body attached to this joint.\n   */\n  getBodyA(): Body {\n    return this.m_bodyA;\n  }\n\n  /**\n   * Get the second body attached to this joint.\n   */\n  getBodyB(): Body {\n    return this.m_bodyB;\n  }\n\n  /**\n   * Get the next joint the world joint list.\n   */\n  getNext(): Joint {\n    return this.m_next;\n  }\n\n  getUserData(): unknown {\n    return this.m_userData;\n  }\n\n  setUserData(data: unknown): void {\n    this.m_userData = data;\n  }\n\n  /**\n   * Get collide connected. Note: modifying the collide connect flag won't work\n   * correctly because the flag is only checked when fixture AABBs begin to\n   * overlap.\n   */\n  getCollideConnected(): boolean {\n    return this.m_collideConnected;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  abstract getAnchorA(): Vec2;\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  abstract getAnchorB(): Vec2;\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  abstract getReactionForce(inv_dt: number): Vec2;\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  abstract getReactionTorque(inv_dt: number): number;\n\n  /**\n   * Shift the origin for any points stored in world coordinates.\n   */\n  shiftOrigin(newOrigin: Vec2): void {}\n\n  abstract initVelocityConstraints(step: TimeStep): void;\n\n  abstract solveVelocityConstraints(step: TimeStep): void;\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  abstract solvePositionConstraints(step: TimeStep): boolean;\n\n}\n","export const stats = {\n  gjkCalls: 0,\n  gjkIters: 0,\n  gjkMaxIters: 0,\n\n  toiTime: 0,\n  toiMaxTime: 0,\n  toiCalls: 0,\n  toiIters: 0,\n  toiMaxIters: 0,\n  toiRootIters: 0,\n  toiMaxRootIters: 0,\n\n  toString(newline?: string): string {\n    newline = typeof newline === 'string' ? newline : '\\n';\n    let string = \"\";\n    // tslint:disable-next-line:no-for-in\n    for (const name in this) {\n      if (typeof this[name] !== 'function' && typeof this[name] !== 'object') {\n        string += name + ': ' + this[name] + newline;\n      }\n    }\n    return string;\n  }\n};\n","export const now = function(): number {\n  return Date.now();\n};\n\nexport const diff = function(time: number): number {\n  return Date.now() - time;\n};\n\nexport default {\n  now,\n  diff,\n};\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport * as matrix from '../common/Matrix';\nimport { SettingsInternal as Settings } from '../Settings';\nimport { stats } from '../util/stats';\nimport { Shape } from './Shape';\nimport { math as Math } from '../common/Math';\nimport { Vec2, Vec2Value } from '../common/Vec2';\nimport { Rot } from '../common/Rot';\nimport { Transform, TransformValue } from '../common/Transform';\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\nconst temp = matrix.vec2(0, 0);\nconst normal = matrix.vec2(0, 0);\nconst e12 = matrix.vec2(0, 0);\nconst e13 = matrix.vec2(0, 0);\nconst e23 = matrix.vec2(0, 0);\nconst temp1 = matrix.vec2(0, 0);\nconst temp2 = matrix.vec2(0, 0);\n\n/**\n * GJK using Voronoi regions (Christer Ericson) and Barycentric coordinates.\n */\n\nstats.gjkCalls = 0;\nstats.gjkIters = 0;\nstats.gjkMaxIters = 0;\n\n/**\n * Input for Distance. You have to option to use the shape radii in the\n * computation. Even\n */\nexport class DistanceInput {\n  readonly proxyA = new DistanceProxy();\n  readonly proxyB = new DistanceProxy();\n  readonly transformA = Transform.identity();\n  readonly transformB = Transform.identity();\n  useRadii = false;\n  recycle() {\n    this.proxyA.recycle();\n    this.proxyB.recycle();\n    this.transformA.setIdentity();\n    this.transformB.setIdentity();\n    this.useRadii = false;\n  }\n}\n\n/**\n * Output for Distance.\n */\nexport class DistanceOutput {\n  /** closest point on shapeA */\n  pointA = matrix.vec2(0, 0);\n  /** closest point on shapeB */\n  pointB = matrix.vec2(0, 0);\n  distance = 0;\n  /** iterations number of GJK iterations used */\n  iterations = 0;\n  recycle() {\n    matrix.zeroVec2(this.pointA)\n    matrix.zeroVec2(this.pointB)\n    this.distance = 0;\n    this.iterations = 0;\n  }\n}\n\n/**\n * Used to warm start Distance. Set count to zero on first call.\n */\nexport class SimplexCache {\n  /** length or area */\n  metric: number = 0;\n  /** vertices on shape A */\n  indexA: number[] = [];\n  /** vertices on shape B */\n  indexB: number[] = [];\n  count: number = 0;\n  recycle() {\n    this.metric = 0;\n    this.indexA.length = 0;\n    this.indexB.length = 0;\n    this.count = 0;\n  }\n}\n\n/**\n * Compute the closest points between two shapes. Supports any combination of:\n * CircleShape, PolygonShape, EdgeShape. The simplex cache is input/output. On\n * the first call set SimplexCache.count to zero.\n */\nexport const Distance = function (output: DistanceOutput, cache: SimplexCache, input: DistanceInput): void {\n  ++stats.gjkCalls;\n\n  const proxyA = input.proxyA;\n  const proxyB = input.proxyB;\n  const xfA = input.transformA;\n  const xfB = input.transformB;\n\n  // Initialize the simplex.\n  // const simplex = new Simplex();\n  simplex.recycle();\n  simplex.readCache(cache, proxyA, xfA, proxyB, xfB);\n\n  // Get simplex vertices as an array.\n  const vertices = simplex.m_v;\n  const k_maxIters = Settings.maxDistnceIterations;\n\n  // These store the vertices of the last simplex so that we\n  // can check for duplicates and prevent cycling.\n  const saveA = [];\n  const saveB = []; // int[3]\n  let saveCount = 0;\n\n  // Main iteration loop.\n  let iter = 0;\n  while (iter < k_maxIters) {\n    // Copy simplex so we can identify duplicates.\n    saveCount = simplex.m_count;\n    for (let i = 0; i < saveCount; ++i) {\n      saveA[i] = vertices[i].indexA;\n      saveB[i] = vertices[i].indexB;\n    }\n\n    simplex.solve();\n\n    // If we have 3 points, then the origin is in the corresponding triangle.\n    if (simplex.m_count === 3) {\n      break;\n    }\n\n    // Get search direction.\n    const d = simplex.getSearchDirection();\n\n    // Ensure the search direction is numerically fit.\n    if (matrix.lengthSqrVec2(d) < Math.EPSILON * Math.EPSILON) {\n      // The origin is probably contained by a line segment\n      // or triangle. Thus the shapes are overlapped.\n\n      // We can't return zero here even though there may be overlap.\n      // In case the simplex is a point, segment, or triangle it is difficult\n      // to determine if the origin is contained in the CSO or very close to it.\n      break;\n    }\n\n    // Compute a tentative new simplex vertex using support points.\n    const vertex = vertices[simplex.m_count]; // SimplexVertex\n\n    vertex.indexA = proxyA.getSupport(matrix.invRotVec2(temp, xfA.q, matrix.setMulVec2(temp, -1, d)));\n    matrix.transformVec2(vertex.wA, xfA, proxyA.getVertex(vertex.indexA));\n\n    vertex.indexB = proxyB.getSupport(matrix.invRotVec2(temp, xfB.q, d));\n    matrix.transformVec2(vertex.wB, xfB, proxyB.getVertex(vertex.indexB));\n\n    matrix.diffVec2(vertex.w, vertex.wB, vertex.wA);\n\n    // Iteration count is equated to the number of support point calls.\n    ++iter;\n    ++stats.gjkIters;\n\n    // Check for duplicate support points. This is the main termination\n    // criteria.\n    let duplicate = false;\n    for (let i = 0; i < saveCount; ++i) {\n      if (vertex.indexA === saveA[i] && vertex.indexB === saveB[i]) {\n        duplicate = true;\n        break;\n      }\n    }\n\n    // If we found a duplicate support point we must exit to avoid cycling.\n    if (duplicate) {\n      break;\n    }\n\n    // New vertex is ok and needed.\n    ++simplex.m_count;\n  }\n\n  stats.gjkMaxIters = Math.max(stats.gjkMaxIters, iter);\n\n  // Prepare output.\n  simplex.getWitnessPoints(output.pointA, output.pointB);\n  output.distance = matrix.distVec2(output.pointA, output.pointB);\n  output.iterations = iter;\n\n  // Cache the simplex.\n  simplex.writeCache(cache);\n\n  // Apply radii if requested.\n  if (input.useRadii) {\n    const rA = proxyA.m_radius;\n    const rB = proxyB.m_radius;\n\n    if (output.distance > rA + rB && output.distance > Math.EPSILON) {\n      // Shapes are still no overlapped.\n      // Move the witness points to the outer surface.\n      output.distance -= rA + rB;\n      matrix.diffVec2(normal, output.pointB, output.pointA);\n      matrix.normalizeVec2(normal);\n      matrix.addMulVec2(output.pointA, rA, normal);\n      matrix.subMulVec2(output.pointB, rB, normal);\n    } else {\n      // Shapes are overlapped when radii are considered.\n      // Move the witness points to the middle.\n      const p = matrix.diffVec2(temp, output.pointA, output.pointB);\n      matrix.copyVec2(output.pointA, p);\n      matrix.copyVec2(output.pointB, p);\n      output.distance = 0.0;\n    }\n  }\n}\n\n/**\n * A distance proxy is used by the GJK algorithm. It encapsulates any shape.\n */\nexport class DistanceProxy {\n  /** @internal */ m_vertices: Vec2Value[] = [];\n  // todo: remove this?\n  /** @internal */ m_count = 0;\n  /** @internal */ m_radius = 0;\n\n  recycle() {\n    this.m_vertices.length = 0;\n    this.m_count = 0;\n    this.m_radius = 0;\n  }\n\n  /**\n   * Get the vertex count.\n   */\n  getVertexCount(): number {\n    return this.m_count;\n  }\n\n  /**\n   * Get a vertex by index. Used by Distance.\n   */\n  getVertex(index: number): Vec2Value {\n    _ASSERT && console.assert(0 <= index && index < this.m_count);\n    return this.m_vertices[index];\n  }\n\n  /**\n   * Get the supporting vertex index in the given direction.\n   */\n  getSupport(d: Vec2Value): number {\n    let bestIndex = -1;\n    let bestValue = -Infinity;\n    for (let i = 0; i < this.m_count; ++i) {\n      const value = matrix.dotVec2(this.m_vertices[i], d);\n      if (value > bestValue) {\n        bestIndex = i;\n        bestValue = value;\n      }\n    }\n    return bestIndex;\n  }\n\n  /**\n   * Get the supporting vertex in the given direction.\n   */\n  getSupportVertex(d: Vec2Value): Vec2Value {\n    return this.m_vertices[this.getSupport(d)];\n  }\n\n  /**\n   * Initialize the proxy using the given shape. The shape must remain in scope\n   * while the proxy is in use.\n   */\n  set(shape: Shape, index: number): void {\n    // TODO remove, use shape instead\n    _ASSERT && console.assert(typeof shape.computeDistanceProxy === 'function');\n    shape.computeDistanceProxy(this, index);\n  }\n\n  /**\n   * Initialize the proxy using a vertex cloud and radius. The vertices\n   * must remain in scope while the proxy is in use.\n   */\n  setVertices(vertices: Vec2Value[], count: number, radius: number) {\n    this.m_vertices = vertices;\n    this.m_count = count;\n    this.m_radius = radius;\n  }\n}\n\nclass SimplexVertex {\n  /** support point in proxyA */\n  wA = matrix.vec2(0, 0);\n  /** wA index */\n  indexA = 0;\n\n  /** support point in proxyB */\n  wB = matrix.vec2(0, 0);\n  /** wB index */\n  indexB = 0;\n\n  /** wB - wA; */\n  w = matrix.vec2(0, 0);\n  /** barycentric coordinate for closest point */\n  a = 0;\n\n  recycle() {\n    this.indexA = 0;\n    this.indexB = 0;\n    matrix.zeroVec2(this.wA)\n    matrix.zeroVec2(this.wB)\n    matrix.zeroVec2(this.w)\n    this.a = 0;\n  }\n  set(v: SimplexVertex): void {\n    this.indexA = v.indexA;\n    this.indexB = v.indexB;\n    matrix.copyVec2(this.wA, v.wA);\n    matrix.copyVec2(this.wB, v.wB);\n    matrix.copyVec2(this.w, v.w);\n    this.a = v.a;\n  }\n}\n\nconst searchDirection_reuse = matrix.vec2(0, 0);\nconst closestPoint_reuse = matrix.vec2(0, 0);  \n\nclass Simplex {\n  m_v1 = new SimplexVertex();\n  m_v2 = new SimplexVertex();\n  m_v3 = new SimplexVertex();\n  m_v = [this.m_v1, this.m_v2, this.m_v3];\n  m_count: number;\n  recycle() {\n    this.m_v1.recycle();\n    this.m_v2.recycle();\n    this.m_v3.recycle();\n    this.m_count = 0;\n  }\n\n  /** @internal */\n  toString(): string {\n    if (this.m_count === 3) {\n      return [\"+\" + this.m_count,\n        this.m_v1.a, this.m_v1.wA.x, this.m_v1.wA.y, this.m_v1.wB.x, this.m_v1.wB.y,\n        this.m_v2.a, this.m_v2.wA.x, this.m_v2.wA.y, this.m_v2.wB.x, this.m_v2.wB.y,\n        this.m_v3.a, this.m_v3.wA.x, this.m_v3.wA.y, this.m_v3.wB.x, this.m_v3.wB.y\n      ].toString();\n\n    } else if (this.m_count === 2) {\n      return [\"+\" + this.m_count,\n        this.m_v1.a, this.m_v1.wA.x, this.m_v1.wA.y, this.m_v1.wB.x, this.m_v1.wB.y,\n        this.m_v2.a, this.m_v2.wA.x, this.m_v2.wA.y, this.m_v2.wB.x, this.m_v2.wB.y\n      ].toString();\n\n    } else if (this.m_count === 1) {\n      return [\"+\" + this.m_count,\n        this.m_v1.a, this.m_v1.wA.x, this.m_v1.wA.y, this.m_v1.wB.x, this.m_v1.wB.y\n      ].toString();\n\n    } else {\n      return \"+\" + this.m_count;\n    }\n  }\n\n  readCache(cache: SimplexCache, proxyA: DistanceProxy, transformA: TransformValue, proxyB: DistanceProxy, transformB: TransformValue): void {\n    _ASSERT && console.assert(cache.count <= 3);\n\n    // Copy data from cache.\n    this.m_count = cache.count;\n    for (let i = 0; i < this.m_count; ++i) {\n      const v = this.m_v[i];\n      v.indexA = cache.indexA[i];\n      v.indexB = cache.indexB[i];\n      const wALocal = proxyA.getVertex(v.indexA);\n      const wBLocal = proxyB.getVertex(v.indexB);\n      matrix.transformVec2(v.wA, transformA, wALocal);\n      matrix.transformVec2(v.wB, transformB, wBLocal);\n      matrix.diffVec2(v.w,v.wB, v.wA);\n      v.a = 0.0;\n    }\n\n    // Compute the new simplex metric, if it is substantially different than\n    // old metric then flush the simplex.\n    if (this.m_count > 1) {\n      const metric1 = cache.metric;\n      const metric2 = this.getMetric();\n      if (metric2 < 0.5 * metric1 || 2.0 * metric1 < metric2 || metric2 < Math.EPSILON) {\n        // Reset the simplex.\n        this.m_count = 0;\n      }\n    }\n\n    // If the cache is empty or invalid...\n    if (this.m_count === 0) {\n      const v = this.m_v[0];\n      v.indexA = 0;\n      v.indexB = 0;\n      const wALocal = proxyA.getVertex(0);\n      const wBLocal = proxyB.getVertex(0);\n      matrix.transformVec2(v.wA, transformA, wALocal);\n      matrix.transformVec2(v.wB, transformB, wBLocal);\n      matrix.diffVec2(v.w,v.wB, v.wA);\n      v.a = 1.0;\n      this.m_count = 1;\n    }\n  }\n\n  writeCache(cache: SimplexCache): void {\n    cache.metric = this.getMetric();\n    cache.count = this.m_count;\n    for (let i = 0; i < this.m_count; ++i) {\n      cache.indexA[i] = this.m_v[i].indexA;\n      cache.indexB[i] = this.m_v[i].indexB;\n    }\n  }\n\n  getSearchDirection(): Vec2Value {\n    const v1 = this.m_v1;\n    const v2 = this.m_v2;\n    const v3 = this.m_v3;\n    switch (this.m_count) {\n      case 1:\n        return matrix.setVec2(searchDirection_reuse, -v1.w.x, -v1.w.y);\n\n      case 2: {\n        matrix.diffVec2(e12, v2.w, v1.w);\n        const sgn = -matrix.crossVec2Vec2(e12, v1.w);\n        if (sgn > 0.0) {\n          // Origin is left of e12.\n          return matrix.setVec2(searchDirection_reuse, -e12.y, e12.x);\n        } else {\n          // Origin is right of e12.\n          return matrix.setVec2(searchDirection_reuse, e12.y, -e12.x);\n        }\n      }\n\n      default:\n        _ASSERT && console.assert(false);\n        return matrix.zeroVec2(searchDirection_reuse);\n    }\n  }\n\n  getClosestPoint(): Vec2Value {\n    const v1 = this.m_v1;\n    const v2 = this.m_v2;\n    const v3 = this.m_v3;\n    switch (this.m_count) {\n      case 0:\n        _ASSERT && console.assert(false);\n        return matrix.zeroVec2(closestPoint_reuse);\n\n      case 1:\n        return matrix.copyVec2(closestPoint_reuse, v1.w);\n\n      case 2:\n        return  matrix.combineVec2(closestPoint_reuse, v1.a, v1.w, v2.a, v2.w);\n\n      case 3:\n        return matrix.zeroVec2(closestPoint_reuse);\n\n      default:\n        _ASSERT && console.assert(false);\n        return matrix.zeroVec2(closestPoint_reuse);\n    }\n  }\n\n  getWitnessPoints(pA: Vec2Value, pB: Vec2Value): void {\n    const v1 = this.m_v1;\n    const v2 = this.m_v2;\n    const v3 = this.m_v3;\n    switch (this.m_count) {\n      case 0:\n        _ASSERT && console.assert(false);\n        break;\n\n      case 1:\n        matrix.copyVec2(pA, v1.wA);\n        matrix.copyVec2(pB, v1.wB);\n        break;\n\n      case 2:\n        matrix.combineVec2(pA, v1.a, v1.wA, v2.a, v2.wA);\n        matrix.combineVec2(pB, v1.a, v1.wB, v2.a, v2.wB);\n        break;\n\n      case 3:\n        pB.x = pA.x = v1.a * v1.wA.x + v2.a * v2.wA.x + v3.a * v3.wA.x;\n        pB.y = pA.y = v1.a * v1.wA.y + v2.a * v2.wA.y + v3.a * v3.wA.y;\n        break;\n\n      default:\n        _ASSERT && console.assert(false);\n        break;\n    }\n  }\n\n  getMetric(): number {\n    switch (this.m_count) {\n      case 0:\n        _ASSERT && console.assert(false);\n        return 0.0;\n\n      case 1:\n        return 0.0;\n\n      case 2:\n        return matrix.distVec2(this.m_v1.w, this.m_v2.w);\n\n      case 3:\n        return matrix.crossVec2Vec2(\n          matrix.diffVec2(temp1, this.m_v2.w, this.m_v1.w),\n          matrix.diffVec2(temp2, this.m_v3.w, this.m_v1.w),\n        );\n\n      default:\n        _ASSERT && console.assert(false);\n        return 0.0;\n    }\n  }\n\n  solve(): void {\n    switch (this.m_count) {\n      case 1:\n        break;\n\n      case 2:\n        this.solve2();\n        break;\n\n      case 3:\n        this.solve3();\n        break;\n\n      default:\n        _ASSERT && console.assert(false);\n    }\n  }\n\n// Solve a line segment using barycentric coordinates.\n//\n// p = a1 * w1 + a2 * w2\n// a1 + a2 = 1\n//\n// The vector from the origin to the closest point on the line is\n// perpendicular to the line.\n// e12 = w2 - w1\n// dot(p, e) = 0\n// a1 * dot(w1, e) + a2 * dot(w2, e) = 0\n//\n// 2-by-2 linear system\n// [1 1 ][a1] = [1]\n// [w1.e12 w2.e12][a2] = [0]\n//\n// Define\n// d12_1 = dot(w2, e12)\n// d12_2 = -dot(w1, e12)\n// d12 = d12_1 + d12_2\n//\n// Solution\n// a1 = d12_1 / d12\n// a2 = d12_2 / d12\n  solve2(): void {\n    const w1 = this.m_v1.w;\n    const w2 = this.m_v2.w;\n    matrix.diffVec2(e12, w2, w1);\n\n    // w1 region\n    const d12_2 = -matrix.dotVec2(w1, e12);\n    if (d12_2 <= 0.0) {\n      // a2 <= 0, so we clamp it to 0\n      this.m_v1.a = 1.0;\n      this.m_count = 1;\n      return;\n    }\n\n    // w2 region\n    const d12_1 = matrix.dotVec2(w2, e12);\n    if (d12_1 <= 0.0) {\n      // a1 <= 0, so we clamp it to 0\n      this.m_v2.a = 1.0;\n      this.m_count = 1;\n      this.m_v1.set(this.m_v2);\n      return;\n    }\n\n    // Must be in e12 region.\n    const inv_d12 = 1.0 / (d12_1 + d12_2);\n    this.m_v1.a = d12_1 * inv_d12;\n    this.m_v2.a = d12_2 * inv_d12;\n    this.m_count = 2;\n  }\n\n// Possible regions:\n// - points[2]\n// - edge points[0]-points[2]\n// - edge points[1]-points[2]\n// - inside the triangle\n  solve3(): void {\n    const w1 = this.m_v1.w;\n    const w2 = this.m_v2.w;\n    const w3 = this.m_v3.w;\n\n    // Edge12\n    // [1 1 ][a1] = [1]\n    // [w1.e12 w2.e12][a2] = [0]\n    // a3 = 0\n    matrix.diffVec2(e12, w2, w1);\n    const w1e12 = matrix.dotVec2(w1, e12);\n    const w2e12 = matrix.dotVec2(w2, e12);\n    const d12_1 = w2e12;\n    const d12_2 = -w1e12;\n\n    // Edge13\n    // [1 1 ][a1] = [1]\n    // [w1.e13 w3.e13][a3] = [0]\n    // a2 = 0\n    matrix.diffVec2(e13, w3, w1);\n    const w1e13 = matrix.dotVec2(w1, e13);\n    const w3e13 = matrix.dotVec2(w3, e13);\n    const d13_1 = w3e13;\n    const d13_2 = -w1e13;\n\n    // Edge23\n    // [1 1 ][a2] = [1]\n    // [w2.e23 w3.e23][a3] = [0]\n    // a1 = 0\n    matrix.diffVec2(e23, w3, w2);\n    const w2e23 = matrix.dotVec2(w2, e23);\n    const w3e23 = matrix.dotVec2(w3, e23);\n    const d23_1 = w3e23;\n    const d23_2 = -w2e23;\n\n    // Triangle123\n    const n123 = matrix.crossVec2Vec2(e12, e13);\n\n    const d123_1 = n123 * matrix.crossVec2Vec2(w2, w3);\n    const d123_2 = n123 * matrix.crossVec2Vec2(w3, w1);\n    const d123_3 = n123 * matrix.crossVec2Vec2(w1, w2);\n\n    // w1 region\n    if (d12_2 <= 0.0 && d13_2 <= 0.0) {\n      this.m_v1.a = 1.0;\n      this.m_count = 1;\n      return;\n    }\n\n    // e12\n    if (d12_1 > 0.0 && d12_2 > 0.0 && d123_3 <= 0.0) {\n      const inv_d12 = 1.0 / (d12_1 + d12_2);\n      this.m_v1.a = d12_1 * inv_d12;\n      this.m_v2.a = d12_2 * inv_d12;\n      this.m_count = 2;\n      return;\n    }\n\n    // e13\n    if (d13_1 > 0.0 && d13_2 > 0.0 && d123_2 <= 0.0) {\n      const inv_d13 = 1.0 / (d13_1 + d13_2);\n      this.m_v1.a = d13_1 * inv_d13;\n      this.m_v3.a = d13_2 * inv_d13;\n      this.m_count = 2;\n      this.m_v2.set(this.m_v3);\n      return;\n    }\n\n    // w2 region\n    if (d12_1 <= 0.0 && d23_2 <= 0.0) {\n      this.m_v2.a = 1.0;\n      this.m_count = 1;\n      this.m_v1.set(this.m_v2);\n      return;\n    }\n\n    // w3 region\n    if (d13_1 <= 0.0 && d23_1 <= 0.0) {\n      this.m_v3.a = 1.0;\n      this.m_count = 1;\n      this.m_v1.set(this.m_v3);\n      return;\n    }\n\n    // e23\n    if (d23_1 > 0.0 && d23_2 > 0.0 && d123_1 <= 0.0) {\n      const inv_d23 = 1.0 / (d23_1 + d23_2);\n      this.m_v2.a = d23_1 * inv_d23;\n      this.m_v3.a = d23_2 * inv_d23;\n      this.m_count = 2;\n      this.m_v1.set(this.m_v3);\n      return;\n    }\n\n    // Must be in triangle123\n    const inv_d123 = 1.0 / (d123_1 + d123_2 + d123_3);\n    this.m_v1.a = d123_1 * inv_d123;\n    this.m_v2.a = d123_2 * inv_d123;\n    this.m_v3.a = d123_3 * inv_d123;\n    this.m_count = 3;\n  }\n}\n\nconst simplex = new Simplex();\n\nconst input = new DistanceInput();\nconst cache = new SimplexCache();\nconst output = new DistanceOutput();\n\n/**\n * Determine if two generic shapes overlap.\n */\nexport const testOverlap = function (shapeA: Shape, indexA: number, shapeB: Shape, indexB: number, xfA: TransformValue, xfB: TransformValue): boolean {\n  input.recycle();\n  input.proxyA.set(shapeA, indexA);\n  input.proxyB.set(shapeB, indexB);\n  matrix.copyTransform(input.transformA, xfA);\n  matrix.copyTransform(input.transformB, xfB);\n  input.useRadii = true;\n\n  output.recycle();\n  cache.recycle();\n\n  Distance(output, cache, input);\n\n  return output.distance < 10.0 * Math.EPSILON;\n}\n\n// legacy exports\nDistance.testOverlap = testOverlap;\nDistance.Input = DistanceInput;\nDistance.Output = DistanceOutput;\nDistance.Proxy = DistanceProxy;\nDistance.Cache = SimplexCache;\n\n/**\n * Input parameters for ShapeCast\n */\nexport class ShapeCastInput {\n  readonly proxyA = new DistanceProxy();\n  readonly proxyB = new DistanceProxy();\n  readonly transformA = Transform.identity();\n  readonly transformB = Transform.identity();\n  readonly translationB = Vec2.zero();\n  recycle() {\n    this.proxyA.recycle();\n    this.proxyB.recycle();\n    this.transformA.setIdentity();\n    this.transformB.setIdentity();\n    matrix.zeroVec2(this.translationB);\n  }\n}\n\n/**\n * Output results for b2ShapeCast\n */\nexport class ShapeCastOutput {\n  point: Vec2 = Vec2.zero();\n  normal: Vec2 = Vec2.zero();\n  lambda = 1.0;\n  iterations = 0;\n}\n\n/**\n * Perform a linear shape cast of shape B moving and shape A fixed. Determines\n * the hit point, normal, and translation fraction.\n * \n * @returns true if hit, false if there is no hit or an initial overlap\n */\n//\n// GJK-raycast\n// Algorithm by Gino van den Bergen.\n// \"Smooth Mesh Contacts with GJK\" in Game Physics Pearls. 2010\nexport const ShapeCast = function(output: ShapeCastOutput, input: ShapeCastInput): boolean {\n  output.iterations = 0;\n  output.lambda = 1.0;\n  output.normal.setZero();\n  output.point.setZero();\n\n  const proxyA = input.proxyA;\n  const proxyB = input.proxyB;\n\n  const radiusA = Math.max(proxyA.m_radius, Settings.polygonRadius);\n  const radiusB = Math.max(proxyB.m_radius, Settings.polygonRadius);\n  const radius = radiusA + radiusB;\n\n  const xfA = input.transformA;\n  const xfB = input.transformB;\n\n  const r = input.translationB;\n  const n = Vec2.zero();\n  let lambda = 0.0;\n\n  // Initial simplex\n  const simplex = new Simplex();\n  simplex.m_count = 0;\n\n  // Get simplex vertices as an array.\n  const vertices = simplex.m_v;\n\n  // Get support point in -r direction\n  let indexA = proxyA.getSupport(Rot.mulTVec2(xfA.q, Vec2.neg(r)));\n  let wA = Transform.mulVec2(xfA, proxyA.getVertex(indexA));\n  let indexB = proxyB.getSupport(Rot.mulTVec2(xfB.q, r));\n  let wB = Transform.mulVec2(xfB, proxyB.getVertex(indexB));\n  const v = Vec2.sub(wA, wB);\n\n  // Sigma is the target distance between polygons\n  const sigma = Math.max(Settings.polygonRadius, radius - Settings.polygonRadius);\n  const tolerance = 0.5 * Settings.linearSlop;\n\n  // Main iteration loop.\n  const k_maxIters = 20;\n  let iter = 0;\n  while (iter < k_maxIters && v.length() - sigma > tolerance) {\n    _ASSERT && console.assert(simplex.m_count < 3);\n\n    output.iterations += 1;\n\n    // Support in direction -v (A - B)\n    indexA = proxyA.getSupport(Rot.mulTVec2(xfA.q, Vec2.neg(v)));\n    wA = Transform.mulVec2(xfA, proxyA.getVertex(indexA));\n    indexB = proxyB.getSupport(Rot.mulTVec2(xfB.q, v));\n    wB = Transform.mulVec2(xfB, proxyB.getVertex(indexB));\n    const p = Vec2.sub(wA, wB);\n\n    // -v is a normal at p\n    v.normalize();\n\n    // Intersect ray with plane\n    const vp = Vec2.dot(v, p);\n    const vr = Vec2.dot(v, r);\n    if (vp - sigma > lambda * vr) {\n      if (vr <= 0.0) {\n        return false;\n      }\n\n      lambda = (vp - sigma) / vr;\n      if (lambda > 1.0) {\n        return false;\n      }\n\n      n.setMul(-1, v);\n      simplex.m_count = 0;\n    }\n\n    // Reverse simplex since it works with B - A.\n    // Shift by lambda * r because we want the closest point to the current clip point.\n    // Note that the support point p is not shifted because we want the plane equation\n    // to be formed in unshifted space.\n    const vertex = vertices[simplex.m_count];\n    vertex.indexA = indexB;\n    vertex.wA = Vec2.combine(1, wB, lambda, r);\n    vertex.indexB = indexA;\n    vertex.wB = wA;\n    vertex.w = Vec2.sub(vertex.wB, vertex.wA);\n    vertex.a = 1.0;\n    simplex.m_count += 1;\n\n    switch (simplex.m_count) {\n      case 1:\n        break;\n\n      case 2:\n        simplex.solve2();\n        break;\n\n      case 3:\n        simplex.solve3();\n        break;\n\n      default:\n        _ASSERT && console.assert(false);\n    }\n    \n    // If we have 3 points, then the origin is in the corresponding triangle.\n    if (simplex.m_count == 3) {\n      // Overlap\n      return false;\n    }\n\n    // Get search direction.\n    v.setVec2(simplex.getClosestPoint());\n\n    // Iteration count is equated to the number of support point calls.\n    ++iter;\n  }\n\n  if (iter == 0) {\n    // Initial overlap\n    return false;\n\t}\n\n  // Prepare output.\n  const pointA = Vec2.zero();\n  const pointB = Vec2.zero();\n  simplex.getWitnessPoints(pointB, pointA);\n\n  if (v.lengthSquared() > 0.0) {\n    n.setMul(-1, v);\n    n.normalize();\n  }\n\n  output.point = Vec2.combine(1, pointA, radiusA, n);\n  output.normal = n;\n  output.lambda = lambda;\n  output.iterations = iter;\n  return true;\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport * as matrix from '../common/Matrix';\nimport { SettingsInternal as Settings } from '../Settings';\nimport { stats } from '../util/stats';\nimport Timer from '../util/Timer';\nimport { math as Math } from '../common/Math';\nimport { Sweep } from '../common/Sweep';\nimport { Transform } from '../common/Transform';\nimport { Distance, DistanceInput, DistanceOutput, DistanceProxy, SimplexCache } from './Distance';\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n/**\n * Input parameters for TimeOfImpact.\n */\nexport class TOIInput {\n  proxyA = new DistanceProxy();\n  proxyB = new DistanceProxy();\n  sweepA = new Sweep();\n  sweepB = new Sweep();\n  /** defines sweep interval [0, tMax] */\n  tMax: number;\n  recycle() {\n    this.proxyA.recycle();\n    this.proxyB.recycle();\n    this.sweepA.recycle();\n    this.sweepB.recycle();\n    this.tMax = -1;\n  }\n}\n\nexport enum TOIOutputState {\n  e_unset = -1,\n  e_unknown = 0,\n  e_failed = 1,\n  e_overlapped = 2,\n  e_touching = 3,\n  e_separated = 4,\n}\n\n/**\n * Output parameters for TimeOfImpact.\n */\nexport class TOIOutput {\n  state = TOIOutputState.e_unset;\n  t = -1;\n  recycle() {\n    this.state = TOIOutputState.e_unset;\n    this.t = -1;\n  }\n}\n\nstats.toiTime = 0;\nstats.toiMaxTime = 0;\nstats.toiCalls = 0;\nstats.toiIters = 0;\nstats.toiMaxIters = 0;\nstats.toiRootIters = 0;\nstats.toiMaxRootIters = 0;\n\nconst distanceInput = new DistanceInput();\nconst distanceOutput = new DistanceOutput();\n// this is passed to Distance and SeparationFunction\nconst cache = new SimplexCache();\n\nconst xfA = matrix.transform(0, 0, 0);\nconst xfB = matrix.transform(0, 0, 0);\nconst temp = matrix.vec2(0, 0);\nconst pointA = matrix.vec2(0, 0);\nconst pointB = matrix.vec2(0, 0);\nconst normal = matrix.vec2(0, 0);\nconst axisA = matrix.vec2(0, 0);\nconst axisB = matrix.vec2(0, 0);\nconst localPointA = matrix.vec2(0, 0);\nconst localPointB = matrix.vec2(0, 0);\n\n\n/**\n * Compute the upper bound on time before two shapes penetrate. Time is\n * represented as a fraction between [0,tMax]. This uses a swept separating axis\n * and may miss some intermediate, non-tunneling collisions. If you change the\n * time interval, you should call this function again.\n *\n * Note: use Distance to compute the contact point and normal at the time of\n * impact.\n *\n * CCD via the local separating axis method. This seeks progression by computing\n * the largest time at which separation is maintained.\n */\nexport const TimeOfImpact = function (output: TOIOutput, input: TOIInput): void {\n  const timer = Timer.now();\n\n  ++stats.toiCalls;\n\n  output.state = TOIOutputState.e_unknown;\n  output.t = input.tMax;\n\n  const proxyA = input.proxyA; // DistanceProxy\n  const proxyB = input.proxyB; // DistanceProxy\n\n  const sweepA = input.sweepA; // Sweep\n  const sweepB = input.sweepB; // Sweep\n\n  // Large rotations can make the root finder fail, so we normalize the\n  // sweep angles.\n  sweepA.normalize();\n  sweepB.normalize();\n\n  const tMax = input.tMax;\n\n  const totalRadius = proxyA.m_radius + proxyB.m_radius;\n  const target = Math.max(Settings.linearSlop, totalRadius - 3.0 * Settings.linearSlop);\n  const tolerance = 0.25 * Settings.linearSlop;\n  _ASSERT && console.assert(target > tolerance);\n\n  let t1 = 0.0;\n  const k_maxIterations = Settings.maxTOIIterations;\n  let iter = 0;\n\n  // Prepare input for distance query.\n  // const cache = new SimplexCache();\n  cache.recycle();\n\n  distanceInput.proxyA.setVertices(proxyA.m_vertices, proxyA.m_count, proxyA.m_radius);\n  distanceInput.proxyB.setVertices(proxyB.m_vertices, proxyB.m_count, proxyB.m_radius);\n  distanceInput.useRadii = false;\n\n  // The outer loop progressively attempts to compute new separating axes.\n  // This loop terminates when an axis is repeated (no progress is made).\n  while (true) {\n    sweepA.getTransform(xfA, t1);\n    sweepB.getTransform(xfB, t1);\n\n    // Get the distance between shapes. We can also use the results\n    // to get a separating axis.\n    matrix.copyTransform(distanceInput.transformA, xfA);\n    matrix.copyTransform(distanceInput.transformB, xfB);\n    Distance(distanceOutput, cache, distanceInput);\n\n    // If the shapes are overlapped, we give up on continuous collision.\n    if (distanceOutput.distance <= 0.0) {\n      // Failure!\n      output.state = TOIOutputState.e_overlapped;\n      output.t = 0.0;\n      break;\n    }\n\n    if (distanceOutput.distance < target + tolerance) {\n      // Victory!\n      output.state = TOIOutputState.e_touching;\n      output.t = t1;\n      break;\n    }\n\n    // Initialize the separating axis.\n    separationFunction.initialize(cache, proxyA, sweepA, proxyB, sweepB, t1);\n\n    // if (false) {\n    //   // Dump the curve seen by the root finder\n    //   const N = 100;\n    //   const dx = 1.0 / N;\n    //   const xs = []; // [ N + 1 ];\n    //   const fs = []; // [ N + 1 ];\n    //   const x = 0.0;\n    //   for (const i = 0; i <= N; ++i) {\n    //     sweepA.getTransform(xfA, x);\n    //     sweepB.getTransform(xfB, x);\n    //     const f = fcn.evaluate(xfA, xfB) - target;\n    //     printf(\"%g %g\\n\", x, f);\n    //     xs[i] = x;\n    //     fs[i] = f;\n    //     x += dx;\n    //   }\n    // }\n\n    // Compute the TOI on the separating axis. We do this by successively\n    // resolving the deepest point. This loop is bounded by the number of\n    // vertices.\n    let done = false;\n    let t2 = tMax;\n    let pushBackIter = 0;\n    while (true) {\n      // Find the deepest point at t2. Store the witness point indices.\n      let s2 = separationFunction.findMinSeparation(t2);\n\n      // Is the final configuration separated?\n      if (s2 > target + tolerance) {\n        // Victory!\n        output.state = TOIOutputState.e_separated;\n        output.t = tMax;\n        done = true;\n        break;\n      }\n\n      // Has the separation reached tolerance?\n      if (s2 > target - tolerance) {\n        // Advance the sweeps\n        t1 = t2;\n        break;\n      }\n\n      // Compute the initial separation of the witness points.\n      let s1 = separationFunction.evaluate(t1);\n\n      // Check for initial overlap. This might happen if the root finder\n      // runs out of iterations.\n      if (s1 < target - tolerance) {\n        output.state = TOIOutputState.e_failed;\n        output.t = t1;\n        done = true;\n        break;\n      }\n\n      // Check for touching\n      if (s1 <= target + tolerance) {\n        // Victory! t1 should hold the TOI (could be 0.0).\n        output.state = TOIOutputState.e_touching;\n        output.t = t1;\n        done = true;\n        break;\n      }\n\n      // Compute 1D root of: f(x) - target = 0\n      let rootIterCount = 0;\n      let a1 = t1;\n      let a2 = t2;\n      while (true) {\n        // Use a mix of the secant rule and bisection.\n        let t;\n        if (rootIterCount & 1) {\n          // Secant rule to improve convergence.\n          t = a1 + (target - s1) * (a2 - a1) / (s2 - s1);\n        } else {\n          // Bisection to guarantee progress.\n          t = 0.5 * (a1 + a2);\n        }\n\n        ++rootIterCount;\n        ++stats.toiRootIters;\n\n        const s = separationFunction.evaluate(t);\n\n        if (Math.abs(s - target) < tolerance) {\n          // t2 holds a tentative value for t1\n          t2 = t;\n          break;\n        }\n\n        // Ensure we continue to bracket the root.\n        if (s > target) {\n          a1 = t;\n          s1 = s;\n        } else {\n          a2 = t;\n          s2 = s;\n        }\n\n        if (rootIterCount === 50) {\n          break;\n        }\n      }\n\n      stats.toiMaxRootIters = Math.max(stats.toiMaxRootIters, rootIterCount);\n\n      ++pushBackIter;\n\n      if (pushBackIter === Settings.maxPolygonVertices) {\n        break;\n      }\n    }\n\n    ++iter;\n    ++stats.toiIters;\n\n    if (done) {\n      break;\n    }\n\n    if (iter === k_maxIterations) {\n      // Root finder got stuck. Semi-victory.\n      output.state = TOIOutputState.e_failed;\n      output.t = t1;\n      break;\n    }\n  }\n\n  stats.toiMaxIters = Math.max(stats.toiMaxIters, iter);\n\n  const time = Timer.diff(timer);\n  stats.toiMaxTime = Math.max(stats.toiMaxTime, time);\n  stats.toiTime += time;\n\n  separationFunction.recycle();\n}\n\nenum SeparationFunctionType {\n  e_unset = -1,\n  e_points = 1,\n  e_faceA = 2,\n  e_faceB = 3,\n}\n\nclass SeparationFunction {\n  // input cache\n  // todo: maybe assign by copy instead of reference?\n  m_proxyA: DistanceProxy = null;\n  m_proxyB: DistanceProxy = null;\n  m_sweepA: Sweep = null;\n  m_sweepB: Sweep = null;\n\n  // initialize cache\n  m_type = SeparationFunctionType.e_unset;\n  m_localPoint = matrix.vec2(0, 0);\n  m_axis = matrix.vec2(0, 0);\n\n  // compute output\n  indexA = -1;\n  indexB = -1;\n\n  recycle() {\n    this.m_proxyA = null;\n    this.m_proxyB = null;\n    this.m_sweepA = null;\n    this.m_sweepB = null;\n\n    this.m_type = SeparationFunctionType.e_unset;\n    matrix.zeroVec2(this.m_localPoint)\n    matrix.zeroVec2(this.m_axis)\n\n    this.indexA = -1;\n    this.indexB = -1;\n  }\n\n  // TODO_ERIN might not need to return the separation\n\n  initialize(cache: SimplexCache, proxyA: DistanceProxy, sweepA: Sweep, proxyB: DistanceProxy, sweepB: Sweep, t1: number): number {\n    const count = cache.count;\n    _ASSERT && console.assert(0 < count && count < 3);\n\n    this.m_proxyA = proxyA;\n    this.m_proxyB = proxyB;\n    this.m_sweepA = sweepA;\n    this.m_sweepB = sweepB;\n\n    this.m_sweepA.getTransform(xfA, t1);\n    this.m_sweepB.getTransform(xfB, t1);\n\n    if (count === 1) {\n      this.m_type = SeparationFunctionType.e_points;\n      const localPointA = this.m_proxyA.getVertex(cache.indexA[0]);\n      const localPointB = this.m_proxyB.getVertex(cache.indexB[0]);\n      matrix.transformVec2(pointA, xfA, localPointA);\n      matrix.transformVec2(pointB, xfB, localPointB);\n      matrix.diffVec2(this.m_axis, pointB, pointA);\n      const s = matrix.normalizeVec2Length(this.m_axis);\n      return s;\n\n    } else if (cache.indexA[0] === cache.indexA[1]) {\n      // Two points on B and one on A.\n      this.m_type = SeparationFunctionType.e_faceB;\n      const localPointB1 = proxyB.getVertex(cache.indexB[0]);\n      const localPointB2 = proxyB.getVertex(cache.indexB[1]);\n\n      matrix.crossVec2Num(this.m_axis, matrix.diffVec2(temp, localPointB2, localPointB1), 1.0);\n      matrix.normalizeVec2(this.m_axis);\n      matrix.rotVec2(normal, xfB.q, this.m_axis);\n\n      matrix.combineVec2(this.m_localPoint, 0.5, localPointB1, 0.5, localPointB2);\n      matrix.transformVec2(pointB, xfB, this.m_localPoint);\n\n      const localPointA = proxyA.getVertex(cache.indexA[0]);\n      const pointA = Transform.mulVec2(xfA, localPointA);\n\n      let s = matrix.dotVec2(pointA, normal) - matrix.dotVec2(pointB, normal);\n      if (s < 0.0) {\n        matrix.negVec2(this.m_axis);\n        s = -s;\n      }\n      return s;\n\n    } else {\n      // Two points on A and one or two points on B.\n      this.m_type = SeparationFunctionType.e_faceA;\n      const localPointA1 = this.m_proxyA.getVertex(cache.indexA[0]);\n      const localPointA2 = this.m_proxyA.getVertex(cache.indexA[1]);\n\n      matrix.crossVec2Num(this.m_axis, matrix.diffVec2(temp, localPointA2, localPointA1), 1.0);\n      matrix.normalizeVec2(this.m_axis);\n      matrix.rotVec2(normal, xfA.q, this.m_axis);\n\n      matrix.combineVec2(this.m_localPoint, 0.5, localPointA1, 0.5, localPointA2);\n      matrix.transformVec2(pointA, xfA, this.m_localPoint);\n\n      const localPointB = this.m_proxyB.getVertex(cache.indexB[0]);\n      matrix.transformVec2(pointB, xfB, localPointB);\n\n      let s = matrix.dotVec2(pointB, normal) - matrix.dotVec2(pointA, normal);\n      if (s < 0.0) {\n        matrix.negVec2(this.m_axis);\n        s = -s;\n      }\n      return s;\n    }\n  }\n\n  compute(find: boolean, t: number): number {\n    // It was findMinSeparation and evaluate\n    this.m_sweepA.getTransform(xfA, t);\n    this.m_sweepB.getTransform(xfB, t);\n\n    switch (this.m_type) {\n      case SeparationFunctionType.e_points: {\n        if (find) {\n          matrix.invRotVec2(axisA, xfA.q, this.m_axis);\n          matrix.invRotVec2(axisB, xfB.q, matrix.setMulVec2(temp, -1, this.m_axis));\n\n          this.indexA = this.m_proxyA.getSupport(axisA);\n          this.indexB = this.m_proxyB.getSupport(axisB);\n        }\n\n        matrix.copyVec2(localPointA, this.m_proxyA.getVertex(this.indexA));\n        matrix.copyVec2(localPointB, this.m_proxyB.getVertex(this.indexB));\n\n        matrix.transformVec2(pointA, xfA, localPointA);\n        matrix.transformVec2(pointB, xfB, localPointB);\n\n        const sep = matrix.dotVec2(pointB, this.m_axis) - matrix.dotVec2(pointA, this.m_axis);\n        return sep;\n      }\n\n      case SeparationFunctionType.e_faceA: {\n        matrix.rotVec2(normal, xfA.q, this.m_axis);\n        matrix.transformVec2(pointA, xfA, this.m_localPoint);\n\n        if (find) {\n          matrix.invRotVec2(axisB, xfB.q, matrix.setMulVec2(temp, -1, normal));\n\n          this.indexA = -1;\n          this.indexB = this.m_proxyB.getSupport(axisB);\n        }\n\n        matrix.copyVec2(localPointB, this.m_proxyB.getVertex(this.indexB));\n        matrix.transformVec2(pointB, xfB, localPointB);\n\n        const sep = matrix.dotVec2(pointB, normal) - matrix.dotVec2(pointA, normal);\n        return sep;\n      }\n\n      case SeparationFunctionType.e_faceB: {\n        matrix.rotVec2(normal, xfB.q, this.m_axis);\n        matrix.transformVec2(pointB, xfB, this.m_localPoint);\n\n        if (find) {\n          matrix.invRotVec2(axisA, xfA.q, matrix.setMulVec2(temp, -1, normal));\n\n          this.indexB = -1;\n          this.indexA = this.m_proxyA.getSupport(axisA);\n        }\n\n        matrix.copyVec2(localPointA, this.m_proxyA.getVertex(this.indexA));\n        matrix.transformVec2(pointA, xfA, localPointA);\n\n        const sep = matrix.dotVec2(pointA, normal) - matrix.dotVec2(pointB, normal);\n        return sep;\n      }\n\n      default:\n        _ASSERT && console.assert(false);\n        if (find) {\n          this.indexA = -1;\n          this.indexB = -1;\n        }\n        return 0.0;\n    }\n  }\n\n  findMinSeparation(t: number): number {\n    return this.compute(true, t);\n  }\n\n  evaluate(t: number): number {\n    return this.compute(false, t);\n  }\n}\n\nconst separationFunction = new SeparationFunction();\n\n// legacy exports\nTimeOfImpact.Input = TOIInput;\nTimeOfImpact.Output = TOIOutput;\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport * as matrix from '../common/Matrix';\nimport { SettingsInternal as Settings } from '../Settings';\nimport { math as Math } from '../common/Math';\nimport { Body } from './Body';\nimport type { Contact } from './Contact';\nimport { Joint } from './Joint';\nimport { TimeOfImpact, TOIInput, TOIOutput, TOIOutputState } from '../collision/TimeOfImpact';\nimport { Distance, DistanceInput, DistanceOutput, SimplexCache } from '../collision/Distance';\nimport { World } from \"./World\";\nimport { Sweep } from '../common/Sweep';\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nexport class TimeStep {\n  /** time step */\n  dt: number = 0;\n  /** inverse time step (0 if dt == 0) */\n  inv_dt: number = 0;\n  velocityIterations: number = 0;\n  positionIterations: number = 0;\n  warmStarting: boolean = false;\n  blockSolve: boolean = true;\n\n  /** timestep ratio for variable timestep */\n  inv_dt0: number = 0.0;\n  /** dt * inv_dt0 */\n  dtRatio: number = 1;\n\n  reset(dt: number): void {\n    if (this.dt > 0.0) {\n      this.inv_dt0 = this.inv_dt;\n    }\n    this.dt = dt;\n    this.inv_dt = dt == 0 ? 0 : 1 / dt;\n    this.dtRatio = dt * this.inv_dt0;\n  }\n}\n\n// reuse\nconst s_subStep = new TimeStep();\nconst c = matrix.vec2(0, 0);\nconst v = matrix.vec2(0, 0);\nconst translation = matrix.vec2(0, 0);\nconst input = new TOIInput();\nconst output = new TOIOutput();\nconst backup = new Sweep();\nconst backup1 = new Sweep();\nconst backup2 = new Sweep();\n\n/**\n * Contact impulses for reporting. Impulses are used instead of forces because\n * sub-step forces may approach infinity for rigid body collisions. These match\n * up one-to-one with the contact points in Manifold.\n */\nexport class ContactImpulse {\n  // TODO: merge with Contact class?\n\n  private readonly contact: Contact;\n  private readonly normals: number[];\n  private readonly tangents: number[];\n\n  constructor(contact: Contact) {\n    this.contact = contact;\n    this.normals = [];\n    this.tangents = [];\n  }\n\n  recycle() {\n    this.normals.length = 0;\n    this.tangents.length = 0;\n  }\n\n  get normalImpulses(): number[] {\n    const contact = this.contact;\n    const normals = this.normals;\n    normals.length = 0;\n    for (let p = 0; p < contact.v_points.length; ++p) {\n      normals.push(contact.v_points[p].normalImpulse);\n    }\n    return normals;\n  }\n\n  get tangentImpulses(): number[] {\n    const contact = this.contact;\n    const tangents = this.tangents;\n    tangents.length = 0;\n    for (let p = 0; p < contact.v_points.length; ++p) {\n      tangents.push(contact.v_points[p].tangentImpulse);\n    }\n    return tangents;\n  }\n}\n\n/**\n * Finds and solves islands. An island is a connected subset of the world.\n */\nexport class Solver {\n  m_world: World;\n  m_stack: Body[];\n  m_bodies: Body[];\n  m_contacts: Contact[];\n  m_joints: Joint[];\n\n  constructor(world: World) {\n    this.m_world = world;\n    this.m_stack = [];\n    this.m_bodies = [];\n    this.m_contacts = [];\n    this.m_joints = [];\n  }\n\n  clear(): void {\n    this.m_stack.length = 0;\n    this.m_bodies.length = 0;\n    this.m_contacts.length = 0;\n    this.m_joints.length = 0;\n  }\n\n  addBody(body: Body): void {\n    _ASSERT && console.assert(body instanceof Body, 'Not a Body!', body);\n    this.m_bodies.push(body);\n    // why?\n    // body.c_position.c.setZero();\n    // body.c_position.a = 0;\n    // body.c_velocity.v.setZero();\n    // body.c_velocity.w = 0;\n  }\n\n  addContact(contact: Contact): void {\n    // _ASSERT && console.assert(contact instanceof Contact, 'Not a Contact!', contact);\n    this.m_contacts.push(contact);\n  }\n\n  addJoint(joint: Joint): void {\n    _ASSERT && console.assert(joint instanceof Joint, 'Not a Joint!', joint);\n    this.m_joints.push(joint);\n  }\n\n  solveWorld(step: TimeStep): void {\n    const world = this.m_world;\n\n    // Clear all the island flags.\n    for (let b = world.m_bodyList; b; b = b.m_next) {\n      b.m_islandFlag = false;\n    }\n    for (let c = world.m_contactList; c; c = c.m_next) {\n      c.m_islandFlag = false;\n    }\n    for (let j = world.m_jointList; j; j = j.m_next) {\n      j.m_islandFlag = false;\n    }\n\n    // Build and simulate all awake islands.\n    const stack = this.m_stack;\n    let loop = -1;\n    for (let seed = world.m_bodyList; seed; seed = seed.m_next) {\n      loop++;\n      if (seed.m_islandFlag) {\n        continue;\n      }\n\n      if (seed.isAwake() == false || seed.isActive() == false) {\n        continue;\n      }\n\n      // The seed can be dynamic or kinematic.\n      if (seed.isStatic()) {\n        continue;\n      }\n\n      // Reset island and stack.\n      this.clear();\n\n      stack.push(seed);\n\n      seed.m_islandFlag = true;\n\n      // Perform a depth first search (DFS) on the constraint graph.\n      while (stack.length > 0) {\n        // Grab the next body off the stack and add it to the island.\n        const b = stack.pop();\n        _ASSERT && console.assert(b.isActive() == true);\n        this.addBody(b);\n\n        // Make sure the body is awake (without resetting sleep timer).\n        b.m_awakeFlag = true;\n\n        // To keep islands as small as possible, we don't\n        // propagate islands across static bodies.\n        if (b.isStatic()) {\n          continue;\n        }\n\n        // Search all contacts connected to this body.\n        for (let ce = b.m_contactList; ce; ce = ce.next) {\n          const contact = ce.contact;\n\n          // Has this contact already been added to an island?\n          if (contact.m_islandFlag) {\n            continue;\n          }\n\n          // Is this contact solid and touching?\n          if (contact.isEnabled() == false || contact.isTouching() == false) {\n            continue;\n          }\n\n          // Skip sensors.\n          const sensorA = contact.m_fixtureA.m_isSensor;\n          const sensorB = contact.m_fixtureB.m_isSensor;\n          if (sensorA || sensorB) {\n            continue;\n          }\n\n          this.addContact(contact);\n          contact.m_islandFlag = true;\n\n          const other = ce.other;\n\n          // Was the other body already added to this island?\n          if (other.m_islandFlag) {\n            continue;\n          }\n\n          // _ASSERT && console.assert(stack.length < world.m_bodyCount);\n          stack.push(other);\n          other.m_islandFlag = true;\n        }\n\n        // Search all joints connect to this body.\n        for (let je = b.m_jointList; je; je = je.next) {\n          if (je.joint.m_islandFlag == true) {\n            continue;\n          }\n\n          const other = je.other;\n\n          // Don't simulate joints connected to inactive bodies.\n          if (other.isActive() == false) {\n            continue;\n          }\n\n          this.addJoint(je.joint);\n          je.joint.m_islandFlag = true;\n\n          if (other.m_islandFlag) {\n            continue;\n          }\n\n          // _ASSERT && console.assert(stack.length < world.m_bodyCount);\n          stack.push(other);\n          other.m_islandFlag = true;\n        }\n      }\n\n      this.solveIsland(step);\n\n      // Post solve cleanup.\n      for (let i = 0; i < this.m_bodies.length; ++i) {\n        // Allow static bodies to participate in other islands.\n        // TODO: are they added at all?\n        const b = this.m_bodies[i];\n        if (b.isStatic()) {\n          b.m_islandFlag = false;\n        }\n      }\n    }\n  }\n\n  solveIsland(step: TimeStep): void {\n    // B2: Island Solve\n    const world = this.m_world;\n    const gravity = world.m_gravity;\n    const allowSleep = world.m_allowSleep;\n\n    const h = step.dt;\n\n    // Integrate velocities and apply damping. Initialize the body state.\n    for (let i = 0; i < this.m_bodies.length; ++i) {\n      const body = this.m_bodies[i];\n\n      matrix.copyVec2(c, body.m_sweep.c);\n      const a = body.m_sweep.a;\n      matrix.copyVec2(v, body.m_linearVelocity);\n      let w = body.m_angularVelocity;\n\n      // Store positions for continuous collision.\n      matrix.copyVec2(body.m_sweep.c0, body.m_sweep.c);\n      body.m_sweep.a0 = body.m_sweep.a;\n\n      if (body.isDynamic()) {\n        // Integrate velocities.\n        matrix.addMulVec2(v, h * body.m_gravityScale, gravity);\n        matrix.addMulVec2(v, h * body.m_invMass, body.m_force);\n        w += h * body.m_invI * body.m_torque;\n        /**\n         * <pre>\n         * Apply damping.\n         * ODE: dv/dt + c * v = 0\n         * Solution: v(t) = v0 * exp(-c * t)\n         * Time step: v(t + dt) = v0 * exp(-c * (t + dt)) = v0 * exp(-c * t) * exp(-c * dt) = v * exp(-c * dt)\n         * v2 = exp(-c * dt) * v1\n         * Pade approximation:\n         * v2 = v1 * 1 / (1 + c * dt)\n         * </pre>\n         */\n        matrix.setMulVec2(v, 1.0 / (1.0 + h * body.m_linearDamping), v)\n        w *= 1.0 / (1.0 + h * body.m_angularDamping);\n      }\n\n      matrix.copyVec2(body.c_position.c, c);\n      body.c_position.a = a;\n      matrix.copyVec2(body.c_velocity.v, v);\n      body.c_velocity.w = w;\n    }\n\n    for (let i = 0; i < this.m_contacts.length; ++i) {\n      const contact = this.m_contacts[i];\n      contact.initConstraint(step);\n    }\n\n    for (let i = 0; i < this.m_contacts.length; ++i) {\n      const contact = this.m_contacts[i];\n      contact.initVelocityConstraint(step);\n    }\n\n    if (step.warmStarting) {\n      // Warm start.\n      for (let i = 0; i < this.m_contacts.length; ++i) {\n        const contact = this.m_contacts[i];\n        contact.warmStartConstraint(step);\n      }\n    }\n\n    for (let i = 0; i < this.m_joints.length; ++i) {\n      const joint = this.m_joints[i];\n      joint.initVelocityConstraints(step);\n    }\n\n    // Solve velocity constraints\n    for (let i = 0; i < step.velocityIterations; ++i) {\n      for (let j = 0; j < this.m_joints.length; ++j) {\n        const joint = this.m_joints[j];\n        joint.solveVelocityConstraints(step);\n      }\n\n      for (let j = 0; j < this.m_contacts.length; ++j) {\n        const contact = this.m_contacts[j];\n        contact.solveVelocityConstraint(step);\n      }\n    }\n\n    // Store impulses for warm starting\n    for (let i = 0; i < this.m_contacts.length; ++i) {\n      const contact = this.m_contacts[i];\n      contact.storeConstraintImpulses(step);\n    }\n\n    // Integrate positions\n    for (let i = 0; i < this.m_bodies.length; ++i) {\n      const body = this.m_bodies[i];\n\n      matrix.copyVec2(c, body.c_position.c);\n      let a = body.c_position.a;\n      matrix.copyVec2(v, body.c_velocity.v);\n      let w = body.c_velocity.w;\n\n      // Check for large velocities\n      matrix.setMulVec2(translation, h, v);\n      const translationLengthSqr = matrix.lengthSqrVec2(translation);\n      if (translationLengthSqr > Settings.maxTranslationSquared) {\n        const ratio = Settings.maxTranslation / Math.sqrt(translationLengthSqr);\n        matrix.scaleVec2(v, ratio);\n      }\n\n      const rotation = h * w;\n      if (rotation * rotation > Settings.maxRotationSquared) {\n        const ratio = Settings.maxRotation / Math.abs(rotation);\n        w *= ratio;\n      }\n\n      // Integrate\n      matrix.addMulVec2(c, h, v);\n      a += h * w;\n\n      matrix.copyVec2(body.c_position.c, c);\n      body.c_position.a = a;\n      matrix.copyVec2(body.c_velocity.v, v);\n      body.c_velocity.w = w;\n    }\n\n    // Solve position constraints\n    let positionSolved = false;\n    for (let i = 0; i < step.positionIterations; ++i) {\n      let minSeparation = 0.0;\n      for (let j = 0; j < this.m_contacts.length; ++j) {\n        const contact = this.m_contacts[j];\n        const separation = contact.solvePositionConstraint(step);\n        minSeparation = Math.min(minSeparation, separation);\n      }\n      // We can't expect minSpeparation >= -Settings.linearSlop because we don't\n      // push the separation above -Settings.linearSlop.\n      const contactsOkay = minSeparation >= -3.0 * Settings.linearSlop;\n\n      let jointsOkay = true;\n      for (let j = 0; j < this.m_joints.length; ++j) {\n        const joint = this.m_joints[j];\n        const jointOkay = joint.solvePositionConstraints(step);\n        jointsOkay = jointsOkay && jointOkay;\n      }\n\n      if (contactsOkay && jointsOkay) {\n        // Exit early if the position errors are small.\n        positionSolved = true;\n        break;\n      }\n    }\n\n    // Copy state buffers back to the bodies\n    for (let i = 0; i < this.m_bodies.length; ++i) {\n      const body = this.m_bodies[i];\n\n      matrix.copyVec2(body.m_sweep.c, body.c_position.c);\n      body.m_sweep.a = body.c_position.a;\n      matrix.copyVec2(body.m_linearVelocity, body.c_velocity.v);\n      body.m_angularVelocity = body.c_velocity.w;\n      body.synchronizeTransform();\n    }\n\n    this.postSolveIsland();\n\n    if (allowSleep) {\n      let minSleepTime = Infinity;\n\n      const linTolSqr = Settings.linearSleepToleranceSqr;\n      const angTolSqr = Settings.angularSleepToleranceSqr;\n\n      for (let i = 0; i < this.m_bodies.length; ++i) {\n        const body = this.m_bodies[i];\n        if (body.isStatic()) {\n          continue;\n        }\n\n        if ((body.m_autoSleepFlag == false)\n          || (body.m_angularVelocity * body.m_angularVelocity > angTolSqr)\n          || (matrix.lengthSqrVec2(body.m_linearVelocity) > linTolSqr)) {\n          body.m_sleepTime = 0.0;\n          minSleepTime = 0.0;\n        } else {\n          body.m_sleepTime += h;\n          minSleepTime = Math.min(minSleepTime, body.m_sleepTime);\n        }\n      }\n\n      if (minSleepTime >= Settings.timeToSleep && positionSolved) {\n        for (let i = 0; i < this.m_bodies.length; ++i) {\n          const body = this.m_bodies[i];\n          body.setAwake(false);\n        }\n      }\n    }\n  }\n\n  /**\n   * Find TOI contacts and solve them.\n   */\n  solveWorldTOI(step: TimeStep): void {\n    const world = this.m_world;\n\n    if (world.m_stepComplete) {\n      for (let b = world.m_bodyList; b; b = b.m_next) {\n        b.m_islandFlag = false;\n        b.m_sweep.alpha0 = 0.0;\n      }\n\n      for (let c = world.m_contactList; c; c = c.m_next) {\n        // Invalidate TOI\n        c.m_toiFlag = false;\n        c.m_islandFlag = false;\n        c.m_toiCount = 0;\n        c.m_toi = 1.0;\n      }\n    }\n\n    // Find TOI events and solve them.\n    while (true) {\n      // Find the first TOI.\n      let minContact: Contact | null = null;\n      let minAlpha = 1.0;\n\n      for (let c = world.m_contactList; c; c = c.m_next) {\n        // Is this contact disabled?\n        if (c.isEnabled() == false) {\n          continue;\n        }\n\n        // Prevent excessive sub-stepping.\n        if (c.m_toiCount > Settings.maxSubSteps) {\n          continue;\n        }\n\n        let alpha = 1.0;\n        if (c.m_toiFlag) {\n          // This contact has a valid cached TOI.\n          alpha = c.m_toi;\n        } else {\n          const fA = c.getFixtureA();\n          const fB = c.getFixtureB();\n\n          // Is there a sensor?\n          if (fA.isSensor() || fB.isSensor()) {\n            continue;\n          }\n\n          const bA = fA.getBody();\n          const bB = fB.getBody();\n\n          _ASSERT && console.assert(bA.isDynamic() || bB.isDynamic());\n\n          const activeA = bA.isAwake() && !bA.isStatic();\n          const activeB = bB.isAwake() && !bB.isStatic();\n\n          // Is at least one body active (awake and dynamic or kinematic)?\n          if (activeA == false && activeB == false) {\n            continue;\n          }\n\n          const collideA = bA.isBullet() || !bA.isDynamic();\n          const collideB = bB.isBullet() || !bB.isDynamic();\n\n          // Are these two non-bullet dynamic bodies?\n          if (collideA == false && collideB == false) {\n            continue;\n          }\n\n          // Compute the TOI for this contact.\n          // Put the sweeps onto the same time interval.\n          let alpha0 = bA.m_sweep.alpha0;\n\n          if (bA.m_sweep.alpha0 < bB.m_sweep.alpha0) {\n            alpha0 = bB.m_sweep.alpha0;\n            bA.m_sweep.advance(alpha0);\n          } else if (bB.m_sweep.alpha0 < bA.m_sweep.alpha0) {\n            alpha0 = bA.m_sweep.alpha0;\n            bB.m_sweep.advance(alpha0);\n          }\n\n          _ASSERT && console.assert(alpha0 < 1.0);\n\n          const indexA = c.getChildIndexA();\n          const indexB = c.getChildIndexB();\n\n          const sweepA = bA.m_sweep;\n          const sweepB = bB.m_sweep;\n\n          // Compute the time of impact in interval [0, minTOI]\n          input.proxyA.set(fA.getShape(), indexA);\n          input.proxyB.set(fB.getShape(), indexB);\n          input.sweepA.set(bA.m_sweep);\n          input.sweepB.set(bB.m_sweep);\n          input.tMax = 1.0;\n\n          TimeOfImpact(output, input);\n\n          // Beta is the fraction of the remaining portion of the [time?].\n          const beta = output.t;\n          if (output.state == TOIOutputState.e_touching) {\n            alpha = Math.min(alpha0 + (1.0 - alpha0) * beta, 1.0);\n          } else {\n            alpha = 1.0;\n          }\n\n          c.m_toi = alpha;\n          c.m_toiFlag = true;\n        }\n\n        if (alpha < minAlpha) {\n          // This is the minimum TOI found so far.\n          minContact = c;\n          minAlpha = alpha;\n        }\n      }\n\n      if (minContact == null || 1.0 - 10.0 * Math.EPSILON < minAlpha) {\n        // No more TOI events. Done!\n        world.m_stepComplete = true;\n        break;\n      }\n\n      // Advance the bodies to the TOI.\n      const fA = minContact.getFixtureA();\n      const fB = minContact.getFixtureB();\n      const bA = fA.getBody();\n      const bB = fB.getBody();\n\n      backup1.set(bA.m_sweep);\n      backup2.set(bB.m_sweep);\n\n      bA.advance(minAlpha);\n      bB.advance(minAlpha);\n\n      // The TOI contact likely has some new contact points.\n      minContact.update(world);\n      minContact.m_toiFlag = false;\n      ++minContact.m_toiCount;\n\n      // Is the contact solid?\n      if (minContact.isEnabled() == false || minContact.isTouching() == false) {\n        // Restore the sweeps.\n        minContact.setEnabled(false);\n        bA.m_sweep.set(backup1);\n        bB.m_sweep.set(backup2);\n        bA.synchronizeTransform();\n        bB.synchronizeTransform();\n        continue;\n      }\n\n      bA.setAwake(true);\n      bB.setAwake(true);\n\n      // Build the island\n      this.clear();\n      this.addBody(bA);\n      this.addBody(bB);\n      this.addContact(minContact);\n\n      bA.m_islandFlag = true;\n      bB.m_islandFlag = true;\n      minContact.m_islandFlag = true;\n\n      // Get contacts on bodyA and bodyB.\n      const bodies = [ bA, bB ];\n      for (let i = 0; i < bodies.length; ++i) {\n        const body = bodies[i];\n        if (body.isDynamic()) {\n          for (let ce = body.m_contactList; ce; ce = ce.next) {\n            // if (this.m_bodyCount == this.m_bodyCapacity) { break; }\n            // if (this.m_contactCount == this.m_contactCapacity) { break; }\n\n            const contact = ce.contact;\n\n            // Has this contact already been added to the island?\n            if (contact.m_islandFlag) {\n              continue;\n            }\n\n            // Only add if either is static, kinematic or bullet.\n            const other = ce.other;\n            if (other.isDynamic() && !body.isBullet() && !other.isBullet()) {\n              continue;\n            }\n\n            // Skip sensors.\n            const sensorA = contact.m_fixtureA.m_isSensor;\n            const sensorB = contact.m_fixtureB.m_isSensor;\n            if (sensorA || sensorB) {\n              continue;\n            }\n\n            // Tentatively advance the body to the TOI.\n            backup.set(other.m_sweep);\n            if (other.m_islandFlag == false) {\n              other.advance(minAlpha);\n            }\n\n            // Update the contact points\n            contact.update(world);\n\n            // Was the contact disabled by the user?\n            // Are there contact points?\n            if (contact.isEnabled() == false || contact.isTouching() == false) {\n              other.m_sweep.set(backup);\n              other.synchronizeTransform();\n              continue;\n            }\n\n            // Add the contact to the island\n            contact.m_islandFlag = true;\n            this.addContact(contact);\n\n            // Has the other body already been added to the island?\n            if (other.m_islandFlag) {\n              continue;\n            }\n\n            // Add the other body to the island.\n            other.m_islandFlag = true;\n\n            if (!other.isStatic()) {\n              other.setAwake(true);\n            }\n\n            this.addBody(other);\n          }\n        }\n      }\n\n      s_subStep.reset((1.0 - minAlpha) * step.dt);\n      s_subStep.dtRatio = 1.0;\n      s_subStep.positionIterations = 20;\n      s_subStep.velocityIterations = step.velocityIterations;\n      s_subStep.warmStarting = false;\n\n      this.solveIslandTOI(s_subStep, bA, bB);\n\n      // Reset island flags and synchronize broad-phase proxies.\n      for (let i = 0; i < this.m_bodies.length; ++i) {\n        const body = this.m_bodies[i];\n        body.m_islandFlag = false;\n\n        if (!body.isDynamic()) {\n          continue;\n        }\n\n        body.synchronizeFixtures();\n\n        // Invalidate all contact TOIs on this displaced body.\n        for (let ce = body.m_contactList; ce; ce = ce.next) {\n          ce.contact.m_toiFlag = false;\n          ce.contact.m_islandFlag = false;\n        }\n      }\n\n      // Commit fixture proxy movements to the broad-phase so that new contacts\n      // are created.\n      // Also, some contacts can be destroyed.\n      world.findNewContacts();\n\n      if (world.m_subStepping) {\n        world.m_stepComplete = false;\n        break;\n      }\n    }\n  }\n\n  solveIslandTOI(subStep: TimeStep, toiA: Body, toiB: Body): void {\n\n    // Initialize the body state.\n    for (let i = 0; i < this.m_bodies.length; ++i) {\n      const body = this.m_bodies[i];\n      matrix.copyVec2(body.c_position.c, body.m_sweep.c);\n      body.c_position.a = body.m_sweep.a;\n      matrix.copyVec2(body.c_velocity.v, body.m_linearVelocity);\n      body.c_velocity.w = body.m_angularVelocity;\n    }\n\n    for (let i = 0; i < this.m_contacts.length; ++i) {\n      const contact = this.m_contacts[i];\n      contact.initConstraint(subStep);\n    }\n\n    // Solve position constraints.\n    for (let i = 0; i < subStep.positionIterations; ++i) {\n      let minSeparation = 0.0;\n      for (let j = 0; j < this.m_contacts.length; ++j) {\n        const contact = this.m_contacts[j];\n        const separation = contact.solvePositionConstraintTOI(subStep, toiA, toiB);\n        minSeparation = Math.min(minSeparation, separation);\n      }\n      // We can't expect minSpeparation >= -Settings.linearSlop because we don't\n      // push the separation above -Settings.linearSlop.\n      const contactsOkay = minSeparation >= -1.5 * Settings.linearSlop;\n      if (contactsOkay) {\n        break;\n      }\n    }\n\n    if (false) {\n      // Is the new position really safe?\n      for (let i = 0; i < this.m_contacts.length; ++i) {\n        const c = this.m_contacts[i];\n        const fA = c.getFixtureA();\n        const fB = c.getFixtureB();\n\n        const bA = fA.getBody();\n        const bB = fB.getBody();\n\n        const indexA = c.getChildIndexA();\n        const indexB = c.getChildIndexB();\n\n        const input = new DistanceInput();\n        input.proxyA.set(fA.getShape(), indexA);\n        input.proxyB.set(fB.getShape(), indexB);\n        input.transformA.set(bA.getTransform());\n        input.transformB.set(bB.getTransform());\n        input.useRadii = false;\n\n        const output = new DistanceOutput();\n        const cache = new SimplexCache();\n        Distance(output, cache, input);\n\n        if (output.distance == 0 || cache.count == 3) {\n          cache.count += 0;\n        }\n      }\n    }\n\n    // Leap of faith to new safe state.\n    matrix.copyVec2(toiA.m_sweep.c0, toiA.c_position.c);\n    toiA.m_sweep.a0 = toiA.c_position.a;\n    matrix.copyVec2(toiB.m_sweep.c0, toiB.c_position.c);\n    toiB.m_sweep.a0 = toiB.c_position.a;\n\n    // No warm starting is needed for TOI events because warm\n    // starting impulses were applied in the discrete solver.\n    for (let i = 0; i < this.m_contacts.length; ++i) {\n      const contact = this.m_contacts[i];\n      contact.initVelocityConstraint(subStep);\n    }\n\n    // Solve velocity constraints.\n    for (let i = 0; i < subStep.velocityIterations; ++i) {\n      for (let j = 0; j < this.m_contacts.length; ++j) {\n        const contact = this.m_contacts[j];\n        contact.solveVelocityConstraint(subStep);\n      }\n    }\n\n    // Don't store the TOI contact forces for warm starting\n    // because they can be quite large.\n\n    const h = subStep.dt;\n\n    // Integrate positions\n    for (let i = 0; i < this.m_bodies.length; ++i) {\n      const body = this.m_bodies[i];\n\n      matrix.copyVec2(c, body.c_position.c);\n      let a = body.c_position.a;\n      matrix.copyVec2(v, body.c_velocity.v);\n      let w = body.c_velocity.w;\n\n      // Check for large velocities\n      matrix.setMulVec2(translation, h, v);\n      const translationLengthSqr = matrix.lengthSqrVec2(translation);\n      if (translationLengthSqr > Settings.maxTranslationSquared) {\n        const ratio = Settings.maxTranslation / Math.sqrt(translationLengthSqr);\n        matrix.scaleVec2(v, ratio);\n      }\n\n      const rotation = h * w;\n      if (rotation * rotation > Settings.maxRotationSquared) {\n        const ratio = Settings.maxRotation / Math.abs(rotation);\n        w *= ratio;\n      }\n\n      // Integrate\n      matrix.addMulVec2(c, h, v);\n      a += h * w;\n\n      matrix.copyVec2(body.c_position.c, c);\n      body.c_position.a = a;\n      matrix.copyVec2(body.c_velocity.v, v);\n      body.c_velocity.w = w;\n\n      // Sync bodies\n      matrix.copyVec2(body.m_sweep.c, c);\n      body.m_sweep.a = a;\n      matrix.copyVec2(body.m_linearVelocity, v);\n      body.m_angularVelocity = w;\n      body.synchronizeTransform();\n    }\n\n    this.postSolveIsland();\n  }\n\n  /** @internal */\n  postSolveIsland(): void {\n    for (let c = 0; c < this.m_contacts.length; ++c) {\n      const contact = this.m_contacts[c];\n      this.m_world.postSolve(contact, contact.m_impulse);\n    }\n  }\n}\n\n// @ts-ignore\nSolver.TimeStep = TimeStep;\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { Vec2 } from './Vec2';\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\n/**\n * A 2-by-2 matrix. Stored in column-major order.\n */\nexport class Mat22 {\n  ex: Vec2;\n  ey: Vec2;\n\n  constructor(a: number, b: number, c: number, d: number);\n  constructor(a: { x: number; y: number }, b: { x: number; y: number });\n  constructor();\n  // tslint:disable-next-line:typedef\n  constructor(a?, b?, c?, d?) {\n    if (typeof a === 'object' && a !== null) {\n      this.ex = Vec2.clone(a);\n      this.ey = Vec2.clone(b);\n    } else if (typeof a === 'number') {\n      this.ex = Vec2.neo(a, c);\n      this.ey = Vec2.neo(b, d);\n    } else {\n      this.ex = Vec2.zero();\n      this.ey = Vec2.zero();\n    }\n  }\n\n  /** @internal */\n  toString(): string {\n    return JSON.stringify(this);\n  }\n\n  static isValid(obj: any): boolean {\n    if (obj === null || typeof obj === 'undefined') {\n      return false;\n    }\n    return Vec2.isValid(obj.ex) && Vec2.isValid(obj.ey);\n  }\n\n  static assert(o: any): void {\n    _ASSERT && console.assert(!Mat22.isValid(o), 'Invalid Mat22!', o);\n  }\n\n  set(a: Mat22): void;\n  set(a: Vec2, b: Vec2): void;\n  set(a: number, b: number, c: number, d: number): void;\n  // tslint:disable-next-line:typedef\n  set(a, b?, c?, d?): void {\n    if (typeof a === 'number' && typeof b === 'number' && typeof c === 'number'\n      && typeof d === 'number') {\n      this.ex.setNum(a, c);\n      this.ey.setNum(b, d);\n\n    } else if (typeof a === 'object' && typeof b === 'object') {\n      this.ex.setVec2(a);\n      this.ey.setVec2(b);\n\n    } else if (typeof a === 'object') {\n      _ASSERT && Mat22.assert(a);\n      this.ex.setVec2(a.ex);\n      this.ey.setVec2(a.ey);\n\n    } else {\n      _ASSERT && console.assert(false);\n    }\n  }\n\n  setIdentity(): void {\n    this.ex.x = 1.0;\n    this.ey.x = 0.0;\n    this.ex.y = 0.0;\n    this.ey.y = 1.0;\n  }\n\n  setZero(): void {\n    this.ex.x = 0.0;\n    this.ey.x = 0.0;\n    this.ex.y = 0.0;\n    this.ey.y = 0.0;\n  }\n\n  getInverse(): Mat22 {\n    const a = this.ex.x;\n    const b = this.ey.x;\n    const c = this.ex.y;\n    const d = this.ey.y;\n    let det = a * d - b * c;\n    if (det !== 0.0) {\n      det = 1.0 / det;\n    }\n    const imx = new Mat22();\n    imx.ex.x = det * d;\n    imx.ey.x = -det * b;\n    imx.ex.y = -det * c;\n    imx.ey.y = det * a;\n    return imx;\n  }\n\n  /**\n   * Solve A * x = b, where b is a column vector. This is more efficient than\n   * computing the inverse in one-shot cases.\n   */\n  solve(v: Vec2): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    const a = this.ex.x;\n    const b = this.ey.x;\n    const c = this.ex.y;\n    const d = this.ey.y;\n    let det = a * d - b * c;\n    if (det !== 0.0) {\n      det = 1.0 / det;\n    }\n    const w = Vec2.zero();\n    w.x = det * (d * v.x - b * v.y);\n    w.y = det * (a * v.y - c * v.x);\n    return w;\n  }\n\n  /**\n   * Multiply a matrix times a vector. If a rotation matrix is provided, then this\n   * transforms the vector from one frame to another.\n   */\n  static mul(mx: Mat22, my: Mat22): Mat22;\n  static mul(mx: Mat22, v: Vec2): Vec2;\n  // tslint:disable-next-line:typedef\n  static mul(mx, v) {\n    if (v && 'x' in v && 'y' in v) {\n      _ASSERT && Vec2.assert(v);\n      const x = mx.ex.x * v.x + mx.ey.x * v.y;\n      const y = mx.ex.y * v.x + mx.ey.y * v.y;\n      return Vec2.neo(x, y);\n\n    } else if (v && 'ex' in v && 'ey' in v) { // Mat22\n      _ASSERT && Mat22.assert(v);\n      // return new Mat22(Vec2.mul(mx, v.ex), Vec2.mul(mx, v.ey));\n      const a = mx.ex.x * v.ex.x + mx.ey.x * v.ex.y;\n      const b = mx.ex.x * v.ey.x + mx.ey.x * v.ey.y;\n      const c = mx.ex.y * v.ex.x + mx.ey.y * v.ex.y;\n      const d = mx.ex.y * v.ey.x + mx.ey.y * v.ey.y;\n      return new Mat22(a, b, c, d);\n    }\n\n    _ASSERT && console.assert(false);\n  }\n\n  static mulVec2(mx: Mat22, v: Vec2): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    const x = mx.ex.x * v.x + mx.ey.x * v.y;\n    const y = mx.ex.y * v.x + mx.ey.y * v.y;\n    return Vec2.neo(x, y);\n  }\n\n  static mulMat22(mx: Mat22, v: Mat22): Mat22 {\n    _ASSERT && Mat22.assert(v);\n    // return new Mat22(Vec2.mul(mx, v.ex), Vec2.mul(mx, v.ey));\n    const a = mx.ex.x * v.ex.x + mx.ey.x * v.ex.y;\n    const b = mx.ex.x * v.ey.x + mx.ey.x * v.ey.y;\n    const c = mx.ex.y * v.ex.x + mx.ey.y * v.ex.y;\n    const d = mx.ex.y * v.ey.x + mx.ey.y * v.ey.y;\n    return new Mat22(a, b, c, d);\n  }\n\n  /**\n   * Multiply a matrix transpose times a vector. If a rotation matrix is provided,\n   * then this transforms the vector from one frame to another (inverse\n   * transform).\n   */\n  static mulT(mx: Mat22, my: Mat22): Mat22;\n  static mulT(mx: Mat22, v: Vec2): Vec2;\n  // tslint:disable-next-line:typedef\n  static mulT(mx, v) {\n    if (v && 'x' in v && 'y' in v) { // Vec2\n      _ASSERT && Vec2.assert(v);\n      return Vec2.neo(Vec2.dot(v, mx.ex), Vec2.dot(v, mx.ey));\n\n    } else if (v && 'ex' in v && 'ey' in v) { // Mat22\n      _ASSERT && Mat22.assert(v);\n      const c1 = Vec2.neo(Vec2.dot(mx.ex, v.ex), Vec2.dot(mx.ey, v.ex));\n      const c2 = Vec2.neo(Vec2.dot(mx.ex, v.ey), Vec2.dot(mx.ey, v.ey));\n      return new Mat22(c1, c2);\n    }\n\n    _ASSERT && console.assert(false);\n  }\n\n  static mulTVec2(mx: Mat22, v: Vec2): Vec2 {\n    _ASSERT && Mat22.assert(mx);\n    _ASSERT && Vec2.assert(v);\n    return Vec2.neo(Vec2.dot(v, mx.ex), Vec2.dot(v, mx.ey));\n  }\n\n  static mulTMat22(mx: Mat22, v: Mat22): Mat22 {\n    _ASSERT && Mat22.assert(mx);\n    _ASSERT && Mat22.assert(v);\n    const c1 = Vec2.neo(Vec2.dot(mx.ex, v.ex), Vec2.dot(mx.ey, v.ex));\n    const c2 = Vec2.neo(Vec2.dot(mx.ex, v.ey), Vec2.dot(mx.ey, v.ey));\n    return new Mat22(c1, c2);\n  }\n\n  static abs(mx: Mat22): Mat22 {\n    _ASSERT && Mat22.assert(mx);\n    return new Mat22(Vec2.abs(mx.ex), Vec2.abs(mx.ey));\n  }\n\n  static add(mx1: Mat22, mx2: Mat22): Mat22 {\n    _ASSERT && Mat22.assert(mx1);\n    _ASSERT && Mat22.assert(mx2);\n    return new Mat22(Vec2.add(mx1.ex, mx2.ex), Vec2.add(mx1.ey, mx2.ey));\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport * as matrix from '../common/Matrix';\nimport { Vec2Value } from '../common/Vec2';\nimport { TransformValue } from '../common/Transform';\nimport { math as Math } from '../common/Math';\n\nconst pointA = matrix.vec2(0, 0);\nconst pointB = matrix.vec2(0, 0);\nconst temp = matrix.vec2(0, 0);\nconst cA = matrix.vec2(0, 0);\nconst cB = matrix.vec2(0, 0);\nconst dist = matrix.vec2(0, 0);\nconst planePoint = matrix.vec2(0, 0);\nconst clipPoint = matrix.vec2(0, 0);\n\nexport enum ManifoldType {\n  e_unset = -1,\n  e_circles = 0,\n  e_faceA = 1,\n  e_faceB = 2\n}\n\nexport enum ContactFeatureType {\n  e_unset = -1,\n  e_vertex = 0,\n  e_face = 1\n}\n\n/**\n * This is used for determining the state of contact points.\n */\n export enum PointState {\n  /** Point does not exist */\n  nullState = 0,\n  /** Point was added in the update */\n  addState = 1,\n  /** Point persisted across the update */\n  persistState = 2,\n  /** Point was removed in the update */\n  removeState = 3\n}\n\n/**\n * Used for computing contact manifolds.\n */\n export class ClipVertex {\n  v = matrix.vec2(0, 0);\n  id: ContactID = new ContactID();\n\n  set(o: ClipVertex): void {\n    matrix.copyVec2(this.v, o.v);\n    this.id.set(o.id);\n  }\n  recycle() {\n    matrix.zeroVec2(this.v)\n    this.id.recycle();\n  }\n}\n\n/**\n * A manifold for two touching convex shapes. Manifolds are created in `evaluate`\n * method of Contact subclasses.\n *\n * Supported manifold types are e_faceA or e_faceB for clip point versus plane\n * with radius and e_circles point versus point with radius.\n *\n * We store contacts in this way so that position correction can account for\n * movement, which is critical for continuous physics. All contact scenarios\n * must be expressed in one of these types. This structure is stored across time\n * steps, so we keep it small.\n */\nexport class Manifold {\n  type: ManifoldType;\n\n  /**\n   * Usage depends on manifold type:\n   * - circles: not used\n   * - faceA: the normal on polygonA\n   * - faceB: the normal on polygonB\n   */\n  localNormal = matrix.vec2(0, 0);\n\n  /**\n   * Usage depends on manifold type:\n   * - circles: the local center of circleA\n   * - faceA: the center of faceA\n   * - faceB: the center of faceB\n   */\n  localPoint = matrix.vec2(0, 0);\n\n  /** The points of contact */\n  points: ManifoldPoint[] = [ new ManifoldPoint(), new ManifoldPoint() ];\n\n  /** The number of manifold points */\n  pointCount: number = 0;\n\n  set(that: Manifold): void {\n    this.type = that.type;\n    matrix.copyVec2(this.localNormal, that.localNormal);\n    matrix.copyVec2(this.localPoint, that.localPoint);\n    this.pointCount = that.pointCount;\n    this.points[0].set(that.points[0]);\n    this.points[1].set(that.points[1]);\n  }\n\n  recycle(): void {\n    this.type = ManifoldType.e_unset;\n    matrix.zeroVec2(this.localNormal)\n    matrix.zeroVec2(this.localPoint)\n    this.pointCount = 0;\n    this.points[0].recycle();\n    this.points[1].recycle();\n  }\n\n  /**\n   * Evaluate the manifold with supplied transforms. This assumes modest motion\n   * from the original state. This does not change the point count, impulses, etc.\n   * The radii must come from the shapes that generated the manifold.\n   */\n  getWorldManifold(wm: WorldManifold | null, xfA: TransformValue, radiusA: number, xfB: TransformValue, radiusB: number): WorldManifold {\n    if (this.pointCount == 0) {\n      return wm;\n    }\n\n    wm = wm || new WorldManifold();\n\n    wm.pointCount = this.pointCount;\n\n    const normal = wm.normal;\n    const points = wm.points;\n    const separations = wm.separations;\n\n    switch (this.type) {\n      case ManifoldType.e_circles: {\n        matrix.setVec2(normal, 1.0, 0.0);\n        const manifoldPoint = this.points[0];\n        matrix.transformVec2(pointA, xfA, this.localPoint);\n        matrix.transformVec2(pointB, xfB, manifoldPoint.localPoint);\n        matrix.diffVec2(dist, pointB, pointA);\n        const lengthSqr = matrix.lengthSqrVec2(dist);\n          if (lengthSqr > Math.EPSILON * Math.EPSILON) {\n          const length = Math.sqrt(lengthSqr);\n          matrix.setMulVec2(normal, 1 / length, dist);\n        }\n        matrix.combineVec2(cA, 1, pointA, radiusA, normal);\n        matrix.combineVec2(cB, 1, pointB, -radiusB, normal);\n        matrix.combineVec2(points[0], 0.5, cA, 0.5, cB);\n        separations[0] = matrix.dotVec2(matrix.diffVec2(temp, cB, cA), normal);\n        break;\n      }\n\n      case ManifoldType.e_faceA: {\n        matrix.rotVec2(normal, xfA.q, this.localNormal);\n        matrix.transformVec2(planePoint, xfA, this.localPoint);\n\n        for (let i = 0; i < this.pointCount; ++i) {\n          const manifoldPoint = this.points[i];\n          matrix.transformVec2(clipPoint, xfB, manifoldPoint.localPoint);\n          matrix.combineVec2(cA, 1, clipPoint, radiusA - matrix.dotVec2(matrix.diffVec2(temp, clipPoint, planePoint), normal), normal);\n          matrix.combineVec2(cB, 1, clipPoint, -radiusB, normal);\n          matrix.combineVec2(points[i], 0.5, cA, 0.5, cB);\n          separations[i] = matrix.dotVec2(matrix.diffVec2(temp, cB, cA), normal);\n        }\n        break;\n      }\n\n      case ManifoldType.e_faceB: {\n        matrix.rotVec2(normal, xfB.q, this.localNormal);\n        matrix.transformVec2(planePoint, xfB, this.localPoint);\n\n        for (let i = 0; i < this.pointCount; ++i) {\n          const manifoldPoint = this.points[i];\n          matrix.transformVec2(clipPoint, xfA, manifoldPoint.localPoint);\n          matrix.combineVec2(cB, 1, clipPoint, radiusB - matrix.dotVec2(matrix.diffVec2(temp, clipPoint, planePoint), normal), normal);\n          matrix.combineVec2(cA, 1, clipPoint, -radiusA, normal);\n          matrix.combineVec2(points[i], 0.5, cA, 0.5, cB);\n          separations[i] = matrix.dotVec2(matrix.diffVec2(temp, cA, cB), normal);\n        }\n        // Ensure normal points from A to B.\n        matrix.negVec2(normal);\n        break;\n      }\n    }\n\n    return wm;\n  }\n\n  static clipSegmentToLine = clipSegmentToLine;\n  static ClipVertex = ClipVertex;\n  static getPointStates = getPointStates;\n  static PointState = PointState;\n}\n\n/**\n * A manifold point is a contact point belonging to a contact manifold. It holds\n * details related to the geometry and dynamics of the contact points.\n *\n * This structure is stored across time steps, so we keep it small.\n *\n * Note: impulses are used for internal caching and may not provide reliable\n * contact forces, especially for high speed collisions.\n */\nexport class ManifoldPoint {\n  /**\n   * Usage depends on manifold type:\n   * - circles: the local center of circleB\n   * - faceA: the local center of circleB or the clip point of polygonB\n   * - faceB: the clip point of polygonA\n   */\n  localPoint = matrix.vec2(0, 0);\n  /**\n   * The non-penetration impulse\n   */\n  normalImpulse = 0;\n  /**\n   * The friction impulse\n   */\n  tangentImpulse = 0;\n  /**\n   * Uniquely identifies a contact point between two shapes to facilitate warm starting\n   */\n  readonly id = new ContactID();\n\n  set(that: ManifoldPoint): void {\n    matrix.copyVec2(this.localPoint, that.localPoint);\n    this.normalImpulse = that.normalImpulse;\n    this.tangentImpulse = that.tangentImpulse;\n    this.id.set(that.id);\n  }\n\n  recycle(): void {\n    matrix.zeroVec2(this.localPoint)\n    this.normalImpulse = 0;\n    this.tangentImpulse = 0;\n    this.id.recycle();\n  }\n}\n\n/**\n * Contact ids to facilitate warm starting.\n * \n * ContactFeature: The features that intersect to form the contact point.\n */\nexport class ContactID {\n\n  /**\n   * Used to quickly compare contact ids.\n   */\n  key = -1;\n\n  /** ContactFeature index on shapeA */\n  indexA = -1;\n\n  /** ContactFeature index on shapeB */\n  indexB = -1;\n\n  /** ContactFeature type on shapeA */\n  typeA = ContactFeatureType.e_unset;\n\n  /** ContactFeature type on shapeB */\n  typeB = ContactFeatureType.e_unset;\n\n  setFeatures(indexA: number, typeA: ContactFeatureType, indexB: number, typeB: ContactFeatureType): void {\n    this.indexA = indexA;\n    this.indexB = indexB;\n    this.typeA = typeA;\n    this.typeB = typeB;\n    this.key = this.indexA + this.indexB * 4 + this.typeA * 16 + this.typeB * 64\n  }\n\n  set(that: ContactID): void {\n    this.indexA = that.indexA;\n    this.indexB = that.indexB;\n    this.typeA = that.typeA;\n    this.typeB = that.typeB;\n    this.key = this.indexA + this.indexB * 4 + this.typeA * 16 + this.typeB * 64\n  }\n\n  swapFeatures(): void {\n    const indexA = this.indexA;\n    const indexB = this.indexB;\n    const typeA = this.typeA;\n    const typeB = this.typeB;\n    this.indexA = indexB;\n    this.indexB = indexA;\n    this.typeA = typeB;\n    this.typeB = typeA;\n    this.key = this.indexA + this.indexB * 4 + this.typeA * 16 + this.typeB * 64\n  }\n\n  recycle(): void {\n    this.indexA = 0;\n    this.indexB = 0;\n    this.typeA = ContactFeatureType.e_unset;\n    this.typeB = ContactFeatureType.e_unset;\n    this.key = -1;\n  }\n}\n\n/**\n * This is used to compute the current state of a contact manifold.\n */\nexport class WorldManifold {\n  /** World vector pointing from A to B */\n  normal = matrix.vec2(0, 0);\n\n  /** World contact point (point of intersection) */\n  points = [matrix.vec2(0, 0), matrix.vec2(0, 0)]; // [maxManifoldPoints]\n\n  /** A negative value indicates overlap, in meters */\n  separations = [0, 0]; // [maxManifoldPoints]\n\n  /** The number of manifold points */\n  pointCount = 0;\n\n  recycle() {\n    matrix.zeroVec2(this.normal)\n    matrix.zeroVec2(this.points[0]);\n    matrix.zeroVec2(this.points[1]);\n    this.separations[0] = 0;\n    this.separations[1] = 0;\n    this.pointCount = 0;\n  }\n}\n\n/**\n * Compute the point states given two manifolds. The states pertain to the\n * transition from manifold1 to manifold2. So state1 is either persist or remove\n * while state2 is either add or persist.\n */\nexport function getPointStates(\n  state1: PointState[],\n  state2: PointState[],\n  manifold1: Manifold,\n  manifold2: Manifold\n): void {\n  // state1, state2: PointState[Settings.maxManifoldPoints]\n\n  // for (var i = 0; i < Settings.maxManifoldPoints; ++i) {\n  // state1[i] = PointState.nullState;\n  // state2[i] = PointState.nullState;\n  // }\n\n  // Detect persists and removes.\n  for (let i = 0; i < manifold1.pointCount; ++i) {\n    const id = manifold1.points[i].id;\n\n    state1[i] = PointState.removeState;\n\n    for (let j = 0; j < manifold2.pointCount; ++j) {\n      if (manifold2.points[j].id.key === id.key) {\n        state1[i] = PointState.persistState;\n        break;\n      }\n    }\n  }\n\n  // Detect persists and adds.\n  for (let i = 0; i < manifold2.pointCount; ++i) {\n    const id = manifold2.points[i].id;\n\n    state2[i] = PointState.addState;\n\n    for (let j = 0; j < manifold1.pointCount; ++j) {\n      if (manifold1.points[j].id.key === id.key) {\n        state2[i] = PointState.persistState;\n        break;\n      }\n    }\n  }\n}\n\n/**\n * Clipping for contact manifolds. Sutherland-Hodgman clipping.\n */\nexport function clipSegmentToLine(\n  vOut: ClipVertex[],\n  vIn: ClipVertex[],\n  normal: Vec2Value,\n  offset: number,\n  vertexIndexA: number\n): number {\n  // Start with no output points\n  let numOut = 0;\n\n  // Calculate the distance of end points to the line\n  const distance0 = matrix.dotVec2(normal, vIn[0].v) - offset;\n  const distance1 = matrix.dotVec2(normal, vIn[1].v) - offset;\n\n  // If the points are behind the plane\n  if (distance0 <= 0.0)\n    vOut[numOut++].set(vIn[0]);\n  if (distance1 <= 0.0)\n    vOut[numOut++].set(vIn[1]);\n\n  // If the points are on different sides of the plane\n  if (distance0 * distance1 < 0.0) {\n    // Find intersection point of edge and plane\n    const interp = distance0 / (distance0 - distance1);\n    matrix.combineVec2(vOut[numOut].v, 1 - interp, vIn[0].v, interp, vIn[1].v);\n\n    // VertexA is hitting edgeB.\n    vOut[numOut].id.setFeatures(vertexIndexA, ContactFeatureType.e_vertex, vIn[0].id.indexB, ContactFeatureType.e_face);\n    ++numOut;\n  }\n\n  return numOut;\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport * as matrix from '../common/Matrix';\nimport { ShapeType } from \"../collision/Shape\";\nimport { math as Math } from '../common/Math';\nimport { TransformValue } from '../common/Transform';\nimport { Mat22 } from '../common/Mat22';\nimport { SettingsInternal as Settings } from '../Settings';\nimport { Manifold, ManifoldType, WorldManifold } from '../collision/Manifold';\nimport { testOverlap } from '../collision/Distance';\nimport { Fixture } from \"./Fixture\";\nimport { Body } from \"./Body\";\nimport { ContactImpulse, TimeStep } from \"./Solver\";\nimport { Pool } from \"../util/Pool\";\nimport { getTransform } from \"./Position\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\n// Solver debugging is normally disabled because the block solver sometimes has to deal with a poorly conditioned effective mass matrix.\nconst DEBUG_SOLVER = false;\n\nconst contactPool = new Pool<Contact>({\n  create() {\n    return new Contact();\n  },\n  release(contact: Contact) {\n    contact.recycle();\n  }\n});\n\nconst oldManifold = new Manifold();\n\nconst worldManifold = new WorldManifold();\n\n/**\n * A contact edge is used to connect bodies and contacts together in a contact\n * graph where each body is a node and each contact is an edge. A contact edge\n * belongs to a doubly linked list maintained in each attached body. Each\n * contact has two contact nodes, one for each attached body.\n */\nexport class ContactEdge {\n  contact: Contact;\n  prev: ContactEdge | null = null;\n  next: ContactEdge | null = null;\n  other: Body | null = null;\n  constructor(contact: Contact) {\n    this.contact = contact;\n  }\n\n  /** @internal */\n  recycle() {\n    this.prev = null;\n    this.next = null;\n    this.other = null;\n  }\n}\n\nexport type EvaluateFunction = (\n  manifold: Manifold,\n  xfA: TransformValue,\n  fixtureA: Fixture,\n  indexA: number,\n  xfB: TransformValue,\n  fixtureB: Fixture,\n  indexB: number\n) => void;\n\n/**\n * Friction mixing law. The idea is to allow either fixture to drive the\n * friction to zero. For example, anything slides on ice.\n */\nexport function mixFriction(friction1: number, friction2: number): number {\n  return Math.sqrt(friction1 * friction2);\n}\n\n/**\n * Restitution mixing law. The idea is allow for anything to bounce off an\n * inelastic surface. For example, a superball bounces on anything.\n */\nexport function mixRestitution(restitution1: number, restitution2: number): number {\n  return restitution1 > restitution2 ? restitution1 : restitution2;\n}\n\n// TODO: move this to Settings?\nconst s_registers = [];\n\n// TODO: merge with ManifoldPoint?\nexport class VelocityConstraintPoint {\n  rA = matrix.vec2(0, 0);\n  rB = matrix.vec2(0, 0);\n  normalImpulse = 0;\n  tangentImpulse = 0;\n  normalMass = 0;\n  tangentMass = 0;\n  velocityBias = 0;\n\n  recycle() {\n    matrix.zeroVec2(this.rA)\n    matrix.zeroVec2(this.rB)\n    this.normalImpulse = 0;\n    this.tangentImpulse = 0;\n    this.normalMass = 0;\n    this.tangentMass = 0;\n    this.velocityBias = 0;\n  }\n}\n\nconst cA = matrix.vec2(0, 0);\nconst vA = matrix.vec2(0, 0);\nconst cB = matrix.vec2(0, 0);\nconst vB = matrix.vec2(0, 0);\nconst tangent = matrix.vec2(0, 0);\nconst xfA = matrix.transform(0, 0, 0);\nconst xfB = matrix.transform(0, 0, 0);\nconst pointA = matrix.vec2(0, 0);\nconst pointB = matrix.vec2(0, 0);\nconst clipPoint = matrix.vec2(0, 0);\nconst planePoint = matrix.vec2(0, 0);\nconst rA = matrix.vec2(0, 0);\nconst rB = matrix.vec2(0, 0);\nconst P = matrix.vec2(0, 0);\nconst normal = matrix.vec2(0, 0);\nconst point = matrix.vec2(0, 0);\nconst dv = matrix.vec2(0, 0);\nconst dv1 = matrix.vec2(0, 0);\nconst dv2 = matrix.vec2(0, 0);\nconst b = matrix.vec2(0, 0);\nconst a = matrix.vec2(0, 0);\nconst x = matrix.vec2(0, 0);\nconst d = matrix.vec2(0, 0);\nconst P1 = matrix.vec2(0, 0);\nconst P2 = matrix.vec2(0, 0);\nconst temp = matrix.vec2(0, 0);\n\n/**\n * The class manages contact between two shapes. A contact exists for each\n * overlapping AABB in the broad-phase (except if filtered). Therefore a contact\n * object may exist that has no contact points.\n */\nexport class Contact {\n  // Nodes for connecting bodies.\n  /** @internal */\n  m_nodeA = new ContactEdge(this);\n  /** @internal */\n  m_nodeB = new ContactEdge(this);\n  /** @internal */\n  m_fixtureA: Fixture | null = null;\n  /** @internal */\n  m_fixtureB: Fixture | null = null;\n  /** @internal */\n  m_indexA = -1;\n  /** @internal */\n  m_indexB = -1;\n  /** @internal */\n  m_evaluateFcn: EvaluateFunction | null = null;\n  /** @internal */\n  m_manifold: Manifold = new Manifold();\n  /** @internal */\n  m_prev: Contact | null = null;\n  /** @internal */\n  m_next: Contact | null = null;\n  /** @internal */\n  m_toi = 1.0;\n  /** @internal */\n  m_toiCount = 0;\n  /** @internal This contact has a valid TOI in m_toi */\n  m_toiFlag = false;\n  /** @internal */\n  m_friction = 0.0;\n  /** @internal */\n  m_restitution = 0.0;\n  /** @internal */\n  m_tangentSpeed = 0.0;\n  /** @internal This contact can be disabled (by user) */\n  m_enabledFlag = true;\n  /** @internal Used when crawling contact graph when forming islands. */\n  m_islandFlag = false;\n  /** @internal Set when the shapes are touching. */\n  m_touchingFlag = false;\n  /** @internal This contact needs filtering because a fixture filter was changed. */\n  m_filterFlag = false;\n  /** @internal This bullet contact had a TOI event */\n  m_bulletHitFlag = false;\n\n  /** @internal Contact reporting impulse object cache */\n  m_impulse: ContactImpulse = new ContactImpulse(this);\n\n  // VelocityConstraint\n  /** @internal */\n  v_points = [new VelocityConstraintPoint(), new VelocityConstraintPoint()]; // [maxManifoldPoints];\n  /** @internal */\n  v_normal = matrix.vec2(0, 0);\n  /** @internal */ v_normalMass: Mat22 = new Mat22();\n  /** @internal */ v_K: Mat22 = new Mat22();\n  /** @internal */ v_pointCount = 0;\n  /** @internal */ v_tangentSpeed = 0;\n  /** @internal */ v_friction = 0;\n  /** @internal */ v_restitution = 0;\n  /** @internal */ v_invMassA = 0;\n  /** @internal */ v_invMassB = 0;\n  /** @internal */ v_invIA = 0;\n  /** @internal */ v_invIB = 0;\n\n  // PositionConstraint\n  /** @internal */ p_localPoints = [matrix.vec2(0, 0), matrix.vec2(0, 0)]; // [maxManifoldPoints];\n  /** @internal */ p_localNormal = matrix.vec2(0, 0);\n  /** @internal */ p_localPoint = matrix.vec2(0, 0);\n  /** @internal */ p_localCenterA = matrix.vec2(0, 0);\n  /** @internal */ p_localCenterB = matrix.vec2(0, 0);\n  /** @internal */ p_type = ManifoldType.e_unset;\n  /** @internal */ p_radiusA = 0;\n  /** @internal */ p_radiusB = 0;\n  /** @internal */ p_pointCount = 0;\n  /** @internal */ p_invMassA = 0;\n  /** @internal */ p_invMassB = 0;\n  /** @internal */ p_invIA = 0;\n  /** @internal */ p_invIB = 0;\n\n  initialize(fA: Fixture, indexA: number, fB: Fixture, indexB: number, evaluateFcn: EvaluateFunction) {\n    this.m_fixtureA = fA;\n    this.m_fixtureB = fB;\n\n    this.m_indexA = indexA;\n    this.m_indexB = indexB;\n\n    this.m_evaluateFcn = evaluateFcn;\n\n    this.m_friction = mixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction);\n    this.m_restitution = mixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution);\n  }\n\n  recycle() {\n    this.m_nodeA.recycle();\n    this.m_nodeB.recycle();\n    this.m_fixtureA = null;\n    this.m_fixtureB = null;\n    this.m_indexA = -1;\n    this.m_indexB = -1;\n    this.m_evaluateFcn = null;\n    this.m_manifold.recycle();\n    this.m_prev = null;\n    this.m_next = null;\n    this.m_toi = 1;\n    this.m_toiCount = 0;\n    this.m_toiFlag = false;\n    this.m_friction = 0;\n    this.m_restitution = 0;\n    this.m_tangentSpeed = 0;\n    this.m_enabledFlag = true;\n    this.m_islandFlag = false;\n    this.m_touchingFlag = false;\n    this.m_filterFlag = false;\n    this.m_bulletHitFlag = false;\n\n    this.m_impulse.recycle();\n\n    // VelocityConstraint\n    for(const point of this.v_points) {\n      point.recycle();\n    }\n    matrix.zeroVec2(this.v_normal)\n    this.v_normalMass.setZero();\n    this.v_K.setZero();\n    this.v_pointCount = 0;\n    this.v_tangentSpeed = 0;\n    this.v_friction = 0;\n    this.v_restitution = 0;\n    this.v_invMassA = 0;\n    this.v_invMassB = 0;\n    this.v_invIA = 0;\n    this.v_invIB = 0;\n\n    // PositionConstraint\n    for(const point of this.p_localPoints) {\n      matrix.zeroVec2(point);\n    }\n    matrix.zeroVec2(this.p_localNormal)\n    matrix.zeroVec2(this.p_localPoint)\n    matrix.zeroVec2(this.p_localCenterA)\n    matrix.zeroVec2(this.p_localCenterB)\n    this.p_type = ManifoldType.e_unset;\n    this.p_radiusA = 0;\n    this.p_radiusB = 0;\n    this.p_pointCount = 0;\n    this.p_invMassA = 0;\n    this.p_invMassB = 0;\n    this.p_invIA = 0;\n    this.p_invIB = 0;\n  }\n\n  initConstraint(step: TimeStep): void {\n    const fixtureA = this.m_fixtureA;\n    const fixtureB = this.m_fixtureB;\n    if (fixtureA === null || fixtureB === null) return;\n    const bodyA = fixtureA.m_body;\n    const bodyB = fixtureB.m_body;\n    if (bodyA === null || bodyB === null) return;\n    const shapeA = fixtureA.m_shape;\n    const shapeB = fixtureB.m_shape;\n    if (shapeA === null || shapeB === null) return;\n\n    const manifold = this.m_manifold;\n\n    const pointCount = manifold.pointCount;\n    _ASSERT && console.assert(pointCount > 0);\n\n    this.v_invMassA = bodyA.m_invMass;\n    this.v_invMassB = bodyB.m_invMass;\n    this.v_invIA = bodyA.m_invI;\n    this.v_invIB = bodyB.m_invI;\n\n    this.v_friction = this.m_friction;\n    this.v_restitution = this.m_restitution;\n    this.v_tangentSpeed = this.m_tangentSpeed;\n\n    this.v_pointCount = pointCount;\n\n    this.v_K.setZero();\n    this.v_normalMass.setZero();\n\n    this.p_invMassA = bodyA.m_invMass;\n    this.p_invMassB = bodyB.m_invMass;\n    this.p_invIA = bodyA.m_invI;\n    this.p_invIB = bodyB.m_invI;\n    matrix.copyVec2(this.p_localCenterA, bodyA.m_sweep.localCenter);\n    matrix.copyVec2(this.p_localCenterB, bodyB.m_sweep.localCenter);\n\n    this.p_radiusA = shapeA.m_radius;\n    this.p_radiusB = shapeB.m_radius;\n\n    this.p_type = manifold.type;\n    matrix.copyVec2(this.p_localNormal, manifold.localNormal);\n    matrix.copyVec2(this.p_localPoint, manifold.localPoint);\n    this.p_pointCount = pointCount;\n\n    for (let j = 0; j < Settings.maxManifoldPoints; ++j) {\n      this.v_points[j].recycle();\n      matrix.zeroVec2(this.p_localPoints[j]);\n    }\n\n    for (let j = 0; j < pointCount; ++j) {\n      const cp = manifold.points[j];\n      const vcp = this.v_points[j];\n      if (step.warmStarting) {\n        vcp.normalImpulse = step.dtRatio * cp.normalImpulse;\n        vcp.tangentImpulse = step.dtRatio * cp.tangentImpulse;\n      }\n      matrix.copyVec2(this.p_localPoints[j], cp.localPoint);\n    }\n  }\n\n  /**\n   * Get the contact manifold. Do not modify the manifold unless you understand\n   * the internals of the library.\n   */\n  getManifold(): Manifold {\n    return this.m_manifold;\n  }\n\n  /**\n   * Get the world manifold.\n   */\n  getWorldManifold(worldManifold: WorldManifold | null): WorldManifold | undefined {\n    const fixtureA = this.m_fixtureA;\n    const fixtureB = this.m_fixtureB;\n    if (fixtureA === null || fixtureB === null) return;\n    const bodyA = fixtureA.m_body;\n    const bodyB = fixtureB.m_body;\n    if (bodyA === null || bodyB === null) return;\n    const shapeA = fixtureA.m_shape;\n    const shapeB = fixtureB.m_shape;\n    if (shapeA === null || shapeB === null) return;\n\n    return this.m_manifold.getWorldManifold(\n      worldManifold,\n      bodyA.getTransform(), shapeA.m_radius,\n      bodyB.getTransform(), shapeB.m_radius\n    );\n  }\n\n  /**\n   * Enable/disable this contact. This can be used inside the pre-solve contact\n   * listener. The contact is only disabled for the current time step (or sub-step\n   * in continuous collisions).\n   */\n  setEnabled(flag: boolean): void {\n    this.m_enabledFlag = !!flag;\n  }\n\n  /**\n   * Has this contact been disabled?\n   */\n  isEnabled(): boolean {\n    return this.m_enabledFlag;\n  }\n\n  /**\n   * Is this contact touching?\n   */\n  isTouching(): boolean {\n    return this.m_touchingFlag;\n  }\n\n  /**\n   * Get the next contact in the world's contact list.\n   */\n  getNext(): Contact | null {\n    return this.m_next;\n  }\n\n  /**\n   * Get fixture A in this contact.\n   */\n  getFixtureA(): Fixture {\n    return this.m_fixtureA;\n  }\n\n  /**\n   * Get fixture B in this contact.\n   */\n  getFixtureB(): Fixture {\n    return this.m_fixtureB;\n  }\n\n  /**\n   * Get the child primitive index for fixture A.\n   */\n  getChildIndexA(): number {\n    return this.m_indexA;\n  }\n\n  /**\n   * Get the child primitive index for fixture B.\n   */\n  getChildIndexB(): number {\n    return this.m_indexB;\n  }\n\n  /**\n   * Flag this contact for filtering. Filtering will occur the next time step.\n   */\n  flagForFiltering(): void {\n    this.m_filterFlag = true;\n  }\n\n  /**\n   * Override the default friction mixture. You can call this in\n   * ContactListener.preSolve. This value persists until set or reset.\n   */\n  setFriction(friction: number): void {\n    this.m_friction = friction;\n  }\n\n  /**\n   * Get the friction.\n   */\n  getFriction(): number {\n    return this.m_friction;\n  }\n\n  /**\n   * Reset the friction mixture to the default value.\n   */\n  resetFriction(): void {\n    const fixtureA = this.m_fixtureA;\n    const fixtureB = this.m_fixtureB;\n    if (fixtureA === null || fixtureB === null) return;\n    this.m_friction = mixFriction(fixtureA.m_friction, fixtureB.m_friction);\n  }\n\n  /**\n   * Override the default restitution mixture. You can call this in\n   * ContactListener.preSolve. The value persists until you set or reset.\n   */\n  setRestitution(restitution: number): void {\n    this.m_restitution = restitution;\n  }\n\n  /**\n   * Get the restitution.\n   */\n  getRestitution(): number {\n    return this.m_restitution;\n  }\n\n  /**\n   * Reset the restitution to the default value.\n   */\n  resetRestitution(): void {\n    const fixtureA = this.m_fixtureA;\n    const fixtureB = this.m_fixtureB;\n    if (fixtureA === null || fixtureB === null) return;\n    this.m_restitution = mixRestitution(fixtureA.m_restitution, fixtureB.m_restitution);\n  }\n\n  /**\n   * Set the desired tangent speed for a conveyor belt behavior. In meters per\n   * second.\n   */\n  setTangentSpeed(speed: number): void {\n    this.m_tangentSpeed = speed;\n  }\n\n  /**\n   * Get the desired tangent speed. In meters per second.\n   */\n  getTangentSpeed(): number {\n    return this.m_tangentSpeed;\n  }\n\n  /**\n   * Called by Update method, and implemented by subclasses.\n   */\n  evaluate(manifold: Manifold, xfA: TransformValue, xfB: TransformValue): void {\n    const fixtureA = this.m_fixtureA;\n    const fixtureB = this.m_fixtureB;\n    if (fixtureA === null || fixtureB === null) return;\n    this.m_evaluateFcn(manifold, xfA, fixtureA, this.m_indexA, xfB, fixtureB, this.m_indexB);\n  }\n\n  /**\n   * Updates the contact manifold and touching status.\n   *\n   * Note: do not assume the fixture AABBs are overlapping or are valid.\n   *\n   * @param listener.beginContact\n   * @param listener.endContact\n   * @param listener.preSolve\n   */\n  update(listener?: {\n    beginContact(contact: Contact): void,\n    endContact(contact: Contact): void,\n    preSolve(contact: Contact, oldManifold: Manifold): void\n  }): void {\n    const fixtureA = this.m_fixtureA;\n    const fixtureB = this.m_fixtureB;\n    if (fixtureA === null || fixtureB === null) return;\n    const bodyA = fixtureA.m_body;\n    const bodyB = fixtureB.m_body;\n    if (bodyA === null || bodyB === null) return;\n    const shapeA = fixtureA.m_shape;\n    const shapeB = fixtureB.m_shape;\n    if (shapeA === null || shapeB === null) return;\n\n    // Re-enable this contact.\n    this.m_enabledFlag = true;\n\n    let touching = false;\n    const wasTouching = this.m_touchingFlag;\n\n    const sensorA = fixtureA.m_isSensor;\n    const sensorB = fixtureB.m_isSensor;\n    const sensor = sensorA || sensorB;\n\n    const xfA = bodyA.m_xf;\n    const xfB = bodyB.m_xf;\n\n    // Is this contact a sensor?\n    if (sensor) {\n      touching = testOverlap(shapeA, this.m_indexA, shapeB, this.m_indexB, xfA, xfB);\n\n      // Sensors don't generate manifolds.\n      this.m_manifold.pointCount = 0;\n    } else {\n\n      oldManifold.recycle();\n      oldManifold.set(this.m_manifold);\n      this.m_manifold.recycle();\n\n      this.evaluate(this.m_manifold, xfA, xfB);\n      touching = this.m_manifold.pointCount > 0;\n\n      // Match old contact ids to new contact ids and copy the\n      // stored impulses to warm start the solver.\n      for (let i = 0; i < this.m_manifold.pointCount; ++i) {\n        const nmp = this.m_manifold.points[i];\n        nmp.normalImpulse = 0.0;\n        nmp.tangentImpulse = 0.0;\n\n        for (let j = 0; j < oldManifold.pointCount; ++j) {\n          const omp = oldManifold.points[j];\n          if (omp.id.key === nmp.id.key) {\n            nmp.normalImpulse = omp.normalImpulse;\n            nmp.tangentImpulse = omp.tangentImpulse;\n            break;\n          }\n        }\n      }\n\n      if (touching !== wasTouching) {\n        bodyA.setAwake(true);\n        bodyB.setAwake(true);\n      }\n    }\n\n    this.m_touchingFlag = touching;\n\n    const hasListener = typeof listener === 'object' && listener !== null;\n\n    if (!wasTouching && touching && hasListener) {\n      listener.beginContact(this);\n    }\n\n    if (wasTouching && !touching && hasListener) {\n      listener.endContact(this);\n    }\n\n    if (!sensor && touching && hasListener && oldManifold) {\n      listener.preSolve(this, oldManifold);\n    }\n  }\n\n  solvePositionConstraint(step: TimeStep): number {\n    return this._solvePositionConstraint(step, null, null);\n  }\n\n  solvePositionConstraintTOI(step: TimeStep, toiA: Body, toiB: Body): number {\n    return this._solvePositionConstraint(step, toiA, toiB);\n  }\n\n  private _solvePositionConstraint(step: TimeStep, toiA: Body | null, toiB: Body | null): number {\n    const toi = toiA !== null && toiB !== null ? true : false;\n    let minSeparation = 0.0;\n\n    const fixtureA = this.m_fixtureA;\n    const fixtureB = this.m_fixtureB;\n    if (fixtureA === null || fixtureB === null) return minSeparation;\n    const bodyA = fixtureA.m_body;\n    const bodyB = fixtureB.m_body;\n    if (bodyA === null || bodyB === null) return minSeparation;\n\n    const velocityA = bodyA.c_velocity;\n    const velocityB = bodyB.c_velocity;\n    const positionA = bodyA.c_position;\n    const positionB = bodyB.c_position;\n\n    const localCenterA = this.p_localCenterA;\n    const localCenterB = this.p_localCenterB;\n\n    let mA = 0.0;\n    let iA = 0.0;\n    if (!toi || (bodyA === toiA || bodyA === toiB)) {\n      mA = this.p_invMassA;\n      iA = this.p_invIA;\n    }\n\n    let mB = 0.0;\n    let iB = 0.0;\n    if (!toi || (bodyB === toiA || bodyB === toiB)) {\n      mB = this.p_invMassB;\n      iB = this.p_invIB;\n    }\n\n    matrix.copyVec2(cA, positionA.c);\n    let aA = positionA.a;\n\n    matrix.copyVec2(cB, positionB.c);\n    let aB = positionB.a;\n\n    // Solve normal constraints\n    for (let j = 0; j < this.p_pointCount; ++j) {\n      getTransform(xfA, localCenterA, cA, aA);\n      getTransform(xfB, localCenterB, cB, aB);\n\n      // PositionSolverManifold\n      let separation: number;\n      switch (this.p_type) {\n        case ManifoldType.e_circles: {\n          matrix.transformVec2(pointA, xfA, this.p_localPoint);\n          matrix.transformVec2(pointB, xfB, this.p_localPoints[0]);\n          matrix.diffVec2(normal, pointB, pointA);\n          matrix.normalizeVec2(normal);\n\n          matrix.combineVec2(point, 0.5, pointA, 0.5, pointB);\n          separation = matrix.dotVec2(pointB, normal) - matrix.dotVec2(pointA, normal) - this.p_radiusA - this.p_radiusB;\n          break;\n        }\n\n        case ManifoldType.e_faceA: {\n          matrix.rotVec2(normal, xfA.q, this.p_localNormal);\n          matrix.transformVec2(planePoint, xfA, this.p_localPoint);\n          matrix.transformVec2(clipPoint, xfB, this.p_localPoints[j]);\n          separation = matrix.dotVec2(clipPoint, normal) - matrix.dotVec2(planePoint, normal) - this.p_radiusA - this.p_radiusB;\n          matrix.copyVec2(point, clipPoint);\n          break;\n        }\n\n        case ManifoldType.e_faceB: {\n          matrix.rotVec2(normal, xfB.q, this.p_localNormal);\n          matrix.transformVec2(planePoint, xfB, this.p_localPoint);\n          matrix.transformVec2(clipPoint, xfA, this.p_localPoints[j]);\n          separation = matrix.dotVec2(clipPoint, normal) - matrix.dotVec2(planePoint, normal) - this.p_radiusA - this.p_radiusB;\n          matrix.copyVec2(point, clipPoint);\n\n          // Ensure normal points from A to B\n          matrix.negVec2(normal);\n          break;\n        }\n        // todo: what should we do here?\n        default: {\n          return minSeparation;\n        }\n      }\n\n      matrix.diffVec2(rA, point, cA);\n      matrix.diffVec2(rB, point, cB);\n\n      // Track max constraint error.\n      minSeparation = Math.min(minSeparation, separation);\n\n      const baumgarte = toi ? Settings.toiBaugarte : Settings.baumgarte;\n      const linearSlop = Settings.linearSlop;\n      const maxLinearCorrection = Settings.maxLinearCorrection;\n\n      // Prevent large corrections and allow slop.\n      const C = Math.clamp(baumgarte * (separation + linearSlop), -maxLinearCorrection, 0.0);\n\n      // Compute the effective mass.\n      const rnA = matrix.crossVec2Vec2(rA, normal);\n      const rnB = matrix.crossVec2Vec2(rB, normal);\n      const K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;\n\n      // Compute normal impulse\n      const impulse = K > 0.0 ? -C / K : 0.0;\n\n      matrix.setMulVec2(P, impulse, normal);\n\n      matrix.subMulVec2(cA, mA, P);\n      aA -= iA * matrix.crossVec2Vec2(rA, P);\n\n      matrix.addMulVec2(cB, mB, P);\n      aB += iB * matrix.crossVec2Vec2(rB, P);\n    }\n\n    matrix.copyVec2(positionA.c, cA);\n    positionA.a = aA;\n\n    matrix.copyVec2(positionB.c, cB);\n    positionB.a = aB;\n\n    return minSeparation;\n  }\n\n  initVelocityConstraint(step: TimeStep): void {\n    const fixtureA = this.m_fixtureA;\n    const fixtureB = this.m_fixtureB;\n    if (fixtureA === null || fixtureB === null) return;\n    const bodyA = fixtureA.m_body;\n    const bodyB = fixtureB.m_body;\n    if (bodyA === null || bodyB === null) return;\n\n    const velocityA = bodyA.c_velocity;\n    const velocityB = bodyB.c_velocity;\n\n    const positionA = bodyA.c_position;\n    const positionB = bodyB.c_position;\n\n    const radiusA = this.p_radiusA;\n    const radiusB = this.p_radiusB;\n    const manifold = this.m_manifold;\n\n    const mA = this.v_invMassA;\n    const mB = this.v_invMassB;\n    const iA = this.v_invIA;\n    const iB = this.v_invIB;\n    const localCenterA = this.p_localCenterA;\n    const localCenterB = this.p_localCenterB;\n\n    matrix.copyVec2(cA, positionA.c);\n    const aA = positionA.a;\n    matrix.copyVec2(vA, velocityA.v);\n    const wA = velocityA.w;\n\n    matrix.copyVec2(cB, positionB.c);\n    const aB = positionB.a;\n    matrix.copyVec2(vB, velocityB.v);\n    const wB = velocityB.w;\n\n    _ASSERT && console.assert(manifold.pointCount > 0);\n\n    getTransform(xfA, localCenterA, cA, aA);\n    getTransform(xfB, localCenterB, cB, aB);\n\n    worldManifold.recycle();\n    manifold.getWorldManifold(worldManifold, xfA, radiusA, xfB, radiusB);\n\n    matrix.copyVec2(this.v_normal, worldManifold.normal);\n\n    for (let j = 0; j < this.v_pointCount; ++j) {\n      const vcp = this.v_points[j]; // VelocityConstraintPoint\n      const wmp = worldManifold.points[j];\n\n      matrix.diffVec2(vcp.rA, wmp, cA);\n      matrix.diffVec2(vcp.rB, wmp, cB);\n\n      const rnA = matrix.crossVec2Vec2(vcp.rA, this.v_normal);\n      const rnB = matrix.crossVec2Vec2(vcp.rB, this.v_normal);\n\n      const kNormal = mA + mB + iA * rnA * rnA + iB * rnB * rnB;\n\n      vcp.normalMass = kNormal > 0.0 ? 1.0 / kNormal : 0.0;\n\n      matrix.crossVec2Num(tangent, this.v_normal, 1.0);\n\n      const rtA = matrix.crossVec2Vec2(vcp.rA, tangent);\n      const rtB = matrix.crossVec2Vec2(vcp.rB, tangent);\n\n      const kTangent = mA + mB + iA * rtA * rtA + iB * rtB * rtB;\n\n      vcp.tangentMass = kTangent > 0.0 ? 1.0 / kTangent : 0.0;\n\n      // Setup a velocity bias for restitution.\n      vcp.velocityBias = 0.0;\n      let vRel = 0;\n      vRel += matrix.dotVec2(this.v_normal, vB)\n      vRel += matrix.dotVec2(this.v_normal, matrix.crossNumVec2(temp, wB, vcp.rB))\n      vRel -= matrix.dotVec2(this.v_normal, vA)\n      vRel -= matrix.dotVec2(this.v_normal, matrix.crossNumVec2(temp, wA, vcp.rA));\n      if (vRel < -Settings.velocityThreshold) {\n        vcp.velocityBias = -this.v_restitution * vRel;\n      }\n    }\n\n    // If we have two points, then prepare the block solver.\n    if (this.v_pointCount == 2 && step.blockSolve) {\n      const vcp1 = this.v_points[0]; // VelocityConstraintPoint\n      const vcp2 = this.v_points[1]; // VelocityConstraintPoint\n\n      const rn1A = matrix.crossVec2Vec2(vcp1.rA, this.v_normal);\n      const rn1B = matrix.crossVec2Vec2(vcp1.rB, this.v_normal);\n      const rn2A = matrix.crossVec2Vec2(vcp2.rA, this.v_normal);\n      const rn2B = matrix.crossVec2Vec2(vcp2.rB, this.v_normal);\n\n      const k11 = mA + mB + iA * rn1A * rn1A + iB * rn1B * rn1B;\n      const k22 = mA + mB + iA * rn2A * rn2A + iB * rn2B * rn2B;\n      const k12 = mA + mB + iA * rn1A * rn2A + iB * rn1B * rn2B;\n\n      // Ensure a reasonable condition number.\n      const k_maxConditionNumber = 1000.0;\n      if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {\n        // K is safe to invert.\n        this.v_K.ex.setNum(k11, k12);\n        this.v_K.ey.setNum(k12, k22);\n        // this.v_normalMass.set(this.v_K.getInverse());\n        const a = this.v_K.ex.x;\n        const b = this.v_K.ey.x;\n        const c = this.v_K.ex.y;\n        const d = this.v_K.ey.y;\n        let det = a * d - b * c;\n        if (det !== 0.0) {\n          det = 1.0 / det;\n        }\n        this.v_normalMass.ex.x = det * d;\n        this.v_normalMass.ey.x = -det * b;\n        this.v_normalMass.ex.y = -det * c;\n        this.v_normalMass.ey.y = det * a;\n\n      } else {\n        // The constraints are redundant, just use one.\n        // TODO_ERIN use deepest?\n        this.v_pointCount = 1;\n      }\n    }\n\n    matrix.copyVec2(positionA.c, cA);\n    positionA.a = aA;\n    matrix.copyVec2(velocityA.v, vA);\n    velocityA.w = wA;\n\n    matrix.copyVec2(positionB.c, cB);\n    positionB.a = aB;\n    matrix.copyVec2(velocityB.v, vB);\n    velocityB.w = wB;\n  }\n\n  warmStartConstraint(step: TimeStep): void {\n    const fixtureA = this.m_fixtureA;\n    const fixtureB = this.m_fixtureB;\n    if (fixtureA === null || fixtureB === null) return;\n    const bodyA = fixtureA.m_body;\n    const bodyB = fixtureB.m_body;\n    if (bodyA === null || bodyB === null) return;\n\n    const velocityA = bodyA.c_velocity;\n    const velocityB = bodyB.c_velocity;\n    const positionA = bodyA.c_position;\n    const positionB = bodyB.c_position;\n\n    const mA = this.v_invMassA;\n    const iA = this.v_invIA;\n    const mB = this.v_invMassB;\n    const iB = this.v_invIB;\n\n    matrix.copyVec2(vA, velocityA.v);\n    let wA = velocityA.w;\n    matrix.copyVec2(vB, velocityB.v);\n    let wB = velocityB.w;\n\n    matrix.copyVec2(normal, this.v_normal);\n    matrix.crossVec2Num(tangent, normal, 1.0);\n\n    for (let j = 0; j < this.v_pointCount; ++j) {\n      const vcp = this.v_points[j]; // VelocityConstraintPoint\n\n      matrix.combineVec2(P, vcp.normalImpulse, normal, vcp.tangentImpulse, tangent);\n\n      wA -= iA * matrix.crossVec2Vec2(vcp.rA, P);\n      matrix.subMulVec2(vA, mA, P);\n      wB += iB * matrix.crossVec2Vec2(vcp.rB, P);\n      matrix.addMulVec2(vB, mB, P);\n    }\n\n    matrix.copyVec2(velocityA.v, vA);\n    velocityA.w = wA;\n    matrix.copyVec2(velocityB.v, vB);\n    velocityB.w = wB;\n  }\n\n  storeConstraintImpulses(step: TimeStep): void {\n    const manifold = this.m_manifold;\n    for (let j = 0; j < this.v_pointCount; ++j) {\n      manifold.points[j].normalImpulse = this.v_points[j].normalImpulse;\n      manifold.points[j].tangentImpulse = this.v_points[j].tangentImpulse;\n    }\n  }\n\n  solveVelocityConstraint(step: TimeStep): void {\n    const fixtureA = this.m_fixtureA;\n    const fixtureB = this.m_fixtureB;\n    if (fixtureA === null || fixtureB === null) return;\n    const bodyA = fixtureA.m_body;\n    const bodyB = fixtureB.m_body;\n    if (bodyA === null || bodyB === null) return;\n\n    const velocityA = bodyA.c_velocity;\n    const positionA = bodyA.c_position;\n\n    const velocityB = bodyB.c_velocity;\n    const positionB = bodyB.c_position;\n\n    const mA = this.v_invMassA;\n    const iA = this.v_invIA;\n    const mB = this.v_invMassB;\n    const iB = this.v_invIB;\n\n    matrix.copyVec2(vA, velocityA.v);\n    let wA = velocityA.w;\n    matrix.copyVec2(vB, velocityB.v);\n    let wB = velocityB.w;\n\n    matrix.copyVec2(normal, this.v_normal);\n    matrix.crossVec2Num(tangent, normal, 1.0);\n    const friction = this.v_friction;\n\n    _ASSERT && console.assert(this.v_pointCount == 1 || this.v_pointCount == 2);\n\n    // Solve tangent constraints first because non-penetration is more important\n    // than friction.\n    for (let j = 0; j < this.v_pointCount; ++j) {\n      const vcp = this.v_points[j]; // VelocityConstraintPoint\n\n      // Relative velocity at contact\n      matrix.zeroVec2(dv);\n      matrix.addVec2(dv, vB);\n      matrix.addVec2(dv, matrix.crossNumVec2(temp, wB, vcp.rB));\n      matrix.subVec2(dv, vA);\n      matrix.subVec2(dv, matrix.crossNumVec2(temp, wA, vcp.rA));\n\n      // Compute tangent force\n      const vt = matrix.dotVec2(dv, tangent) - this.v_tangentSpeed;\n      let lambda = vcp.tangentMass * (-vt);\n\n      // Clamp the accumulated force\n      const maxFriction = friction * vcp.normalImpulse;\n      const newImpulse = Math.clamp(vcp.tangentImpulse + lambda, -maxFriction, maxFriction);\n      lambda = newImpulse - vcp.tangentImpulse;\n      vcp.tangentImpulse = newImpulse;\n\n      // Apply contact impulse\n      matrix.setMulVec2(P, lambda, tangent);\n\n      matrix.subMulVec2(vA, mA, P);\n      wA -= iA * matrix.crossVec2Vec2(vcp.rA, P);\n\n      matrix.addMulVec2(vB, mB, P);\n      wB += iB * matrix.crossVec2Vec2(vcp.rB, P);\n    }\n\n    // Solve normal constraints\n    if (this.v_pointCount == 1 || step.blockSolve == false) {\n      for (let i = 0; i < this.v_pointCount; ++i) {\n        const vcp = this.v_points[i]; // VelocityConstraintPoint\n\n        // Relative velocity at contact\n        matrix.zeroVec2(dv);\n        matrix.addVec2(dv, vB);\n        matrix.addVec2(dv, matrix.crossNumVec2(temp, wB, vcp.rB));\n        matrix.subVec2(dv, vA);\n        matrix.subVec2(dv, matrix.crossNumVec2(temp, wA, vcp.rA));\n\n        // Compute normal impulse\n        const vn = matrix.dotVec2(dv, normal);\n        let lambda = -vcp.normalMass * (vn - vcp.velocityBias);\n\n        // Clamp the accumulated impulse\n        const newImpulse = Math.max(vcp.normalImpulse + lambda, 0.0);\n        lambda = newImpulse - vcp.normalImpulse;\n        vcp.normalImpulse = newImpulse;\n\n        // Apply contact impulse\n        matrix.setMulVec2(P, lambda, normal);\n\n        matrix.subMulVec2(vA, mA, P);\n        wA -= iA * matrix.crossVec2Vec2(vcp.rA, P);\n\n        matrix.addMulVec2(vB, mB, P);\n        wB += iB * matrix.crossVec2Vec2(vcp.rB, P);\n      }\n    } else {\n      // Block solver developed in collaboration with Dirk Gregorius (back in\n      // 01/07 on Box2D_Lite).\n      // Build the mini LCP for this contact patch\n      //\n      // vn = A * x + b, vn >= 0, x >= 0 and vn_i * x_i = 0 with i = 1..2\n      //\n      // A = J * W * JT and J = ( -n, -r1 x n, n, r2 x n )\n      // b = vn0 - velocityBias\n      //\n      // The system is solved using the \"Total enumeration method\" (s. Murty).\n      // The complementary constraint vn_i * x_i\n      // implies that we must have in any solution either vn_i = 0 or x_i = 0.\n      // So for the 2D contact problem the cases\n      // vn1 = 0 and vn2 = 0, x1 = 0 and x2 = 0, x1 = 0 and vn2 = 0, x2 = 0 and\n      // vn1 = 0 need to be tested. The first valid\n      // solution that satisfies the problem is chosen.\n      //\n      // In order to account of the accumulated impulse 'a' (because of the\n      // iterative nature of the solver which only requires\n      // that the accumulated impulse is clamped and not the incremental\n      // impulse) we change the impulse variable (x_i).\n      //\n      // Substitute:\n      //\n      // x = a + d\n      //\n      // a := old total impulse\n      // x := new total impulse\n      // d := incremental impulse\n      //\n      // For the current iteration we extend the formula for the incremental\n      // impulse\n      // to compute the new total impulse:\n      //\n      // vn = A * d + b\n      // = A * (x - a) + b\n      // = A * x + b - A * a\n      // = A * x + b'\n      // b' = b - A * a;\n\n      const vcp1 = this.v_points[0]; // VelocityConstraintPoint\n      const vcp2 = this.v_points[1]; // VelocityConstraintPoint\n\n      matrix.setVec2(a, vcp1.normalImpulse, vcp2.normalImpulse);\n      _ASSERT && console.assert(a.x >= 0.0 && a.y >= 0.0);\n\n      // Relative velocity at contact\n      // let dv1 = Vec2.zero().add(vB).add(Vec2.crossNumVec2(wB, vcp1.rB)).sub(vA).sub(Vec2.crossNumVec2(wA, vcp1.rA));\n      matrix.zeroVec2(dv1);\n      matrix.addVec2(dv1, vB);\n      matrix.addVec2(dv1, matrix.crossNumVec2(temp, wB, vcp1.rB));\n      matrix.subVec2(dv1, vA);\n      matrix.subVec2(dv1, matrix.crossNumVec2(temp, wA, vcp1.rA));\n\n      // let dv2 = Vec2.zero().add(vB).add(Vec2.crossNumVec2(wB, vcp2.rB)).sub(vA).sub(Vec2.crossNumVec2(wA, vcp2.rA));\n      matrix.zeroVec2(dv2);\n      matrix.addVec2(dv2, vB);\n      matrix.addVec2(dv2, matrix.crossNumVec2(temp, wB, vcp2.rB));\n      matrix.subVec2(dv2, vA);\n      matrix.subVec2(dv2, matrix.crossNumVec2(temp, wA, vcp2.rA));\n\n      // Compute normal velocity\n      let vn1 = matrix.dotVec2(dv1, normal);\n      let vn2 = matrix.dotVec2(dv2, normal);\n\n      matrix.setVec2(b, vn1 - vcp1.velocityBias, vn2 - vcp2.velocityBias);\n\n      // Compute b'\n      // b.sub(Mat22.mulVec2(this.v_K, a));\n      b.x -= this.v_K.ex.x * a.x + this.v_K.ey.x * a.y;\n      b.y -= this.v_K.ex.y * a.x + this.v_K.ey.y * a.y;\n\n      const k_errorTol = 1e-3;\n      // NOT_USED(k_errorTol);\n\n      while (true) {\n        //\n        // Case 1: vn = 0\n        //\n        // 0 = A * x + b'\n        //\n        // Solve for x:\n        //\n        // x = - inv(A) * b'\n        //\n        // const x = Mat22.mulVec2(this.v_normalMass, b).neg();\n        matrix.zeroVec2(x);\n        x.x = -(this.v_normalMass.ex.x * b.x + this.v_normalMass.ey.x * b.y);\n        x.y = -(this.v_normalMass.ex.y * b.x + this.v_normalMass.ey.y * b.y);\n\n        if (x.x >= 0.0 && x.y >= 0.0) {\n          // Get the incremental impulse\n          matrix.diffVec2(d, x, a)\n\n          // Apply incremental impulse\n          matrix.setMulVec2(P1, d.x, normal);\n          matrix.setMulVec2(P2, d.y, normal);\n\n          // vA.subCombine(mA, P1, mA, P2);\n          matrix.subMulVec2(vA, mA, P1);\n          matrix.subMulVec2(vA, mA, P2);\n          wA -= iA * (matrix.crossVec2Vec2(vcp1.rA, P1) + matrix.crossVec2Vec2(vcp2.rA, P2));\n\n          // vB.addCombine(mB, P1, mB, P2);\n          matrix.addMulVec2(vB, mB, P1);\n          matrix.addMulVec2(vB, mB, P2);\n          wB += iB * (matrix.crossVec2Vec2(vcp1.rB, P1) + matrix.crossVec2Vec2(vcp2.rB, P2));\n\n          // Accumulate\n          vcp1.normalImpulse = x.x;\n          vcp2.normalImpulse = x.y;\n\n          if (DEBUG_SOLVER) {\n            // Postconditions\n            matrix.zeroVec2(dv1);\n            matrix.addVec2(dv1, vB);\n            matrix.addVec2(dv1, matrix.crossNumVec2(temp, wB, vcp1.rB));\n            matrix.subVec2(dv1, vA);\n            matrix.subVec2(dv1, matrix.crossNumVec2(temp, wA, vcp1.rA));\n\n            matrix.zeroVec2(dv2);\n            matrix.addVec2(dv2, vB);\n            matrix.addVec2(dv2, matrix.crossNumVec2(temp, wB, vcp2.rB));\n            matrix.subVec2(dv2, vA);\n            matrix.subVec2(dv2, matrix.crossNumVec2(temp, wA, vcp2.rA));\n\n            // Compute normal velocity\n            vn1 = matrix.dotVec2(dv1, normal);\n            vn2 = matrix.dotVec2(dv2, normal);\n\n            _ASSERT && console.assert(Math.abs(vn1 - vcp1.velocityBias) < k_errorTol);\n            _ASSERT && console.assert(Math.abs(vn2 - vcp2.velocityBias) < k_errorTol);\n          }\n          break;\n        }\n\n        //\n        // Case 2: vn1 = 0 and x2 = 0\n        //\n        // 0 = a11 * x1 + a12 * 0 + b1'\n        // vn2 = a21 * x1 + a22 * 0 + b2'\n        //\n        x.x = -vcp1.normalMass * b.x;\n        x.y = 0.0;\n        vn1 = 0.0;\n        vn2 = this.v_K.ex.y * x.x + b.y;\n\n        if (x.x >= 0.0 && vn2 >= 0.0) {\n          // Get the incremental impulse\n          matrix.diffVec2(d, x, a);\n\n          // Apply incremental impulse\n          matrix.setMulVec2(P1, d.x, normal);\n          matrix.setMulVec2(P2, d.y, normal);\n\n          // vA.subCombine(mA, P1, mA, P2);\n          matrix.subMulVec2(vA, mA, P1);\n          matrix.subMulVec2(vA, mA, P2);\n          wA -= iA * (matrix.crossVec2Vec2(vcp1.rA, P1) + matrix.crossVec2Vec2(vcp2.rA, P2));\n\n          // vB.addCombine(mB, P1, mB, P2);\n          matrix.addMulVec2(vB, mB, P1);\n          matrix.addMulVec2(vB, mB, P2);\n          wB += iB * (matrix.crossVec2Vec2(vcp1.rB, P1) + matrix.crossVec2Vec2(vcp2.rB, P2));\n\n          // Accumulate\n          vcp1.normalImpulse = x.x;\n          vcp2.normalImpulse = x.y;\n\n          if (DEBUG_SOLVER) {\n            // Postconditions\n            matrix.zeroVec2(dv1);\n            matrix.addVec2(dv1, vB);\n            matrix.addVec2(dv1, matrix.crossNumVec2(temp, wB, vcp1.rB));\n            matrix.subVec2(dv1, vA);\n            matrix.subVec2(dv1, matrix.crossNumVec2(temp, wA, vcp1.rA));\n\n            // Compute normal velocity\n            vn1 = matrix.dotVec2(dv1, normal);\n\n            _ASSERT && console.assert(Math.abs(vn1 - vcp1.velocityBias) < k_errorTol);\n          }\n          break;\n        }\n\n        //\n        // Case 3: vn2 = 0 and x1 = 0\n        //\n        // vn1 = a11 * 0 + a12 * x2 + b1'\n        // 0 = a21 * 0 + a22 * x2 + b2'\n        //\n        x.x = 0.0;\n        x.y = -vcp2.normalMass * b.y;\n        vn1 = this.v_K.ey.x * x.y + b.x;\n        vn2 = 0.0;\n\n        if (x.y >= 0.0 && vn1 >= 0.0) {\n          // Resubstitute for the incremental impulse\n          matrix.diffVec2(d, x, a);\n\n          // Apply incremental impulse\n          matrix.setMulVec2(P1, d.x, normal);\n          matrix.setMulVec2(P2, d.y, normal);\n\n          // vA.subCombine(mA, P1, mA, P2);\n          matrix.subMulVec2(vA, mA, P1);\n          matrix.subMulVec2(vA, mA, P2);\n          wA -= iA * (matrix.crossVec2Vec2(vcp1.rA, P1) + matrix.crossVec2Vec2(vcp2.rA, P2));\n\n          // vB.addCombine(mB, P1, mB, P2);\n          matrix.addMulVec2(vB, mB, P1);\n          matrix.addMulVec2(vB, mB, P2);\n          wB += iB * (matrix.crossVec2Vec2(vcp1.rB, P1) + matrix.crossVec2Vec2(vcp2.rB, P2));\n\n          // Accumulate\n          vcp1.normalImpulse = x.x;\n          vcp2.normalImpulse = x.y;\n\n          if (DEBUG_SOLVER) {\n            // Postconditions\n            matrix.zeroVec2(dv2);\n            matrix.addVec2(dv2, vB);\n            matrix.addVec2(dv2, matrix.crossNumVec2(temp, wB, vcp2.rB));\n            matrix.subVec2(dv2, vA);\n            matrix.subVec2(dv2, matrix.crossNumVec2(temp, wA, vcp2.rA));\n\n            // Compute normal velocity\n            vn2 = matrix.dotVec2(dv2, normal);\n\n            _ASSERT && console.assert(Math.abs(vn2 - vcp2.velocityBias) < k_errorTol);\n          }\n          break;\n        }\n\n        //\n        // Case 4: x1 = 0 and x2 = 0\n        //\n        // vn1 = b1\n        // vn2 = b2;\n        //\n        x.x = 0.0;\n        x.y = 0.0;\n        vn1 = b.x;\n        vn2 = b.y;\n\n        if (vn1 >= 0.0 && vn2 >= 0.0) {\n          // Resubstitute for the incremental impulse\n          matrix.diffVec2(d, x, a);\n\n          // Apply incremental impulse\n          matrix.setMulVec2(P1, d.x, normal);\n          matrix.setMulVec2(P2, d.y, normal);\n\n          // vA.subCombine(mA, P1, mA, P2);\n          matrix.subMulVec2(vA, mA, P1);\n          matrix.subMulVec2(vA, mA, P2);\n          wA -= iA * (matrix.crossVec2Vec2(vcp1.rA, P1) + matrix.crossVec2Vec2(vcp2.rA, P2));\n\n          // vB.addCombine(mB, P1, mB, P2);\n          matrix.addMulVec2(vB, mB, P1);\n          matrix.addMulVec2(vB, mB, P2);\n          wB += iB * (matrix.crossVec2Vec2(vcp1.rB, P1) + matrix.crossVec2Vec2(vcp2.rB, P2));\n\n          // Accumulate\n          vcp1.normalImpulse = x.x;\n          vcp2.normalImpulse = x.y;\n\n          break;\n        }\n\n        // No solution, give up. This is hit sometimes, but it doesn't seem to\n        // matter.\n        break;\n      }\n    }\n\n    matrix.copyVec2(velocityA.v, vA);\n    velocityA.w = wA;\n\n    matrix.copyVec2(velocityB.v, vB);\n    velocityB.w = wB;\n  }\n\n  /**\n   * @internal\n   */\n  static addType(type1: ShapeType, type2: ShapeType, callback: EvaluateFunction): void {\n    s_registers[type1] = s_registers[type1] || {};\n    s_registers[type1][type2] = callback;\n  }\n\n  /**\n   * @internal\n   */\n  static create(fixtureA: Fixture, indexA: number, fixtureB: Fixture, indexB: number): Contact | null {\n    const typeA = fixtureA.m_shape.m_type;\n    const typeB = fixtureB.m_shape.m_type;\n\n    const contact = contactPool.allocate();\n    let evaluateFcn;\n    if (evaluateFcn = s_registers[typeA] && s_registers[typeA][typeB]) {\n      contact.initialize(fixtureA, indexA, fixtureB, indexB, evaluateFcn);\n    } else if (evaluateFcn = s_registers[typeB] && s_registers[typeB][typeA]) {\n      contact.initialize(fixtureB, indexB, fixtureA, indexA, evaluateFcn);\n    } else {\n      return null;\n    }\n\n    // Contact creation may swap fixtures.\n    fixtureA = contact.m_fixtureA;\n    fixtureB = contact.m_fixtureB;\n    indexA = contact.getChildIndexA();\n    indexB = contact.getChildIndexB();\n    const bodyA = fixtureA.m_body;\n    const bodyB = fixtureB.m_body;\n\n    // Connect to body A\n    contact.m_nodeA.contact = contact;\n    contact.m_nodeA.other = bodyB;\n\n    contact.m_nodeA.prev = null;\n    contact.m_nodeA.next = bodyA.m_contactList;\n    if (bodyA.m_contactList != null) {\n      bodyA.m_contactList.prev = contact.m_nodeA;\n    }\n    bodyA.m_contactList = contact.m_nodeA;\n\n    // Connect to body B\n    contact.m_nodeB.contact = contact;\n    contact.m_nodeB.other = bodyA;\n\n    contact.m_nodeB.prev = null;\n    contact.m_nodeB.next = bodyB.m_contactList;\n    if (bodyB.m_contactList != null) {\n      bodyB.m_contactList.prev = contact.m_nodeB;\n    }\n    bodyB.m_contactList = contact.m_nodeB;\n\n    // Wake up the bodies\n    if (fixtureA.isSensor() == false && fixtureB.isSensor() == false) {\n      bodyA.setAwake(true);\n      bodyB.setAwake(true);\n    }\n\n    return contact;\n  }\n\n  /** @internal */\n  static destroy(contact: Contact, listener: { endContact: (contact: Contact) => void }): void {\n    const fixtureA = contact.m_fixtureA;\n    const fixtureB = contact.m_fixtureB;\n    if (fixtureA === null || fixtureB === null) return;\n    const bodyA = fixtureA.m_body;\n    const bodyB = fixtureB.m_body;\n    if (bodyA === null || bodyB === null) return;\n\n    if (contact.isTouching()) {\n      listener.endContact(contact);\n    }\n\n    // Remove from body 1\n    if (contact.m_nodeA.prev) {\n      contact.m_nodeA.prev.next = contact.m_nodeA.next;\n    }\n\n    if (contact.m_nodeA.next) {\n      contact.m_nodeA.next.prev = contact.m_nodeA.prev;\n    }\n\n    if (contact.m_nodeA == bodyA.m_contactList) {\n      bodyA.m_contactList = contact.m_nodeA.next;\n    }\n\n    // Remove from body 2\n    if (contact.m_nodeB.prev) {\n      contact.m_nodeB.prev.next = contact.m_nodeB.next;\n    }\n\n    if (contact.m_nodeB.next) {\n      contact.m_nodeB.next.prev = contact.m_nodeB.prev;\n    }\n\n    if (contact.m_nodeB == bodyB.m_contactList) {\n      bodyB.m_contactList = contact.m_nodeB.next;\n    }\n\n    if (contact.m_manifold.pointCount > 0 && !fixtureA.m_isSensor && !fixtureB.m_isSensor) {\n      bodyA.setAwake(true);\n      bodyB.setAwake(true);\n    }\n\n    // const typeA = fixtureA.getType();\n    // const typeB = fixtureB.getType();\n\n    // const destroyFcn = s_registers[typeA][typeB].destroyFcn;\n    // if (typeof destroyFcn === 'function') {\n    //   destroyFcn(contact);\n    // }\n\n    contactPool.release(contact);\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { options } from '../util/options';\nimport { Vec2 } from '../common/Vec2';\nimport { BroadPhase } from '../collision/BroadPhase';\nimport { Solver, ContactImpulse, TimeStep } from './Solver';\nimport { Body, BodyDef } from './Body';\nimport { Joint } from './Joint';\nimport { Contact } from './Contact';\nimport { AABB, RayCastInput, RayCastOutput } from \"../collision/AABB\";\nimport { Fixture, FixtureProxy } from \"./Fixture\";\nimport { Manifold } from \"../collision/Manifold\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\nconst _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\n/**\n * @prop gravity [{ x : 0, y : 0}]\n * @prop allowSleep [true]\n * @prop warmStarting [true]\n * @prop continuousPhysics [true]\n * @prop subStepping [false]\n * @prop blockSolve [true]\n * @prop velocityIterations [8] For the velocity constraint solver.\n * @prop positionIterations [3] For the position constraint solver.\n */\nexport interface WorldDef {\n  gravity?: Vec2;\n  allowSleep?: boolean;\n  warmStarting?: boolean;\n  continuousPhysics?: boolean;\n  subStepping?: boolean;\n  blockSolve?: boolean;\n  velocityIterations?: number;\n  positionIterations?: number;\n}\n\nconst WorldDefDefault: WorldDef = {\n  gravity : Vec2.zero(),\n  allowSleep : true,\n  warmStarting : true,\n  continuousPhysics : true,\n  subStepping : false,\n  blockSolve : true,\n  velocityIterations : 8,\n  positionIterations : 3\n};\n\n/**\n * Callback function for ray casts, see {@link World.rayCast}.\n *\n * Called for each fixture found in the query. You control how the ray cast\n * proceeds by returning a float: return -1: ignore this fixture and continue\n * return 0: terminate the ray cast return fraction: clip the ray to this point\n * return 1: don't clip the ray and continue\n *\n * @param fixture The fixture hit by the ray\n * @param point The point of initial intersection\n * @param normal The normal vector at the point of intersection\n * @param fraction\n *\n * @return -1 to filter, 0 to terminate, fraction to clip the ray for closest hit, 1 to continue\n */\nexport type WorldRayCastCallback = (fixture: Fixture, point: Vec2, normal: Vec2, fraction: number) => number;\n\n/**\n * Called for each fixture found in the query AABB. It may return `false` to terminate the query.\n */\nexport type WorldAABBQueryCallback = (fixture: Fixture) => boolean;\n\nexport class World {\n  /** @internal */ m_solver: Solver;\n  /** @internal */ m_broadPhase: BroadPhase;\n  /** @internal */ m_contactList: Contact | null;\n  /** @internal */ m_contactCount: number;\n  /** @internal */ m_bodyList: Body | null;\n  /** @internal */ m_bodyCount: number;\n  /** @internal */ m_jointList: Joint | null;\n  /** @internal */ m_jointCount: number;\n  /** @internal */ m_stepComplete: boolean;\n  /** @internal */ m_allowSleep: boolean;\n  /** @internal */ m_gravity: Vec2;\n  /** @internal */ m_clearForces: boolean;\n  /** @internal */ m_newFixture: boolean;\n  /** @internal */ m_locked: boolean;\n  /** @internal */ m_warmStarting: boolean;\n  /** @internal */ m_continuousPhysics: boolean;\n  /** @internal */ m_subStepping: boolean;\n  /** @internal */ m_blockSolve: boolean;\n  /** @internal */ m_velocityIterations: number;\n  /** @internal */ m_positionIterations: number;\n  /** @internal */ m_t: number;\n\n  // TODO\n  /** @internal */ _listeners: {\n    [key: string]: any[]\n  };\n\n  /**\n   * @param def World definition or gravity vector.\n   */\n  constructor(def?: WorldDef | Vec2 | null) {\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof World)) {\n      return new World(def);\n    }\n\n    this.s_step = new TimeStep();\n\n\n    if (def && Vec2.isValid(def)) {\n      def = { gravity: def as Vec2 };\n    }\n\n    def = options(def, WorldDefDefault) as WorldDef;\n\n    this.m_solver = new Solver(this);\n\n    this.m_broadPhase = new BroadPhase();\n\n    this.m_contactList = null;\n    this.m_contactCount = 0;\n\n    this.m_bodyList = null;\n    this.m_bodyCount = 0;\n\n    this.m_jointList = null;\n    this.m_jointCount = 0;\n\n    this.m_stepComplete = true;\n\n    this.m_allowSleep = def.allowSleep;\n    this.m_gravity = Vec2.clone(def.gravity);\n\n    this.m_clearForces = true;\n    this.m_newFixture = false;\n    this.m_locked = false;\n\n    // These are for debugging the solver.\n    this.m_warmStarting = def.warmStarting;\n    this.m_continuousPhysics = def.continuousPhysics;\n    this.m_subStepping = def.subStepping;\n\n    this.m_blockSolve = def.blockSolve;\n    this.m_velocityIterations = def.velocityIterations;\n    this.m_positionIterations = def.positionIterations;\n\n    this.m_t = 0;\n  }\n\n  /** @internal */\n  _serialize(): object {\n    const bodies = [];\n    const joints = [];\n\n    for (let b = this.getBodyList(); b; b = b.getNext()) {\n      bodies.push(b);\n    }\n\n    for (let j = this.getJointList(); j; j = j.getNext()) {\n      // @ts-ignore\n      if (typeof j._serialize === 'function') {\n        joints.push(j);\n      }\n    }\n\n    return {\n      gravity: this.m_gravity,\n      bodies,\n      joints,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, context: any, restore: any): World {\n    if (!data) {\n      return new World();\n    }\n\n    const world = new World(data.gravity);\n\n    if (data.bodies) {\n      for (let i = data.bodies.length - 1; i >= 0; i -= 1) {\n        world._addBody(restore(Body, data.bodies[i], world));\n      }\n    }\n\n    if (data.joints) {\n      for (let i = data.joints.length - 1; i >= 0; i--) {\n        world.createJoint(restore(Joint, data.joints[i], world));\n      }\n    }\n\n    return world;\n  }\n\n  /**\n   * Get the world body list. With the returned body, use Body.getNext to get the\n   * next body in the world list. A null body indicates the end of the list.\n   *\n   * @return the head of the world body list.\n   */\n  getBodyList(): Body | null {\n    return this.m_bodyList;\n  }\n\n  /**\n   * Get the world joint list. With the returned joint, use Joint.getNext to get\n   * the next joint in the world list. A null joint indicates the end of the list.\n   *\n   * @return the head of the world joint list.\n   */\n  getJointList(): Joint | null {\n    return this.m_jointList;\n  }\n\n  /**\n   * Get the world contact list. With the returned contact, use Contact.getNext to\n   * get the next contact in the world list. A null contact indicates the end of\n   * the list.\n   *\n   * Warning: contacts are created and destroyed in the middle of a time step.\n   * Use ContactListener to avoid missing contacts.\n   *\n   * @return the head of the world contact list.\n   */\n  getContactList(): Contact | null {\n    return this.m_contactList;\n  }\n\n  getBodyCount(): number {\n    return this.m_bodyCount;\n  }\n\n  getJointCount(): number {\n    return this.m_jointCount;\n  }\n\n  /**\n   * Get the number of contacts (each may have 0 or more contact points).\n   */\n  getContactCount(): number {\n    return this.m_contactCount;\n  }\n\n  /**\n   * Change the global gravity vector.\n   */\n  setGravity(gravity: Vec2): void {\n    this.m_gravity = gravity;\n  }\n\n  /**\n   * Get the global gravity vector.\n   */\n  getGravity(): Vec2 {\n    return this.m_gravity;\n  }\n\n  /**\n   * Is the world locked (in the middle of a time step).\n   */\n  isLocked(): boolean {\n    return this.m_locked;\n  }\n\n  /**\n   * Enable/disable sleep.\n   */\n  setAllowSleeping(flag: boolean): void {\n    if (flag == this.m_allowSleep) {\n      return;\n    }\n\n    this.m_allowSleep = flag;\n    if (this.m_allowSleep == false) {\n      for (let b = this.m_bodyList; b; b = b.m_next) {\n        b.setAwake(true);\n      }\n    }\n  }\n\n  getAllowSleeping(): boolean {\n    return this.m_allowSleep;\n  }\n\n  /**\n   * Enable/disable warm starting. For testing.\n   */\n  setWarmStarting(flag: boolean): void {\n    this.m_warmStarting = flag;\n  }\n\n  getWarmStarting(): boolean {\n    return this.m_warmStarting;\n  }\n\n  /**\n   * Enable/disable continuous physics. For testing.\n   */\n  setContinuousPhysics(flag: boolean): void {\n    this.m_continuousPhysics = flag;\n  }\n\n  getContinuousPhysics(): boolean {\n    return this.m_continuousPhysics;\n  }\n\n  /**\n   * Enable/disable single stepped continuous physics. For testing.\n   */\n  setSubStepping(flag: boolean): void {\n    this.m_subStepping = flag;\n  }\n\n  getSubStepping(): boolean {\n    return this.m_subStepping;\n  }\n\n  /**\n   * Set flag to control automatic clearing of forces after each time step.\n   */\n  setAutoClearForces(flag: boolean): void {\n    this.m_clearForces = flag;\n  }\n\n  /**\n   * Get the flag that controls automatic clearing of forces after each time step.\n   */\n  getAutoClearForces(): boolean {\n    return this.m_clearForces;\n  }\n\n  /**\n   * Manually clear the force buffer on all bodies. By default, forces are cleared\n   * automatically after each call to step. The default behavior is modified by\n   * calling setAutoClearForces. The purpose of this function is to support\n   * sub-stepping. Sub-stepping is often used to maintain a fixed sized time step\n   * under a variable frame-rate. When you perform sub-stepping you will disable\n   * auto clearing of forces and instead call clearForces after all sub-steps are\n   * complete in one pass of your game loop.\n   *\n   * See {@link World.setAutoClearForces}\n   */\n  clearForces(): void {\n    for (let body = this.m_bodyList; body; body = body.getNext()) {\n      body.m_force.setZero();\n      body.m_torque = 0.0;\n    }\n  }\n\n  /**\n   * Query the world for all fixtures that potentially overlap the provided AABB.\n   *\n   * @param aabb The query box.\n   * @param callback Called for each fixture found in the query AABB. It may return `false` to terminate the query.\n   */\n  queryAABB(aabb: AABB, callback: WorldAABBQueryCallback): void {\n    _ASSERT && console.assert(typeof callback === 'function');\n    const broadPhase = this.m_broadPhase;\n    this.m_broadPhase.query(aabb, function(proxyId: number): boolean { // TODO GC\n      const proxy = broadPhase.getUserData(proxyId);\n      return callback(proxy.fixture);\n    });\n  }\n\n  /**\n   * Ray-cast the world for all fixtures in the path of the ray. Your callback\n   * controls whether you get the closest point, any point, or n-points. The\n   * ray-cast ignores shapes that contain the starting point.\n   *\n   * @param point1 The ray starting point\n   * @param point2 The ray ending point\n   * @param callback A user implemented callback function.\n   */\n  rayCast(point1: Vec2, point2: Vec2, callback: WorldRayCastCallback): void {\n    _ASSERT && console.assert(typeof callback === 'function');\n    const broadPhase = this.m_broadPhase;\n\n    this.m_broadPhase.rayCast({\n      maxFraction : 1.0,\n      p1 : point1,\n      p2 : point2\n    }, function(input: RayCastInput, proxyId: number): number { // TODO GC\n      const proxy = broadPhase.getUserData(proxyId);\n      const fixture = proxy.fixture;\n      const index = proxy.childIndex;\n      // @ts-ignore\n      const output: RayCastOutput = {}; // TODO GC\n      const hit = fixture.rayCast(output, input, index);\n      if (hit) {\n        const fraction = output.fraction;\n        const point = Vec2.add(Vec2.mulNumVec2((1.0 - fraction), input.p1), Vec2.mulNumVec2(fraction, input.p2));\n        return callback(fixture, point, output.normal, fraction);\n      }\n      return input.maxFraction;\n    });\n  }\n\n  /**\n   * Get the number of broad-phase proxies.\n   */\n  getProxyCount(): number {\n    return this.m_broadPhase.getProxyCount();\n  }\n\n  /**\n   * Get the height of broad-phase dynamic tree.\n   */\n  getTreeHeight(): number {\n    return this.m_broadPhase.getTreeHeight();\n  }\n\n  /**\n   * Get the balance of broad-phase dynamic tree.\n   */\n  getTreeBalance(): number {\n    return this.m_broadPhase.getTreeBalance();\n  }\n\n  /**\n   * Get the quality metric of broad-phase dynamic tree. The smaller the better.\n   * The minimum is 1.\n   */\n  getTreeQuality(): number {\n    return this.m_broadPhase.getTreeQuality();\n  }\n\n  /**\n   * Shift the world origin. Useful for large worlds. The body shift formula is:\n   * position -= newOrigin\n   *\n   * @param newOrigin The new origin with respect to the old origin\n   */\n  shiftOrigin(newOrigin: Vec2): void {\n    _ASSERT && console.assert(this.m_locked == false);\n    if (this.m_locked) {\n      return;\n    }\n\n    for (let b = this.m_bodyList; b; b = b.m_next) {\n      b.m_xf.p.sub(newOrigin);\n      b.m_sweep.c0.sub(newOrigin);\n      b.m_sweep.c.sub(newOrigin);\n    }\n\n    for (let j = this.m_jointList; j; j = j.m_next) {\n      j.shiftOrigin(newOrigin);\n    }\n\n    this.m_broadPhase.shiftOrigin(newOrigin);\n  }\n\n  /**\n   * @internal Used for deserialize.\n   */\n  _addBody(body: Body): void {\n    _ASSERT && console.assert(this.isLocked() === false);\n    if (this.isLocked()) {\n      return;\n    }\n\n    // Add to world doubly linked list.\n    body.m_prev = null;\n    body.m_next = this.m_bodyList;\n    if (this.m_bodyList) {\n      this.m_bodyList.m_prev = body;\n    }\n    this.m_bodyList = body;\n    ++this.m_bodyCount;\n  }\n\n  /**\n   * Create a rigid body given a definition. No reference to the definition is\n   * retained.\n   *\n   * Warning: This function is locked during callbacks.\n   */\n  createBody(def?: BodyDef): Body;\n  createBody(position: Vec2, angle?: number): Body;\n  // tslint:disable-next-line:typedef\n  /** @internal */ createBody(arg1?, arg2?) {\n    _ASSERT && console.assert(this.isLocked() == false);\n    if (this.isLocked()) {\n      return null;\n    }\n\n    let def: BodyDef = {};\n    if (!arg1) {\n    } else if (Vec2.isValid(arg1)) {\n      def = { position : arg1, angle: arg2 };\n    } else if (typeof arg1 === 'object') {\n      def = arg1;\n    }\n\n    const body = new Body(this, def);\n    this._addBody(body);\n    return body;\n  }\n\n  createDynamicBody(def?: BodyDef): Body;\n  createDynamicBody(position: Vec2, angle?: number): Body;\n  // tslint:disable-next-line:typedef\n  /** @internal */ createDynamicBody(arg1?, arg2?) {\n    let def: BodyDef = {};\n    if (!arg1) {\n    } else if (Vec2.isValid(arg1)) {\n      def = { position : arg1, angle: arg2 };\n    } else if (typeof arg1 === 'object') {\n      def = arg1;\n    }\n    def.type = 'dynamic';\n    return this.createBody(def);\n  }\n\n  createKinematicBody(def?: BodyDef): Body;\n  createKinematicBody(position: Vec2, angle?: number): Body;\n  // tslint:disable-next-line:typedef\n  createKinematicBody(arg1?, arg2?) {\n    let def: BodyDef = {};\n    if (!arg1) {\n    } else if (Vec2.isValid(arg1)) {\n      def = { position : arg1, angle: arg2 };\n    } else if (typeof arg1 === 'object') {\n      def = arg1;\n    }\n    def.type = 'kinematic';\n    return this.createBody(def);\n  }\n\n  /**\n   * Destroy a rigid body given a definition. No reference to the definition is\n   * retained.\n   *\n   * Warning: This automatically deletes all associated shapes and joints.\n   *\n   * Warning: This function is locked during callbacks.\n   */\n  destroyBody(b: Body): boolean {\n    _ASSERT && console.assert(this.m_bodyCount > 0);\n    _ASSERT && console.assert(this.isLocked() == false);\n    if (this.isLocked()) {\n      return;\n    }\n\n    if (b.m_destroyed) {\n      return false;\n    }\n\n    // Delete the attached joints.\n    let je = b.m_jointList;\n    while (je) {\n      const je0 = je;\n      je = je.next;\n\n      this.publish('remove-joint', je0.joint);\n      this.destroyJoint(je0.joint);\n\n      b.m_jointList = je;\n    }\n    b.m_jointList = null;\n\n    // Delete the attached contacts.\n    let ce = b.m_contactList;\n    while (ce) {\n      const ce0 = ce;\n      ce = ce.next;\n\n      this.destroyContact(ce0.contact);\n\n      b.m_contactList = ce;\n    }\n    b.m_contactList = null;\n\n    // Delete the attached fixtures. This destroys broad-phase proxies.\n    let f = b.m_fixtureList;\n    while (f) {\n      const f0 = f;\n      f = f.m_next;\n\n      this.publish('remove-fixture', f0);\n      f0.destroyProxies(this.m_broadPhase);\n\n      b.m_fixtureList = f;\n    }\n    b.m_fixtureList = null;\n\n    // Remove world body list.\n    if (b.m_prev) {\n      b.m_prev.m_next = b.m_next;\n    }\n\n    if (b.m_next) {\n      b.m_next.m_prev = b.m_prev;\n    }\n\n    if (b == this.m_bodyList) {\n      this.m_bodyList = b.m_next;\n    }\n\n    b.m_destroyed = true;\n\n    --this.m_bodyCount;\n\n    this.publish('remove-body', b);\n\n    return true;\n  }\n\n  /**\n   * Create a joint to constrain bodies together. No reference to the definition\n   * is retained. This may cause the connected bodies to cease colliding.\n   *\n   * Warning: This function is locked during callbacks.\n   */\n  createJoint<T extends Joint>(joint: T): T | null {\n    _ASSERT && console.assert(!!joint.m_bodyA);\n    _ASSERT && console.assert(!!joint.m_bodyB);\n    _ASSERT && console.assert(this.isLocked() == false);\n    if (this.isLocked()) {\n      return null;\n    }\n\n    // Connect to the world list.\n    joint.m_prev = null;\n    joint.m_next = this.m_jointList;\n    if (this.m_jointList) {\n      this.m_jointList.m_prev = joint;\n    }\n    this.m_jointList = joint;\n    ++this.m_jointCount;\n\n    // Connect to the bodies' doubly linked lists.\n    joint.m_edgeA.joint = joint;\n    joint.m_edgeA.other = joint.m_bodyB;\n    joint.m_edgeA.prev = null;\n    joint.m_edgeA.next = joint.m_bodyA.m_jointList;\n    if (joint.m_bodyA.m_jointList)\n      joint.m_bodyA.m_jointList.prev = joint.m_edgeA;\n    joint.m_bodyA.m_jointList = joint.m_edgeA;\n\n    joint.m_edgeB.joint = joint;\n    joint.m_edgeB.other = joint.m_bodyA;\n    joint.m_edgeB.prev = null;\n    joint.m_edgeB.next = joint.m_bodyB.m_jointList;\n    if (joint.m_bodyB.m_jointList)\n      joint.m_bodyB.m_jointList.prev = joint.m_edgeB;\n    joint.m_bodyB.m_jointList = joint.m_edgeB;\n\n    // If the joint prevents collisions, then flag any contacts for filtering.\n    if (joint.m_collideConnected == false) {\n      for (let edge = joint.m_bodyB.getContactList(); edge; edge = edge.next) {\n        if (edge.other == joint.m_bodyA) {\n          // Flag the contact for filtering at the next time step (where either\n          // body is awake).\n          edge.contact.flagForFiltering();\n        }\n      }\n    }\n\n    // Note: creating a joint doesn't wake the bodies.\n\n    return joint;\n  }\n\n  /**\n   * Destroy a joint. This may cause the connected bodies to begin colliding.\n   * Warning: This function is locked during callbacks.\n   */\n  destroyJoint(joint: Joint): void {\n    _ASSERT && console.assert(this.isLocked() == false);\n    if (this.isLocked()) {\n      return;\n    }\n\n    // Remove from the doubly linked list.\n    if (joint.m_prev) {\n      joint.m_prev.m_next = joint.m_next;\n    }\n\n    if (joint.m_next) {\n      joint.m_next.m_prev = joint.m_prev;\n    }\n\n    if (joint == this.m_jointList) {\n      this.m_jointList = joint.m_next;\n    }\n\n    // Disconnect from bodies.\n    const bodyA = joint.m_bodyA;\n    const bodyB = joint.m_bodyB;\n\n    // Wake up connected bodies.\n    bodyA.setAwake(true);\n    bodyB.setAwake(true);\n\n    // Remove from body 1.\n    if (joint.m_edgeA.prev) {\n      joint.m_edgeA.prev.next = joint.m_edgeA.next;\n    }\n\n    if (joint.m_edgeA.next) {\n      joint.m_edgeA.next.prev = joint.m_edgeA.prev;\n    }\n\n    if (joint.m_edgeA == bodyA.m_jointList) {\n      bodyA.m_jointList = joint.m_edgeA.next;\n    }\n\n    joint.m_edgeA.prev = null;\n    joint.m_edgeA.next = null;\n\n    // Remove from body 2\n    if (joint.m_edgeB.prev) {\n      joint.m_edgeB.prev.next = joint.m_edgeB.next;\n    }\n\n    if (joint.m_edgeB.next) {\n      joint.m_edgeB.next.prev = joint.m_edgeB.prev;\n    }\n\n    if (joint.m_edgeB == bodyB.m_jointList) {\n      bodyB.m_jointList = joint.m_edgeB.next;\n    }\n\n    joint.m_edgeB.prev = null;\n    joint.m_edgeB.next = null;\n\n    _ASSERT && console.assert(this.m_jointCount > 0);\n    --this.m_jointCount;\n\n    // If the joint prevents collisions, then flag any contacts for filtering.\n    if (joint.m_collideConnected == false) {\n      let edge = bodyB.getContactList();\n      while (edge) {\n        if (edge.other == bodyA) {\n          // Flag the contact for filtering at the next time step (where either\n          // body is awake).\n          edge.contact.flagForFiltering();\n        }\n\n        edge = edge.next;\n      }\n    }\n\n    this.publish('remove-joint', joint);\n  }\n\n  /** @internal */\n  s_step: TimeStep; // reuse\n\n  /**\n   * Take a time step. This performs collision detection, integration, and\n   * constraint solution.\n   *\n   * Broad-phase, narrow-phase, solve and solve time of impacts.\n   *\n   * @param timeStep Time step, this should not vary.\n   */\n  step(timeStep: number, velocityIterations?: number, positionIterations?: number): void {\n    this.publish('pre-step', timeStep);\n\n    if ((velocityIterations | 0) !== velocityIterations) {\n      // TODO: remove this in future\n      velocityIterations = 0;\n    }\n\n    velocityIterations = velocityIterations || this.m_velocityIterations;\n    positionIterations = positionIterations || this.m_positionIterations;\n\n    // If new fixtures were added, we need to find the new contacts.\n    if (this.m_newFixture) {\n      this.findNewContacts();\n      this.m_newFixture = false;\n    }\n\n    this.m_locked = true;\n\n    this.s_step.reset(timeStep);\n    this.s_step.velocityIterations = velocityIterations;\n    this.s_step.positionIterations = positionIterations;\n    this.s_step.warmStarting = this.m_warmStarting;\n    this.s_step.blockSolve = this.m_blockSolve;\n\n    // Update contacts. This is where some contacts are destroyed.\n    this.updateContacts();\n\n    // Integrate velocities, solve velocity constraints, and integrate positions.\n    if (this.m_stepComplete && timeStep > 0.0) {\n      this.m_solver.solveWorld(this.s_step);\n\n      // Synchronize fixtures, check for out of range bodies.\n      for (let b = this.m_bodyList; b; b = b.getNext()) {\n        // If a body was not in an island then it did not move.\n        if (b.m_islandFlag == false) {\n          continue;\n        }\n\n        if (b.isStatic()) {\n          continue;\n        }\n\n        // Update fixtures (for broad-phase).\n        b.synchronizeFixtures();\n      }\n      // Look for new contacts.\n      this.findNewContacts();\n    }\n\n    // Handle TOI events.\n    if (this.m_continuousPhysics && timeStep > 0.0) {\n      this.m_solver.solveWorldTOI(this.s_step);\n    }\n\n    if (this.m_clearForces) {\n      this.clearForces();\n    }\n\n    this.m_locked = false;\n\n    this.publish('post-step', timeStep);\n  }\n\n  /**\n   * @internal\n   * Call this method to find new contacts.\n   */\n  findNewContacts(): void {\n    this.m_broadPhase.updatePairs(\n      (proxyA: FixtureProxy, proxyB: FixtureProxy) => this.createContact(proxyA, proxyB)\n    );\n  }\n\n  /**\n   * @internal\n   * Callback for broad-phase.\n   */\n  createContact(proxyA: FixtureProxy, proxyB: FixtureProxy): void {\n    const fixtureA = proxyA.fixture;\n    const fixtureB = proxyB.fixture;\n\n    const indexA = proxyA.childIndex;\n    const indexB = proxyB.childIndex;\n\n    const bodyA = fixtureA.getBody();\n    const bodyB = fixtureB.getBody();\n\n    // Are the fixtures on the same body?\n    if (bodyA == bodyB) {\n      return;\n    }\n\n    // TODO_ERIN use a hash table to remove a potential bottleneck when both\n    // bodies have a lot of contacts.\n    // Does a contact already exist?\n    let edge = bodyB.getContactList(); // ContactEdge\n    while (edge) {\n      if (edge.other == bodyA) {\n        const fA = edge.contact.getFixtureA();\n        const fB = edge.contact.getFixtureB();\n        const iA = edge.contact.getChildIndexA();\n        const iB = edge.contact.getChildIndexB();\n\n        if (fA == fixtureA && fB == fixtureB && iA == indexA && iB == indexB) {\n          // A contact already exists.\n          return;\n        }\n\n        if (fA == fixtureB && fB == fixtureA && iA == indexB && iB == indexA) {\n          // A contact already exists.\n          return;\n        }\n      }\n\n      edge = edge.next;\n    }\n\n    if (bodyB.shouldCollide(bodyA) == false) {\n      return;\n    }\n    if (fixtureB.shouldCollide(fixtureA) == false) {\n      return;\n    }\n\n    // Call the factory.\n    const contact = Contact.create(fixtureA, indexA, fixtureB, indexB);\n    if (contact == null) {\n      return;\n    }\n\n    // Insert into the world.\n    contact.m_prev = null;\n    if (this.m_contactList != null) {\n      contact.m_next = this.m_contactList;\n      this.m_contactList.m_prev = contact;\n    }\n    this.m_contactList = contact;\n\n    ++this.m_contactCount;\n  }\n\n  /**\n   * @internal\n   * Removes old non-overlapping contacts, applies filters and updates contacts.\n   */\n  updateContacts(): void {\n    // Update awake contacts.\n    let c;\n    let next_c = this.m_contactList;\n    while (c = next_c) {\n      next_c = c.getNext();\n      const fixtureA = c.getFixtureA();\n      const fixtureB = c.getFixtureB();\n      const indexA = c.getChildIndexA();\n      const indexB = c.getChildIndexB();\n      const bodyA = fixtureA.getBody();\n      const bodyB = fixtureB.getBody();\n\n      // Is this contact flagged for filtering?\n      if (c.m_filterFlag) {\n        if (bodyB.shouldCollide(bodyA) == false) {\n          this.destroyContact(c);\n          continue;\n        }\n\n        if (fixtureB.shouldCollide(fixtureA) == false) {\n          this.destroyContact(c);\n          continue;\n        }\n\n        // Clear the filtering flag.\n        c.m_filterFlag = false;\n      }\n\n      const activeA = bodyA.isAwake() && !bodyA.isStatic();\n      const activeB = bodyB.isAwake() && !bodyB.isStatic();\n\n      // At least one body must be awake and it must be dynamic or kinematic.\n      if (activeA == false && activeB == false) {\n        continue;\n      }\n\n      const proxyIdA = fixtureA.m_proxies[indexA].proxyId;\n      const proxyIdB = fixtureB.m_proxies[indexB].proxyId;\n      const overlap = this.m_broadPhase.testOverlap(proxyIdA, proxyIdB);\n\n      // Here we destroy contacts that cease to overlap in the broad-phase.\n      if (overlap == false) {\n        this.destroyContact(c);\n        continue;\n      }\n\n      // The contact persists.\n      c.update(this);\n    }\n  }\n\n  /** @internal */\n  destroyContact(contact: Contact): void {\n    // Remove from the world.\n    if (contact.m_prev) {\n      contact.m_prev.m_next = contact.m_next;\n    }\n    if (contact.m_next) {\n      contact.m_next.m_prev = contact.m_prev;\n    }\n    if (contact == this.m_contactList) {\n      this.m_contactList = contact.m_next;\n    }\n\n    Contact.destroy(contact, this);\n\n    --this.m_contactCount;\n  }\n\n\n  /**\n   * Called when two fixtures begin to touch.\n   *\n   * Implement contact callbacks to get contact information. You can use these\n   * results for things like sounds and game logic. You can also get contact\n   * results by traversing the contact lists after the time step. However, you\n   * might miss some contacts because continuous physics leads to sub-stepping.\n   * Additionally you may receive multiple callbacks for the same contact in a\n   * single time step. You should strive to make your callbacks efficient because\n   * there may be many callbacks per time step.\n   *\n   * Warning: You cannot create/destroy world entities inside these callbacks.\n   */\n  on(name: 'begin-contact', listener: (contact: Contact) => void): World;\n  /**\n   * Called when two fixtures cease to touch.\n   *\n   * Implement contact callbacks to get contact information. You can use these\n   * results for things like sounds and game logic. You can also get contact\n   * results by traversing the contact lists after the time step. However, you\n   * might miss some contacts because continuous physics leads to sub-stepping.\n   * Additionally you may receive multiple callbacks for the same contact in a\n   * single time step. You should strive to make your callbacks efficient because\n   * there may be many callbacks per time step.\n   *\n   * Warning: You cannot create/destroy world entities inside these callbacks.\n   */\n  on(name: 'end-contact', listener: (contact: Contact) => void): World;\n  /**\n   * This is called after a contact is updated. This allows you to inspect a\n   * contact before it goes to the solver. If you are careful, you can modify the\n   * contact manifold (e.g. disable contact). A copy of the old manifold is\n   * provided so that you can detect changes. Note: this is called only for awake\n   * bodies. Note: this is called even when the number of contact points is zero.\n   * Note: this is not called for sensors. Note: if you set the number of contact\n   * points to zero, you will not get an endContact callback. However, you may get\n   * a beginContact callback the next step.\n   *\n   * Warning: You cannot create/destroy world entities inside these callbacks.\n   */\n  on(name: 'pre-solve', listener: (contact: Contact, oldManifold: Manifold) => void): World;\n  /**\n   * This lets you inspect a contact after the solver is finished. This is useful\n   * for inspecting impulses. Note: the contact manifold does not include time of\n   * impact impulses, which can be arbitrarily large if the sub-step is small.\n   * Hence the impulse is provided explicitly in a separate data structure. Note:\n   * this is only called for contacts that are touching, solid, and awake.\n   *\n   * Warning: You cannot create/destroy world entities inside these callbacks.\n   */\n  on(name: 'post-solve', listener: (contact: Contact, impulse: ContactImpulse) => void): World;\n  /** Listener is called whenever a body is removed. */\n  on(name: 'remove-body', listener: (body: Body) => void): World;\n  /** Listener is called whenever a joint is removed implicitly or explicitly. */\n  on(name: 'remove-joint', listener: (joint: Joint) => void): World;\n  /** Listener is called whenever a fixture is removed implicitly or explicitly. */\n  on(name: 'remove-fixture', listener: (fixture: Fixture) => void): World;\n  /**\n   * Register an event listener.\n   */\n  // tslint:disable-next-line:typedef\n  on(name, listener) {\n    if (typeof name !== 'string' || typeof listener !== 'function') {\n      return this;\n    }\n    if (!this._listeners) {\n      this._listeners = {};\n    }\n    if (!this._listeners[name]) {\n      this._listeners[name] = [];\n    }\n    this._listeners[name].push(listener);\n    return this;\n  }\n\n  off(name: 'begin-contact', listener: (contact: Contact) => void): World;\n  off(name: 'end-contact', listener: (contact: Contact) => void): World;\n  off(name: 'pre-solve', listener: (contact: Contact, oldManifold: Manifold) => void): World;\n  off(name: 'post-solve', listener: (contact: Contact, impulse: ContactImpulse) => void): World;\n  off(name: 'remove-body', listener: (body: Body) => void): World;\n  off(name: 'remove-joint', listener: (joint: Joint) => void): World;\n  off(name: 'remove-fixture', listener: (fixture: Fixture) => void): World;\n  /**\n   * Remove an event listener.\n   */\n  // tslint:disable-next-line:typedef\n  off(name, listener) {\n    if (typeof name !== 'string' || typeof listener !== 'function') {\n      return this;\n    }\n    const listeners = this._listeners && this._listeners[name];\n    if (!listeners || !listeners.length) {\n      return this;\n    }\n    const index = listeners.indexOf(listener);\n    if (index >= 0) {\n      listeners.splice(index, 1);\n    }\n    return this;\n  }\n\n  publish(name: string, arg1?: any, arg2?: any, arg3?: any): number {\n    const listeners = this._listeners && this._listeners[name];\n    if (!listeners || !listeners.length) {\n      return 0;\n    }\n    for (let l = 0; l < listeners.length; l++) {\n      listeners[l].call(this, arg1, arg2, arg3);\n    }\n    return listeners.length;\n  }\n\n  /**\n   * @internal\n   */\n  beginContact(contact: Contact): void {\n    this.publish('begin-contact', contact);\n  }\n\n  /**\n   * @internal\n   */\n  endContact(contact: Contact): void {\n    this.publish('end-contact', contact);\n  }\n\n  /**\n   * @internal\n   */\n  preSolve(contact: Contact, oldManifold: Manifold): void {\n    this.publish('pre-solve', contact, oldManifold);\n  }\n\n  /**\n   * @internal\n   */\n  postSolve(contact: Contact, impulse: ContactImpulse): void {\n    this.publish('post-solve', contact, impulse);\n  }\n\n  /**\n   * Joints and fixtures are destroyed when their associated body is destroyed.\n   * Register a destruction listener so that you may nullify references to these\n   * joints and shapes.\n   *\n   * `function(object)` is called when any joint or fixture is about to\n   * be destroyed due to the destruction of one of its attached or parent bodies.\n   */\n\n  /**\n   * Register a contact filter to provide specific control over collision.\n   * Otherwise the default filter is used (defaultFilter). The listener is owned\n   * by you and must remain in scope.\n   *\n   * Moved to Fixture.\n   */\n}","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport * as matrix from './Matrix';\nimport { math as Math } from './Math';\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\nconst _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\nexport interface Vec3Value {\n  x: number;\n  y: number;\n  z: number;\n}\n\nexport class Vec3 {\n  x: number;\n  y: number;\n  z: number;\n\n  constructor(x: number, y: number, z: number);\n  constructor(obj: { x: number, y: number, z: number });\n  constructor();\n  // tslint:disable-next-line:typedef\n  constructor(x?, y?, z?) {\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof Vec3)) {\n      return new Vec3(x, y, z);\n    }\n    if (typeof x === 'undefined') {\n      this.x = 0;\n      this.y = 0;\n      this.z = 0;\n    } else if (typeof x === 'object') {\n      this.x = x.x;\n      this.y = x.y;\n      this.z = x.z;\n    } else {\n      this.x = x;\n      this.y = y;\n      this.z = z;\n    }\n    _ASSERT && Vec3.assert(this);\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      x: this.x,\n      y: this.y,\n      z: this.z\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any): Vec3 {\n    const obj = Object.create(Vec3.prototype);\n    obj.x = data.x;\n    obj.y = data.y;\n    obj.z = data.z;\n    return obj;\n  }\n\n  /** @internal */\n  static neo(x: number, y: number, z: number): Vec3 {\n    const obj = Object.create(Vec3.prototype);\n    obj.x = x;\n    obj.y = y;\n    obj.z = z;\n    return obj;\n  }\n\n  static zero(): Vec3 {\n    const obj = Object.create(Vec3.prototype);\n    obj.x = 0;\n    obj.y = 0;\n    obj.z = 0;\n    return obj;\n  }\n\n  static clone(v: Vec3Value): Vec3 {\n    _ASSERT && Vec3.assert(v);\n    return Vec3.neo(v.x, v.y, v.z);\n  }\n\n  /** @internal */\n  toString(): string {\n    return JSON.stringify(this);\n  }\n\n  /**\n   * Does this vector contain finite coordinates?\n   */\n  static isValid(obj: any): boolean {\n    if (obj === null || typeof obj === 'undefined') {\n      return false;\n    }\n    return Math.isFinite(obj.x) && Math.isFinite(obj.y) && Math.isFinite(obj.z);\n  }\n\n  static assert(o: any): void {\n    _ASSERT && console.assert(!Vec3.isValid(o), 'Invalid Vec3!', o);\n  }\n\n  setZero(): Vec3 {\n    this.x = 0.0;\n    this.y = 0.0;\n    this.z = 0.0;\n    return this;\n  }\n\n  set(x: number, y: number, z: number): Vec3 {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    return this;\n  }\n\n  add(w: Vec3Value): Vec3 {\n    this.x += w.x;\n    this.y += w.y;\n    this.z += w.z;\n    return this;\n  }\n\n  sub(w: Vec3Value): Vec3 {\n    this.x -= w.x;\n    this.y -= w.y;\n    this.z -= w.z;\n    return this;\n  }\n\n  mul(m: number): Vec3 {\n    this.x *= m;\n    this.y *= m;\n    this.z *= m;\n    return this;\n  }\n\n  static areEqual(v: Vec3Value, w: Vec3Value): boolean {\n    _ASSERT && Vec3.assert(v);\n    _ASSERT && Vec3.assert(w);\n    return v === w ||\n      typeof v === 'object' && v !== null &&\n      typeof w === 'object' && w !== null &&\n      v.x === w.x && v.y === w.y && v.z === w.z;\n  }\n\n  /**\n   * Perform the dot product on two vectors.\n   */\n  static dot(v: Vec3Value, w: Vec3Value): number {\n    return v.x * w.x + v.y * w.y + v.z * w.z;\n  }\n\n  /**\n   * Perform the cross product on two vectors. In 2D this produces a scalar.\n   */\n  static cross(v: Vec3Value, w: Vec3Value): Vec3 {\n    return new Vec3(\n      v.y * w.z - v.z * w.y,\n      v.z * w.x - v.x * w.z,\n      v.x * w.y - v.y * w.x\n    );\n  }\n\n  static add(v: Vec3Value, w: Vec3Value): Vec3 {\n    return new Vec3(v.x + w.x, v.y + w.y, v.z + w.z);\n  }\n\n  static sub(v: Vec3Value, w: Vec3Value): Vec3 {\n    return new Vec3(v.x - w.x, v.y - w.y, v.z - w.z);\n  }\n\n  static mul(v: Vec3Value, m: number): Vec3 {\n    return new Vec3(m * v.x, m * v.y, m * v.z);\n  }\n\n  neg(): Vec3 {\n    this.x = -this.x;\n    this.y = -this.y;\n    this.z = -this.z;\n    return this;\n  }\n\n  static neg(v: Vec3Value): Vec3 {\n    return new Vec3(-v.x, -v.y, -v.z);\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { SettingsInternal as Settings } from '../../Settings';\nimport * as matrix from '../../common/Matrix';\nimport { Shape } from '../Shape';\nimport { Transform, TransformValue } from '../../common/Transform';\nimport { Rot } from '../../common/Rot';\nimport { Vec2, Vec2Value } from '../../common/Vec2';\nimport { AABB, AABBValue, RayCastInput, RayCastOutput } from '../AABB';\nimport { MassData } from '../../dynamics/Body';\nimport { DistanceProxy } from '../Distance';\n\n\nconst _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\nconst v1 = matrix.vec2(0, 0);\nconst v2 = matrix.vec2(0, 0);\n\n/**\n * A line segment (edge) shape. These can be connected in chains or loops to\n * other edge shapes. The connectivity information is used to ensure correct\n * contact normals.\n */\nexport class EdgeShape extends Shape {\n  static TYPE = 'edge' as const;\n  m_type: 'edge';\n\n  m_radius: number;\n\n  // These are the edge vertices\n  m_vertex1: Vec2;\n  m_vertex2: Vec2;\n\n  // Optional adjacent vertices. These are used for smooth collision.\n  // Used by chain shape.\n  m_vertex0: Vec2;\n  m_vertex3: Vec2;\n  m_hasVertex0: boolean;\n  m_hasVertex3: boolean;\n\n  constructor(v1?: Vec2Value, v2?: Vec2Value) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof EdgeShape)) {\n      return new EdgeShape(v1, v2);\n    }\n\n    super();\n\n    this.m_type = EdgeShape.TYPE;\n    this.m_radius = Settings.polygonRadius;\n\n    this.m_vertex1 = v1 ? Vec2.clone(v1) : Vec2.zero();\n    this.m_vertex2 = v2 ? Vec2.clone(v2) : Vec2.zero();\n\n    this.m_vertex0 = Vec2.zero();\n    this.m_vertex3 = Vec2.zero();\n    this.m_hasVertex0 = false;\n    this.m_hasVertex3 = false;\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n\n      vertex1: this.m_vertex1,\n      vertex2: this.m_vertex2,\n\n      vertex0: this.m_vertex0,\n      vertex3: this.m_vertex3,\n      hasVertex0: this.m_hasVertex0,\n      hasVertex3: this.m_hasVertex3,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any): EdgeShape {\n    const shape = new EdgeShape(data.vertex1, data.vertex2);\n    if (shape.m_hasVertex0) {\n      shape.setPrevVertex(data.vertex0);\n    }\n    if (shape.m_hasVertex3) {\n      shape.setNextVertex(data.vertex3);\n    }\n    return shape;\n  }\n\n  /** @internal */\n  _reset(): void {\n    // noop\n  }\n\n  getRadius(): number {\n    return this.m_radius;\n  }\n\n  getType(): 'edge' {\n    return this.m_type;\n  }\n\n  /** @internal @deprecated */\n  setNext(v?: Vec2): EdgeShape {\n    return this.setNextVertex(v);\n  }\n\n  /**\n   * Optional next vertex, used for smooth collision.\n   */\n  setNextVertex(v?: Vec2): EdgeShape {\n    if (v) {\n      this.m_vertex3.setVec2(v);\n      this.m_hasVertex3 = true;\n    } else {\n      this.m_vertex3.setZero();\n      this.m_hasVertex3 = false;\n    }\n    return this;\n  }\n\n  /**\n   * Optional next vertex, used for smooth collision.\n   */\n  getNextVertex(): Vec2 {\n    return this.m_vertex3;\n  }\n\n  /** @internal @deprecated */\n  setPrev(v?: Vec2): EdgeShape {\n    return this.setPrevVertex(v);\n  }\n\n  /**\n   * Optional prev vertex, used for smooth collision.\n   */\n  setPrevVertex(v?: Vec2): EdgeShape {\n    if (v) {\n      this.m_vertex0.setVec2(v);\n      this.m_hasVertex0 = true;\n    } else {\n      this.m_vertex0.setZero();\n      this.m_hasVertex0 = false;\n    }\n    return this;\n  }\n\n  /**\n   * Optional prev vertex, used for smooth collision.\n   */\n  getPrevVertex(): Vec2 {\n    return this.m_vertex0;\n  }\n\n  /**\n   * Set this as an isolated edge.\n   */\n  _set(v1: Vec2, v2: Vec2): EdgeShape {\n    this.m_vertex1.setVec2(v1);\n    this.m_vertex2.setVec2(v2);\n    this.m_hasVertex0 = false;\n    this.m_hasVertex3 = false;\n    return this;\n  }\n\n  /**\n   * @internal\n   * @deprecated Shapes should be treated as immutable.\n   *\n   * clone the concrete shape.\n   */\n  _clone(): EdgeShape {\n    const clone = new EdgeShape();\n    clone.m_type = this.m_type;\n    clone.m_radius = this.m_radius;\n    clone.m_vertex1.setVec2(this.m_vertex1);\n    clone.m_vertex2.setVec2(this.m_vertex2);\n    clone.m_vertex0.setVec2(this.m_vertex0);\n    clone.m_vertex3.setVec2(this.m_vertex3);\n    clone.m_hasVertex0 = this.m_hasVertex0;\n    clone.m_hasVertex3 = this.m_hasVertex3;\n    return clone;\n  }\n\n  /**\n   * Get the number of child primitives.\n   */\n  getChildCount(): 1 {\n    return 1;\n  }\n\n  /**\n   * Test a point for containment in this shape. This only works for convex\n   * shapes.\n   *\n   * @param xf The shape world transform.\n   * @param p A point in world coordinates.\n   */\n  testPoint(xf: TransformValue, p: Vec2Value): false {\n    return false;\n  }\n\n  /**\n   * Cast a ray against a child shape.\n   *\n   * @param output The ray-cast results.\n   * @param input The ray-cast input parameters.\n   * @param xf The transform to be applied to the shape.\n   * @param childIndex The child shape index\n   */\n  rayCast(output: RayCastOutput, input: RayCastInput, xf: Transform, childIndex: number): boolean {\n    // p = p1 + t * d\n    // v = v1 + s * e\n    // p1 + t * d = v1 + s * e\n    // s * e - t * d = p1 - v1\n\n    // NOT_USED(childIndex);\n\n    // Put the ray into the edge's frame of reference.\n    const p1 = Rot.mulTVec2(xf.q, Vec2.sub(input.p1, xf.p));\n    const p2 = Rot.mulTVec2(xf.q, Vec2.sub(input.p2, xf.p));\n    const d = Vec2.sub(p2, p1);\n\n    const v1 = this.m_vertex1;\n    const v2 = this.m_vertex2;\n    const e = Vec2.sub(v2, v1);\n    const normal = Vec2.neo(e.y, -e.x);\n    normal.normalize();\n\n    // q = p1 + t * d\n    // dot(normal, q - v1) = 0\n    // dot(normal, p1 - v1) + t * dot(normal, d) = 0\n    const numerator = Vec2.dot(normal, Vec2.sub(v1, p1));\n    const denominator = Vec2.dot(normal, d);\n\n    if (denominator == 0.0) {\n      return false;\n    }\n\n    const t = numerator / denominator;\n    if (t < 0.0 || input.maxFraction < t) {\n      return false;\n    }\n\n    const q = Vec2.add(p1, Vec2.mulNumVec2(t, d));\n\n    // q = v1 + s * r\n    // s = dot(q - v1, r) / dot(r, r)\n    const r = Vec2.sub(v2, v1);\n    const rr = Vec2.dot(r, r);\n    if (rr == 0.0) {\n      return false;\n    }\n\n    const s = Vec2.dot(Vec2.sub(q, v1), r) / rr;\n    if (s < 0.0 || 1.0 < s) {\n      return false;\n    }\n\n    output.fraction = t;\n    if (numerator > 0.0) {\n      output.normal = Rot.mulVec2(xf.q, normal).neg();\n    } else {\n      output.normal = Rot.mulVec2(xf.q, normal);\n    }\n    return true;\n  }\n\n  /**\n   * Given a transform, compute the associated axis aligned bounding box for a\n   * child shape.\n   *\n   * @param aabb Returns the axis aligned box.\n   * @param xf The world transform of the shape.\n   * @param childIndex The child shape\n   */\n  computeAABB(aabb: AABBValue, xf: TransformValue, childIndex: number): void {\n    matrix.transformVec2(v1, xf, this.m_vertex1);\n    matrix.transformVec2(v2, xf, this.m_vertex2);\n\n    AABB.combinePoints(aabb, v1, v2);\n    AABB.extend(aabb, this.m_radius);\n  }\n\n  /**\n   * Compute the mass properties of this shape using its dimensions and density.\n   * The inertia tensor is computed about the local origin.\n   *\n   * @param massData Returns the mass data for this shape.\n   * @param density The density in kilograms per meter squared.\n   */\n  computeMass(massData: MassData, density?: number): void {\n    massData.mass = 0.0;\n    matrix.combineVec2(massData.center, 0.5, this.m_vertex1, 0.5, this.m_vertex2);\n    massData.I = 0.0;\n  }\n\n  computeDistanceProxy(proxy: DistanceProxy): void {\n    proxy.m_vertices[0] = this.m_vertex1;\n    proxy.m_vertices[1] = this.m_vertex2;\n    proxy.m_vertices.length = 2;\n    proxy.m_count = 2;\n    proxy.m_radius = this.m_radius;\n  }\n}\n\nexport const Edge = EdgeShape;\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport * as matrix from '../../common/Matrix';\nimport type { MassData } from '../../dynamics/Body';\nimport { AABBValue, RayCastOutput, RayCastInput, AABB } from '../AABB';\nimport { DistanceProxy } from '../Distance';\nimport { Transform, TransformValue } from '../../common/Transform';\nimport { Vec2, Vec2Value } from '../../common/Vec2';\nimport { SettingsInternal as Settings } from '../../Settings';\nimport { Shape } from '../Shape';\nimport { EdgeShape } from './EdgeShape';\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\nconst _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\nconst v1 = matrix.vec2(0, 0);\nconst v2 = matrix.vec2(0, 0);\n\n\n/**\n * A chain shape is a free form sequence of line segments. The chain has\n * two-sided collision, so you can use inside and outside collision. Therefore,\n * you may use any winding order. Connectivity information is used to create\n * smooth collisions.\n *\n * WARNING: The chain will not collide properly if there are self-intersections.\n */\nexport class ChainShape extends Shape {\n  static TYPE = 'chain' as const;\n  m_type: 'chain';\n\n  m_radius: number;\n\n  m_vertices: Vec2[];\n  m_count: number;\n  m_prevVertex: Vec2 | null;\n  m_nextVertex: Vec2 | null;\n  m_hasPrevVertex: boolean;\n  m_hasNextVertex: boolean;\n\n  m_isLoop: boolean;\n\n  constructor(vertices?: Vec2Value[], loop?: boolean) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof ChainShape)) {\n      return new ChainShape(vertices, loop);\n    }\n\n    super();\n\n    this.m_type = ChainShape.TYPE;\n    this.m_radius = Settings.polygonRadius;\n    this.m_vertices = [];\n    this.m_count = 0;\n    this.m_prevVertex = null;\n    this.m_nextVertex = null;\n    this.m_hasPrevVertex = false;\n    this.m_hasNextVertex = false;\n\n    this.m_isLoop = !!loop;\n\n    if (vertices && vertices.length) {\n      if (loop) {\n        this._createLoop(vertices);\n      } else {\n        this._createChain(vertices);\n      }\n    }\n  }\n\n  /** @internal */\n  _serialize(): object {\n    const data = {\n      type: this.m_type,\n      vertices: this.m_vertices,\n      isLoop: this.m_isLoop,\n      hasPrevVertex: this.m_hasPrevVertex,\n      hasNextVertex: this.m_hasNextVertex,\n      prevVertex: null as Vec2 | null,\n      nextVertex: null as Vec2 | null,\n    };\n    if (this.m_prevVertex) {\n      data.prevVertex = this.m_prevVertex;\n    }\n    if (this.m_nextVertex) {\n      data.nextVertex = this.m_nextVertex;\n    }\n    return data;\n  }\n\n  /** @internal */\n  static _deserialize(data: any, fixture: any, restore: any): ChainShape {\n    const vertices: Vec2[] = [];\n    if (data.vertices) {\n      for (let i = 0; i < data.vertices.length; i++) {\n        vertices.push(restore(Vec2, data.vertices[i]));\n      }\n    }\n    const shape = new ChainShape(vertices, data.isLoop);\n    if (data.prevVertex) {\n      shape.setPrevVertex(data.prevVertex);\n    }\n    if (data.nextVertex) {\n      shape.setNextVertex(data.nextVertex);\n    }\n    return shape;\n  }\n\n  // clear() {\n  //   this.m_vertices.length = 0;\n  //   this.m_count = 0;\n  // }\n\n  getType(): 'chain' {\n    return this.m_type;\n  }\n\n  getRadius(): number {\n    return this.m_radius;\n  }\n\n  /**\n   * @internal\n   * Create a loop. This automatically adjusts connectivity.\n   *\n   * @param vertices an array of vertices, these are copied\n   * @param count the vertex count\n   */\n  _createLoop(vertices: Vec2Value[]): ChainShape {\n    _ASSERT && console.assert(this.m_vertices.length == 0 && this.m_count == 0);\n    _ASSERT && console.assert(vertices.length >= 3);\n    if (vertices.length < 3) {\n      return;\n    }\n\n    for (let i = 1; i < vertices.length; ++i) {\n      const v1 = vertices[i - 1];\n      const v2 = vertices[i];\n      // If the code crashes here, it means your vertices are too close together.\n      _ASSERT && console.assert(Vec2.distanceSquared(v1, v2) > Settings.linearSlopSquared);\n    }\n\n    this.m_vertices = [];\n    this.m_count = vertices.length + 1;\n    for (let i = 0; i < vertices.length; ++i) {\n      this.m_vertices[i] = Vec2.clone(vertices[i]);\n    }\n    this.m_vertices[vertices.length] = Vec2.clone(vertices[0]);\n\n    this.m_prevVertex = this.m_vertices[this.m_count - 2];\n    this.m_nextVertex = this.m_vertices[1];\n    this.m_hasPrevVertex = true;\n    this.m_hasNextVertex = true;\n    return this;\n  }\n\n  /**\n   * @internal\n   * Create a chain with isolated end vertices.\n   *\n   * @param vertices an array of vertices, these are copied\n   * @param count the vertex count\n   */\n  _createChain(vertices: Vec2Value[]): ChainShape {\n    _ASSERT && console.assert(this.m_vertices.length == 0 && this.m_count == 0);\n    _ASSERT && console.assert(vertices.length >= 2);\n    for (let i = 1; i < vertices.length; ++i) {\n      // If the code crashes here, it means your vertices are too close together.\n      const v1 = vertices[i - 1];\n      const v2 = vertices[i];\n      _ASSERT && console.assert(Vec2.distanceSquared(v1, v2) > Settings.linearSlopSquared);\n    }\n\n    this.m_count = vertices.length;\n    for (let i = 0; i < vertices.length; ++i) {\n      this.m_vertices[i] = Vec2.clone(vertices[i]);\n    }\n\n    this.m_hasPrevVertex = false;\n    this.m_hasNextVertex = false;\n    this.m_prevVertex = null;\n    this.m_nextVertex = null;\n    return this;\n  }\n\n  /** @internal */\n  _reset(): void {\n    if (this.m_isLoop) {\n      this._createLoop(this.m_vertices);\n    } else {\n      this._createChain(this.m_vertices);\n    }\n  }\n\n  /**\n   * Establish connectivity to a vertex that precedes the first vertex. Don't call\n   * this for loops.\n   */\n  setPrevVertex(prevVertex: Vec2): void {\n    this.m_prevVertex = prevVertex;\n    this.m_hasPrevVertex = true;\n  }\n\n  getPrevVertex(): Vec2 {\n    return this.m_prevVertex;\n  }\n\n  /**\n   * Establish connectivity to a vertex that follows the last vertex. Don't call\n   * this for loops.\n   */\n  setNextVertex(nextVertex: Vec2): void {\n    this.m_nextVertex = nextVertex;\n    this.m_hasNextVertex = true;\n  }\n\n  getNextVertex(): Vec2 {\n    return this.m_nextVertex;\n  }\n\n  /**\n   * @internal\n   * @deprecated Shapes should be treated as immutable.\n   *\n   * clone the concrete shape.\n   */\n  _clone(): ChainShape {\n    const clone = new ChainShape();\n    clone._createChain(this.m_vertices);\n    clone.m_type = this.m_type;\n    clone.m_radius = this.m_radius;\n    clone.m_prevVertex = this.m_prevVertex;\n    clone.m_nextVertex = this.m_nextVertex;\n    clone.m_hasPrevVertex = this.m_hasPrevVertex;\n    clone.m_hasNextVertex = this.m_hasNextVertex;\n    return clone;\n  }\n\n  /**\n   * Get the number of child primitives.\n   */\n  getChildCount(): number {\n    // edge count = vertex count - 1\n    return this.m_count - 1;\n  }\n\n  // Get a child edge.\n  getChildEdge(edge: EdgeShape, childIndex: number): void {\n    _ASSERT && console.assert(0 <= childIndex && childIndex < this.m_count - 1);\n    edge.m_type = EdgeShape.TYPE;\n    edge.m_radius = this.m_radius;\n\n    edge.m_vertex1 = this.m_vertices[childIndex];\n    edge.m_vertex2 = this.m_vertices[childIndex + 1];\n\n    if (childIndex > 0) {\n      edge.m_vertex0 = this.m_vertices[childIndex - 1];\n      edge.m_hasVertex0 = true;\n    } else {\n      edge.m_vertex0 = this.m_prevVertex;\n      edge.m_hasVertex0 = this.m_hasPrevVertex;\n    }\n\n    if (childIndex < this.m_count - 2) {\n      edge.m_vertex3 = this.m_vertices[childIndex + 2];\n      edge.m_hasVertex3 = true;\n    } else {\n      edge.m_vertex3 = this.m_nextVertex;\n      edge.m_hasVertex3 = this.m_hasNextVertex;\n    }\n  }\n\n  getVertex(index: number): Vec2 {\n    _ASSERT && console.assert(0 <= index && index <= this.m_count);\n    if (index < this.m_count) {\n      return this.m_vertices[index];\n    } else {\n      return this.m_vertices[0];\n    }\n  }\n\n  isLoop(): boolean {\n    return this.m_isLoop;\n  }\n\n  /**\n   * Test a point for containment in this shape. This only works for convex\n   * shapes.\n   *\n   * This always return false.\n   *\n   * @param xf The shape world transform.\n   * @param p A point in world coordinates.\n   */\n  testPoint(xf: TransformValue, p: Vec2Value): false {\n    return false;\n  }\n\n  /**\n   * Cast a ray against a child shape.\n   *\n   * @param output The ray-cast results.\n   * @param input The ray-cast input parameters.\n   * @param xf The transform to be applied to the shape.\n   * @param childIndex The child shape index\n   */\n  rayCast(output: RayCastOutput, input: RayCastInput, xf: Transform, childIndex: number): boolean {\n    _ASSERT && console.assert(0 <= childIndex && childIndex < this.m_count);\n\n    const edgeShape = new EdgeShape(this.getVertex(childIndex), this.getVertex(childIndex + 1));\n    return edgeShape.rayCast(output, input, xf, 0);\n  }\n\n  /**\n   * Given a transform, compute the associated axis aligned bounding box for a\n   * child shape.\n   *\n   * @param aabb Returns the axis aligned box.\n   * @param xf The world transform of the shape.\n   * @param childIndex The child shape\n   */\n  computeAABB(aabb: AABBValue, xf: TransformValue, childIndex: number): void {\n    _ASSERT && console.assert(0 <= childIndex && childIndex < this.m_count);\n\n    matrix.transformVec2(v1, xf, this.getVertex(childIndex));\n    matrix.transformVec2(v2, xf, this.getVertex(childIndex + 1));\n\n    AABB.combinePoints(aabb, v1, v2);\n  }\n\n  /**\n   * Compute the mass properties of this shape using its dimensions and density.\n   * The inertia tensor is computed about the local origin.\n   *\n   * Chains have zero mass.\n   *\n   * @param massData Returns the mass data for this shape.\n   * @param density The density in kilograms per meter squared.\n   */\n  computeMass(massData: MassData, density?: number): void {\n    massData.mass = 0.0;\n    matrix.zeroVec2(massData.center)\n    massData.I = 0.0;\n  }\n\n  computeDistanceProxy(proxy: DistanceProxy, childIndex: number): void {\n    _ASSERT && console.assert(0 <= childIndex && childIndex < this.m_count);\n    proxy.m_vertices[0] = this.getVertex(childIndex);\n    proxy.m_vertices[1] = this.getVertex(childIndex + 1);\n    proxy.m_count = 2;\n    proxy.m_radius = this.m_radius;\n  }\n}\n\nexport const Chain = ChainShape;\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport * as matrix from '../../common/Matrix';\nimport type { MassData } from '../../dynamics/Body';\nimport { RayCastOutput, RayCastInput, AABBValue } from '../AABB';\nimport { DistanceProxy } from '../Distance';\nimport { math as Math } from '../../common/Math';\nimport { Transform, TransformValue } from '../../common/Transform';\nimport { Rot } from '../../common/Rot';\nimport { Vec2, Vec2Value } from '../../common/Vec2';\nimport { SettingsInternal as Settings } from '../../Settings';\nimport { Shape } from '../Shape';\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\nconst _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\nconst temp = matrix.vec2(0, 0);\nconst e = matrix.vec2(0, 0);\nconst e1 = matrix.vec2(0, 0);\nconst e2 = matrix.vec2(0, 0);\nconst center = matrix.vec2(0, 0);\nconst s = matrix.vec2(0, 0);\n\n/**\n * A convex polygon. It is assumed that the interior of the polygon is to the\n * left of each edge. Polygons have a maximum number of vertices equal to\n * Settings.maxPolygonVertices. In most cases you should not need many vertices\n * for a convex polygon. extends Shape\n */\nexport class PolygonShape extends Shape {\n  static TYPE = 'polygon' as const;\n  m_type: 'polygon';\n\n  m_centroid: Vec2;\n  m_vertices: Vec2[]; // [Settings.maxPolygonVertices]\n  m_normals: Vec2[]; // [Settings.maxPolygonVertices]\n  m_count: number;\n  m_radius: number;\n\n  // @ts-ignore\n  constructor(vertices?: Vec2Value[]) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof PolygonShape)) {\n      return new PolygonShape(vertices);\n    }\n\n    super();\n\n    this.m_type = PolygonShape.TYPE;\n    this.m_radius = Settings.polygonRadius;\n    this.m_centroid = Vec2.zero();\n    this.m_vertices = [];\n    this.m_normals = [];\n    this.m_count = 0;\n\n    if (vertices && vertices.length) {\n      this._set(vertices);\n    }\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n\n      vertices: this.m_vertices,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, fixture: any, restore: any): PolygonShape {\n    const vertices: Vec2[] = [];\n    if (data.vertices) {\n      for (let i = 0; i < data.vertices.length; i++) {\n        vertices.push(restore(Vec2, data.vertices[i]));\n      }\n    }\n\n    const shape = new PolygonShape(vertices);\n    return shape;\n  }\n\n  getType(): 'polygon' {\n    return this.m_type;\n  }\n\n  getRadius(): number {\n    return this.m_radius;\n  }\n\n  /**\n   * @internal\n   * @deprecated Shapes should be treated as immutable.\n   *\n   * clone the concrete shape.\n   */\n  _clone(): PolygonShape {\n    const clone = new PolygonShape();\n    clone.m_type = this.m_type;\n    clone.m_radius = this.m_radius;\n    clone.m_count = this.m_count;\n    clone.m_centroid.setVec2(this.m_centroid);\n    for (let i = 0; i < this.m_count; i++) {\n      clone.m_vertices.push(this.m_vertices[i].clone());\n    }\n    for (let i = 0; i < this.m_normals.length; i++) {\n      clone.m_normals.push(this.m_normals[i].clone());\n    }\n    return clone;\n  }\n\n  /**\n   * Get the number of child primitives.\n   */\n  getChildCount(): 1 {\n    return 1;\n  }\n\n  /** @internal */\n  _reset(): void {\n    this._set(this.m_vertices);\n  }\n\n  /**\n   * @internal\n   *\n   * Create a convex hull from the given array of local points. The count must be\n   * in the range [3, Settings.maxPolygonVertices].\n   *\n   * Warning: the points may be re-ordered, even if they form a convex polygon\n   * Warning: collinear points are handled but not removed. Collinear points may\n   * lead to poor stacking behavior.\n   */\n  _set(vertices: Vec2Value[]): void {\n    _ASSERT && console.assert(3 <= vertices.length && vertices.length <= Settings.maxPolygonVertices);\n    if (vertices.length < 3) {\n      this._setAsBox(1.0, 1.0);\n      return;\n    }\n\n    let n = Math.min(vertices.length, Settings.maxPolygonVertices);\n\n    // Perform welding and copy vertices into local buffer.\n    const ps: Vec2[] = []; // [Settings.maxPolygonVertices];\n    for (let i = 0; i < n; ++i) {\n      const v = vertices[i];\n\n      let unique = true;\n      for (let j = 0; j < ps.length; ++j) {\n        if (Vec2.distanceSquared(v, ps[j]) < 0.25 * Settings.linearSlopSquared) {\n          unique = false;\n          break;\n        }\n      }\n\n      if (unique) {\n        ps.push(Vec2.clone(v));\n      }\n    }\n\n    n = ps.length;\n    if (n < 3) {\n      // Polygon is degenerate.\n      _ASSERT && console.assert(false);\n      this._setAsBox(1.0, 1.0);\n      return;\n    }\n\n    // Create the convex hull using the Gift wrapping algorithm\n    // http://en.wikipedia.org/wiki/Gift_wrapping_algorithm\n\n    // Find the right most point on the hull (in case of multiple points bottom most is used)\n    let i0 = 0;\n    let x0 = ps[0].x;\n    for (let i = 1; i < n; ++i) {\n      const x = ps[i].x;\n      if (x > x0 || (x === x0 && ps[i].y < ps[i0].y)) {\n        i0 = i;\n        x0 = x;\n      }\n    }\n\n    const hull = [] as number[]; // [Settings.maxPolygonVertices];\n    let m = 0;\n    let ih = i0;\n\n    while (true) {\n      _ASSERT && console.assert(m < Settings.maxPolygonVertices);\n      hull[m] = ih;\n\n      let ie = 0;\n      for (let j = 1; j < n; ++j) {\n        if (ie === ih) {\n          ie = j;\n          continue;\n        }\n\n        const r = Vec2.sub(ps[ie], ps[hull[m]]);\n        const v = Vec2.sub(ps[j], ps[hull[m]]);\n        const c = Vec2.crossVec2Vec2(r, v);\n        // c < 0 means counter-clockwise wrapping, c > 0 means clockwise wrapping\n        if (c < 0.0) {\n          ie = j;\n        }\n\n        // Collinearity check\n        if (c === 0.0 && v.lengthSquared() > r.lengthSquared()) {\n          ie = j;\n        }\n      }\n\n      ++m;\n      ih = ie;\n\n      if (ie === i0) {\n        break;\n      }\n    }\n\n    if (m < 3) {\n      // Polygon is degenerate.\n      _ASSERT && console.assert(false);\n      this._setAsBox(1.0, 1.0);\n      return;\n    }\n\n    this.m_count = m;\n\n    // Copy vertices.\n    this.m_vertices = [];\n    for (let i = 0; i < m; ++i) {\n      this.m_vertices[i] = ps[hull[i]];\n    }\n\n    // Compute normals. Ensure the edges have non-zero length.\n    for (let i = 0; i < m; ++i) {\n      const i1 = i;\n      const i2 = i + 1 < m ? i + 1 : 0;\n      const edge = Vec2.sub(this.m_vertices[i2], this.m_vertices[i1]);\n      _ASSERT && console.assert(edge.lengthSquared() > Math.EPSILON * Math.EPSILON);\n      this.m_normals[i] = Vec2.crossVec2Num(edge, 1.0);\n      this.m_normals[i].normalize();\n    }\n\n    // Compute the polygon centroid.\n    this.m_centroid = ComputeCentroid(this.m_vertices, m);\n  }\n\n  /** @internal */\n  _setAsBox(hx: number, hy: number, center?: Vec2Value, angle?: number): void {\n    // start with right-bottom, counter-clockwise, as in Gift wrapping algorithm in PolygonShape._set()\n    this.m_vertices[0] = Vec2.neo(hx, -hy);\n    this.m_vertices[1] = Vec2.neo(hx, hy);\n    this.m_vertices[2] = Vec2.neo(-hx, hy);\n    this.m_vertices[3] = Vec2.neo(-hx, -hy);\n\n    this.m_normals[0] = Vec2.neo(1.0, 0.0);\n    this.m_normals[1] = Vec2.neo(0.0, 1.0);\n    this.m_normals[2] = Vec2.neo(-1.0, 0.0);\n    this.m_normals[3] = Vec2.neo(0.0, -1.0);\n\n    this.m_count = 4;\n\n    if (center && Vec2.isValid(center)) {\n      angle = angle || 0;\n\n      matrix.copyVec2(this.m_centroid, center);\n\n      const xf = Transform.identity();\n      xf.p.setVec2(center);\n      xf.q.setAngle(angle);\n\n      // Transform vertices and normals.\n      for (let i = 0; i < this.m_count; ++i) {\n        this.m_vertices[i] = Transform.mulVec2(xf, this.m_vertices[i]);\n        this.m_normals[i] = Rot.mulVec2(xf.q, this.m_normals[i]);\n      }\n    }\n  }\n\n  /**\n   * Test a point for containment in this shape. This only works for convex\n   * shapes.\n   *\n   * @param xf The shape world transform.\n   * @param p A point in world coordinates.\n   */\n  testPoint(xf: TransformValue, p: Vec2): boolean {\n    const pLocal = matrix.invTransformVec2(temp, xf, p);\n\n    for (let i = 0; i < this.m_count; ++i) {\n      const dot = matrix.dotVec2(this.m_normals[i], pLocal) - matrix.dotVec2(this.m_normals[i], this.m_vertices[i]);\n      if (dot > 0.0) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Cast a ray against a child shape.\n   *\n   * @param output The ray-cast results.\n   * @param input The ray-cast input parameters.\n   * @param xf The transform to be applied to the shape.\n   * @param childIndex The child shape index\n   */\n  rayCast(output: RayCastOutput, input: RayCastInput, xf: Transform, childIndex: number): boolean {\n\n    // Put the ray into the polygon's frame of reference.\n    const p1 = Rot.mulTVec2(xf.q, Vec2.sub(input.p1, xf.p));\n    const p2 = Rot.mulTVec2(xf.q, Vec2.sub(input.p2, xf.p));\n    const d = Vec2.sub(p2, p1);\n\n    let lower = 0.0;\n    let upper = input.maxFraction;\n\n    let index = -1;\n\n    for (let i = 0; i < this.m_count; ++i) {\n      // p = p1 + a * d\n      // dot(normal, p - v) = 0\n      // dot(normal, p1 - v) + a * dot(normal, d) = 0\n      const numerator = Vec2.dot(this.m_normals[i], Vec2.sub(this.m_vertices[i], p1));\n      const denominator = Vec2.dot(this.m_normals[i], d);\n\n      if (denominator == 0.0) {\n        if (numerator < 0.0) {\n          return false;\n        }\n      } else {\n        // Note: we want this predicate without division:\n        // lower < numerator / denominator, where denominator < 0\n        // Since denominator < 0, we have to flip the inequality:\n        // lower < numerator / denominator <==> denominator * lower > numerator.\n        if (denominator < 0.0 && numerator < lower * denominator) {\n          // Increase lower.\n          // The segment enters this half-space.\n          lower = numerator / denominator;\n          index = i;\n        } else if (denominator > 0.0 && numerator < upper * denominator) {\n          // Decrease upper.\n          // The segment exits this half-space.\n          upper = numerator / denominator;\n        }\n      }\n\n      // The use of epsilon here causes the assert on lower to trip\n      // in some cases. Apparently the use of epsilon was to make edge\n      // shapes work, but now those are handled separately.\n      // if (upper < lower - matrix.EPSILON)\n      if (upper < lower) {\n        return false;\n      }\n    }\n\n    _ASSERT && console.assert(0.0 <= lower && lower <= input.maxFraction);\n\n    if (index >= 0) {\n      output.fraction = lower;\n      output.normal = Rot.mulVec2(xf.q, this.m_normals[index]);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Given a transform, compute the associated axis aligned bounding box for a\n   * child shape.\n   *\n   * @param aabb Returns the axis aligned box.\n   * @param xf The world transform of the shape.\n   * @param childIndex The child shape\n   */\n  computeAABB(aabb: AABBValue, xf: TransformValue, childIndex: number): void {\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n    for (let i = 0; i < this.m_count; ++i) {\n      const v = matrix.transformVec2(temp, xf, this.m_vertices[i]);\n      minX = Math.min(minX, v.x);\n      maxX = Math.max(maxX, v.x);\n      minY = Math.min(minY, v.y);\n      maxY = Math.max(maxY, v.y);\n    }\n\n    matrix.setVec2(aabb.lowerBound, minX - this.m_radius, minY - this.m_radius);\n    matrix.setVec2(aabb.upperBound, maxX + this.m_radius, maxY + this.m_radius);\n  }\n\n  /**\n   * Compute the mass properties of this shape using its dimensions and density.\n   * The inertia tensor is computed about the local origin.\n   *\n   * @param massData Returns the mass data for this shape.\n   * @param density The density in kilograms per meter squared.\n   */\n  computeMass(massData: MassData, density: number): void {\n    // Polygon mass, centroid, and inertia.\n    // Let rho be the polygon density in mass per unit area.\n    // Then:\n    // mass = rho * int(dA)\n    // centroid.x = (1/mass) * rho * int(x * dA)\n    // centroid.y = (1/mass) * rho * int(y * dA)\n    // I = rho * int((x*x + y*y) * dA)\n    //\n    // We can compute these integrals by summing all the integrals\n    // for each triangle of the polygon. To evaluate the integral\n    // for a single triangle, we make a change of variables to\n    // the (u,v) coordinates of the triangle:\n    // x = x0 + e1x * u + e2x * v\n    // y = y0 + e1y * u + e2y * v\n    // where 0 <= u && 0 <= v && u + v <= 1.\n    //\n    // We integrate u from [0,1-v] and then v from [0,1].\n    // We also need to use the Jacobian of the transformation:\n    // D = cross(e1, e2)\n    //\n    // Simplification: triangle centroid = (1/3) * (p1 + p2 + p3)\n    //\n    // The rest of the derivation is handled by computer algebra.\n\n    _ASSERT && console.assert(this.m_count >= 3);\n\n    matrix.zeroVec2(center);\n    let area = 0.0;\n    let I = 0.0;\n\n    // s is the reference point for forming triangles.\n    // It's location doesn't change the result (except for rounding error).\n    matrix.zeroVec2(s);\n\n    // This code would put the reference point inside the polygon.\n    for (let i = 0; i < this.m_count; ++i) {\n      matrix.addVec2(s, this.m_vertices[i]);\n    }\n    matrix.setMulVec2(s, 1.0 / this.m_count, s);\n\n    const k_inv3 = 1.0 / 3.0;\n\n    for (let i = 0; i < this.m_count; ++i) {\n      // Triangle vertices.\n      matrix.diffVec2(e1, this.m_vertices[i], s);\n      if ( i + 1 < this.m_count) {\n        matrix.diffVec2(e2, this.m_vertices[i + 1], s);\n      } else {\n        matrix.diffVec2(e2, this.m_vertices[0], s);\n      }\n\n      const D = matrix.crossVec2Vec2(e1, e2);\n\n      const triangleArea = 0.5 * D;\n      area += triangleArea;\n\n      // Area weighted centroid\n      matrix.combineVec2(center, 1, center, triangleArea * k_inv3, e1);\n      matrix.combineVec2(center, 1, center, triangleArea * k_inv3, e2);\n\n      const ex1 = e1.x;\n      const ey1 = e1.y;\n      const ex2 = e2.x;\n      const ey2 = e2.y;\n\n      const intx2 = ex1 * ex1 + ex2 * ex1 + ex2 * ex2;\n      const inty2 = ey1 * ey1 + ey2 * ey1 + ey2 * ey2;\n\n      I += (0.25 * k_inv3 * D) * (intx2 + inty2);\n    }\n\n    // Total mass\n    massData.mass = density * area;\n\n    // Center of mass\n    _ASSERT && console.assert(area > Math.EPSILON);\n    matrix.setMulVec2(center, 1.0 / area, center);\n    matrix.sumVec2(massData.center, center, s);\n\n    // Inertia tensor relative to the local origin (point s).\n    massData.I = density * I;\n\n    // Shift to center of mass then to original body origin.\n    massData.I += massData.mass * (matrix.dotVec2(massData.center, massData.center) - matrix.dotVec2(center, center));\n  }\n\n  /**\n   * Validate convexity. This is a very time consuming operation.\n   * @returns true if valid\n   */\n  validate(): boolean {\n    for (let i = 0; i < this.m_count; ++i) {\n      const i1 = i;\n      const i2 = i < this.m_count - 1 ? i1 + 1 : 0;\n      const p = this.m_vertices[i1];\n      matrix.diffVec2(e, this.m_vertices[i2], p);\n\n      for (let j = 0; j < this.m_count; ++j) {\n        if (j == i1 || j == i2) {\n          continue;\n        }\n\n        const c = matrix.crossVec2Vec2(e, matrix.diffVec2(temp, this.m_vertices[j], p));\n        if (c < 0.0) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  computeDistanceProxy(proxy: DistanceProxy): void {\n    for (let i = 0; i < this.m_count; ++i) {\n      proxy.m_vertices[i] = this.m_vertices[i];\n    }\n    proxy.m_vertices.length = this.m_count;\n    proxy.m_count = this.m_count;\n    proxy.m_radius = this.m_radius;\n  }\n}\n\nfunction ComputeCentroid(vs: Vec2[], count: number): Vec2 {\n  _ASSERT && console.assert(count >= 3);\n\n  const c = Vec2.zero();\n  let area = 0.0;\n\n  // pRef is the reference point for forming triangles.\n  // It's location doesn't change the result (except for rounding error).\n  const pRef = Vec2.zero();\n  if (false) {\n    // This code would put the reference point inside the polygon.\n    for (let i = 0; i < count; ++i) {\n      pRef.add(vs[i]);\n    }\n    pRef.mul(1.0 / count);\n  }\n\n  const inv3 = 1.0 / 3.0;\n\n  for (let i = 0; i < count; ++i) {\n    // Triangle vertices.\n    const p1 = pRef;\n    const p2 = vs[i];\n    const p3 = i + 1 < count ? vs[i + 1] : vs[0];\n\n    const e1 = Vec2.sub(p2, p1);\n    const e2 = Vec2.sub(p3, p1);\n\n    const D = Vec2.crossVec2Vec2(e1, e2);\n\n    const triangleArea = 0.5 * D;\n    area += triangleArea;\n\n    // Area weighted centroid\n    c.addMul(triangleArea * inv3, p1);\n    c.addMul(triangleArea * inv3, p2);\n    c.addMul(triangleArea * inv3, p3);\n  }\n\n  // Centroid\n  _ASSERT && console.assert(area > Math.EPSILON);\n  c.mul(1.0 / area);\n  return c;\n}\n\nexport const Polygon = PolygonShape;\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport type { Vec2Value } from '../../common/Vec2';\nimport { PolygonShape } from './PolygonShape';\n\n\nconst _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\n/**\n * A rectangle polygon which extend PolygonShape.\n */\nexport class BoxShape extends PolygonShape {\n  static TYPE = 'polygon' as const;\n\n  constructor(hx: number, hy: number, center?: Vec2Value, angle?: number) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof BoxShape)) {\n      return new BoxShape(hx, hy, center, angle);\n    }\n\n    super();\n\n    this._setAsBox(hx, hy, center, angle);\n  }\n}\n\nexport const Box = BoxShape;\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport * as matrix from '../../common/Matrix';\nimport { math as Math } from '../../common/Math';\nimport { Rot } from '../../common/Rot';\nimport { Vec2, Vec2Value } from '../../common/Vec2';\nimport { Shape } from '../Shape';\nimport { AABBValue, RayCastInput, RayCastOutput } from '../AABB';\nimport { Transform, TransformValue } from '../../common/Transform';\nimport { MassData } from '../../dynamics/Body';\nimport { DistanceProxy } from '../Distance';\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\nconst _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\nconst temp = matrix.vec2(0, 0);\n\nexport class CircleShape extends Shape {\n  static TYPE = 'circle' as const;\n  m_type: 'circle';\n\n  m_p: Vec2;\n  m_radius: number;\n\n  constructor(position: Vec2Value, radius?: number);\n  constructor(radius?: number);\n  // tslint:disable-next-line:typedef\n  constructor(a, b?) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof CircleShape)) {\n      return new CircleShape(a, b);\n    }\n\n    super();\n\n    this.m_type = CircleShape.TYPE;\n    this.m_p = Vec2.zero();\n    this.m_radius = 1;\n\n    if (typeof a === 'object' && Vec2.isValid(a)) {\n      this.m_p.setVec2(a);\n\n      if (typeof b === 'number') {\n        this.m_radius = b;\n      }\n\n    } else if (typeof a === 'number') {\n      this.m_radius = a;\n    }\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n\n      p: this.m_p,\n      radius: this.m_radius,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any): CircleShape {\n    return new CircleShape(data.p, data.radius);\n  }\n\n  /** @internal */\n  _reset(): void {\n    // noop\n  }\n\n  getType(): 'circle' {\n    return this.m_type;\n  }\n\n  getRadius(): number {\n    return this.m_radius;\n  }\n\n  getCenter(): Vec2 {\n    return this.m_p;\n  }\n\n  /**\n   * @internal\n   * @deprecated Shapes should be treated as immutable.\n   *\n   * clone the concrete shape.\n   */\n  _clone(): CircleShape {\n    const clone = new CircleShape();\n    clone.m_type = this.m_type;\n    clone.m_radius = this.m_radius;\n    clone.m_p = this.m_p.clone();\n    return clone;\n  }\n\n  /**\n   * Get the number of child primitives.\n   */\n  getChildCount(): 1 {\n    return 1;\n  }\n\n  /**\n   * Test a point for containment in this shape. This only works for convex\n   * shapes.\n   *\n   * @param xf The shape world transform.\n   * @param p A point in world coordinates.\n   */\n  testPoint(xf: TransformValue, p: Vec2Value): boolean {\n    const center = matrix.transformVec2(temp, xf, this.m_p)\n    return matrix.distSqrVec2(p, center) <= this.m_radius * this.m_radius;\n  }\n\n  /**\n   * Cast a ray against a child shape.\n   *\n   * @param output The ray-cast results.\n   * @param input The ray-cast input parameters.\n   * @param xf The transform to be applied to the shape.\n   * @param childIndex The child shape index\n   */\n  rayCast(output: RayCastOutput, input: RayCastInput, xf: Transform, childIndex: number): boolean {\n    // Collision Detection in Interactive 3D Environments by Gino van den Bergen\n    // From Section 3.1.2\n    // x = s + a * r\n    // norm(x) = radius\n\n    const position = Vec2.add(xf.p, Rot.mulVec2(xf.q, this.m_p));\n    const s = Vec2.sub(input.p1, position);\n    const b = Vec2.dot(s, s) - this.m_radius * this.m_radius;\n\n    // Solve quadratic equation.\n    const r = Vec2.sub(input.p2, input.p1);\n    const c = Vec2.dot(s, r);\n    const rr = Vec2.dot(r, r);\n    const sigma = c * c - rr * b;\n\n    // Check for negative discriminant and short segment.\n    if (sigma < 0.0 || rr < Math.EPSILON) {\n      return false;\n    }\n\n    // Find the point of intersection of the line with the circle.\n    let a = -(c + Math.sqrt(sigma));\n\n    // Is the intersection point on the segment?\n    if (0.0 <= a && a <= input.maxFraction * rr) {\n      a /= rr;\n      output.fraction = a;\n      output.normal = Vec2.add(s, Vec2.mulNumVec2(a, r));\n      output.normal.normalize();\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Given a transform, compute the associated axis aligned bounding box for a\n   * child shape.\n   *\n   * @param aabb Returns the axis aligned box.\n   * @param xf The world transform of the shape.\n   * @param childIndex The child shape\n   */\n  computeAABB(aabb: AABBValue, xf: TransformValue, childIndex: number): void {\n    const p = matrix.transformVec2(temp, xf, this.m_p);\n\n    matrix.setVec2(aabb.lowerBound, p.x - this.m_radius, p.y - this.m_radius);\n    matrix.setVec2(aabb.upperBound, p.x + this.m_radius, p.y + this.m_radius);\n  }\n\n  /**\n   * Compute the mass properties of this shape using its dimensions and density.\n   * The inertia tensor is computed about the local origin.\n   *\n   * @param massData Returns the mass data for this shape.\n   * @param density The density in kilograms per meter squared.\n   */\n  computeMass(massData: MassData, density: number): void {\n    massData.mass = density * Math.PI * this.m_radius * this.m_radius;\n    matrix.copyVec2(massData.center, this.m_p);\n    // inertia about the local origin\n    massData.I = massData.mass * (0.5 * this.m_radius * this.m_radius + matrix.lengthSqrVec2(this.m_p));\n  }\n\n  computeDistanceProxy(proxy: DistanceProxy): void {\n    proxy.m_vertices[0] = this.m_p;\n    proxy.m_vertices.length = 1;\n    proxy.m_count = 1;\n    proxy.m_radius = this.m_radius;\n  }\n}\n\nexport const Circle = CircleShape;\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { options } from '../../util/options';\nimport { SettingsInternal as Settings } from '../../Settings';\nimport { math as Math } from '../../common/Math';\nimport { Vec2 } from '../../common/Vec2';\nimport { Rot } from '../../common/Rot';\nimport { Joint, JointOpt, JointDef } from '../Joint';\nimport { Body } from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\nconst _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\n/**\n * Distance joint definition. This requires defining an anchor point on both\n * bodies and the non-zero length of the distance joint. The definition uses\n * local anchor points so that the initial configuration can violate the\n * constraint slightly. This helps when saving and loading a game. Warning: Do\n * not use a zero or short length.\n */\nexport interface DistanceJointOpt extends JointOpt {\n  /**\n   * The mass-spring-damper frequency in Hertz. A value of 0 disables softness.\n   */\n  frequencyHz?: number;\n  /**\n   * The damping ratio. 0 = no damping, 1 = critical damping.\n   */\n  dampingRatio?: number;\n  /**\n   * Distance length.\n   */\n  length?: number;\n}\n/**\n * Distance joint definition. This requires defining an anchor point on both\n * bodies and the non-zero length of the distance joint. The definition uses\n * local anchor points so that the initial configuration can violate the\n * constraint slightly. This helps when saving and loading a game. Warning: Do\n * not use a zero or short length.\n */\nexport interface DistanceJointDef extends JointDef, DistanceJointOpt {\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  localAnchorA: Vec2;\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  localAnchorB: Vec2;\n}\n\nconst DEFAULTS = {\n  frequencyHz : 0.0,\n  dampingRatio : 0.0\n};\n\n/**\n * A distance joint constrains two points on two bodies to remain at a fixed\n * distance from each other. You can view this as a massless, rigid rod.\n *\n * @param anchorA Anchor A in global coordination.\n * @param anchorB Anchor B in global coordination.\n */\nexport class DistanceJoint extends Joint {\n  static TYPE = 'distance-joint' as const;\n\n  // Solver shared\n  /** @internal */ m_localAnchorA: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n  /** @internal */ m_length: number;\n  /** @internal */ m_frequencyHz: number;\n  /** @internal */ m_dampingRatio: number;\n  /** @internal */ m_impulse: number;\n  /** @internal */ m_gamma: number;\n  /** @internal */ m_bias: number;\n\n  // Solver temp\n  /** @internal */ m_u: Vec2;\n  /** @internal */ m_rA: Vec2;\n  /** @internal */ m_rB: Vec2;\n  /** @internal */ m_localCenterA: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_invMassA: number;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIA: number;\n  /** @internal */ m_invIB: number;\n  /** @internal */ m_mass: number;\n\n  constructor(def: DistanceJointDef);\n  constructor(def: DistanceJointOpt, bodyA: Body, bodyB: Body, anchorA: Vec2, anchorB: Vec2);\n  constructor(def: DistanceJointDef, bodyA?: Body, bodyB?: Body, anchorA?: Vec2, anchorB?: Vec2) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof DistanceJoint)) {\n      return new DistanceJoint(def, bodyA, bodyB, anchorA, anchorB);\n    }\n\n    // order of constructor arguments is changed in v0.2\n    if (bodyB && anchorA && ('m_type' in anchorA) && ('x' in bodyB) && ('y' in bodyB)) {\n      const temp = bodyB;\n      bodyB = anchorA as any as Body;\n      anchorA = temp as any as Vec2;\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = DistanceJoint.TYPE;\n\n    // Solver shared\n    this.m_localAnchorA = Vec2.clone(anchorA ? bodyA.getLocalPoint(anchorA) : def.localAnchorA || Vec2.zero());\n    this.m_localAnchorB = Vec2.clone(anchorB ? bodyB.getLocalPoint(anchorB) : def.localAnchorB || Vec2.zero());\n    this.m_length = Math.isFinite(def.length) ? def.length :\n      Vec2.distance(bodyA.getWorldPoint(this.m_localAnchorA), bodyB.getWorldPoint(this.m_localAnchorB));\n    this.m_frequencyHz = def.frequencyHz;\n    this.m_dampingRatio = def.dampingRatio;\n    this.m_impulse = 0.0;\n    this.m_gamma = 0.0;\n    this.m_bias = 0.0;\n\n    // 1-D constrained system\n    // m (v2 - v1) = lambda\n    // v2 + (beta/h) * x1 + gamma * lambda = 0, gamma has units of inverse mass.\n    // x2 = x1 + h * v2\n\n    // 1-D mass-damper-spring system\n    // m (v2 - v1) + h * d * v2 + h * k *\n\n    // C = norm(p2 - p1) - L\n    // u = (p2 - p1) / norm(p2 - p1)\n    // Cdot = dot(u, v2 + cross(w2, r2) - v1 - cross(w1, r1))\n    // J = [-u -cross(r1, u) u cross(r2, u)]\n    // K = J * invM * JT\n    // = invMass1 + invI1 * cross(r1, u)^2 + invMass2 + invI2 * cross(r2, u)^2\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      frequencyHz: this.m_frequencyHz,\n      dampingRatio: this.m_dampingRatio,\n\n      localAnchorA: this.m_localAnchorA,\n      localAnchorB: this.m_localAnchorB,\n      length: this.m_length,\n\n      impulse: this.m_impulse,\n      gamma: this.m_gamma,\n      bias: this.m_bias,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): DistanceJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    const joint = new DistanceJoint(data);\n    return joint;\n  }\n\n  /** @internal */\n  _setAnchors(def: {\n    anchorA?: Vec2,\n    localAnchorA?: Vec2,\n    anchorB?: Vec2,\n    localAnchorB?: Vec2,\n    length?: number,\n  }): void {\n    if (def.anchorA) {\n      this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n    } else if (def.localAnchorA) {\n      this.m_localAnchorA.setVec2(def.localAnchorA);\n    }\n\n    if (def.anchorB) {\n      this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n    } else if (def.localAnchorB) {\n      this.m_localAnchorB.setVec2(def.localAnchorB);\n    }\n\n    if (def.length > 0) {\n      this.m_length = +def.length;\n    } else if (def.length < 0) { // don't change length\n    } else if (def.anchorA || def.anchorA || def.anchorA || def.anchorA) {\n      this.m_length = Vec2.distance(\n          this.m_bodyA.getWorldPoint(this.m_localAnchorA),\n          this.m_bodyB.getWorldPoint(this.m_localAnchorB)\n      );\n    }\n  }\n\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  getLocalAnchorA(): Vec2 {\n    return this.m_localAnchorA;\n  }\n\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  getLocalAnchorB(): Vec2 {\n    return this.m_localAnchorB;\n  }\n\n  /**\n   * Set the natural length. Manipulating the length can lead to non-physical\n   * behavior when the frequency is zero.\n   */\n  setLength(length: number): void {\n    this.m_length = length;\n  }\n\n  /**\n   * Get the natural length.\n   */\n  getLength(): number {\n    return this.m_length;\n  }\n\n  setFrequency(hz: number): void {\n    this.m_frequencyHz = hz;\n  }\n\n  getFrequency(): number {\n    return this.m_frequencyHz;\n  }\n\n  setDampingRatio(ratio: number): void {\n    this.m_dampingRatio = ratio;\n  }\n\n  getDampingRatio(): number {\n    return this.m_dampingRatio;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.mulNumVec2(this.m_impulse, this.m_u).mul(inv_dt);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return 0.0;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassA = this.m_bodyA.m_invMass;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIA = this.m_bodyA.m_invI;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const cA = this.m_bodyA.c_position.c;\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const cB = this.m_bodyB.c_position.c;\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n    this.m_u = Vec2.sub(Vec2.add(cB, this.m_rB), Vec2.add(cA, this.m_rA));\n\n    // Handle singularity.\n    const length = this.m_u.length();\n    if (length > Settings.linearSlop) {\n      this.m_u.mul(1.0 / length);\n    } else {\n      this.m_u.setNum(0.0, 0.0);\n    }\n\n    const crAu = Vec2.crossVec2Vec2(this.m_rA, this.m_u);\n    const crBu = Vec2.crossVec2Vec2(this.m_rB, this.m_u);\n    let invMass = this.m_invMassA + this.m_invIA * crAu * crAu + this.m_invMassB\n        + this.m_invIB * crBu * crBu;\n\n    // Compute the effective mass matrix.\n    this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;\n\n    if (this.m_frequencyHz > 0.0) {\n      const C = length - this.m_length;\n\n      // Frequency\n      const omega = 2.0 * Math.PI * this.m_frequencyHz;\n\n      // Damping coefficient\n      const d = 2.0 * this.m_mass * this.m_dampingRatio * omega;\n\n      // Spring stiffness\n      const k = this.m_mass * omega * omega;\n\n      // magic formulas\n      const h = step.dt;\n      this.m_gamma = h * (d + h * k);\n      this.m_gamma = this.m_gamma != 0.0 ? 1.0 / this.m_gamma : 0.0;\n      this.m_bias = C * h * k * this.m_gamma;\n\n      invMass += this.m_gamma;\n      this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;\n    } else {\n      this.m_gamma = 0.0;\n      this.m_bias = 0.0;\n    }\n\n    if (step.warmStarting) {\n      // Scale the impulse to support a variable time step.\n      this.m_impulse *= step.dtRatio;\n\n      const P = Vec2.mulNumVec2(this.m_impulse, this.m_u);\n\n      vA.subMul(this.m_invMassA, P);\n      wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P);\n\n      vB.addMul(this.m_invMassB, P);\n      wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P);\n\n    } else {\n      this.m_impulse = 0.0;\n    }\n\n    this.m_bodyA.c_velocity.v.setVec2(vA);\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v.setVec2(vB);\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    // Cdot = dot(u, v + cross(w, r))\n    const vpA = Vec2.add(vA, Vec2.crossNumVec2(wA, this.m_rA));\n    const vpB = Vec2.add(vB, Vec2.crossNumVec2(wB, this.m_rB));\n    const Cdot = Vec2.dot(this.m_u, vpB) - Vec2.dot(this.m_u, vpA);\n\n    const impulse = -this.m_mass\n        * (Cdot + this.m_bias + this.m_gamma * this.m_impulse);\n    this.m_impulse += impulse;\n\n    const P = Vec2.mulNumVec2(impulse, this.m_u);\n    vA.subMul(this.m_invMassA, P);\n    wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P);\n    vB.addMul(this.m_invMassB, P);\n    wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P);\n\n    this.m_bodyA.c_velocity.v.setVec2(vA);\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v.setVec2(vB);\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    if (this.m_frequencyHz > 0.0) {\n      // There is no position correction for soft distance constraints.\n      return true;\n    }\n\n    const cA = this.m_bodyA.c_position.c;\n    let aA = this.m_bodyA.c_position.a;\n    const cB = this.m_bodyB.c_position.c;\n    let aB = this.m_bodyB.c_position.a;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    const rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);\n    const rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);\n    const u = Vec2.sub(Vec2.add(cB, rB), Vec2.add(cA, rA));\n\n    const length = u.normalize();\n    let C = length - this.m_length;\n    C = Math\n        .clamp(C, -Settings.maxLinearCorrection, Settings.maxLinearCorrection);\n\n    const impulse = -this.m_mass * C;\n    const P = Vec2.mulNumVec2(impulse, u);\n\n    cA.subMul(this.m_invMassA, P);\n    aA -= this.m_invIA * Vec2.crossVec2Vec2(rA, P);\n    cB.addMul(this.m_invMassB, P);\n    aB += this.m_invIB * Vec2.crossVec2Vec2(rB, P);\n\n    this.m_bodyA.c_position.c.setVec2(cA);\n    this.m_bodyA.c_position.a = aA;\n    this.m_bodyB.c_position.c.setVec2(cB);\n    this.m_bodyB.c_position.a = aB;\n\n    return Math.abs(C) < Settings.linearSlop;\n  }\n\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { options } from '../../util/options';\nimport { math as Math } from '../../common/Math';\nimport { Vec2 } from '../../common/Vec2';\nimport { Mat22 } from '../../common/Mat22';\nimport { Rot } from '../../common/Rot';\nimport { Joint, JointOpt, JointDef } from '../Joint';\nimport { Body } from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\nconst _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\n/**\n * Friction joint definition.\n */\nexport interface FrictionJointOpt extends JointOpt {\n  /**\n   * The maximum friction force in N.\n   */\n  maxForce?: number;\n  /**\n   * The maximum friction torque in N-m.\n   */\n  maxTorque?: number;\n}\n/**\n * Friction joint definition.\n */\nexport interface FrictionJointDef extends JointDef, FrictionJointOpt {\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  localAnchorA: Vec2;\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  localAnchorB: Vec2;\n}\n\nconst DEFAULTS = {\n  maxForce : 0.0,\n  maxTorque : 0.0,\n};\n\n/**\n * Friction joint. This is used for top-down friction. It provides 2D\n * translational friction and angular friction.\n *\n * @param anchor Anchor in global coordination.\n */\nexport class FrictionJoint extends Joint {\n  static TYPE = 'friction-joint' as const;\n\n  /** @internal */ m_type: 'friction-joint';\n\n  /** @internal */ m_localAnchorA: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n\n  // Solver shared\n  /** @internal */ m_linearImpulse: Vec2;\n  /** @internal */ m_angularImpulse: number;\n  /** @internal */ m_maxForce: number;\n  /** @internal */ m_maxTorque: number;\n\n  // Solver temp\n  /** @internal */ m_rA: Vec2;\n  /** @internal */ m_rB: Vec2;\n  /** @internal */ m_localCenterA: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_invMassA: number;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIA: number;\n  /** @internal */ m_invIB: number;\n  /** @internal */ m_linearMass: Mat22;\n  /** @internal */ m_angularMass: number;\n\n  constructor(def: FrictionJointDef);\n  constructor(def: FrictionJointOpt, bodyA: Body, bodyB: Body, anchor: Vec2);\n  constructor(def: FrictionJointDef, bodyA?: Body, bodyB?: Body, anchor?: Vec2) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof FrictionJoint)) {\n      return new FrictionJoint(def, bodyA, bodyB, anchor);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = FrictionJoint.TYPE;\n\n    this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n    this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n\n    // Solver shared\n    this.m_linearImpulse = Vec2.zero();\n    this.m_angularImpulse = 0.0;\n    this.m_maxForce = def.maxForce;\n    this.m_maxTorque = def.maxTorque;\n\n    // Point-to-point constraint\n    // Cdot = v2 - v1\n    // = v2 + cross(w2, r2) - v1 - cross(w1, r1)\n    // J = [-I -r1_skew I r2_skew ]\n    // Identity used:\n    // w k % (rx i + ry j) = w * (-ry i + rx j)\n\n    // Angle constraint\n    // Cdot = w2 - w1\n    // J = [0 0 -1 0 0 1]\n    // K = invI1 + invI2\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      maxForce: this.m_maxForce,\n      maxTorque: this.m_maxTorque,\n\n      localAnchorA: this.m_localAnchorA,\n      localAnchorB: this.m_localAnchorB,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): FrictionJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    const joint = new FrictionJoint(data);\n    return joint;\n  }\n\n  /** @internal */\n  _setAnchors(def: {\n    anchorA?: Vec2,\n    localAnchorA?: Vec2,\n    anchorB?: Vec2,\n    localAnchorB?: Vec2,\n  }): void {\n    if (def.anchorA) {\n      this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n    } else if (def.localAnchorA) {\n      this.m_localAnchorA.setVec2(def.localAnchorA);\n    }\n\n    if (def.anchorB) {\n      this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n    } else if (def.localAnchorB) {\n      this.m_localAnchorB.setVec2(def.localAnchorB);\n    }\n  }\n\n\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  getLocalAnchorA(): Vec2 {\n    return this.m_localAnchorA;\n  }\n\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  getLocalAnchorB(): Vec2 {\n    return this.m_localAnchorB;\n  }\n\n  /**\n   * Set the maximum friction force in N.\n   */\n  setMaxForce(force: number): void {\n    _ASSERT && console.assert(Math.isFinite(force) && force >= 0.0);\n    this.m_maxForce = force;\n  }\n\n  /**\n   * Get the maximum friction force in N.\n   */\n  getMaxForce(): number {\n    return this.m_maxForce;\n  }\n\n  /**\n   * Set the maximum friction torque in N*m.\n   */\n  setMaxTorque(torque: number): void {\n    _ASSERT && console.assert(Math.isFinite(torque) && torque >= 0.0);\n    this.m_maxTorque = torque;\n  }\n\n  /**\n   * Get the maximum friction torque in N*m.\n   */\n  getMaxTorque(): number {\n    return this.m_maxTorque;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.mulNumVec2(inv_dt, this.m_linearImpulse);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return inv_dt * this.m_angularImpulse;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassA = this.m_bodyA.m_invMass;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIA = this.m_bodyA.m_invI;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    // Compute the effective mass matrix.\n    this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n\n    // J = [-I -r1_skew I r2_skew]\n    // [ 0 -1 0 1]\n    // r_skew = [-ry; rx]\n\n    // Matlab\n    // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]\n    // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]\n    // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    const K = new Mat22();\n    K.ex.x = mA + mB + iA * this.m_rA.y * this.m_rA.y + iB * this.m_rB.y\n        * this.m_rB.y;\n    K.ex.y = -iA * this.m_rA.x * this.m_rA.y - iB * this.m_rB.x * this.m_rB.y;\n    K.ey.x = K.ex.y;\n    K.ey.y = mA + mB + iA * this.m_rA.x * this.m_rA.x + iB * this.m_rB.x\n        * this.m_rB.x;\n\n    this.m_linearMass = K.getInverse();\n\n    this.m_angularMass = iA + iB;\n    if (this.m_angularMass > 0.0) {\n      this.m_angularMass = 1.0 / this.m_angularMass;\n    }\n\n    if (step.warmStarting) {\n      // Scale impulses to support a variable time step.\n      this.m_linearImpulse.mul(step.dtRatio);\n      this.m_angularImpulse *= step.dtRatio;\n\n      const P = Vec2.neo(this.m_linearImpulse.x, this.m_linearImpulse.y);\n\n      vA.subMul(mA, P);\n      wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + this.m_angularImpulse);\n\n      vB.addMul(mB, P);\n      wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + this.m_angularImpulse);\n\n    } else {\n      this.m_linearImpulse.setZero();\n      this.m_angularImpulse = 0.0;\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    const h = step.dt; // float\n\n    // Solve angular friction\n    {\n      const Cdot = wB - wA; // float\n      let impulse = -this.m_angularMass * Cdot; // float\n\n      const oldImpulse = this.m_angularImpulse; // float\n      const maxImpulse = h * this.m_maxTorque; // float\n      this.m_angularImpulse = Math.clamp(this.m_angularImpulse + impulse,\n          -maxImpulse, maxImpulse);\n      impulse = this.m_angularImpulse - oldImpulse;\n\n      wA -= iA * impulse;\n      wB += iB * impulse;\n    }\n\n    // Solve linear friction\n    {\n      const Cdot = Vec2.sub(Vec2.add(vB, Vec2.crossNumVec2(wB, this.m_rB)), Vec2.add(vA,\n          Vec2.crossNumVec2(wA, this.m_rA))); // Vec2\n\n      let impulse = Vec2.neg(Mat22.mulVec2(this.m_linearMass, Cdot)); // Vec2\n      const oldImpulse = this.m_linearImpulse; // Vec2\n      this.m_linearImpulse.add(impulse);\n\n      const maxImpulse = h * this.m_maxForce; // float\n\n      if (this.m_linearImpulse.lengthSquared() > maxImpulse * maxImpulse) {\n        this.m_linearImpulse.normalize();\n        this.m_linearImpulse.mul(maxImpulse);\n      }\n\n      impulse = Vec2.sub(this.m_linearImpulse, oldImpulse);\n\n      vA.subMul(mA, impulse);\n      wA -= iA * Vec2.crossVec2Vec2(this.m_rA, impulse);\n\n      vB.addMul(mB, impulse);\n      wB += iB * Vec2.crossVec2Vec2(this.m_rB, impulse);\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    return true;\n  }\n\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { Vec2, Vec2Value } from './Vec2';\nimport { Vec3, Vec3Value } from './Vec3';\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\n/**\n * A 3-by-3 matrix. Stored in column-major order.\n */\nexport class Mat33 {\n  ex: Vec3;\n  ey: Vec3;\n  ez: Vec3;\n\n  constructor(a: Vec3Value, b: Vec3Value, c: Vec3Value);\n  constructor();\n  constructor(a?: Vec3Value, b?: Vec3Value, c?: Vec3Value) {\n    if (typeof a === 'object' && a !== null) {\n      this.ex = Vec3.clone(a);\n      this.ey = Vec3.clone(b);\n      this.ez = Vec3.clone(c);\n    } else {\n      this.ex = Vec3.zero();\n      this.ey = Vec3.zero();\n      this.ez = Vec3.zero();\n    }\n  }\n\n  /** @internal */\n  toString(): string {\n    return JSON.stringify(this);\n  }\n\n  static isValid(obj: any): boolean {\n    if (obj === null || typeof obj === 'undefined') {\n      return false;\n    }\n    return Vec3.isValid(obj.ex) && Vec3.isValid(obj.ey) && Vec3.isValid(obj.ez);\n  }\n\n  static assert(o: any): void {\n    _ASSERT && console.assert(!Mat33.isValid(o), 'Invalid Mat33!', o);\n  }\n\n  /**\n   * Set this matrix to all zeros.\n   */\n  setZero(): Mat33 {\n    this.ex.setZero();\n    this.ey.setZero();\n    this.ez.setZero();\n    return this;\n  }\n\n  /**\n   * Solve A * x = b, where b is a column vector. This is more efficient than\n   * computing the inverse in one-shot cases.\n   */\n  solve33(v: Vec3Value): Vec3 {\n    // let det = matrix.dotVec3(this.ex, matrix.newCrossVec3(this.ey, this.ez));\n    let cross_x = this.ey.y * this.ez.z - this.ey.z * this.ez.y;\n    let cross_y = this.ey.z * this.ez.x - this.ey.x * this.ez.z;\n    let cross_z = this.ey.x * this.ez.y - this.ey.y * this.ez.x;\n    let det = this.ex.x * cross_x + this.ex.y * cross_y + this.ex.z * cross_z;\n    if (det !== 0.0) {\n      det = 1.0 / det;\n    }\n    const r = new Vec3();\n    // r.x = det * matrix.dotVec3(v, matrix.newCrossVec3(this.ey, this.ez));\n    cross_x = this.ey.y * this.ez.z - this.ey.z * this.ez.y;\n    cross_y = this.ey.z * this.ez.x - this.ey.x * this.ez.z;\n    cross_z = this.ey.x * this.ez.y - this.ey.y * this.ez.x;\n    r.x = det * (v.x * cross_x + v.y * cross_y + v.z * cross_z);\n\n    // r.y = det * matrix.dotVec3(this.ex, matrix.newCrossVec3(v, this.ez));\n    cross_x = v.y * this.ez.z - v.z * this.ez.y;\n    cross_y = v.z * this.ez.x - v.x * this.ez.z;\n    cross_z = v.x * this.ez.y - v.y * this.ez.x;\n    r.y = det * (this.ex.x * cross_x + this.ex.y * cross_y + this.ex.z * cross_z);\n\n    // r.z = det * matrix.dotVec3(this.ex, matrix.newCrossVec3(this.ey, v));\n    cross_x = this.ey.y * v.z - this.ey.z * v.y;\n    cross_y = this.ey.z * v.x - this.ey.x * v.z;\n    cross_z = this.ey.x * v.y - this.ey.y * v.x;\n    r.z = det * (this.ex.x * cross_x + this.ex.y * cross_y + this.ex.z * cross_z);\n    return r;\n  }\n\n  /**\n   * Solve A * x = b, where b is a column vector. This is more efficient than\n   * computing the inverse in one-shot cases. Solve only the upper 2-by-2 matrix\n   * equation.\n   */\n  solve22(v: Vec2Value): Vec2 {\n    const a11 = this.ex.x;\n    const a12 = this.ey.x;\n    const a21 = this.ex.y;\n    const a22 = this.ey.y;\n    let det = a11 * a22 - a12 * a21;\n    if (det !== 0.0) {\n      det = 1.0 / det;\n    }\n    const r = Vec2.zero();\n    r.x = det * (a22 * v.x - a12 * v.y);\n    r.y = det * (a11 * v.y - a21 * v.x);\n    return r;\n  }\n\n  /**\n   * Get the inverse of this matrix as a 2-by-2. Returns the zero matrix if\n   * singular.\n   */\n  getInverse22(M: Mat33): void {\n    const a = this.ex.x;\n    const b = this.ey.x;\n    const c = this.ex.y;\n    const d = this.ey.y;\n    let det = a * d - b * c;\n    if (det !== 0.0) {\n      det = 1.0 / det;\n    }\n    M.ex.x = det * d;\n    M.ey.x = -det * b;\n    M.ex.z = 0.0;\n    M.ex.y = -det * c;\n    M.ey.y = det * a;\n    M.ey.z = 0.0;\n    M.ez.x = 0.0;\n    M.ez.y = 0.0;\n    M.ez.z = 0.0;\n  }\n\n  /**\n   * Get the symmetric inverse of this matrix as a 3-by-3. Returns the zero matrix\n   * if singular.\n   */\n  getSymInverse33(M: Mat33): void {\n    let det = Vec3.dot(this.ex, Vec3.cross(this.ey, this.ez));\n    if (det !== 0.0) {\n      det = 1.0 / det;\n    }\n    const a11 = this.ex.x;\n    const a12 = this.ey.x;\n    const a13 = this.ez.x;\n    const a22 = this.ey.y;\n    const a23 = this.ez.y;\n    const a33 = this.ez.z;\n\n    M.ex.x = det * (a22 * a33 - a23 * a23);\n    M.ex.y = det * (a13 * a23 - a12 * a33);\n    M.ex.z = det * (a12 * a23 - a13 * a22);\n\n    M.ey.x = M.ex.y;\n    M.ey.y = det * (a11 * a33 - a13 * a13);\n    M.ey.z = det * (a13 * a12 - a11 * a23);\n\n    M.ez.x = M.ex.z;\n    M.ez.y = M.ey.z;\n    M.ez.z = det * (a11 * a22 - a12 * a12);\n  }\n\n  /**\n   * Multiply a matrix times a vector.\n   */\n  static mul(a: Mat33, b: Vec2Value): Vec2;\n  static mul(a: Mat33, b: Vec3Value): Vec3;\n  // tslint:disable-next-line:typedef\n  static mul(a, b) {\n    _ASSERT && Mat33.assert(a);\n    if (b && 'z' in b && 'y' in b && 'x' in b) {\n      _ASSERT && Vec3.assert(b);\n      const x = a.ex.x * b.x + a.ey.x * b.y + a.ez.x * b.z;\n      const y = a.ex.y * b.x + a.ey.y * b.y + a.ez.y * b.z;\n      const z = a.ex.z * b.x + a.ey.z * b.y + a.ez.z * b.z;\n      return new Vec3(x, y, z);\n\n    } else if (b && 'y' in b && 'x' in b) {\n      _ASSERT && Vec2.assert(b);\n      const x = a.ex.x * b.x + a.ey.x * b.y;\n      const y = a.ex.y * b.x + a.ey.y * b.y;\n      return Vec2.neo(x, y);\n    }\n\n    _ASSERT && console.assert(false);\n  }\n\n  static mulVec3(a: Mat33, b: Vec3): Vec3 {\n    _ASSERT && Mat33.assert(a);\n    _ASSERT && Vec3.assert(b);\n    const x = a.ex.x * b.x + a.ey.x * b.y + a.ez.x * b.z;\n    const y = a.ex.y * b.x + a.ey.y * b.y + a.ez.y * b.z;\n    const z = a.ex.z * b.x + a.ey.z * b.y + a.ez.z * b.z;\n    return new Vec3(x, y, z);\n  }\n\n  static mulVec2(a: Mat33, b: Vec2Value): Vec2 {\n    _ASSERT && Mat33.assert(a);\n    _ASSERT && Vec2.assert(b);\n    const x = a.ex.x * b.x + a.ey.x * b.y;\n    const y = a.ex.y * b.x + a.ey.y * b.y;\n    return Vec2.neo(x, y);\n  }\n\n  static add(a: Mat33, b: Mat33): Mat33 {\n    _ASSERT && Mat33.assert(a);\n    _ASSERT && Mat33.assert(b);\n    return new Mat33(\n      Vec3.add(a.ex, b.ex),\n      Vec3.add(a.ey, b.ey),\n      Vec3.add(a.ez, b.ez)\n    );\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { options } from '../../util/options';\nimport { SettingsInternal as Settings } from '../../Settings';\nimport { math as Math } from '../../common/Math';\nimport { Vec2 } from '../../common/Vec2';\nimport { Vec3 } from '../../common/Vec3';\nimport { Mat22 } from '../../common/Mat22';\nimport { Mat33 } from '../../common/Mat33';\nimport { Rot } from '../../common/Rot';\nimport { Joint, JointOpt, JointDef } from '../Joint';\nimport { Body } from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\nconst _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\nconst inactiveLimit = 0;\nconst atLowerLimit = 1;\nconst atUpperLimit = 2;\nconst equalLimits = 3;\n\n/**\n * Revolute joint definition. This requires defining an anchor point where the\n * bodies are joined. The definition uses local anchor points so that the\n * initial configuration can violate the constraint slightly. You also need to\n * specify the initial relative angle for joint limits. This helps when saving\n * and loading a game.\n *\n * The local anchor points are measured from the body's origin rather than the\n * center of mass because: 1. you might not know where the center of mass will\n * be. 2. if you add/remove shapes from a body and recompute the mass, the\n * joints will be broken.\n */\nexport interface RevoluteJointOpt extends JointOpt {\n  /**\n   * The lower angle for the joint limit (radians).\n   */\n  lowerAngle?: number;\n  /**\n   * The upper angle for the joint limit (radians).\n   */\n  upperAngle?: number;\n  /**\n   * The maximum motor torque used to achieve the desired motor speed. Usually\n   * in N-m.\n   */\n  maxMotorTorque?: number;\n  /**\n   * The desired motor speed. Usually in radians per second.\n   */\n  motorSpeed?: number;\n  /**\n   * A flag to enable joint limits.\n   */\n  enableLimit?: boolean;\n  /**\n   * A flag to enable the joint motor.\n   */\n  enableMotor?: boolean;\n}\n/**\n * Revolute joint definition. This requires defining an anchor point where the\n * bodies are joined. The definition uses local anchor points so that the\n * initial configuration can violate the constraint slightly. You also need to\n * specify the initial relative angle for joint limits. This helps when saving\n * and loading a game.\n *\n * The local anchor points are measured from the body's origin rather than the\n * center of mass because: 1. you might not know where the center of mass will\n * be. 2. if you add/remove shapes from a body and recompute the mass, the\n * joints will be broken.\n */\nexport interface RevoluteJointDef extends JointDef, RevoluteJointOpt {\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  localAnchorA: Vec2;\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  localAnchorB: Vec2;\n  /**\n   * The bodyB angle minus bodyA angle in the reference state (radians).\n   */\n  referenceAngle: number;\n}\n\nconst DEFAULTS = {\n  lowerAngle : 0.0,\n  upperAngle : 0.0,\n  maxMotorTorque : 0.0,\n  motorSpeed : 0.0,\n  enableLimit : false,\n  enableMotor : false\n};\n\n/**\n * A revolute joint constrains two bodies to share a common point while they are\n * free to rotate about the point. The relative rotation about the shared point\n * is the joint angle. You can limit the relative rotation with a joint limit\n * that specifies a lower and upper angle. You can use a motor to drive the\n * relative rotation about the shared point. A maximum motor torque is provided\n * so that infinite forces are not generated.\n */\nexport class RevoluteJoint extends Joint {\n  static TYPE = 'revolute-joint' as const;\n\n  /** @internal */ m_type: 'revolute-joint';\n  /** @internal */ m_localAnchorA: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n  /** @internal */ m_referenceAngle: number;\n  /** @internal */ m_impulse: Vec3;\n  /** @internal */ m_motorImpulse: number;\n  /** @internal */ m_lowerAngle: number;\n  /** @internal */ m_upperAngle: number;\n  /** @internal */ m_maxMotorTorque: number;\n  /** @internal */ m_motorSpeed: number;\n  /** @internal */ m_enableLimit: boolean;\n  /** @internal */ m_enableMotor: boolean;\n\n  // Solver temp\n  /** @internal */ m_rA: Vec2;\n  /** @internal */ m_rB: Vec2;\n  /** @internal */ m_localCenterA: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_invMassA: number;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIA: number;\n  /** @internal */ m_invIB: number;\n  // effective mass for point-to-point constraint.\n  /** @internal */ m_mass: Mat33 = new Mat33();\n  // effective mass for motor/limit angular constraint.\n  /** @internal */ m_motorMass: number;\n  /** @internal */ m_limitState: number = inactiveLimit; // TODO enum\n\n  constructor(def: RevoluteJointDef);\n  constructor(def: RevoluteJointOpt, bodyA: Body, bodyB: Body, anchor: Vec2);\n  // @ts-ignore\n  constructor(def: RevoluteJointDef, bodyA?: Body, bodyB?: Body, anchor?: Vec2) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof RevoluteJoint)) {\n      return new RevoluteJoint(def, bodyA, bodyB, anchor);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = RevoluteJoint.TYPE;\n\n    this.m_localAnchorA =  Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n    this.m_localAnchorB =  Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n    this.m_referenceAngle = Math.isFinite(def.referenceAngle) ? def.referenceAngle : bodyB.getAngle() - bodyA.getAngle();\n\n    this.m_impulse = new Vec3();\n    this.m_motorImpulse = 0.0;\n\n    this.m_lowerAngle = def.lowerAngle;\n    this.m_upperAngle = def.upperAngle;\n    this.m_maxMotorTorque = def.maxMotorTorque;\n    this.m_motorSpeed = def.motorSpeed;\n    this.m_enableLimit = def.enableLimit;\n    this.m_enableMotor = def.enableMotor;\n\n    // Point-to-point constraint\n    // C = p2 - p1\n    // Cdot = v2 - v1\n    // = v2 + cross(w2, r2) - v1 - cross(w1, r1)\n    // J = [-I -r1_skew I r2_skew ]\n    // Identity used:\n    // w k % (rx i + ry j) = w * (-ry i + rx j)\n\n    // Motor constraint\n    // Cdot = w2 - w1\n    // J = [0 0 -1 0 0 1]\n    // K = invI1 + invI2\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      lowerAngle: this.m_lowerAngle,\n      upperAngle: this.m_upperAngle,\n      maxMotorTorque: this.m_maxMotorTorque,\n      motorSpeed: this.m_motorSpeed,\n      enableLimit: this.m_enableLimit,\n      enableMotor: this.m_enableMotor,\n\n      localAnchorA: this.m_localAnchorA,\n      localAnchorB: this.m_localAnchorB,\n      referenceAngle: this.m_referenceAngle,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any):RevoluteJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    const joint = new RevoluteJoint(data);\n    return joint;\n  }\n\n  /** @internal */\n  _setAnchors(def: {\n    anchorA?: Vec2,\n    localAnchorA?: Vec2,\n    anchorB?: Vec2,\n    localAnchorB?: Vec2,\n  }): void {\n    if (def.anchorA) {\n      this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n    } else if (def.localAnchorA) {\n      this.m_localAnchorA.setVec2(def.localAnchorA);\n    }\n\n    if (def.anchorB) {\n      this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n    } else if (def.localAnchorB) {\n      this.m_localAnchorB.setVec2(def.localAnchorB);\n    }\n  }\n\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  getLocalAnchorA(): Vec2 {\n    return this.m_localAnchorA;\n  }\n\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  getLocalAnchorB(): Vec2 {\n    return this.m_localAnchorB;\n  }\n\n  /**\n   * Get the reference angle.\n   */\n  getReferenceAngle(): number {\n    return this.m_referenceAngle;\n  }\n\n  /**\n   * Get the current joint angle in radians.\n   */\n  getJointAngle(): number {\n    const bA = this.m_bodyA;\n    const bB = this.m_bodyB;\n    return bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;\n  }\n\n  /**\n   * Get the current joint angle speed in radians per second.\n   */\n  getJointSpeed(): number {\n    const bA = this.m_bodyA;\n    const bB = this.m_bodyB;\n    return bB.m_angularVelocity - bA.m_angularVelocity;\n  }\n\n  /**\n   * Is the joint motor enabled?\n   */\n  isMotorEnabled(): boolean {\n    return this.m_enableMotor;\n  }\n\n  /**\n   * Enable/disable the joint motor.\n   */\n  enableMotor(flag: boolean): void {\n    if (flag == this.m_enableMotor) return;\n    this.m_bodyA.setAwake(true);\n    this.m_bodyB.setAwake(true);\n    this.m_enableMotor = flag;\n  }\n\n  /**\n   * Get the current motor torque given the inverse time step. Unit is N*m.\n   */\n  getMotorTorque(inv_dt: number): number {\n    return inv_dt * this.m_motorImpulse;\n  }\n\n  /**\n   * Set the motor speed in radians per second.\n   */\n  setMotorSpeed(speed: number): void {\n    if (speed == this.m_motorSpeed) return;\n    this.m_bodyA.setAwake(true);\n    this.m_bodyB.setAwake(true);\n    this.m_motorSpeed = speed;\n  }\n\n  /**\n   * Get the motor speed in radians per second.\n   */\n  getMotorSpeed(): number {\n    return this.m_motorSpeed;\n  }\n\n  /**\n   * Set the maximum motor torque, usually in N-m.\n   */\n  setMaxMotorTorque(torque: number): void {\n    if (torque == this.m_maxMotorTorque) return;\n    this.m_bodyA.setAwake(true);\n    this.m_bodyB.setAwake(true);\n    this.m_maxMotorTorque = torque;\n  }\n\n  getMaxMotorTorque(): number {\n    return this.m_maxMotorTorque;\n  }\n\n  /**\n   * Is the joint limit enabled?\n   */\n  isLimitEnabled(): boolean {\n    return this.m_enableLimit;\n  }\n\n  /**\n   * Enable/disable the joint limit.\n   */\n  enableLimit(flag: boolean): void {\n    if (flag != this.m_enableLimit) {\n      this.m_bodyA.setAwake(true);\n      this.m_bodyB.setAwake(true);\n      this.m_enableLimit = flag;\n      this.m_impulse.z = 0.0;\n    }\n  }\n\n  /**\n   * Get the lower joint limit in radians.\n   */\n  getLowerLimit(): number {\n    return this.m_lowerAngle;\n  }\n\n  /**\n   * Get the upper joint limit in radians.\n   */\n  getUpperLimit(): number {\n    return this.m_upperAngle;\n  }\n\n  /**\n   * Set the joint limits in radians.\n   */\n  setLimits(lower: number, upper: number): void {\n    _ASSERT && console.assert(lower <= upper);\n\n    if (lower != this.m_lowerAngle || upper != this.m_upperAngle) {\n      this.m_bodyA.setAwake(true);\n      this.m_bodyB.setAwake(true);\n      this.m_impulse.z = 0.0;\n      this.m_lowerAngle = lower;\n      this.m_upperAngle = upper;\n    }\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force given the inverse time step. Unit is N.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.neo(this.m_impulse.x, this.m_impulse.y).mul(inv_dt);\n  }\n\n  /**\n   * Get the reaction torque due to the joint limit given the inverse time step.\n   * Unit is N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return inv_dt * this.m_impulse.z;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassA = this.m_bodyA.m_invMass;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIA = this.m_bodyA.m_invI;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n\n    // J = [-I -r1_skew I r2_skew]\n    // [ 0 -1 0 1]\n    // r_skew = [-ry; rx]\n\n    // Matlab\n    // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]\n    // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]\n    // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB; // float\n    const iA = this.m_invIA;\n    const iB = this.m_invIB; // float\n\n    const fixedRotation = (iA + iB === 0.0); // bool\n\n    this.m_mass.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y\n        * this.m_rB.y * iB;\n    this.m_mass.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y\n        * this.m_rB.x * iB;\n    this.m_mass.ez.x = -this.m_rA.y * iA - this.m_rB.y * iB;\n    this.m_mass.ex.y = this.m_mass.ey.x;\n    this.m_mass.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x\n        * this.m_rB.x * iB;\n    this.m_mass.ez.y = this.m_rA.x * iA + this.m_rB.x * iB;\n    this.m_mass.ex.z = this.m_mass.ez.x;\n    this.m_mass.ey.z = this.m_mass.ez.y;\n    this.m_mass.ez.z = iA + iB;\n\n    this.m_motorMass = iA + iB;\n    if (this.m_motorMass > 0.0) {\n      this.m_motorMass = 1.0 / this.m_motorMass;\n    }\n\n    if (this.m_enableMotor == false || fixedRotation) {\n      this.m_motorImpulse = 0.0;\n    }\n\n    if (this.m_enableLimit && fixedRotation == false) {\n      const jointAngle = aB - aA - this.m_referenceAngle; // float\n\n      if (Math.abs(this.m_upperAngle - this.m_lowerAngle) < 2.0 * Settings.angularSlop) {\n        this.m_limitState = equalLimits;\n\n      } else if (jointAngle <= this.m_lowerAngle) {\n        if (this.m_limitState != atLowerLimit) {\n          this.m_impulse.z = 0.0;\n        }\n        this.m_limitState = atLowerLimit;\n\n      } else if (jointAngle >= this.m_upperAngle) {\n        if (this.m_limitState != atUpperLimit) {\n          this.m_impulse.z = 0.0;\n        }\n        this.m_limitState = atUpperLimit;\n\n      } else {\n        this.m_limitState = inactiveLimit;\n        this.m_impulse.z = 0.0;\n      }\n\n    } else {\n      this.m_limitState = inactiveLimit;\n    }\n\n    if (step.warmStarting) {\n      // Scale impulses to support a variable time step.\n      this.m_impulse.mul(step.dtRatio);\n      this.m_motorImpulse *= step.dtRatio;\n\n      const P = Vec2.neo(this.m_impulse.x, this.m_impulse.y);\n\n      vA.subMul(mA, P);\n      wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + this.m_motorImpulse + this.m_impulse.z);\n\n      vB.addMul(mB, P);\n      wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + this.m_motorImpulse + this.m_impulse.z);\n\n    } else {\n      this.m_impulse.setZero();\n      this.m_motorImpulse = 0.0;\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB; // float\n    const iA = this.m_invIA;\n    const iB = this.m_invIB; // float\n\n    const fixedRotation = (iA + iB === 0.0); // bool\n\n    // Solve motor constraint.\n    if (this.m_enableMotor && this.m_limitState != equalLimits\n        && fixedRotation == false) {\n      const Cdot = wB - wA - this.m_motorSpeed; // float\n      let impulse = -this.m_motorMass * Cdot; // float\n      const oldImpulse = this.m_motorImpulse; // float\n      const maxImpulse = step.dt * this.m_maxMotorTorque; // float\n      this.m_motorImpulse = Math.clamp(this.m_motorImpulse + impulse,\n          -maxImpulse, maxImpulse);\n      impulse = this.m_motorImpulse - oldImpulse;\n\n      wA -= iA * impulse;\n      wB += iB * impulse;\n    }\n\n    // Solve limit constraint.\n    if (this.m_enableLimit && this.m_limitState != inactiveLimit\n        && fixedRotation == false) {\n      const Cdot1 = Vec2.zero();\n      Cdot1.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, this.m_rB));\n      Cdot1.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, this.m_rA));\n      const Cdot2 = wB - wA; // float\n      const Cdot = new Vec3(Cdot1.x, Cdot1.y, Cdot2);\n\n      const impulse = Vec3.neg(this.m_mass.solve33(Cdot)); // Vec3\n\n      if (this.m_limitState == equalLimits) {\n        this.m_impulse.add(impulse);\n\n      } else if (this.m_limitState == atLowerLimit) {\n        const newImpulse = this.m_impulse.z + impulse.z; // float\n\n        if (newImpulse < 0.0) {\n          const rhs = Vec2.combine(-1, Cdot1, this.m_impulse.z, Vec2.neo(this.m_mass.ez.x, this.m_mass.ez.y)); // Vec2\n          const reduced = this.m_mass.solve22(rhs); // Vec2\n          impulse.x = reduced.x;\n          impulse.y = reduced.y;\n          impulse.z = -this.m_impulse.z;\n          this.m_impulse.x += reduced.x;\n          this.m_impulse.y += reduced.y;\n          this.m_impulse.z = 0.0;\n\n        } else {\n          this.m_impulse.add(impulse);\n        }\n\n      } else if (this.m_limitState == atUpperLimit) {\n        const newImpulse = this.m_impulse.z + impulse.z; // float\n\n        if (newImpulse > 0.0) {\n          const rhs = Vec2.combine(-1, Cdot1, this.m_impulse.z, Vec2.neo(this.m_mass.ez.x, this.m_mass.ez.y)); // Vec2\n          const reduced = this.m_mass.solve22(rhs); // Vec2\n          impulse.x = reduced.x;\n          impulse.y = reduced.y;\n          impulse.z = -this.m_impulse.z;\n          this.m_impulse.x += reduced.x;\n          this.m_impulse.y += reduced.y;\n          this.m_impulse.z = 0.0;\n\n        } else {\n          this.m_impulse.add(impulse);\n        }\n      }\n\n      const P = Vec2.neo(impulse.x, impulse.y);\n\n      vA.subMul(mA, P);\n      wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + impulse.z);\n\n      vB.addMul(mB, P);\n      wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + impulse.z);\n\n    } else {\n      // Solve point-to-point constraint\n      const Cdot = Vec2.zero();\n      Cdot.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, this.m_rB));\n      Cdot.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, this.m_rA));\n      const impulse = this.m_mass.solve22(Vec2.neg(Cdot)); // Vec2\n\n      this.m_impulse.x += impulse.x;\n      this.m_impulse.y += impulse.y;\n\n      vA.subMul(mA, impulse);\n      wA -= iA * Vec2.crossVec2Vec2(this.m_rA, impulse);\n\n      vB.addMul(mB, impulse);\n      wB += iB * Vec2.crossVec2Vec2(this.m_rB, impulse);\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    const cA = this.m_bodyA.c_position.c;\n    let aA = this.m_bodyA.c_position.a;\n    const cB = this.m_bodyB.c_position.c;\n    let aB = this.m_bodyB.c_position.a;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    let angularError = 0.0; // float\n    let positionError = 0.0; // float\n\n    const fixedRotation = (this.m_invIA + this.m_invIB == 0.0); // bool\n\n    // Solve angular limit constraint.\n    if (this.m_enableLimit && this.m_limitState != inactiveLimit\n        && fixedRotation == false) {\n      const angle = aB - aA - this.m_referenceAngle; // float\n      let limitImpulse = 0.0; // float\n\n      if (this.m_limitState == equalLimits) {\n        // Prevent large angular corrections\n        const C = Math.clamp(angle - this.m_lowerAngle,\n            -Settings.maxAngularCorrection, Settings.maxAngularCorrection); // float\n        limitImpulse = -this.m_motorMass * C;\n        angularError = Math.abs(C);\n\n      } else if (this.m_limitState == atLowerLimit) {\n        let C = angle - this.m_lowerAngle; // float\n        angularError = -C;\n\n        // Prevent large angular corrections and allow some slop.\n        C = Math.clamp(C + Settings.angularSlop, -Settings.maxAngularCorrection,\n            0.0);\n        limitImpulse = -this.m_motorMass * C;\n\n      } else if (this.m_limitState == atUpperLimit) {\n        let C = angle - this.m_upperAngle; // float\n        angularError = C;\n\n        // Prevent large angular corrections and allow some slop.\n        C = Math.clamp(C - Settings.angularSlop, 0.0,\n            Settings.maxAngularCorrection);\n        limitImpulse = -this.m_motorMass * C;\n      }\n\n      aA -= this.m_invIA * limitImpulse;\n      aB += this.m_invIB * limitImpulse;\n    }\n\n    // Solve point-to-point constraint.\n    {\n      qA.setAngle(aA);\n      qB.setAngle(aB);\n      const rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA)); // Vec2\n      const rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB)); // Vec2\n\n      const C = Vec2.zero();\n      C.addCombine(1, cB, 1, rB);\n      C.subCombine(1, cA, 1, rA);\n      positionError = C.length();\n\n      const mA = this.m_invMassA;\n      const mB = this.m_invMassB; // float\n      const iA = this.m_invIA;\n      const iB = this.m_invIB; // float\n\n      const K = new Mat22();\n      K.ex.x = mA + mB + iA * rA.y * rA.y + iB * rB.y * rB.y;\n      K.ex.y = -iA * rA.x * rA.y - iB * rB.x * rB.y;\n      K.ey.x = K.ex.y;\n      K.ey.y = mA + mB + iA * rA.x * rA.x + iB * rB.x * rB.x;\n\n      const impulse = Vec2.neg(K.solve(C)); // Vec2\n\n      cA.subMul(mA, impulse);\n      aA -= iA * Vec2.crossVec2Vec2(rA, impulse);\n\n      cB.addMul(mB, impulse);\n      aB += iB * Vec2.crossVec2Vec2(rB, impulse);\n    }\n\n    this.m_bodyA.c_position.c.setVec2(cA);\n    this.m_bodyA.c_position.a = aA;\n    this.m_bodyB.c_position.c.setVec2(cB);\n    this.m_bodyB.c_position.a = aB;\n\n    return positionError <= Settings.linearSlop\n        && angularError <= Settings.angularSlop;\n  }\n\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { options } from '../../util/options';\nimport { SettingsInternal as Settings } from '../../Settings';\nimport { math as Math } from '../../common/Math';\nimport { Vec2 } from '../../common/Vec2';\nimport { Vec3 } from '../../common/Vec3';\nimport { Mat22 } from '../../common/Mat22';\nimport { Mat33 } from '../../common/Mat33';\nimport { Rot } from '../../common/Rot';\nimport { Joint, JointOpt, JointDef } from '../Joint';\nimport { Body } from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\nconst _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\nconst inactiveLimit = 0;\nconst atLowerLimit = 1;\nconst atUpperLimit = 2;\nconst equalLimits = 3;\n\n/**\n * Prismatic joint definition. This requires defining a line of motion using an\n * axis and an anchor point. The definition uses local anchor points and a local\n * axis so that the initial configuration can violate the constraint slightly.\n * The joint translation is zero when the local anchor points coincide in world\n * space. Using local anchors and a local axis helps when saving and loading a\n * game.\n */\nexport interface PrismaticJointOpt extends JointOpt {\n  /**\n   * Enable/disable the joint limit.\n   */\n  enableLimit?: boolean;\n  /**\n   * The lower translation limit, usually in meters.\n   */\n  lowerTranslation?: number;\n  /**\n   * The upper translation limit, usually in meters.\n   */\n  upperTranslation?: number;\n  /**\n   * Enable/disable the joint motor.\n   */\n  enableMotor?: boolean;\n  /**\n   * The maximum motor torque, usually in N-m.\n   */\n  maxMotorForce?: number;\n  /**\n   * The desired motor speed in radians per second.\n   */\n  motorSpeed?: number;\n}\n/**\n * Prismatic joint definition. This requires defining a line of motion using an\n * axis and an anchor point. The definition uses local anchor points and a local\n * axis so that the initial configuration can violate the constraint slightly.\n * The joint translation is zero when the local anchor points coincide in world\n * space. Using local anchors and a local axis helps when saving and loading a\n * game.\n */\nexport interface PrismaticJointDef extends JointDef, PrismaticJointOpt {\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  localAnchorA: Vec2;\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  localAnchorB: Vec2;\n  /**\n   * The local translation unit axis in bodyA.\n   */\n  localAxisA: Vec2;\n  /**\n   * referenceAngle The constrained angle between the bodies:\n   * bodyB_angle - bodyA_angle.\n   */\n  referenceAngle: number;\n}\n\nconst DEFAULTS = {\n  enableLimit : false,\n  lowerTranslation : 0.0,\n  upperTranslation : 0.0,\n  enableMotor : false,\n  maxMotorForce : 0.0,\n  motorSpeed : 0.0\n};\n\n/**\n * A prismatic joint. This joint provides one degree of freedom: translation\n * along an axis fixed in bodyA. Relative rotation is prevented. You can use a\n * joint limit to restrict the range of motion and a joint motor to drive the\n * motion or to model joint friction.\n */\nexport class PrismaticJoint extends Joint {\n  static TYPE = 'prismatic-joint' as const;\n\n  /** @internal */ m_type: 'prismatic-joint';\n  /** @internal */ m_localAnchorA: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n  /** @internal */ m_localXAxisA: Vec2;\n  /** @internal */ m_localYAxisA: Vec2;\n  /** @internal */ m_referenceAngle: number;\n  /** @internal */ m_impulse: Vec3;\n  /** @internal */ m_motorMass: number;\n  /** @internal */ m_motorImpulse: number;\n  /** @internal */ m_lowerTranslation: number;\n  /** @internal */ m_upperTranslation: number;\n  /** @internal */ m_maxMotorForce: number;\n  /** @internal */ m_motorSpeed: number;\n  /** @internal */ m_enableLimit: boolean;\n  /** @internal */ m_enableMotor: boolean;\n  /** @internal */ m_limitState: number; // TODO enum\n  /** @internal */ m_axis: Vec2;\n  /** @internal */ m_perp: Vec2;\n  // Solver temp\n  /** @internal */ m_localCenterA: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_invMassA: number;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIA: number;\n  /** @internal */ m_invIB: number;\n  /** @internal */ m_s1: number;\n  /** @internal */ m_s2: number;\n  /** @internal */ m_a1: number;\n  /** @internal */ m_a2: number;\n  /** @internal */ m_K: Mat33;\n\n  constructor(def: PrismaticJointDef);\n  constructor(def: PrismaticJointOpt, bodyA: Body, bodyB: Body, anchor: Vec2, axis: Vec2);\n  constructor(def: PrismaticJointDef, bodyA?: Body, bodyB?: Body, anchor?: Vec2, axis?: Vec2) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof PrismaticJoint)) {\n      return new PrismaticJoint(def, bodyA, bodyB, anchor, axis);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = PrismaticJoint.TYPE;\n\n    this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n    this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n    this.m_localXAxisA = Vec2.clone(axis ? bodyA.getLocalVector(axis) : def.localAxisA || Vec2.neo(1.0, 0.0));\n    this.m_localXAxisA.normalize();\n    this.m_localYAxisA = Vec2.crossNumVec2(1.0, this.m_localXAxisA);\n    this.m_referenceAngle = Math.isFinite(def.referenceAngle) ? def.referenceAngle : bodyB.getAngle() - bodyA.getAngle();\n\n    this.m_impulse = new Vec3();\n    this.m_motorMass = 0.0;\n    this.m_motorImpulse = 0.0;\n\n    this.m_lowerTranslation = def.lowerTranslation;\n    this.m_upperTranslation = def.upperTranslation;\n    this.m_maxMotorForce = def.maxMotorForce;\n    this.m_motorSpeed = def.motorSpeed;\n    this.m_enableLimit = def.enableLimit;\n    this.m_enableMotor = def.enableMotor;\n    this.m_limitState = inactiveLimit;\n\n    this.m_axis = Vec2.zero();\n    this.m_perp = Vec2.zero();\n\n    this.m_K = new Mat33();\n\n    // Linear constraint (point-to-line)\n    // d = p2 - p1 = x2 + r2 - x1 - r1\n    // C = dot(perp, d)\n    // Cdot = dot(d, cross(w1, perp)) + dot(perp, v2 + cross(w2, r2) - v1 -\n    // cross(w1, r1))\n    // = -dot(perp, v1) - dot(cross(d + r1, perp), w1) + dot(perp, v2) +\n    // dot(cross(r2, perp), v2)\n    // J = [-perp, -cross(d + r1, perp), perp, cross(r2,perp)]\n    //\n    // Angular constraint\n    // C = a2 - a1 + a_initial\n    // Cdot = w2 - w1\n    // J = [0 0 -1 0 0 1]\n    //\n    // K = J * invM * JT\n    //\n    // J = [-a -s1 a s2]\n    // [0 -1 0 1]\n    // a = perp\n    // s1 = cross(d + r1, a) = cross(p2 - x1, a)\n    // s2 = cross(r2, a) = cross(p2 - x2, a)\n\n    // Motor/Limit linear constraint\n    // C = dot(ax1, d)\n    // Cdot = = -dot(ax1, v1) - dot(cross(d + r1, ax1), w1) + dot(ax1, v2) +\n    // dot(cross(r2, ax1), v2)\n    // J = [-ax1 -cross(d+r1,ax1) ax1 cross(r2,ax1)]\n\n    // Block Solver\n    // We develop a block solver that includes the joint limit. This makes the\n    // limit stiff (inelastic) even\n    // when the mass has poor distribution (leading to large torques about the\n    // joint anchor points).\n    //\n    // The Jacobian has 3 rows:\n    // J = [-uT -s1 uT s2] // linear\n    // [0 -1 0 1] // angular\n    // [-vT -a1 vT a2] // limit\n    //\n    // u = perp\n    // v = axis\n    // s1 = cross(d + r1, u), s2 = cross(r2, u)\n    // a1 = cross(d + r1, v), a2 = cross(r2, v)\n\n    // M * (v2 - v1) = JT * df\n    // J * v2 = bias\n    //\n    // v2 = v1 + invM * JT * df\n    // J * (v1 + invM * JT * df) = bias\n    // K * df = bias - J * v1 = -Cdot\n    // K = J * invM * JT\n    // Cdot = J * v1 - bias\n    //\n    // Now solve for f2.\n    // df = f2 - f1\n    // K * (f2 - f1) = -Cdot\n    // f2 = invK * (-Cdot) + f1\n    //\n    // Clamp accumulated limit impulse.\n    // lower: f2(3) = max(f2(3), 0)\n    // upper: f2(3) = min(f2(3), 0)\n    //\n    // Solve for correct f2(1:2)\n    // K(1:2, 1:2) * f2(1:2) = -Cdot(1:2) - K(1:2,3) * f2(3) + K(1:2,1:3) * f1\n    // = -Cdot(1:2) - K(1:2,3) * f2(3) + K(1:2,1:2) * f1(1:2) + K(1:2,3) * f1(3)\n    // K(1:2, 1:2) * f2(1:2) = -Cdot(1:2) - K(1:2,3) * (f2(3) - f1(3)) +\n    // K(1:2,1:2) * f1(1:2)\n    // f2(1:2) = invK(1:2,1:2) * (-Cdot(1:2) - K(1:2,3) * (f2(3) - f1(3))) +\n    // f1(1:2)\n    //\n    // Now compute impulse to be applied:\n    // df = f2 - f1\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      lowerTranslation: this.m_lowerTranslation,\n      upperTranslation: this.m_upperTranslation,\n      maxMotorForce: this.m_maxMotorForce,\n      motorSpeed: this.m_motorSpeed,\n      enableLimit: this.m_enableLimit,\n      enableMotor: this.m_enableMotor,\n\n      localAnchorA: this.m_localAnchorA,\n      localAnchorB: this.m_localAnchorB,\n      localAxisA: this.m_localXAxisA,\n      referenceAngle: this.m_referenceAngle,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): PrismaticJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    data.localAxisA = Vec2.clone(data.localAxisA);\n    const joint = new PrismaticJoint(data);\n    return joint;\n  }\n\n  /** @internal */\n  _setAnchors(def: {\n    anchorA?: Vec2,\n    localAnchorA?: Vec2,\n    anchorB?: Vec2,\n    localAnchorB?: Vec2,\n    localAxisA?: Vec2,\n  }): void {\n    if (def.anchorA) {\n      this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n    } else if (def.localAnchorA) {\n      this.m_localAnchorA.setVec2(def.localAnchorA);\n    }\n\n    if (def.anchorB) {\n      this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n    } else if (def.localAnchorB) {\n      this.m_localAnchorB.setVec2(def.localAnchorB);\n    }\n\n    if (def.localAxisA) {\n      this.m_localXAxisA.setVec2(def.localAxisA);\n      this.m_localYAxisA.setVec2(Vec2.crossNumVec2(1.0, def.localAxisA));\n    }\n  }\n\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  getLocalAnchorA(): Vec2 {\n    return this.m_localAnchorA;\n  }\n\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  getLocalAnchorB(): Vec2 {\n    return this.m_localAnchorB;\n  }\n\n  /**\n   * The local joint axis relative to bodyA.\n   */\n  getLocalAxisA(): Vec2 {\n    return this.m_localXAxisA;\n  }\n\n  /**\n   * Get the reference angle.\n   */\n  getReferenceAngle(): number {\n    return this.m_referenceAngle;\n  }\n\n  /**\n   * Get the current joint translation, usually in meters.\n   */\n  getJointTranslation(): number {\n    const pA = this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n    const pB = this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n    const d = Vec2.sub(pB, pA);\n    const axis = this.m_bodyA.getWorldVector(this.m_localXAxisA);\n\n    const translation = Vec2.dot(d, axis);\n    return translation;\n  }\n\n  /**\n   * Get the current joint translation speed, usually in meters per second.\n   */\n  getJointSpeed(): number {\n    const bA = this.m_bodyA;\n    const bB = this.m_bodyB;\n\n    const rA = Rot.mulVec2(bA.m_xf.q, Vec2.sub(this.m_localAnchorA, bA.m_sweep.localCenter)); // Vec2\n    const rB = Rot.mulVec2(bB.m_xf.q, Vec2.sub(this.m_localAnchorB, bB.m_sweep.localCenter)); // Vec2\n    const p1 = Vec2.add(bA.m_sweep.c, rA); // Vec2\n    const p2 = Vec2.add(bB.m_sweep.c, rB); // Vec2\n    const d = Vec2.sub(p2, p1); // Vec2\n    const axis = Rot.mulVec2(bA.m_xf.q, this.m_localXAxisA); // Vec2\n\n    const vA = bA.m_linearVelocity; // Vec2\n    const vB = bB.m_linearVelocity; // Vec2\n    const wA = bA.m_angularVelocity; // float\n    const wB = bB.m_angularVelocity; // float\n\n    const speed = Vec2.dot(d, Vec2.crossNumVec2(wA, axis))\n        + Vec2.dot(axis, Vec2.sub(Vec2.addCrossNumVec2(vB, wB, rB), Vec2.addCrossNumVec2(vA, wA, rA))); // float\n    return speed;\n  }\n\n  /**\n   * Is the joint limit enabled?\n   */\n  isLimitEnabled(): boolean {\n    return this.m_enableLimit;\n  }\n\n  /**\n   * Enable/disable the joint limit.\n   */\n  enableLimit(flag: boolean): void {\n    if (flag != this.m_enableLimit) {\n      this.m_bodyA.setAwake(true);\n      this.m_bodyB.setAwake(true);\n      this.m_enableLimit = flag;\n      this.m_impulse.z = 0.0;\n    }\n  }\n\n  /**\n   * Get the lower joint limit, usually in meters.\n   */\n  getLowerLimit(): number {\n    return this.m_lowerTranslation;\n  }\n\n  /**\n   * Get the upper joint limit, usually in meters.\n   */\n  getUpperLimit(): number {\n    return this.m_upperTranslation;\n  }\n\n  /**\n   * Set the joint limits, usually in meters.\n   */\n  setLimits(lower: number, upper: number): void {\n    _ASSERT && console.assert(lower <= upper);\n    if (lower != this.m_lowerTranslation || upper != this.m_upperTranslation) {\n      this.m_bodyA.setAwake(true);\n      this.m_bodyB.setAwake(true);\n      this.m_lowerTranslation = lower;\n      this.m_upperTranslation = upper;\n      this.m_impulse.z = 0.0;\n    }\n  }\n\n  /**\n   * Is the joint motor enabled?\n   */\n  isMotorEnabled(): boolean {\n    return this.m_enableMotor;\n  }\n\n  /**\n   * Enable/disable the joint motor.\n   */\n  enableMotor(flag: boolean): void {\n    if (flag == this.m_enableMotor) return;\n    this.m_bodyA.setAwake(true);\n    this.m_bodyB.setAwake(true);\n    this.m_enableMotor = flag;\n  }\n\n  /**\n   * Set the motor speed, usually in meters per second.\n   */\n  setMotorSpeed(speed: number): void {\n    if (speed == this.m_motorSpeed) return;\n    this.m_bodyA.setAwake(true);\n    this.m_bodyB.setAwake(true);\n    this.m_motorSpeed = speed;\n  }\n\n  /**\n   * Set the maximum motor force, usually in N.\n   */\n  setMaxMotorForce(force: number): void {\n    if (force == this.m_maxMotorForce) return;\n    this.m_bodyA.setAwake(true);\n    this.m_bodyB.setAwake(true);\n    this.m_maxMotorForce = force;\n  }\n\n  getMaxMotorForce(): number {\n    return this.m_maxMotorForce;\n  }\n\n  /**\n   * Get the motor speed, usually in meters per second.\n   */\n  getMotorSpeed(): number {\n    return this.m_motorSpeed;\n  }\n\n  /**\n   * Get the current motor force given the inverse time step, usually in N.\n   */\n  getMotorForce(inv_dt: number): number {\n    return inv_dt * this.m_motorImpulse;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.combine(this.m_impulse.x, this.m_perp, this.m_motorImpulse + this.m_impulse.z, this.m_axis).mul(inv_dt);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return inv_dt * this.m_impulse.y;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassA = this.m_bodyA.m_invMass;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIA = this.m_bodyA.m_invI;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const cA = this.m_bodyA.c_position.c;\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const cB = this.m_bodyB.c_position.c;\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    // Compute the effective masses.\n    const rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    const rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n    const d = Vec2.zero();\n    d.addCombine(1, cB, 1, rB);\n    d.subCombine(1, cA, 1, rA);\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    // Compute motor Jacobian and effective mass.\n    {\n      this.m_axis = Rot.mulVec2(qA, this.m_localXAxisA);\n      this.m_a1 = Vec2.crossVec2Vec2(Vec2.add(d, rA), this.m_axis);\n      this.m_a2 = Vec2.crossVec2Vec2(rB, this.m_axis);\n\n      this.m_motorMass = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2\n          * this.m_a2;\n      if (this.m_motorMass > 0.0) {\n        this.m_motorMass = 1.0 / this.m_motorMass;\n      }\n    }\n\n    // Prismatic constraint.\n    {\n      this.m_perp = Rot.mulVec2(qA, this.m_localYAxisA);\n\n      this.m_s1 = Vec2.crossVec2Vec2(Vec2.add(d, rA), this.m_perp);\n      this.m_s2 = Vec2.crossVec2Vec2(rB, this.m_perp);\n\n      const s1test = Vec2.crossVec2Vec2(rA, this.m_perp);\n\n      const k11 = mA + mB + iA * this.m_s1 * this.m_s1 + iB * this.m_s2 * this.m_s2;\n      const k12 = iA * this.m_s1 + iB * this.m_s2;\n      const k13 = iA * this.m_s1 * this.m_a1 + iB * this.m_s2 * this.m_a2;\n      let k22 = iA + iB;\n      if (k22 == 0.0) {\n        // For bodies with fixed rotation.\n        k22 = 1.0;\n      }\n      const k23 = iA * this.m_a1 + iB * this.m_a2;\n      const k33 = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2 * this.m_a2;\n\n      this.m_K.ex.set(k11, k12, k13);\n      this.m_K.ey.set(k12, k22, k23);\n      this.m_K.ez.set(k13, k23, k33);\n    }\n\n    // Compute motor and limit terms.\n    if (this.m_enableLimit) {\n\n      const jointTranslation = Vec2.dot(this.m_axis, d); // float\n      if (Math.abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * Settings.linearSlop) {\n        this.m_limitState = equalLimits;\n\n      } else if (jointTranslation <= this.m_lowerTranslation) {\n        if (this.m_limitState != atLowerLimit) {\n          this.m_limitState = atLowerLimit;\n          this.m_impulse.z = 0.0;\n        }\n\n      } else if (jointTranslation >= this.m_upperTranslation) {\n        if (this.m_limitState != atUpperLimit) {\n          this.m_limitState = atUpperLimit;\n          this.m_impulse.z = 0.0;\n        }\n\n      } else {\n        this.m_limitState = inactiveLimit;\n        this.m_impulse.z = 0.0;\n      }\n\n    } else {\n      this.m_limitState = inactiveLimit;\n      this.m_impulse.z = 0.0;\n    }\n\n    if (this.m_enableMotor == false) {\n      this.m_motorImpulse = 0.0;\n    }\n\n    if (step.warmStarting) {\n      // Account for variable time step.\n      this.m_impulse.mul(step.dtRatio);\n      this.m_motorImpulse *= step.dtRatio;\n\n      const P = Vec2.combine(this.m_impulse.x, this.m_perp, this.m_motorImpulse\n          + this.m_impulse.z, this.m_axis);\n      const LA = this.m_impulse.x * this.m_s1 + this.m_impulse.y\n          + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1;\n      const LB = this.m_impulse.x * this.m_s2 + this.m_impulse.y\n          + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;\n\n      vA.subMul(mA, P);\n      wA -= iA * LA;\n\n      vB.addMul(mB, P);\n      wB += iB * LB;\n    } else {\n      this.m_impulse.setZero();\n      this.m_motorImpulse = 0.0;\n    }\n\n    this.m_bodyA.c_velocity.v.setVec2(vA);\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v.setVec2(vB);\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    // Solve linear motor constraint.\n    if (this.m_enableMotor && this.m_limitState != equalLimits) {\n      const Cdot = Vec2.dot(this.m_axis, Vec2.sub(vB, vA)) + this.m_a2 * wB\n          - this.m_a1 * wA;\n      let impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);\n      const oldImpulse = this.m_motorImpulse;\n      const maxImpulse = step.dt * this.m_maxMotorForce;\n      this.m_motorImpulse = Math.clamp(this.m_motorImpulse + impulse,\n          -maxImpulse, maxImpulse);\n      impulse = this.m_motorImpulse - oldImpulse;\n\n      const P = Vec2.mulNumVec2(impulse, this.m_axis);\n      const LA = impulse * this.m_a1;\n      const LB = impulse * this.m_a2;\n\n      vA.subMul(mA, P);\n      wA -= iA * LA;\n\n      vB.addMul(mB, P);\n      wB += iB * LB;\n    }\n\n    const Cdot1 = Vec2.zero();\n    Cdot1.x += Vec2.dot(this.m_perp, vB) + this.m_s2 * wB;\n    Cdot1.x -= Vec2.dot(this.m_perp, vA) + this.m_s1 * wA;\n    Cdot1.y = wB - wA;\n\n    if (this.m_enableLimit && this.m_limitState != inactiveLimit) {\n      // Solve prismatic and limit constraint in block form.\n      let Cdot2 = 0;\n      Cdot2 += Vec2.dot(this.m_axis, vB) + this.m_a2 * wB;\n      Cdot2 -= Vec2.dot(this.m_axis, vA) + this.m_a1 * wA;\n\n      const Cdot = new Vec3(Cdot1.x, Cdot1.y, Cdot2);\n\n      const f1 = Vec3.clone(this.m_impulse);\n      let df = this.m_K.solve33(Vec3.neg(Cdot)); // Vec3\n      this.m_impulse.add(df);\n\n      if (this.m_limitState == atLowerLimit) {\n        this.m_impulse.z = Math.max(this.m_impulse.z, 0.0);\n      } else if (this.m_limitState == atUpperLimit) {\n        this.m_impulse.z = Math.min(this.m_impulse.z, 0.0);\n      }\n\n      // f2(1:2) = invK(1:2,1:2) * (-Cdot(1:2) - K(1:2,3) * (f2(3) - f1(3))) +\n      // f1(1:2)\n      const b = Vec2.combine(-1, Cdot1, -(this.m_impulse.z - f1.z), Vec2.neo(this.m_K.ez.x, this.m_K.ez.y)); // Vec2\n      const f2r = Vec2.add(this.m_K.solve22(b), Vec2.neo(f1.x, f1.y)); // Vec2\n      this.m_impulse.x = f2r.x;\n      this.m_impulse.y = f2r.y;\n\n      df = Vec3.sub(this.m_impulse, f1);\n\n      const P = Vec2.combine(df.x, this.m_perp, df.z, this.m_axis); // Vec2\n      const LA = df.x * this.m_s1 + df.y + df.z * this.m_a1; // float\n      const LB = df.x * this.m_s2 + df.y + df.z * this.m_a2; // float\n\n      vA.subMul(mA, P);\n      wA -= iA * LA;\n\n      vB.addMul(mB, P);\n      wB += iB * LB;\n    } else {\n      // Limit is inactive, just solve the prismatic constraint in block form.\n      const df = this.m_K.solve22(Vec2.neg(Cdot1)); // Vec2\n      this.m_impulse.x += df.x;\n      this.m_impulse.y += df.y;\n\n      const P = Vec2.mulNumVec2(df.x, this.m_perp); // Vec2\n      const LA = df.x * this.m_s1 + df.y; // float\n      const LB = df.x * this.m_s2 + df.y; // float\n\n      vA.subMul(mA, P);\n      wA -= iA * LA;\n\n      vB.addMul(mB, P);\n      wB += iB * LB;\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    const cA = this.m_bodyA.c_position.c;\n    let aA = this.m_bodyA.c_position.a;\n    const cB = this.m_bodyB.c_position.c;\n    let aB = this.m_bodyB.c_position.a;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    // Compute fresh Jacobians\n    const rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA)); // Vec2\n    const rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB)); // Vec2\n    const d = Vec2.sub(Vec2.add(cB, rB), Vec2.add(cA, rA)); // Vec2\n\n    const axis = Rot.mulVec2(qA, this.m_localXAxisA); // Vec2\n    const a1 = Vec2.crossVec2Vec2(Vec2.add(d, rA), axis); // float\n    const a2 = Vec2.crossVec2Vec2(rB, axis); // float\n    const perp = Rot.mulVec2(qA, this.m_localYAxisA); // Vec2\n\n    const s1 = Vec2.crossVec2Vec2(Vec2.add(d, rA), perp); // float\n    const s2 = Vec2.crossVec2Vec2(rB, perp); // float\n\n    let impulse = new Vec3();\n    const C1 = Vec2.zero(); // Vec2\n    C1.x = Vec2.dot(perp, d);\n    C1.y = aB - aA - this.m_referenceAngle;\n\n    let linearError = Math.abs(C1.x); // float\n    const angularError = Math.abs(C1.y); // float\n\n    const linearSlop = Settings.linearSlop;\n    const maxLinearCorrection = Settings.maxLinearCorrection;\n\n    let active = false; // bool\n    let C2 = 0.0; // float\n    if (this.m_enableLimit) {\n\n      const translation = Vec2.dot(axis, d); // float\n      if (Math.abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * linearSlop) {\n        // Prevent large angular corrections\n        C2 = Math.clamp(translation, -maxLinearCorrection, maxLinearCorrection);\n        linearError = Math.max(linearError, Math.abs(translation));\n        active = true;\n\n      } else if (translation <= this.m_lowerTranslation) {\n        // Prevent large linear corrections and allow some slop.\n        C2 = Math.clamp(translation - this.m_lowerTranslation + linearSlop,\n            -maxLinearCorrection, 0.0);\n        linearError = Math\n            .max(linearError, this.m_lowerTranslation - translation);\n        active = true;\n\n      } else if (translation >= this.m_upperTranslation) {\n        // Prevent large linear corrections and allow some slop.\n        C2 = Math.clamp(translation - this.m_upperTranslation - linearSlop, 0.0,\n            maxLinearCorrection);\n        linearError = Math\n            .max(linearError, translation - this.m_upperTranslation);\n        active = true;\n      }\n    }\n\n    if (active) {\n      const k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2; // float\n      const k12 = iA * s1 + iB * s2; // float\n      const k13 = iA * s1 * a1 + iB * s2 * a2; // float\n      let k22 = iA + iB; // float\n      if (k22 == 0.0) {\n        // For fixed rotation\n        k22 = 1.0;\n      }\n      const k23 = iA * a1 + iB * a2; // float\n      const k33 = mA + mB + iA * a1 * a1 + iB * a2 * a2; // float\n\n      const K = new Mat33();\n      K.ex.set(k11, k12, k13);\n      K.ey.set(k12, k22, k23);\n      K.ez.set(k13, k23, k33);\n\n      const C = new Vec3();\n      C.x = C1.x;\n      C.y = C1.y;\n      C.z = C2;\n\n      impulse = K.solve33(Vec3.neg(C));\n    } else {\n      const k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2; // float\n      const k12 = iA * s1 + iB * s2; // float\n      let k22 = iA + iB; // float\n      if (k22 == 0.0) {\n        k22 = 1.0;\n      }\n\n      const K = new Mat22();\n      K.ex.setNum(k11, k12);\n      K.ey.setNum(k12, k22);\n\n      const impulse1 = K.solve(Vec2.neg(C1)); // Vec2\n      impulse.x = impulse1.x;\n      impulse.y = impulse1.y;\n      impulse.z = 0.0;\n    }\n\n    const P = Vec2.combine(impulse.x, perp, impulse.z, axis); // Vec2\n    const LA = impulse.x * s1 + impulse.y + impulse.z * a1; // float\n    const LB = impulse.x * s2 + impulse.y + impulse.z * a2; // float\n\n    cA.subMul(mA, P);\n    aA -= iA * LA;\n    cB.addMul(mB, P);\n    aB += iB * LB;\n\n    this.m_bodyA.c_position.c = cA;\n    this.m_bodyA.c_position.a = aA;\n    this.m_bodyB.c_position.c = cB;\n    this.m_bodyB.c_position.a = aB;\n\n    return linearError <= Settings.linearSlop\n        && angularError <= Settings.angularSlop;\n  }\n\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { options } from '../../util/options';\nimport { SettingsInternal as Settings } from '../../Settings';\nimport { math as Math } from '../../common/Math';\nimport { Vec2 } from '../../common/Vec2';\nimport { Rot } from '../../common/Rot';\nimport { Joint, JointOpt, JointDef } from '../Joint';\nimport { Body } from '../Body';\nimport { RevoluteJoint } from './RevoluteJoint';\nimport { PrismaticJoint } from './PrismaticJoint';\nimport { TimeStep } from \"../Solver\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\nconst _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\n/**\n * Gear joint definition.\n */\nexport interface GearJointOpt extends JointOpt {\n  /**\n   * The gear ratio. See {@link GearJoint} for explanation.\n   */\n  ratio?: number;\n}\n/**\n * Gear joint definition.\n */\nexport interface GearJointDef extends JointDef, GearJointOpt {\n  /**\n   * The first revolute/prismatic joint attached to the gear joint.\n   */\n  joint1: RevoluteJoint | PrismaticJoint;\n  /**\n   * The second prismatic/revolute joint attached to the gear joint.\n   */\n  joint2: RevoluteJoint | PrismaticJoint;\n}\n\nconst DEFAULTS = {\n  ratio : 1.0\n};\n\n/**\n * A gear joint is used to connect two joints together. Either joint can be a\n * revolute or prismatic joint. You specify a gear ratio to bind the motions\n * together: coordinate1 + ratio * coordinate2 = constant\n *\n * The ratio can be negative or positive. If one joint is a revolute joint and\n * the other joint is a prismatic joint, then the ratio will have units of\n * length or units of 1/length. Warning: You have to manually destroy the gear\n * joint if joint1 or joint2 is destroyed.\n *\n * This definition requires two existing revolute or prismatic joints (any\n * combination will work).\n */\nexport class GearJoint extends Joint {\n  static TYPE = 'gear-joint' as const;\n\n  /** @internal */ m_type: 'gear-joint';\n  /** @internal */ m_joint1: RevoluteJoint | PrismaticJoint;\n  /** @internal */ m_joint2: RevoluteJoint | PrismaticJoint;\n  /** @internal */ m_type1: 'revolute-joint' | 'prismatic-joint';\n  /** @internal */ m_type2: 'revolute-joint' | 'prismatic-joint';\n  /** @internal */ m_bodyC: Body;\n  /** @internal */ m_localAnchorC: Vec2;\n  /** @internal */ m_localAnchorA: Vec2;\n  /** @internal */ m_referenceAngleA: number;\n  /** @internal */ m_localAxisC: Vec2;\n  /** @internal */ m_bodyD: Body;\n  /** @internal */ m_localAnchorD: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n  /** @internal */ m_referenceAngleB: number;\n  /** @internal */ m_localAxisD: Vec2;\n  /** @internal */ m_ratio: number;\n  /** @internal */ m_constant: number;\n  /** @internal */ m_impulse: number;\n\n  // Solver temp\n  /** @internal */ m_lcA: Vec2;\n  /** @internal */ m_lcB: Vec2;\n  /** @internal */ m_lcC: Vec2;\n  /** @internal */ m_lcD: Vec2;\n  /** @internal */ m_mA: number;\n  /** @internal */ m_mB: number;\n  /** @internal */ m_mC: number;\n  /** @internal */ m_mD: number;\n  /** @internal */ m_iA: number;\n  /** @internal */ m_iB: number;\n  /** @internal */ m_iC: number;\n  /** @internal */ m_iD: number;\n  /** @internal */ m_JvAC: Vec2;\n  /** @internal */ m_JvBD: Vec2;\n  /** @internal */ m_JwA: number;\n  /** @internal */ m_JwB: number;\n  /** @internal */ m_JwC: number;\n  /** @internal */ m_JwD: number;\n  /** @internal */ m_mass: number;\n\n  constructor(def: GearJointDef);\n  constructor(def: GearJointOpt, bodyA: Body, bodyB: Body, joint1: RevoluteJoint | PrismaticJoint, joint2: RevoluteJoint | PrismaticJoint, ratio?: number);\n  constructor(def: GearJointDef, bodyA?: Body, bodyB?: Body, joint1?: RevoluteJoint | PrismaticJoint, joint2?: RevoluteJoint | PrismaticJoint, ratio?: number) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof GearJoint)) {\n      return new GearJoint(def, bodyA, bodyB, joint1, joint2, ratio);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = GearJoint.TYPE;\n\n    _ASSERT && console.assert(joint1.m_type === RevoluteJoint.TYPE\n        || joint1.m_type === PrismaticJoint.TYPE);\n    _ASSERT && console.assert(joint2.m_type === RevoluteJoint.TYPE\n        || joint2.m_type === PrismaticJoint.TYPE);\n\n    this.m_joint1 = joint1 ? joint1 : def.joint1;\n    this.m_joint2 = joint2 ? joint2 : def.joint2;\n    this.m_ratio = Math.isFinite(ratio) ? ratio : def.ratio;\n\n    this.m_type1 = this.m_joint1.getType() as 'revolute-joint' | 'prismatic-joint';\n    this.m_type2 = this.m_joint2.getType() as 'revolute-joint' | 'prismatic-joint';\n\n    // joint1 connects body A to body C\n    // joint2 connects body B to body D\n\n    let coordinateA: number;\n    let coordinateB: number;\n\n    // TODO_ERIN there might be some problem with the joint edges in Joint.\n\n    this.m_bodyC = this.m_joint1.getBodyA();\n    this.m_bodyA = this.m_joint1.getBodyB();\n\n    // Get geometry of joint1\n    const xfA = this.m_bodyA.m_xf;\n    const aA = this.m_bodyA.m_sweep.a;\n    const xfC = this.m_bodyC.m_xf;\n    const aC = this.m_bodyC.m_sweep.a;\n\n    if (this.m_type1 === RevoluteJoint.TYPE) {\n      const revolute = this.m_joint1 as RevoluteJoint;\n      this.m_localAnchorC = revolute.m_localAnchorA;\n      this.m_localAnchorA = revolute.m_localAnchorB;\n      this.m_referenceAngleA = revolute.m_referenceAngle;\n      this.m_localAxisC = Vec2.zero();\n\n      coordinateA = aA - aC - this.m_referenceAngleA;\n    } else {\n      const prismatic = this.m_joint1 as PrismaticJoint;\n      this.m_localAnchorC = prismatic.m_localAnchorA;\n      this.m_localAnchorA = prismatic.m_localAnchorB;\n      this.m_referenceAngleA = prismatic.m_referenceAngle;\n      this.m_localAxisC = prismatic.m_localXAxisA;\n\n      const pC = this.m_localAnchorC;\n      const pA = Rot.mulTVec2(xfC.q, Vec2.add(Rot.mulVec2(xfA.q, this.m_localAnchorA), Vec2.sub(xfA.p, xfC.p)));\n      coordinateA = Vec2.dot(pA, this.m_localAxisC) - Vec2.dot(pC, this.m_localAxisC);\n    }\n\n    this.m_bodyD = this.m_joint2.getBodyA();\n    this.m_bodyB = this.m_joint2.getBodyB();\n\n    // Get geometry of joint2\n    const xfB = this.m_bodyB.m_xf;\n    const aB = this.m_bodyB.m_sweep.a;\n    const xfD = this.m_bodyD.m_xf;\n    const aD = this.m_bodyD.m_sweep.a;\n\n    if (this.m_type2 === RevoluteJoint.TYPE) {\n      const revolute = this.m_joint2 as RevoluteJoint;\n      this.m_localAnchorD = revolute.m_localAnchorA;\n      this.m_localAnchorB = revolute.m_localAnchorB;\n      this.m_referenceAngleB = revolute.m_referenceAngle;\n      this.m_localAxisD = Vec2.zero();\n\n      coordinateB = aB - aD - this.m_referenceAngleB;\n    } else {\n      const prismatic = this.m_joint2 as PrismaticJoint;\n      this.m_localAnchorD = prismatic.m_localAnchorA;\n      this.m_localAnchorB = prismatic.m_localAnchorB;\n      this.m_referenceAngleB = prismatic.m_referenceAngle;\n      this.m_localAxisD = prismatic.m_localXAxisA;\n\n      const pD = this.m_localAnchorD;\n      const pB = Rot.mulTVec2(xfD.q, Vec2.add(Rot.mulVec2(xfB.q, this.m_localAnchorB), Vec2.sub(xfB.p, xfD.p)));\n      coordinateB = Vec2.dot(pB, this.m_localAxisD) - Vec2.dot(pD, this.m_localAxisD);\n    }\n\n    this.m_constant = coordinateA + this.m_ratio * coordinateB;\n\n    this.m_impulse = 0.0;\n\n    // Gear Joint:\n    // C0 = (coordinate1 + ratio * coordinate2)_initial\n    // C = (coordinate1 + ratio * coordinate2) - C0 = 0\n    // J = [J1 ratio * J2]\n    // K = J * invM * JT\n    // = J1 * invM1 * J1T + ratio * ratio * J2 * invM2 * J2T\n    //\n    // Revolute:\n    // coordinate = rotation\n    // Cdot = angularVelocity\n    // J = [0 0 1]\n    // K = J * invM * JT = invI\n    //\n    // Prismatic:\n    // coordinate = dot(p - pg, ug)\n    // Cdot = dot(v + cross(w, r), ug)\n    // J = [ug cross(r, ug)]\n    // K = J * invM * JT = invMass + invI * cross(r, ug)^2\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      joint1: this.m_joint1,\n      joint2: this.m_joint2,\n      ratio: this.m_ratio,\n\n      // _constant: this.m_constant,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): GearJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    data.joint1 = restore(Joint, data.joint1, world);\n    data.joint2 = restore(Joint, data.joint2, world);\n    const joint = new GearJoint(data);\n    // if (data._constant) joint.m_constant = data._constant;\n    return joint;\n  }\n\n  /**\n   * Get the first joint.\n   */\n  getJoint1(): Joint {\n    return this.m_joint1;\n  }\n\n  /**\n   * Get the second joint.\n   */\n  getJoint2(): Joint {\n    return this.m_joint2;\n  }\n\n  /**\n   * Set the gear ratio.\n   */\n  setRatio(ratio: number): void {\n    _ASSERT && console.assert(Math.isFinite(ratio));\n    this.m_ratio = ratio;\n  }\n\n  /**\n   * Get the gear ratio.\n   */\n  getRatio(): number {\n    return this.m_ratio;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.mulNumVec2(this.m_impulse, this.m_JvAC).mul(inv_dt);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    const L = this.m_impulse * this.m_JwA; // float\n    return inv_dt * L;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_lcA = this.m_bodyA.m_sweep.localCenter;\n    this.m_lcB = this.m_bodyB.m_sweep.localCenter;\n    this.m_lcC = this.m_bodyC.m_sweep.localCenter;\n    this.m_lcD = this.m_bodyD.m_sweep.localCenter;\n    this.m_mA = this.m_bodyA.m_invMass;\n    this.m_mB = this.m_bodyB.m_invMass;\n    this.m_mC = this.m_bodyC.m_invMass;\n    this.m_mD = this.m_bodyD.m_invMass;\n    this.m_iA = this.m_bodyA.m_invI;\n    this.m_iB = this.m_bodyB.m_invI;\n    this.m_iC = this.m_bodyC.m_invI;\n    this.m_iD = this.m_bodyD.m_invI;\n\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const aC = this.m_bodyC.c_position.a;\n    const vC = this.m_bodyC.c_velocity.v;\n    let wC = this.m_bodyC.c_velocity.w;\n\n    const aD = this.m_bodyD.c_position.a;\n    const vD = this.m_bodyD.c_velocity.v;\n    let wD = this.m_bodyD.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n    const qC = Rot.neo(aC);\n    const qD = Rot.neo(aD);\n\n    this.m_mass = 0.0;\n\n    if (this.m_type1 == RevoluteJoint.TYPE) {\n      this.m_JvAC = Vec2.zero();\n      this.m_JwA = 1.0;\n      this.m_JwC = 1.0;\n      this.m_mass += this.m_iA + this.m_iC;\n    } else {\n      const u = Rot.mulVec2(qC, this.m_localAxisC); // Vec2\n      const rC = Rot.mulSub(qC, this.m_localAnchorC, this.m_lcC); // Vec2\n      const rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_lcA); // Vec2\n      this.m_JvAC = u;\n      this.m_JwC = Vec2.crossVec2Vec2(rC, u);\n      this.m_JwA = Vec2.crossVec2Vec2(rA, u);\n      this.m_mass += this.m_mC + this.m_mA + this.m_iC * this.m_JwC * this.m_JwC + this.m_iA * this.m_JwA * this.m_JwA;\n    }\n\n    if (this.m_type2 == RevoluteJoint.TYPE) {\n      this.m_JvBD = Vec2.zero();\n      this.m_JwB = this.m_ratio;\n      this.m_JwD = this.m_ratio;\n      this.m_mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);\n    } else {\n      const u = Rot.mulVec2(qD, this.m_localAxisD); // Vec2\n      const rD = Rot.mulSub(qD, this.m_localAnchorD, this.m_lcD); // Vec2\n      const rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_lcB); // Vec2\n      this.m_JvBD = Vec2.mulNumVec2(this.m_ratio, u);\n      this.m_JwD = this.m_ratio * Vec2.crossVec2Vec2(rD, u);\n      this.m_JwB = this.m_ratio * Vec2.crossVec2Vec2(rB, u);\n      this.m_mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * this.m_JwD * this.m_JwD + this.m_iB * this.m_JwB * this.m_JwB;\n    }\n\n    // Compute effective mass.\n    this.m_mass = this.m_mass > 0.0 ? 1.0 / this.m_mass : 0.0;\n\n    if (step.warmStarting) {\n      vA.addMul(this.m_mA * this.m_impulse, this.m_JvAC);\n      wA += this.m_iA * this.m_impulse * this.m_JwA;\n\n      vB.addMul(this.m_mB * this.m_impulse, this.m_JvBD);\n      wB += this.m_iB * this.m_impulse * this.m_JwB;\n\n      vC.subMul(this.m_mC * this.m_impulse, this.m_JvAC);\n      wC -= this.m_iC * this.m_impulse * this.m_JwC;\n\n      vD.subMul(this.m_mD * this.m_impulse, this.m_JvBD);\n      wD -= this.m_iD * this.m_impulse * this.m_JwD;\n\n    } else {\n      this.m_impulse = 0.0;\n    }\n\n    this.m_bodyA.c_velocity.v.setVec2(vA);\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v.setVec2(vB);\n    this.m_bodyB.c_velocity.w = wB;\n    this.m_bodyC.c_velocity.v.setVec2(vC);\n    this.m_bodyC.c_velocity.w = wC;\n    this.m_bodyD.c_velocity.v.setVec2(vD);\n    this.m_bodyD.c_velocity.w = wD;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n    const vC = this.m_bodyC.c_velocity.v;\n    let wC = this.m_bodyC.c_velocity.w;\n    const vD = this.m_bodyD.c_velocity.v;\n    let wD = this.m_bodyD.c_velocity.w;\n\n    let Cdot = Vec2.dot(this.m_JvAC, vA) - Vec2.dot(this.m_JvAC, vC)\n        + Vec2.dot(this.m_JvBD, vB) - Vec2.dot(this.m_JvBD, vD); // float\n    Cdot += (this.m_JwA * wA - this.m_JwC * wC)\n        + (this.m_JwB * wB - this.m_JwD * wD);\n\n    const impulse = -this.m_mass * Cdot; // float\n    this.m_impulse += impulse;\n\n    vA.addMul(this.m_mA * impulse, this.m_JvAC);\n    wA += this.m_iA * impulse * this.m_JwA;\n    vB.addMul(this.m_mB * impulse, this.m_JvBD);\n    wB += this.m_iB * impulse * this.m_JwB;\n    vC.subMul(this.m_mC * impulse, this.m_JvAC);\n    wC -= this.m_iC * impulse * this.m_JwC;\n    vD.subMul(this.m_mD * impulse, this.m_JvBD);\n    wD -= this.m_iD * impulse * this.m_JwD;\n\n    this.m_bodyA.c_velocity.v.setVec2(vA);\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v.setVec2(vB);\n    this.m_bodyB.c_velocity.w = wB;\n    this.m_bodyC.c_velocity.v.setVec2(vC);\n    this.m_bodyC.c_velocity.w = wC;\n    this.m_bodyD.c_velocity.v.setVec2(vD);\n    this.m_bodyD.c_velocity.w = wD;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    const cA = this.m_bodyA.c_position.c;\n    let aA = this.m_bodyA.c_position.a;\n    const cB = this.m_bodyB.c_position.c;\n    let aB = this.m_bodyB.c_position.a;\n    const cC = this.m_bodyC.c_position.c;\n    let aC = this.m_bodyC.c_position.a;\n    const cD = this.m_bodyD.c_position.c;\n    let aD = this.m_bodyD.c_position.a;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n    const qC = Rot.neo(aC);\n    const qD = Rot.neo(aD);\n\n    const linearError = 0.0;\n\n    let coordinateA: number;\n    let coordinateB: number;\n\n    let JvAC: Vec2;\n    let JvBD: Vec2;\n    let JwA: number;\n    let JwB: number;\n    let JwC: number;\n    let JwD: number;\n    let mass = 0.0;\n\n    if (this.m_type1 == RevoluteJoint.TYPE) {\n      JvAC = Vec2.zero();\n      JwA = 1.0;\n      JwC = 1.0;\n      mass += this.m_iA + this.m_iC;\n\n      coordinateA = aA - aC - this.m_referenceAngleA;\n    } else {\n      const u = Rot.mulVec2(qC, this.m_localAxisC); // Vec2\n      const rC = Rot.mulSub(qC, this.m_localAnchorC, this.m_lcC); // Vec2\n      const rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_lcA); // Vec2\n      JvAC = u;\n      JwC = Vec2.crossVec2Vec2(rC, u);\n      JwA = Vec2.crossVec2Vec2(rA, u);\n      mass += this.m_mC + this.m_mA + this.m_iC * JwC * JwC + this.m_iA * JwA * JwA;\n\n      const pC = Vec2.sub(this.m_localAnchorC, this.m_lcC); // Vec2\n      const pA = Rot.mulTVec2(qC, Vec2.add(rA, Vec2.sub(cA, cC))); // Vec2\n      coordinateA = Vec2.dot(Vec2.sub(pA, pC), this.m_localAxisC);\n    }\n\n    if (this.m_type2 == RevoluteJoint.TYPE) {\n      JvBD = Vec2.zero();\n      JwB = this.m_ratio;\n      JwD = this.m_ratio;\n      mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);\n\n      coordinateB = aB - aD - this.m_referenceAngleB;\n    } else {\n      const u = Rot.mulVec2(qD, this.m_localAxisD);\n      const rD = Rot.mulSub(qD, this.m_localAnchorD, this.m_lcD);\n      const rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_lcB);\n      JvBD = Vec2.mulNumVec2(this.m_ratio, u);\n      JwD = this.m_ratio * Vec2.crossVec2Vec2(rD, u);\n      JwB = this.m_ratio * Vec2.crossVec2Vec2(rB, u);\n      mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD\n          * JwD * JwD + this.m_iB * JwB * JwB;\n\n      const pD = Vec2.sub(this.m_localAnchorD, this.m_lcD); // Vec2\n      const pB = Rot.mulTVec2(qD, Vec2.add(rB, Vec2.sub(cB, cD))); // Vec2\n      coordinateB = Vec2.dot(pB, this.m_localAxisD)\n          - Vec2.dot(pD, this.m_localAxisD);\n    }\n\n    const C = (coordinateA + this.m_ratio * coordinateB) - this.m_constant; // float\n\n    let impulse = 0.0; // float\n    if (mass > 0.0) {\n      impulse = -C / mass;\n    }\n\n    cA.addMul(this.m_mA * impulse, JvAC);\n    aA += this.m_iA * impulse * JwA;\n    cB.addMul(this.m_mB * impulse, JvBD);\n    aB += this.m_iB * impulse * JwB;\n    cC.subMul(this.m_mC * impulse, JvAC);\n    aC -= this.m_iC * impulse * JwC;\n    cD.subMul(this.m_mD * impulse, JvBD);\n    aD -= this.m_iD * impulse * JwD;\n\n    this.m_bodyA.c_position.c.setVec2(cA);\n    this.m_bodyA.c_position.a = aA;\n    this.m_bodyB.c_position.c.setVec2(cB);\n    this.m_bodyB.c_position.a = aB;\n    this.m_bodyC.c_position.c.setVec2(cC);\n    this.m_bodyC.c_position.a = aC;\n    this.m_bodyD.c_position.c.setVec2(cD);\n    this.m_bodyD.c_position.a = aD;\n\n    // TODO_ERIN not implemented\n    return linearError < Settings.linearSlop;\n  }\n\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { options } from '../../util/options';\nimport { math as Math } from '../../common/Math';\nimport { Vec2 } from '../../common/Vec2';\nimport { Mat22 } from '../../common/Mat22';\nimport { Rot } from '../../common/Rot';\nimport { Joint, JointOpt, JointDef } from '../Joint';\nimport { Body } from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\nconst _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\n/**\n * Motor joint definition.\n */\nexport interface MotorJointOpt extends JointOpt {\n  /**\n   * The bodyB angle minus bodyA angle in radians.\n   */\n  angularOffset?: number;\n  /**\n   * The maximum motor force in N.\n   */\n  maxForce?: number;\n  /**\n   * The maximum motor torque in N-m.\n   */\n  maxTorque?: number;\n  /**\n   * Position correction factor in the range [0,1].\n   */\n  correctionFactor?: number;\n  /**\n   * Position of bodyB minus the position of bodyA, in bodyA's frame, in meters.\n   */\n  linearOffset?: Vec2;\n}\n/**\n * Motor joint definition.\n */\nexport interface MotorJointDef extends JointDef, MotorJointOpt {\n}\n\nconst DEFAULTS = {\n  maxForce : 1.0,\n  maxTorque : 1.0,\n  correctionFactor : 0.3\n};\n\n/**\n * A motor joint is used to control the relative motion between two bodies. A\n * typical usage is to control the movement of a dynamic body with respect to\n * the ground.\n */\nexport class MotorJoint extends Joint {\n  static TYPE = 'motor-joint' as const;\n\n  /** @internal */ m_type: 'motor-joint';\n  /** @internal */ m_linearOffset: Vec2;\n  /** @internal */ m_angularOffset: number;\n  /** @internal */ m_linearImpulse: Vec2;\n  /** @internal */ m_angularImpulse: number;\n  /** @internal */ m_maxForce: number;\n  /** @internal */ m_maxTorque: number;\n  /** @internal */ m_correctionFactor: number;\n\n  // Solver temp\n  /** @internal */ m_rA: Vec2;\n  /** @internal */ m_rB: Vec2;\n  /** @internal */ m_localCenterA: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_linearError: Vec2;\n  /** @internal */ m_angularError: number;\n  /** @internal */ m_invMassA: number;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIA: number;\n  /** @internal */ m_invIB: number;\n  /** @internal */ m_linearMass: Mat22;\n  /** @internal */ m_angularMass: number;\n\n  constructor(def: MotorJointDef);\n  constructor(def: MotorJointOpt, bodyA: Body, bodyB: Body);\n  constructor(def: MotorJointDef | MotorJointOpt, bodyA?: Body, bodyB?: Body) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof MotorJoint)) {\n      return new MotorJoint(def, bodyA, bodyB);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = MotorJoint.TYPE;\n\n    this.m_linearOffset = Math.isFinite(def.linearOffset) ? def.linearOffset : bodyA.getLocalPoint(bodyB.getPosition());\n    this.m_angularOffset = Math.isFinite(def.angularOffset) ? def.angularOffset : bodyB.getAngle() - bodyA.getAngle();\n\n    this.m_linearImpulse = Vec2.zero();\n    this.m_angularImpulse = 0.0;\n\n    this.m_maxForce = def.maxForce;\n    this.m_maxTorque = def.maxTorque;\n    this.m_correctionFactor = def.correctionFactor;\n\n    // Point-to-point constraint\n    // Cdot = v2 - v1\n    // = v2 + cross(w2, r2) - v1 - cross(w1, r1)\n    // J = [-I -r1_skew I r2_skew ]\n    // Identity used:\n    // w k % (rx i + ry j) = w * (-ry i + rx j)\n    //\n    // r1 = offset - c1\n    // r2 = -c2\n\n    // Angle constraint\n    // Cdot = w2 - w1\n    // J = [0 0 -1 0 0 1]\n    // K = invI1 + invI2\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      maxForce: this.m_maxForce,\n      maxTorque: this.m_maxTorque,\n      correctionFactor: this.m_correctionFactor,\n\n      linearOffset: this.m_linearOffset,\n      angularOffset: this.m_angularOffset,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): MotorJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    const joint = new MotorJoint(data);\n    return joint;\n  }\n\n  /** @internal */\n  _setAnchors(def: {}): void {\n  }\n\n  /**\n   * Set the maximum friction force in N.\n   */\n  setMaxForce(force: number): void {\n    _ASSERT && console.assert(Math.isFinite(force) && force >= 0.0);\n    this.m_maxForce = force;\n  }\n\n  /**\n   * Get the maximum friction force in N.\n   */\n  getMaxForce(): number {\n    return this.m_maxForce;\n  }\n\n  /**\n   * Set the maximum friction torque in N*m.\n   */\n  setMaxTorque(torque: number): void {\n    _ASSERT && console.assert(Math.isFinite(torque) && torque >= 0.0);\n    this.m_maxTorque = torque;\n  }\n\n  /**\n   * Get the maximum friction torque in N*m.\n   */\n  getMaxTorque(): number {\n    return this.m_maxTorque;\n  }\n\n  /**\n   * Set the position correction factor in the range [0,1].\n   */\n  setCorrectionFactor(factor: number): void {\n    _ASSERT && console.assert(Math.isFinite(factor) && 0.0 <= factor && factor <= 1.0);\n    this.m_correctionFactor = factor;\n  }\n\n  /**\n   * Get the position correction factor in the range [0,1].\n   */\n  getCorrectionFactor(): number {\n    return this.m_correctionFactor;\n  }\n\n  /**\n   * Set/get the target linear offset, in frame A, in meters.\n   */\n  setLinearOffset(linearOffset: Vec2): void {\n    if (linearOffset.x != this.m_linearOffset.x\n        || linearOffset.y != this.m_linearOffset.y) {\n      this.m_bodyA.setAwake(true);\n      this.m_bodyB.setAwake(true);\n      this.m_linearOffset = linearOffset;\n    }\n  }\n\n  getLinearOffset(): Vec2 {\n    return this.m_linearOffset;\n  }\n\n  /**\n   * Set/get the target angular offset, in radians.\n   */\n  setAngularOffset(angularOffset: number): void {\n    if (angularOffset != this.m_angularOffset) {\n      this.m_bodyA.setAwake(true);\n      this.m_bodyB.setAwake(true);\n      this.m_angularOffset = angularOffset;\n    }\n  }\n\n  getAngularOffset(): number {\n    return this.m_angularOffset;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getPosition();\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getPosition();\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.mulNumVec2(inv_dt, this.m_linearImpulse);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return inv_dt * this.m_angularImpulse;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassA = this.m_bodyA.m_invMass;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIA = this.m_bodyA.m_invI;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const cA = this.m_bodyA.c_position.c;\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const cB = this.m_bodyB.c_position.c;\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    // Compute the effective mass matrix.\n    this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_linearOffset, this.m_localCenterA));\n    this.m_rB = Rot.mulVec2(qB, Vec2.neg(this.m_localCenterB));\n\n    // J = [-I -r1_skew I r2_skew]\n    // r_skew = [-ry; rx]\n\n    // Matlab\n    // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]\n    // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]\n    // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    // Upper 2 by 2 of K for point to point\n    const K = new Mat22();\n    K.ex.x = mA + mB + iA * this.m_rA.y * this.m_rA.y + iB * this.m_rB.y * this.m_rB.y;\n    K.ex.y = -iA * this.m_rA.x * this.m_rA.y - iB * this.m_rB.x * this.m_rB.y;\n    K.ey.x = K.ex.y;\n    K.ey.y = mA + mB + iA * this.m_rA.x * this.m_rA.x + iB * this.m_rB.x * this.m_rB.x;\n\n    this.m_linearMass = K.getInverse();\n\n    this.m_angularMass = iA + iB;\n    if (this.m_angularMass > 0.0) {\n      this.m_angularMass = 1.0 / this.m_angularMass;\n    }\n\n    this.m_linearError = Vec2.zero();\n    this.m_linearError.addCombine(1, cB, 1, this.m_rB);\n    this.m_linearError.subCombine(1, cA, 1, this.m_rA);\n\n    this.m_angularError = aB - aA - this.m_angularOffset;\n\n    if (step.warmStarting) {\n      // Scale impulses to support a variable time step.\n      this.m_linearImpulse.mul(step.dtRatio);\n      this.m_angularImpulse *= step.dtRatio;\n\n      const P = Vec2.neo(this.m_linearImpulse.x, this.m_linearImpulse.y);\n\n      vA.subMul(mA, P);\n      wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + this.m_angularImpulse);\n\n      vB.addMul(mB, P);\n      wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + this.m_angularImpulse);\n\n    } else {\n      this.m_linearImpulse.setZero();\n      this.m_angularImpulse = 0.0;\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    const h = step.dt;\n    const inv_h = step.inv_dt;\n\n    // Solve angular friction\n    {\n      const Cdot = wB - wA + inv_h * this.m_correctionFactor * this.m_angularError;\n      let impulse = -this.m_angularMass * Cdot;\n\n      const oldImpulse = this.m_angularImpulse;\n      const maxImpulse = h * this.m_maxTorque;\n      this.m_angularImpulse = Math.clamp(this.m_angularImpulse + impulse,\n          -maxImpulse, maxImpulse);\n      impulse = this.m_angularImpulse - oldImpulse;\n\n      wA -= iA * impulse;\n      wB += iB * impulse;\n    }\n\n    // Solve linear friction\n    {\n      const Cdot = Vec2.zero();\n      Cdot.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, this.m_rB));\n      Cdot.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, this.m_rA));\n      Cdot.addMul(inv_h * this.m_correctionFactor, this.m_linearError);\n\n      let impulse = Vec2.neg(Mat22.mulVec2(this.m_linearMass, Cdot));\n      const oldImpulse = Vec2.clone(this.m_linearImpulse);\n      this.m_linearImpulse.add(impulse);\n\n      const maxImpulse = h * this.m_maxForce;\n\n      this.m_linearImpulse.clamp(maxImpulse);\n\n      impulse = Vec2.sub(this.m_linearImpulse, oldImpulse);\n\n      vA.subMul(mA, impulse);\n      wA -= iA * Vec2.crossVec2Vec2(this.m_rA, impulse);\n\n      vB.addMul(mB, impulse);\n      wB += iB * Vec2.crossVec2Vec2(this.m_rB, impulse);\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    return true;\n  }\n\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { options } from '../../util/options';\nimport { math as Math } from '../../common/Math';\nimport { Vec2, Vec2Value } from '../../common/Vec2';\nimport { Mat22 } from '../../common/Mat22';\nimport { Rot } from '../../common/Rot';\nimport { Transform } from '../../common/Transform';\nimport { Joint, JointOpt, JointDef } from '../Joint';\nimport { Body } from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\nconst _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\n/**\n * Mouse joint definition. This requires a world target point, tuning\n * parameters, and the time step.\n */\nexport interface MouseJointOpt extends JointOpt {\n  /**\n   * [maxForce = 0.0] The maximum constraint force that can be exerted to move\n   * the candidate body. Usually you will express as some multiple of the\n   * weight (multiplier * mass * gravity).\n   */\n  maxForce?: number;\n  /**\n   * [frequencyHz = 5.0] The response speed.\n   */\n  frequencyHz?: number;\n  /**\n   * [dampingRatio = 0.7] The damping ratio. 0 = no damping, 1 = critical\n   * damping.\n   */\n  dampingRatio?: number;\n}\n/**\n * Mouse joint definition. This requires a world target point, tuning\n * parameters, and the time step.\n */\nexport interface MouseJointDef extends JointDef, MouseJointOpt {\n  /**\n   * The initial world target point. This is assumed to coincide with the body\n   * anchor initially.\n   */\n  target: Vec2Value;\n}\n\nconst DEFAULTS = {\n  maxForce : 0.0,\n  frequencyHz : 5.0,\n  dampingRatio : 0.7\n};\n\n/**\n * A mouse joint is used to make a point on a body track a specified world\n * point. This a soft constraint with a maximum force. This allows the\n * constraint to stretch and without applying huge forces.\n *\n * NOTE: this joint is not documented in the manual because it was developed to\n * be used in the testbed. If you want to learn how to use the mouse joint, look\n * at the testbed.\n */\nexport class MouseJoint extends Joint {\n  static TYPE = 'mouse-joint' as const;\n\n  /** @internal */ m_type: 'mouse-joint';\n  /** @internal */ m_targetA: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n  /** @internal */ m_maxForce: number;\n  /** @internal */ m_impulse: Vec2;\n  /** @internal */ m_frequencyHz: number;\n  /** @internal */ m_dampingRatio: number;\n  /** @internal */ m_beta: number;\n  /** @internal */ m_gamma: number;\n  // Solver temp\n  /** @internal */ m_rB: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIB: number;\n  /** @internal */ m_mass: Mat22;\n  /** @internal */ m_C: Vec2;\n\n  constructor(def: MouseJointDef);\n  constructor(def: MouseJointOpt, bodyA: Body, bodyB: Body, target: Vec2);\n  constructor(def: MouseJointDef, bodyA?: Body, bodyB?: Body, target?: Vec2) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof MouseJoint)) {\n      return new MouseJoint(def, bodyA, bodyB, target);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = MouseJoint.TYPE;\n\n    _ASSERT && console.assert(Math.isFinite(def.maxForce) && def.maxForce >= 0.0);\n    _ASSERT && console.assert(Math.isFinite(def.frequencyHz) && def.frequencyHz >= 0.0);\n    _ASSERT && console.assert(Math.isFinite(def.dampingRatio) && def.dampingRatio >= 0.0);\n\n    if (Vec2.isValid(target)) {\n      this.m_targetA = Vec2.clone(target);\n    } else if (Vec2.isValid(def.target)) {\n      this.m_targetA = Vec2.clone(def.target);\n    } else {\n      this.m_targetA = Vec2.zero();\n    }\n\n    this.m_localAnchorB = Transform.mulTVec2(bodyB.getTransform(), this.m_targetA);\n\n    this.m_maxForce = def.maxForce;\n    this.m_impulse = Vec2.zero();\n\n    this.m_frequencyHz = def.frequencyHz;\n    this.m_dampingRatio = def.dampingRatio;\n\n    this.m_beta = 0.0;\n    this.m_gamma = 0.0;\n\n    // Solver temp\n    this.m_rB = Vec2.zero();\n    this.m_localCenterB = Vec2.zero();\n    this.m_invMassB = 0.0;\n    this.m_invIB = 0.0;\n    this.m_mass = new Mat22();\n    this.m_C = Vec2.zero();\n\n    // p = attached point, m = mouse point\n    // C = p - m\n    // Cdot = v\n    // = v + cross(w, r)\n    // J = [I r_skew]\n    // Identity used:\n    // w k % (rx i + ry j) = w * (-ry i + rx j)\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      target: this.m_targetA,\n      maxForce: this.m_maxForce,\n      frequencyHz: this.m_frequencyHz,\n      dampingRatio: this.m_dampingRatio,\n\n      _localAnchorB: this.m_localAnchorB,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): MouseJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    data.target = Vec2.clone(data.target);\n    const joint = new MouseJoint(data);\n    if (data._localAnchorB) {\n      joint.m_localAnchorB = data._localAnchorB;\n    }\n    return joint;\n  }\n\n  /**\n   * Use this to update the target point.\n   */\n  setTarget(target: Vec2Value): void {\n    if (Vec2.areEqual(target, this.m_targetA)) return;\n    this.m_bodyB.setAwake(true);\n    this.m_targetA = Vec2.clone(target);\n  }\n\n  getTarget(): Vec2 {\n    return this.m_targetA;\n  }\n\n  /**\n   * Set the maximum force in Newtons.\n   */\n  setMaxForce(force: number): void {\n    this.m_maxForce = force;\n  }\n\n  /**\n   * Get the maximum force in Newtons.\n   */\n  getMaxForce(): number {\n    return this.m_maxForce;\n  }\n\n  /**\n   * Set the frequency in Hertz.\n   */\n  setFrequency(hz: number): void {\n    this.m_frequencyHz = hz;\n  }\n\n  /**\n   * Get the frequency in Hertz.\n   */\n  getFrequency(): number {\n    return this.m_frequencyHz;\n  }\n\n  /**\n   * Set the damping ratio (dimensionless).\n   */\n  setDampingRatio(ratio: number): void {\n    this.m_dampingRatio = ratio;\n  }\n\n  /**\n   * Get the damping ratio (dimensionless).\n   */\n  getDampingRatio(): number {\n    return this.m_dampingRatio;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return Vec2.clone(this.m_targetA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.mulNumVec2(inv_dt, this.m_impulse);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return inv_dt * 0.0;\n  }\n\n  /**\n   * Shift the origin for any points stored in world coordinates.\n   */\n  shiftOrigin(newOrigin: Vec2Value): void {\n    this.m_targetA.sub(newOrigin);\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const position = this.m_bodyB.c_position;\n    const velocity = this.m_bodyB.c_velocity;\n\n    const cB = position.c;\n    const aB = position.a;\n    const vB = velocity.v;\n    let wB = velocity.w;\n\n    const qB = Rot.neo(aB);\n\n    const mass = this.m_bodyB.getMass();\n\n    // Frequency\n    const omega = 2.0 * Math.PI * this.m_frequencyHz;\n\n    // Damping coefficient\n    const d = 2.0 * mass * this.m_dampingRatio * omega;\n\n    // Spring stiffness\n    const k = mass * (omega * omega);\n\n    // magic formulas\n    // gamma has units of inverse mass.\n    // beta has units of inverse time.\n    const h = step.dt;\n    _ASSERT && console.assert(d + h * k > Math.EPSILON);\n    this.m_gamma = h * (d + h * k);\n    if (this.m_gamma != 0.0) {\n      this.m_gamma = 1.0 / this.m_gamma;\n    }\n    this.m_beta = h * k * this.m_gamma;\n\n    // Compute the effective mass matrix.\n    this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n\n    // K = [(1/m1 + 1/m2) * eye(2) - skew(r1) * invI1 * skew(r1) - skew(r2) *\n    // invI2 * skew(r2)]\n    // = [1/m1+1/m2 0 ] + invI1 * [r1.y*r1.y -r1.x*r1.y] + invI2 * [r1.y*r1.y\n    // -r1.x*r1.y]\n    // [ 0 1/m1+1/m2] [-r1.x*r1.y r1.x*r1.x] [-r1.x*r1.y r1.x*r1.x]\n    const K = new Mat22();\n    K.ex.x = this.m_invMassB + this.m_invIB * this.m_rB.y * this.m_rB.y\n        + this.m_gamma;\n    K.ex.y = -this.m_invIB * this.m_rB.x * this.m_rB.y;\n    K.ey.x = K.ex.y;\n    K.ey.y = this.m_invMassB + this.m_invIB * this.m_rB.x * this.m_rB.x\n        + this.m_gamma;\n\n    this.m_mass = K.getInverse();\n\n    this.m_C.setVec2(cB);\n    this.m_C.addCombine(1, this.m_rB, -1, this.m_targetA);\n    this.m_C.mul(this.m_beta);\n\n    // Cheat with some damping\n    wB *= 0.98;\n\n    if (step.warmStarting) {\n      this.m_impulse.mul(step.dtRatio);\n      vB.addMul(this.m_invMassB, this.m_impulse);\n      wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, this.m_impulse);\n\n    } else {\n      this.m_impulse.setZero();\n    }\n\n    velocity.v.setVec2(vB);\n    velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const velocity = this.m_bodyB.c_velocity;\n    const vB = Vec2.clone(velocity.v);\n    let wB = velocity.w;\n\n    // Cdot = v + cross(w, r)\n\n    const Cdot = Vec2.crossNumVec2(wB, this.m_rB);\n    Cdot.add(vB);\n\n    Cdot.addCombine(1, this.m_C, this.m_gamma, this.m_impulse);\n    Cdot.neg();\n\n    let impulse = Mat22.mulVec2(this.m_mass, Cdot);\n\n    const oldImpulse = Vec2.clone(this.m_impulse);\n    this.m_impulse.add(impulse);\n    const maxImpulse = step.dt * this.m_maxForce;\n    this.m_impulse.clamp(maxImpulse);\n    impulse = Vec2.sub(this.m_impulse, oldImpulse);\n\n    vB.addMul(this.m_invMassB, impulse);\n    wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, impulse);\n\n    velocity.v.setVec2(vB);\n    velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    return true;\n  }\n\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { options } from '../../util/options';\nimport { SettingsInternal as Settings } from '../../Settings';\nimport { math as Math } from '../../common/Math';\nimport { Vec2 } from '../../common/Vec2';\nimport { Rot } from '../../common/Rot';\nimport { Joint, JointOpt, JointDef } from '../Joint';\nimport { Body } from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\nconst _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\n/**\n * Pulley joint definition. This requires two ground anchors, two dynamic body\n * anchor points, and a pulley ratio.\n */\n// tslint:disable-next-line:no-empty-interface\nexport interface PulleyJointOpt extends JointOpt {\n}\n/**\n * Pulley joint definition. This requires two ground anchors, two dynamic body\n * anchor points, and a pulley ratio.\n */\nexport interface PulleyJointDef extends JointDef, PulleyJointOpt {\n  /**\n   * The first ground anchor in world coordinates. This point never moves.\n   */\n  groundAnchorA: Vec2;\n  /**\n   * The second ground anchor in world coordinates. This point never moves.\n   */\n  groundAnchorB: Vec2;\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  localAnchorA: Vec2;\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  localAnchorB: Vec2;\n  /**\n   * The reference length for the segment attached to bodyA.\n   */\n  lengthA: number;\n  /**\n   * The reference length for the segment attached to bodyB.\n   */\n  lengthB: number;\n  /**\n   * The pulley ratio, used to simulate a block-and-tackle.\n   */\n  ratio: number;\n}\n\nconst DEFAULTS = {\n  collideConnected : true\n};\n\n/**\n * The pulley joint is connected to two bodies and two fixed ground points. The\n * pulley supports a ratio such that: length1 + ratio * length2 <= constant\n *\n * Yes, the force transmitted is scaled by the ratio.\n *\n * Warning: the pulley joint can get a bit squirrelly by itself. They often work\n * better when combined with prismatic joints. You should also cover the the\n * anchor points with static shapes to prevent one side from going to zero\n * length.\n */\nexport class PulleyJoint extends Joint {\n  static TYPE = 'pulley-joint' as const;\n  // static MIN_PULLEY_LENGTH: number = 2.0; // TODO where this is used?\n\n  /** @internal */ m_type: 'pulley-joint';\n  /** @internal */ m_groundAnchorA: Vec2;\n  /** @internal */ m_groundAnchorB: Vec2;\n  /** @internal */ m_localAnchorA: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n  /** @internal */ m_lengthA: number;\n  /** @internal */ m_lengthB: number;\n  /** @internal */ m_ratio: number;\n  /** @internal */ m_constant: number;\n  /** @internal */ m_impulse: number;\n\n  // Solver temp\n  /** @internal */ m_uA: Vec2;\n  /** @internal */ m_uB: Vec2;\n  /** @internal */ m_rA: Vec2;\n  /** @internal */ m_rB: Vec2;\n  /** @internal */ m_localCenterA: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_invMassA: number;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIA: number;\n  /** @internal */ m_invIB: number;\n  /** @internal */ m_mass: number;\n\n  constructor(def: PulleyJointDef);\n  constructor(def: PulleyJointOpt, bodyA: Body, bodyB: Body, groundA: Vec2, groundB: Vec2, anchorA: Vec2, anchorB: Vec2, ratio: number);\n  constructor(def: PulleyJointDef, bodyA?: Body, bodyB?: Body, groundA?: Vec2, groundB?: Vec2, anchorA?: Vec2, anchorB?: Vec2, ratio?: number) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof PulleyJoint)) {\n      return new PulleyJoint(def, bodyA, bodyB, groundA, groundB, anchorA, anchorB, ratio);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = PulleyJoint.TYPE;\n    this.m_groundAnchorA = groundA ? groundA : def.groundAnchorA || Vec2.neo(-1.0, 1.0);\n    this.m_groundAnchorB = groundB ? groundB : def.groundAnchorB || Vec2.neo(1.0, 1.0);\n    this.m_localAnchorA = anchorA ? bodyA.getLocalPoint(anchorA) : def.localAnchorA || Vec2.neo(-1.0, 0.0);\n    this.m_localAnchorB = anchorB ? bodyB.getLocalPoint(anchorB) : def.localAnchorB || Vec2.neo(1.0, 0.0);\n    this.m_lengthA = Math.isFinite(def.lengthA) ? def.lengthA : Vec2.distance(anchorA, groundA);\n    this.m_lengthB = Math.isFinite(def.lengthB) ? def.lengthB : Vec2.distance(anchorB, groundB);\n    this.m_ratio = Math.isFinite(ratio) ? ratio : def.ratio;\n\n    _ASSERT && console.assert(ratio > Math.EPSILON);\n\n    this.m_constant = this.m_lengthA + this.m_ratio * this.m_lengthB;\n\n    this.m_impulse = 0.0;\n\n    // Pulley:\n    // length1 = norm(p1 - s1)\n    // length2 = norm(p2 - s2)\n    // C0 = (length1 + ratio * length2)_initial\n    // C = C0 - (length1 + ratio * length2)\n    // u1 = (p1 - s1) / norm(p1 - s1)\n    // u2 = (p2 - s2) / norm(p2 - s2)\n    // Cdot = -dot(u1, v1 + cross(w1, r1)) - ratio * dot(u2, v2 + cross(w2, r2))\n    // J = -[u1 cross(r1, u1) ratio * u2 ratio * cross(r2, u2)]\n    // K = J * invM * JT\n    // = invMass1 + invI1 * cross(r1, u1)^2 + ratio^2 * (invMass2 + invI2 *\n    // cross(r2, u2)^2)\n  }\n\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      groundAnchorA: this.m_groundAnchorA,\n      groundAnchorB: this.m_groundAnchorB,\n      localAnchorA: this.m_localAnchorA,\n      localAnchorB: this.m_localAnchorB,\n      lengthA: this.m_lengthA,\n      lengthB: this.m_lengthB,\n      ratio: this.m_ratio,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): PulleyJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    const joint = new PulleyJoint(data);\n    return joint;\n  }\n\n  /**\n   * Get the first ground anchor.\n   */\n  getGroundAnchorA(): Vec2 {\n    return this.m_groundAnchorA;\n  }\n\n  /**\n   * Get the second ground anchor.\n   */\n  getGroundAnchorB(): Vec2 {\n    return this.m_groundAnchorB;\n  }\n\n  /**\n   * Get the current length of the segment attached to bodyA.\n   */\n  getLengthA(): number {\n    return this.m_lengthA;\n  }\n\n  /**\n   * Get the current length of the segment attached to bodyB.\n   */\n  getLengthB(): number {\n    return this.m_lengthB;\n  }\n\n  /**\n   * Get the pulley ratio.\n   */\n  getRatio(): number {\n    return this.m_ratio;\n  }\n\n  /**\n   * Get the current length of the segment attached to bodyA.\n   */\n  getCurrentLengthA(): number {\n    const p = this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n    const s = this.m_groundAnchorA;\n    return Vec2.distance(p, s);\n  }\n\n  /**\n   * Get the current length of the segment attached to bodyB.\n   */\n  getCurrentLengthB(): number {\n    const p = this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n    const s = this.m_groundAnchorB;\n    return Vec2.distance(p, s);\n  }\n\n  /**\n   * Shift the origin for any points stored in world coordinates.\n   *\n   * @param newOrigin\n   */\n  shiftOrigin(newOrigin: Vec2): void {\n    this.m_groundAnchorA.sub(newOrigin);\n    this.m_groundAnchorB.sub(newOrigin);\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.mulNumVec2(this.m_impulse, this.m_uB).mul(inv_dt);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return 0.0;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassA = this.m_bodyA.m_invMass;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIA = this.m_bodyA.m_invI;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const cA = this.m_bodyA.c_position.c;\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const cB = this.m_bodyB.c_position.c;\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n\n    // Get the pulley axes.\n    this.m_uA = Vec2.sub(Vec2.add(cA, this.m_rA), this.m_groundAnchorA);\n    this.m_uB = Vec2.sub(Vec2.add(cB, this.m_rB), this.m_groundAnchorB);\n\n    const lengthA = this.m_uA.length();\n    const lengthB = this.m_uB.length();\n\n    if (lengthA > 10.0 * Settings.linearSlop) {\n      this.m_uA.mul(1.0 / lengthA);\n    } else {\n      this.m_uA.setZero();\n    }\n\n    if (lengthB > 10.0 * Settings.linearSlop) {\n      this.m_uB.mul(1.0 / lengthB);\n    } else {\n      this.m_uB.setZero();\n    }\n\n    // Compute effective mass.\n    const ruA = Vec2.crossVec2Vec2(this.m_rA, this.m_uA); // float\n    const ruB = Vec2.crossVec2Vec2(this.m_rB, this.m_uB); // float\n\n    const mA = this.m_invMassA + this.m_invIA * ruA * ruA; // float\n    const mB = this.m_invMassB + this.m_invIB * ruB * ruB; // float\n\n    this.m_mass = mA + this.m_ratio * this.m_ratio * mB;\n\n    if (this.m_mass > 0.0) {\n      this.m_mass = 1.0 / this.m_mass;\n    }\n\n    if (step.warmStarting) {\n      // Scale impulses to support variable time steps.\n      this.m_impulse *= step.dtRatio;\n\n      // Warm starting.\n      const PA = Vec2.mulNumVec2(-this.m_impulse, this.m_uA);\n      const PB = Vec2.mulNumVec2(-this.m_ratio * this.m_impulse, this.m_uB);\n\n      vA.addMul(this.m_invMassA, PA);\n      wA += this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, PA);\n\n      vB.addMul(this.m_invMassB, PB);\n      wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, PB);\n\n    } else {\n      this.m_impulse = 0.0;\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const vpA = Vec2.add(vA, Vec2.crossNumVec2(wA, this.m_rA));\n    const vpB = Vec2.add(vB, Vec2.crossNumVec2(wB, this.m_rB));\n\n    const Cdot = -Vec2.dot(this.m_uA, vpA) - this.m_ratio\n        * Vec2.dot(this.m_uB, vpB); // float\n    const impulse = -this.m_mass * Cdot; // float\n    this.m_impulse += impulse;\n\n    const PA = Vec2.mulNumVec2(-impulse, this.m_uA); // Vec2\n    const PB = Vec2.mulNumVec2(-this.m_ratio * impulse, this.m_uB); // Vec2\n    vA.addMul(this.m_invMassA, PA);\n    wA += this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, PA);\n    vB.addMul(this.m_invMassB, PB);\n    wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, PB);\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    const cA = this.m_bodyA.c_position.c;\n    let aA = this.m_bodyA.c_position.a;\n    const cB = this.m_bodyB.c_position.c;\n    let aB = this.m_bodyB.c_position.a;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    const rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    const rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n\n    // Get the pulley axes.\n    const uA = Vec2.sub(Vec2.add(cA, this.m_rA), this.m_groundAnchorA);\n    const uB = Vec2.sub(Vec2.add(cB, this.m_rB), this.m_groundAnchorB);\n\n    const lengthA = uA.length();\n    const lengthB = uB.length();\n\n    if (lengthA > 10.0 * Settings.linearSlop) {\n      uA.mul(1.0 / lengthA);\n    } else {\n      uA.setZero();\n    }\n\n    if (lengthB > 10.0 * Settings.linearSlop) {\n      uB.mul(1.0 / lengthB);\n    } else {\n      uB.setZero();\n    }\n\n    // Compute effective mass.\n    const ruA = Vec2.crossVec2Vec2(rA, uA);\n    const ruB = Vec2.crossVec2Vec2(rB, uB);\n\n    const mA = this.m_invMassA + this.m_invIA * ruA * ruA; // float\n    const mB = this.m_invMassB + this.m_invIB * ruB * ruB; // float\n\n    let mass = mA + this.m_ratio * this.m_ratio * mB; // float\n\n    if (mass > 0.0) {\n      mass = 1.0 / mass;\n    }\n\n    const C = this.m_constant - lengthA - this.m_ratio * lengthB; // float\n    const linearError = Math.abs(C); // float\n\n    const impulse = -mass * C; // float\n\n    const PA = Vec2.mulNumVec2(-impulse, uA); // Vec2\n    const PB = Vec2.mulNumVec2(-this.m_ratio * impulse, uB); // Vec2\n\n    cA.addMul(this.m_invMassA, PA);\n    aA += this.m_invIA * Vec2.crossVec2Vec2(rA, PA);\n    cB.addMul(this.m_invMassB, PB);\n    aB += this.m_invIB * Vec2.crossVec2Vec2(rB, PB);\n\n    this.m_bodyA.c_position.c = cA;\n    this.m_bodyA.c_position.a = aA;\n    this.m_bodyB.c_position.c = cB;\n    this.m_bodyB.c_position.a = aB;\n\n    return linearError < Settings.linearSlop;\n  }\n\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { options } from '../../util/options';\nimport { SettingsInternal as Settings } from '../../Settings';\nimport { math as Math } from '../../common/Math';\nimport { Vec2 } from '../../common/Vec2';\nimport { Rot } from '../../common/Rot';\nimport { Joint, JointOpt, JointDef } from '../Joint';\nimport { Body } from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\nconst _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\nconst inactiveLimit = 0;\nconst atLowerLimit = 1;\nconst atUpperLimit = 2;\nconst equalLimits = 3;\n\n/**\n * Rope joint definition. This requires two body anchor points and a maximum\n * lengths. Note: by default the connected objects will not collide. see\n * collideConnected in JointDef.\n */\nexport interface RopeJointOpt extends JointOpt {\n  /**\n   * The maximum length of the rope.\n   * Warning: this must be larger than linearSlop or the joint will have no effect.\n   */\n  maxLength?: number;\n}\n/**\n * Rope joint definition. This requires two body anchor points and a maximum\n * lengths. Note: by default the connected objects will not collide. see\n * collideConnected in JointDef.\n */\nexport interface RopeJointDef extends JointDef, RopeJointOpt {\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  localAnchorA: Vec2;\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  localAnchorB: Vec2;\n}\n\nconst DEFAULTS = {\n  maxLength : 0.0,\n};\n\n/**\n * A rope joint enforces a maximum distance between two points on two bodies. It\n * has no other effect.\n *\n * Warning: if you attempt to change the maximum length during the simulation\n * you will get some non-physical behavior.\n *\n * A model that would allow you to dynamically modify the length would have some\n * sponginess, so I chose not to implement it that way. See {@link DistanceJoint} if you\n * want to dynamically control length.\n */\nexport class RopeJoint extends Joint {\n  static TYPE = 'rope-joint' as const;\n\n  /** @internal */ m_type: 'rope-joint';\n  /** @internal */ m_localAnchorA: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n\n  /** @internal */ m_maxLength: number;\n\n  /** @internal */ m_mass: number;\n  /** @internal */ m_impulse: number;\n  /** @internal */ m_length: number;\n  /** @internal */ m_state: number; // TODO enum\n\n  // Solver temp\n  /** @internal */ m_u: Vec2;\n  /** @internal */ m_rA: Vec2;\n  /** @internal */ m_rB: Vec2;\n  /** @internal */ m_localCenterA: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_invMassA: number;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIA: number;\n  /** @internal */ m_invIB: number;\n\n  constructor(def: RopeJointDef);\n  constructor(def: RopeJointOpt, bodyA: Body, bodyB: Body, anchor: Vec2);\n  constructor(def: RopeJointDef, bodyA?: Body, bodyB?: Body, anchor?: Vec2) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof RopeJoint)) {\n      return new RopeJoint(def, bodyA, bodyB, anchor);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = RopeJoint.TYPE;\n    this.m_localAnchorA = anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.neo(-1.0, 0.0);\n    this.m_localAnchorB = anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.neo(1.0, 0.0);\n\n    this.m_maxLength = def.maxLength;\n\n    this.m_mass = 0.0;\n    this.m_impulse = 0.0;\n    this.m_length = 0.0;\n    this.m_state = inactiveLimit;\n\n    // Limit:\n    // C = norm(pB - pA) - L\n    // u = (pB - pA) / norm(pB - pA)\n    // Cdot = dot(u, vB + cross(wB, rB) - vA - cross(wA, rA))\n    // J = [-u -cross(rA, u) u cross(rB, u)]\n    // K = J * invM * JT\n    // = invMassA + invIA * cross(rA, u)^2 + invMassB + invIB * cross(rB, u)^2\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      localAnchorA: this.m_localAnchorA,\n      localAnchorB: this.m_localAnchorB,\n      maxLength: this.m_maxLength,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): RopeJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    const joint = new RopeJoint(data);\n    return joint;\n  }\n\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  getLocalAnchorA(): Vec2 {\n    return this.m_localAnchorA;\n  }\n\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  getLocalAnchorB(): Vec2 {\n    return this.m_localAnchorB;\n  }\n\n  /**\n   * Set the maximum length of the rope.\n   */\n  setMaxLength(length: number): void {\n    this.m_maxLength = length;\n  }\n\n  /**\n   * Get the maximum length of the rope.\n   */\n  getMaxLength(): number {\n    return this.m_maxLength;\n  }\n\n  getLimitState(): number {\n    // TODO LimitState\n    return this.m_state;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.mulNumVec2(this.m_impulse, this.m_u).mul(inv_dt);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return 0.0;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassA = this.m_bodyA.m_invMass;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIA = this.m_bodyA.m_invI;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const cA = this.m_bodyA.c_position.c;\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const cB = this.m_bodyB.c_position.c;\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    this.m_rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);\n    this.m_rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);\n    this.m_u = Vec2.zero();\n    this.m_u.addCombine(1, cB, 1, this.m_rB);\n    this.m_u.subCombine(1, cA, 1, this.m_rA); // Vec2\n\n    this.m_length = this.m_u.length();\n\n    const C = this.m_length - this.m_maxLength; // float\n    if (C > 0.0) {\n      this.m_state = atUpperLimit;\n    } else {\n      this.m_state = inactiveLimit;\n    }\n\n    if (this.m_length > Settings.linearSlop) {\n      this.m_u.mul(1.0 / this.m_length);\n    } else {\n      this.m_u.setZero();\n      this.m_mass = 0.0;\n      this.m_impulse = 0.0;\n      return;\n    }\n\n    // Compute effective mass.\n    const crA = Vec2.crossVec2Vec2(this.m_rA, this.m_u); // float\n    const crB = Vec2.crossVec2Vec2(this.m_rB, this.m_u); // float\n    const invMass = this.m_invMassA + this.m_invIA * crA * crA + this.m_invMassB\n        + this.m_invIB * crB * crB; // float\n\n    this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;\n\n    if (step.warmStarting) {\n      // Scale the impulse to support a variable time step.\n      this.m_impulse *= step.dtRatio;\n\n      const P = Vec2.mulNumVec2(this.m_impulse, this.m_u);\n\n      vA.subMul(this.m_invMassA, P);\n      wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P);\n\n      vB.addMul(this.m_invMassB, P);\n      wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P);\n\n    } else {\n      this.m_impulse = 0.0;\n    }\n\n    this.m_bodyA.c_velocity.v.setVec2(vA);\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v.setVec2(vB);\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    // Cdot = dot(u, v + cross(w, r))\n    const vpA = Vec2.addCrossNumVec2(vA, wA, this.m_rA); // Vec2\n    const vpB = Vec2.addCrossNumVec2(vB, wB, this.m_rB); // Vec2\n    const C = this.m_length - this.m_maxLength; // float\n    let Cdot = Vec2.dot(this.m_u, Vec2.sub(vpB, vpA)); // float\n\n    // Predictive constraint.\n    if (C < 0.0) {\n      Cdot += step.inv_dt * C;\n    }\n\n    let impulse = -this.m_mass * Cdot; // float\n    const oldImpulse = this.m_impulse; // float\n    this.m_impulse = Math.min(0.0, this.m_impulse + impulse);\n    impulse = this.m_impulse - oldImpulse;\n\n    const P = Vec2.mulNumVec2(impulse, this.m_u); // Vec2\n    vA.subMul(this.m_invMassA, P);\n    wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P);\n    vB.addMul(this.m_invMassB, P);\n    wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P);\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    const cA = this.m_bodyA.c_position.c; // Vec2\n    let aA = this.m_bodyA.c_position.a; // float\n    const cB = this.m_bodyB.c_position.c; // Vec2\n    let aB = this.m_bodyB.c_position.a; // float\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    const rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);\n    const rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);\n    const u = Vec2.zero();\n    u.addCombine(1, cB, 1, rB);\n    u.subCombine(1, cA, 1, rA); // Vec2\n\n    const length = u.normalize(); // float\n    let C = length - this.m_maxLength; // float\n\n    C = Math.clamp(C, 0.0, Settings.maxLinearCorrection);\n\n    const impulse = -this.m_mass * C; // float\n    const P = Vec2.mulNumVec2(impulse, u); // Vec2\n\n    cA.subMul(this.m_invMassA, P);\n    aA -= this.m_invIA * Vec2.crossVec2Vec2(rA, P);\n    cB.addMul(this.m_invMassB, P);\n    aB += this.m_invIB * Vec2.crossVec2Vec2(rB, P);\n\n    this.m_bodyA.c_position.c.setVec2(cA);\n    this.m_bodyA.c_position.a = aA;\n    this.m_bodyB.c_position.c.setVec2(cB);\n    this.m_bodyB.c_position.a = aB;\n\n    return length - this.m_maxLength < Settings.linearSlop;\n  }\n\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { options } from '../../util/options';\nimport { SettingsInternal as Settings } from '../../Settings';\nimport { math as Math } from '../../common/Math';\nimport { Vec2 } from '../../common/Vec2';\nimport { Vec3 } from '../../common/Vec3';\nimport { Mat33 } from '../../common/Mat33';\nimport { Rot } from '../../common/Rot';\nimport { Joint, JointOpt, JointDef } from '../Joint';\nimport { Body } from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\nconst _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\n/**\n * Weld joint definition. You need to specify local anchor points where they are\n * attached and the relative body angle. The position of the anchor points is\n * important for computing the reaction torque.\n *\n * @prop {float} frequencyHz\n * @prop {float} dampingRatio\n *\n * @prop {Vec2} localAnchorA\n * @prop {Vec2} localAnchorB\n * @prop {float} referenceAngle\n */\nexport interface WeldJointOpt extends JointOpt {\n  /**\n   * The mass-spring-damper frequency in Hertz. Rotation only. Disable softness\n   * with a value of 0.\n   */\n  frequencyHz?: number;\n  /**\n   * The damping ratio. 0 = no damping, 1 = critical damping.\n   */\n  dampingRatio?: number;\n  /**\n   * The bodyB angle minus bodyA angle in the reference state (radians).\n   */\n  referenceAngle?: number;\n}\n/**\n * Weld joint definition. You need to specify local anchor points where they are\n * attached and the relative body angle. The position of the anchor points is\n * important for computing the reaction torque.\n */\nexport interface WeldJointDef extends JointDef, WeldJointOpt {\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  localAnchorA: Vec2;\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  localAnchorB: Vec2;\n}\n\nconst DEFAULTS = {\n  frequencyHz : 0.0,\n  dampingRatio : 0.0,\n};\n\n/**\n * A weld joint essentially glues two bodies together. A weld joint may distort\n * somewhat because the island constraint solver is approximate.\n */\nexport class WeldJoint extends Joint {\n  static TYPE = 'weld-joint' as const\n\n  /** @internal */ m_type: 'weld-joint';\n  /** @internal */ m_localAnchorA: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n  /** @internal */ m_referenceAngle: number;\n\n  /** @internal */ m_frequencyHz: number;\n  /** @internal */ m_dampingRatio: number;\n\n  /** @internal */ m_impulse: Vec3;\n\n  /** @internal */ m_bias: number;\n  /** @internal */ m_gamma: number;\n\n  // Solver temp\n  /** @internal */ m_rA: Vec2;\n  /** @internal */ m_rB: Vec2;\n  /** @internal */ m_localCenterA: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_invMassA: number;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIA: number;\n  /** @internal */ m_invIB: number;\n  /** @internal */ m_mass: Mat33;\n\n  constructor(def: WeldJointDef);\n  constructor(def: WeldJointOpt, bodyA: Body, bodyB: Body, anchor: Vec2);\n  constructor(def: WeldJointDef, bodyA?: Body, bodyB?: Body, anchor?: Vec2) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof WeldJoint)) {\n      return new WeldJoint(def, bodyA, bodyB, anchor);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = WeldJoint.TYPE;\n\n    this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n    this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n    this.m_referenceAngle = Math.isFinite(def.referenceAngle) ? def.referenceAngle : bodyB.getAngle() - bodyA.getAngle();\n\n    this.m_frequencyHz = def.frequencyHz;\n    this.m_dampingRatio = def.dampingRatio;\n\n    this.m_impulse = new Vec3();\n\n    this.m_bias = 0.0;\n    this.m_gamma = 0.0;\n\n    // Solver temp\n    this.m_rA; // Vec2\n    this.m_rB; // Vec2\n    this.m_localCenterA; // Vec2\n    this.m_localCenterB; // Vec2\n    this.m_invMassA; // float\n    this.m_invMassB; // float\n    this.m_invIA; // float\n    this.m_invIB; // float\n    this.m_mass = new Mat33();\n\n    // Point-to-point constraint\n    // C = p2 - p1\n    // Cdot = v2 - v1\n    // / = v2 + cross(w2, r2) - v1 - cross(w1, r1)\n    // J = [-I -r1_skew I r2_skew ]\n    // Identity used:\n    // w k % (rx i + ry j) = w * (-ry i + rx j)\n\n    // Angle constraint\n    // C = angle2 - angle1 - referenceAngle\n    // Cdot = w2 - w1\n    // J = [0 0 -1 0 0 1]\n    // K = invI1 + invI2\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      frequencyHz: this.m_frequencyHz,\n      dampingRatio: this.m_dampingRatio,\n\n      localAnchorA: this.m_localAnchorA,\n      localAnchorB: this.m_localAnchorB,\n      referenceAngle: this.m_referenceAngle,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): WeldJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    const joint = new WeldJoint(data);\n    return joint;\n  }\n\n  /** @internal */\n  _setAnchors(def: {\n    anchorA?: Vec2,\n    localAnchorA?: Vec2,\n    anchorB?: Vec2,\n    localAnchorB?: Vec2,\n  }): void {\n    if (def.anchorA) {\n      this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n    } else if (def.localAnchorA) {\n      this.m_localAnchorA.setVec2(def.localAnchorA);\n    }\n\n    if (def.anchorB) {\n      this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n    } else if (def.localAnchorB) {\n      this.m_localAnchorB.setVec2(def.localAnchorB);\n    }\n  }\n\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  getLocalAnchorA(): Vec2 {\n    return this.m_localAnchorA;\n  }\n\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  getLocalAnchorB(): Vec2 {\n    return this.m_localAnchorB;\n  }\n\n  /**\n   * Get the reference angle.\n   */\n  getReferenceAngle(): number {\n    return this.m_referenceAngle;\n  }\n\n  /**\n   * Set frequency in Hz.\n   */\n  setFrequency(hz: number): void {\n    this.m_frequencyHz = hz;\n  }\n\n  /**\n   * Get frequency in Hz.\n   */\n  getFrequency(): number {\n    return this.m_frequencyHz;\n  }\n\n  /**\n   * Set damping ratio.\n   */\n  setDampingRatio(ratio: number): void {\n    this.m_dampingRatio = ratio;\n  }\n\n  /**\n   * Get damping ratio.\n   */\n  getDampingRatio(): number {\n    return this.m_dampingRatio;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.neo(this.m_impulse.x, this.m_impulse.y).mul(inv_dt);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return inv_dt * this.m_impulse.z;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassA = this.m_bodyA.m_invMass;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIA = this.m_bodyA.m_invI;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n\n    // J = [-I -r1_skew I r2_skew]\n    // [ 0 -1 0 1]\n    // r_skew = [-ry; rx]\n\n    // Matlab\n    // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]\n    // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]\n    // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    const K = new Mat33();\n    K.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y * this.m_rB.y\n        * iB;\n    K.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y * this.m_rB.x * iB;\n    K.ez.x = -this.m_rA.y * iA - this.m_rB.y * iB;\n    K.ex.y = K.ey.x;\n    K.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x * this.m_rB.x\n        * iB;\n    K.ez.y = this.m_rA.x * iA + this.m_rB.x * iB;\n    K.ex.z = K.ez.x;\n    K.ey.z = K.ez.y;\n    K.ez.z = iA + iB;\n\n    if (this.m_frequencyHz > 0.0) {\n      K.getInverse22(this.m_mass);\n\n      let invM = iA + iB; // float\n      const m = invM > 0.0 ? 1.0 / invM : 0.0; // float\n\n      const C = aB - aA - this.m_referenceAngle; // float\n\n      // Frequency\n      const omega = 2.0 * Math.PI * this.m_frequencyHz; // float\n\n      // Damping coefficient\n      const d = 2.0 * m * this.m_dampingRatio * omega; // float\n\n      // Spring stiffness\n      const k = m * omega * omega; // float\n\n      // magic formulas\n      const h = step.dt; // float\n      this.m_gamma = h * (d + h * k);\n      this.m_gamma = this.m_gamma != 0.0 ? 1.0 / this.m_gamma : 0.0;\n      this.m_bias = C * h * k * this.m_gamma;\n\n      invM += this.m_gamma;\n      this.m_mass.ez.z = invM != 0.0 ? 1.0 / invM : 0.0;\n    } else if (K.ez.z == 0.0) {\n      K.getInverse22(this.m_mass);\n      this.m_gamma = 0.0;\n      this.m_bias = 0.0;\n    } else {\n      K.getSymInverse33(this.m_mass);\n      this.m_gamma = 0.0;\n      this.m_bias = 0.0;\n    }\n\n    if (step.warmStarting) {\n      // Scale impulses to support a variable time step.\n      this.m_impulse.mul(step.dtRatio);\n\n      const P = Vec2.neo(this.m_impulse.x, this.m_impulse.y);\n\n      vA.subMul(mA, P);\n      wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + this.m_impulse.z);\n\n      vB.addMul(mB, P);\n      wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + this.m_impulse.z);\n\n    } else {\n      this.m_impulse.setZero();\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB; // float\n    const iA = this.m_invIA;\n    const iB = this.m_invIB; // float\n\n    if (this.m_frequencyHz > 0.0) {\n      const Cdot2 = wB - wA; // float\n\n      const impulse2 = -this.m_mass.ez.z\n          * (Cdot2 + this.m_bias + this.m_gamma * this.m_impulse.z); // float\n      this.m_impulse.z += impulse2;\n\n      wA -= iA * impulse2;\n      wB += iB * impulse2;\n\n      const Cdot1 = Vec2.zero();\n      Cdot1.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, this.m_rB));\n      Cdot1.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, this.m_rA)); // Vec2\n\n      const impulse1 = Vec2.neg(Mat33.mulVec2(this.m_mass, Cdot1)); // Vec2\n      this.m_impulse.x += impulse1.x;\n      this.m_impulse.y += impulse1.y;\n\n      const P = Vec2.clone(impulse1); // Vec2\n\n      vA.subMul(mA, P);\n      wA -= iA * Vec2.crossVec2Vec2(this.m_rA, P);\n\n      vB.addMul(mB, P);\n      wB += iB * Vec2.crossVec2Vec2(this.m_rB, P);\n    } else {\n      const Cdot1 = Vec2.zero();\n      Cdot1.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, this.m_rB));\n      Cdot1.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, this.m_rA)); // Vec2\n      const Cdot2 = wB - wA; // float\n      const Cdot = new Vec3(Cdot1.x, Cdot1.y, Cdot2); // Vec3\n\n      const impulse = Vec3.neg(Mat33.mulVec3(this.m_mass, Cdot)); // Vec3\n      this.m_impulse.add(impulse);\n\n      const P = Vec2.neo(impulse.x, impulse.y);\n\n      vA.subMul(mA, P);\n      wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + impulse.z);\n\n      vB.addMul(mB, P);\n      wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + impulse.z);\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    const cA = this.m_bodyA.c_position.c;\n    let aA = this.m_bodyA.c_position.a;\n    const cB = this.m_bodyB.c_position.c;\n    let aB = this.m_bodyB.c_position.a;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    const rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    const rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n\n    let positionError: number;\n    let angularError: number;\n\n    const K = new Mat33();\n    K.ex.x = mA + mB + rA.y * rA.y * iA + rB.y * rB.y * iB;\n    K.ey.x = -rA.y * rA.x * iA - rB.y * rB.x * iB;\n    K.ez.x = -rA.y * iA - rB.y * iB;\n    K.ex.y = K.ey.x;\n    K.ey.y = mA + mB + rA.x * rA.x * iA + rB.x * rB.x * iB;\n    K.ez.y = rA.x * iA + rB.x * iB;\n    K.ex.z = K.ez.x;\n    K.ey.z = K.ez.y;\n    K.ez.z = iA + iB;\n\n    if (this.m_frequencyHz > 0.0) {\n      const C1 = Vec2.zero();\n      C1.addCombine(1, cB, 1, rB);\n      C1.subCombine(1, cA, 1, rA); // Vec2\n\n      positionError = C1.length();\n      angularError = 0.0;\n\n      const P = Vec2.neg(K.solve22(C1)); // Vec2\n\n      cA.subMul(mA, P);\n      aA -= iA * Vec2.crossVec2Vec2(rA, P);\n\n      cB.addMul(mB, P);\n      aB += iB * Vec2.crossVec2Vec2(rB, P);\n    } else {\n      const C1 = Vec2.zero();\n      C1.addCombine(1, cB, 1, rB);\n      C1.subCombine(1, cA, 1, rA);\n\n      const C2 = aB - aA - this.m_referenceAngle; // float\n\n      positionError = C1.length();\n      angularError = Math.abs(C2);\n\n      const C = new Vec3(C1.x, C1.y, C2);\n\n      let impulse = new Vec3();\n      if (K.ez.z > 0.0) {\n        impulse = Vec3.neg(K.solve33(C));\n      } else {\n        const impulse2 = Vec2.neg(K.solve22(C1));\n        impulse.set(impulse2.x, impulse2.y, 0.0);\n      }\n\n      const P = Vec2.neo(impulse.x, impulse.y);\n\n      cA.subMul(mA, P);\n      aA -= iA * (Vec2.crossVec2Vec2(rA, P) + impulse.z);\n\n      cB.addMul(mB, P);\n      aB += iB * (Vec2.crossVec2Vec2(rB, P) + impulse.z);\n    }\n\n    this.m_bodyA.c_position.c = cA;\n    this.m_bodyA.c_position.a = aA;\n    this.m_bodyB.c_position.c = cB;\n    this.m_bodyB.c_position.a = aB;\n\n    return positionError <= Settings.linearSlop && angularError <= Settings.angularSlop;\n  }\n\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { options } from '../../util/options';\nimport { SettingsInternal as Settings } from '../../Settings';\nimport { math as Math } from '../../common/Math';\nimport { Vec2 } from '../../common/Vec2';\nimport { Rot } from '../../common/Rot';\nimport { Joint, JointOpt, JointDef } from '../Joint';\nimport { Body } from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\nconst _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\n/**\n * Wheel joint definition. This requires defining a line of motion using an axis\n * and an anchor point. The definition uses local anchor points and a local axis\n * so that the initial configuration can violate the constraint slightly. The\n * joint translation is zero when the local anchor points coincide in world\n * space. Using local anchors and a local axis helps when saving and loading a\n * game.\n */\nexport interface WheelJointOpt extends JointOpt {\n  /**\n   * Enable/disable the joint motor.\n   */\n  enableMotor?: boolean;\n  /**\n   * The maximum motor torque, usually in N-m.\n   */\n  maxMotorTorque?: number;\n  /**\n   * The desired motor speed in radians per second.\n   */\n  motorSpeed?: number;\n  /**\n   * Suspension frequency, zero indicates no suspension.\n   */\n  frequencyHz?: number;\n  /**\n   * Suspension damping ratio, one indicates critical damping.\n   */\n  dampingRatio?: number;\n}\n/**\n * Wheel joint definition. This requires defining a line of motion using an axis\n * and an anchor point. The definition uses local anchor points and a local axis\n * so that the initial configuration can violate the constraint slightly. The\n * joint translation is zero when the local anchor points coincide in world\n * space. Using local anchors and a local axis helps when saving and loading a\n * game.\n */\nexport interface WheelJointDef extends JointDef, WheelJointOpt {\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  localAnchorA: Vec2;\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  localAnchorB: Vec2;\n  /**\n   * The local translation axis in bodyA.\n   */\n  localAxisA: Vec2;\n}\n\nconst DEFAULTS = {\n  enableMotor : false,\n  maxMotorTorque : 0.0,\n  motorSpeed : 0.0,\n  frequencyHz : 2.0,\n  dampingRatio : 0.7,\n};\n\n/**\n * A wheel joint. This joint provides two degrees of freedom: translation along\n * an axis fixed in bodyA and rotation in the plane. In other words, it is a\n * point to line constraint with a rotational motor and a linear spring/damper.\n * This joint is designed for vehicle suspensions.\n */\nexport class WheelJoint extends Joint {\n  static TYPE = 'wheel-joint' as const;\n\n  /** @internal */ m_type: 'wheel-joint';\n  /** @internal */ m_localAnchorA: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n  /** @internal */ m_localXAxisA: Vec2;\n  /** @internal */ m_localYAxisA: Vec2;\n\n  /** @internal */ m_mass: number;\n  /** @internal */ m_impulse: number;\n  /** @internal */ m_motorMass: number;\n  /** @internal */ m_motorImpulse: number;\n  /** @internal */ m_springMass: number;\n  /** @internal */ m_springImpulse: number;\n\n  /** @internal */ m_maxMotorTorque: number;\n  /** @internal */ m_motorSpeed: number;\n  /** @internal */ m_enableMotor: boolean;\n\n  /** @internal */ m_frequencyHz: number;\n  /** @internal */ m_dampingRatio: number;\n\n  /** @internal */ m_bias: number;\n  /** @internal */ m_gamma: number;\n\n  // Solver temp\n  /** @internal */ m_localCenterA: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_invMassA: number;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIA: number;\n  /** @internal */ m_invIB: number;\n\n  /** @internal */ m_ax: Vec2 = Vec2.zero();\n  /** @internal */ m_ay: Vec2 = Vec2.zero();\n  /** @internal */ m_sAx: number;\n  /** @internal */ m_sBx: number;\n  /** @internal */ m_sAy: number;\n  /** @internal */ m_sBy: number;\n\n  constructor(def: WheelJointDef);\n  constructor(def: WheelJointOpt, bodyA: Body, bodyB: Body, anchor: Vec2, axis: Vec2);\n  // @ts-ignore\n  constructor(def: WheelJointDef, bodyA?: Body, bodyB?: Body, anchor?: Vec2, axis?: Vec2) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof WheelJoint)) {\n      return new WheelJoint(def, bodyA, bodyB, anchor, axis);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = WheelJoint.TYPE;\n\n    this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n    this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n    // @ts-ignore localAxis\n    this.m_localXAxisA = Vec2.clone(axis ? bodyA.getLocalVector(axis) : def.localAxisA || def.localAxis || Vec2.neo(1.0, 0.0));\n    this.m_localYAxisA = Vec2.crossNumVec2(1.0, this.m_localXAxisA);\n\n    this.m_mass = 0.0;\n    this.m_impulse = 0.0;\n    this.m_motorMass = 0.0;\n    this.m_motorImpulse = 0.0;\n    this.m_springMass = 0.0;\n    this.m_springImpulse = 0.0;\n\n    this.m_maxMotorTorque = def.maxMotorTorque;\n    this.m_motorSpeed = def.motorSpeed;\n    this.m_enableMotor = def.enableMotor;\n\n    this.m_frequencyHz = def.frequencyHz;\n    this.m_dampingRatio = def.dampingRatio;\n\n    this.m_bias = 0.0;\n    this.m_gamma = 0.0;\n\n    // Linear constraint (point-to-line)\n    // d = pB - pA = xB + rB - xA - rA\n    // C = dot(ay, d)\n    // Cdot = dot(d, cross(wA, ay)) + dot(ay, vB + cross(wB, rB) - vA - cross(wA,\n    // rA))\n    // = -dot(ay, vA) - dot(cross(d + rA, ay), wA) + dot(ay, vB) + dot(cross(rB,\n    // ay), vB)\n    // J = [-ay, -cross(d + rA, ay), ay, cross(rB, ay)]\n\n    // Spring linear constraint\n    // C = dot(ax, d)\n    // Cdot = = -dot(ax, vA) - dot(cross(d + rA, ax), wA) + dot(ax, vB) +\n    // dot(cross(rB, ax), vB)\n    // J = [-ax -cross(d+rA, ax) ax cross(rB, ax)]\n\n    // Motor rotational constraint\n    // Cdot = wB - wA\n    // J = [0 0 -1 0 0 1]\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      enableMotor: this.m_enableMotor,\n      maxMotorTorque: this.m_maxMotorTorque,\n      motorSpeed: this.m_motorSpeed,\n      frequencyHz: this.m_frequencyHz,\n      dampingRatio: this.m_dampingRatio,\n\n      localAnchorA: this.m_localAnchorA,\n      localAnchorB: this.m_localAnchorB,\n      localAxisA: this.m_localXAxisA,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): WheelJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    const joint = new WheelJoint(data);\n    return joint;\n  }\n\n  /** @internal */\n  _setAnchors(def: {\n    anchorA?: Vec2,\n    localAnchorA?: Vec2,\n    anchorB?: Vec2,\n    localAnchorB?: Vec2,\n    localAxisA?: Vec2,\n  }): void {\n    if (def.anchorA) {\n      this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n    } else if (def.localAnchorA) {\n      this.m_localAnchorA.setVec2(def.localAnchorA);\n    }\n\n    if (def.anchorB) {\n      this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n    } else if (def.localAnchorB) {\n      this.m_localAnchorB.setVec2(def.localAnchorB);\n    }\n\n    if (def.localAxisA) {\n      this.m_localXAxisA.setVec2(def.localAxisA);\n      this.m_localYAxisA.setVec2(Vec2.crossNumVec2(1.0, def.localAxisA));\n    }\n  }\n\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  getLocalAnchorA(): Vec2 {\n    return this.m_localAnchorA;\n  }\n\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  getLocalAnchorB(): Vec2 {\n    return this.m_localAnchorB;\n  }\n\n  /**\n   * The local joint axis relative to bodyA.\n   */\n  getLocalAxisA(): Vec2 {\n    return this.m_localXAxisA;\n  }\n\n  /**\n   * Get the current joint translation, usually in meters.\n   */\n  getJointTranslation(): number {\n    const bA = this.m_bodyA;\n    const bB = this.m_bodyB;\n\n    const pA = bA.getWorldPoint(this.m_localAnchorA); // Vec2\n    const pB = bB.getWorldPoint(this.m_localAnchorB); // Vec2\n    const d = Vec2.sub(pB, pA); // Vec2\n    const axis = bA.getWorldVector(this.m_localXAxisA); // Vec2\n\n    const translation = Vec2.dot(d, axis); // float\n    return translation;\n  }\n\n  /**\n   * Get the current joint translation speed, usually in meters per second.\n   */\n  getJointSpeed(): number {\n    const wA = this.m_bodyA.m_angularVelocity;\n    const wB = this.m_bodyB.m_angularVelocity;\n    return wB - wA;\n  }\n\n  /**\n   * Is the joint motor enabled?\n   */\n  isMotorEnabled(): boolean {\n    return this.m_enableMotor;\n  }\n\n  /**\n   * Enable/disable the joint motor.\n   */\n  enableMotor(flag: boolean): void {\n    if (flag == this.m_enableMotor) return;\n    this.m_bodyA.setAwake(true);\n    this.m_bodyB.setAwake(true);\n    this.m_enableMotor = flag;\n  }\n\n  /**\n   * Set the motor speed, usually in radians per second.\n   */\n  setMotorSpeed(speed: number): void {\n    if (speed == this.m_motorSpeed) return;\n    this.m_bodyA.setAwake(true);\n    this.m_bodyB.setAwake(true);\n    this.m_motorSpeed = speed;\n  }\n\n  /**\n   * Get the motor speed, usually in radians per second.\n   */\n  getMotorSpeed(): number {\n    return this.m_motorSpeed;\n  }\n\n  /**\n   * Set/Get the maximum motor force, usually in N-m.\n   */\n  setMaxMotorTorque(torque: number): void {\n    if (torque == this.m_maxMotorTorque) return;\n    this.m_bodyA.setAwake(true);\n    this.m_bodyB.setAwake(true);\n    this.m_maxMotorTorque = torque;\n  }\n\n  getMaxMotorTorque(): number {\n    return this.m_maxMotorTorque;\n  }\n\n  /**\n   * Get the current motor torque given the inverse time step, usually in N-m.\n   */\n  getMotorTorque(inv_dt: number): number {\n    return inv_dt * this.m_motorImpulse;\n  }\n\n  /**\n   * Set/Get the spring frequency in hertz. Setting the frequency to zero disables\n   * the spring.\n   */\n  setSpringFrequencyHz(hz: number): void {\n    this.m_frequencyHz = hz;\n  }\n\n  getSpringFrequencyHz(): number {\n    return this.m_frequencyHz;\n  }\n\n  /**\n   * Set/Get the spring damping ratio\n   */\n  setSpringDampingRatio(ratio: number): void {\n    this.m_dampingRatio = ratio;\n  }\n\n  getSpringDampingRatio(): number {\n    return this.m_dampingRatio;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.combine(this.m_impulse, this.m_ay, this.m_springImpulse, this.m_ax).mul(inv_dt);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return inv_dt * this.m_motorImpulse;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassA = this.m_bodyA.m_invMass;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIA = this.m_bodyA.m_invI;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB; // float\n    const iA = this.m_invIA;\n    const iB = this.m_invIB; // float\n\n    const cA = this.m_bodyA.c_position.c;\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const cB = this.m_bodyB.c_position.c;\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    // Compute the effective masses.\n    const rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    const rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n    const d = Vec2.zero();\n    d.addCombine(1, cB, 1, rB);\n    d.subCombine(1, cA, 1, rA); // Vec2\n\n    // Point to line constraint\n    {\n      this.m_ay = Rot.mulVec2(qA, this.m_localYAxisA);\n      this.m_sAy = Vec2.crossVec2Vec2(Vec2.add(d, rA), this.m_ay);\n      this.m_sBy = Vec2.crossVec2Vec2(rB, this.m_ay);\n\n      this.m_mass = mA + mB + iA * this.m_sAy * this.m_sAy + iB * this.m_sBy\n          * this.m_sBy;\n\n      if (this.m_mass > 0.0) {\n        this.m_mass = 1.0 / this.m_mass;\n      }\n    }\n\n    // Spring constraint\n    this.m_springMass = 0.0;\n    this.m_bias = 0.0;\n    this.m_gamma = 0.0;\n    if (this.m_frequencyHz > 0.0) {\n      this.m_ax = Rot.mulVec2(qA, this.m_localXAxisA);\n      this.m_sAx = Vec2.crossVec2Vec2(Vec2.add(d, rA), this.m_ax);\n      this.m_sBx = Vec2.crossVec2Vec2(rB, this.m_ax);\n\n      const invMass = mA + mB + iA * this.m_sAx * this.m_sAx + iB * this.m_sBx\n          * this.m_sBx; // float\n\n      if (invMass > 0.0) {\n        this.m_springMass = 1.0 / invMass;\n\n        const C = Vec2.dot(d, this.m_ax); // float\n\n        // Frequency\n        const omega = 2.0 * Math.PI * this.m_frequencyHz; // float\n\n        // Damping coefficient\n        const damp = 2.0 * this.m_springMass * this.m_dampingRatio * omega; // float\n\n        // Spring stiffness\n        const k = this.m_springMass * omega * omega; // float\n\n        // magic formulas\n        const h = step.dt; // float\n        this.m_gamma = h * (damp + h * k);\n        if (this.m_gamma > 0.0) {\n          this.m_gamma = 1.0 / this.m_gamma;\n        }\n\n        this.m_bias = C * h * k * this.m_gamma;\n\n        this.m_springMass = invMass + this.m_gamma;\n        if (this.m_springMass > 0.0) {\n          this.m_springMass = 1.0 / this.m_springMass;\n        }\n      }\n    } else {\n      this.m_springImpulse = 0.0;\n    }\n\n    // Rotational motor\n    if (this.m_enableMotor) {\n      this.m_motorMass = iA + iB;\n      if (this.m_motorMass > 0.0) {\n        this.m_motorMass = 1.0 / this.m_motorMass;\n      }\n    } else {\n      this.m_motorMass = 0.0;\n      this.m_motorImpulse = 0.0;\n    }\n\n    if (step.warmStarting) {\n      // Account for variable time step.\n      this.m_impulse *= step.dtRatio;\n      this.m_springImpulse *= step.dtRatio;\n      this.m_motorImpulse *= step.dtRatio;\n\n      const P = Vec2.combine(this.m_impulse, this.m_ay, this.m_springImpulse, this.m_ax);\n      const LA = this.m_impulse * this.m_sAy + this.m_springImpulse * this.m_sAx + this.m_motorImpulse;\n      const LB = this.m_impulse * this.m_sBy + this.m_springImpulse * this.m_sBx + this.m_motorImpulse;\n\n      vA.subMul(this.m_invMassA, P);\n      wA -= this.m_invIA * LA;\n\n      vB.addMul(this.m_invMassB, P);\n      wB += this.m_invIB * LB;\n\n    } else {\n      this.m_impulse = 0.0;\n      this.m_springImpulse = 0.0;\n      this.m_motorImpulse = 0.0;\n    }\n\n    this.m_bodyA.c_velocity.v.setVec2(vA);\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v.setVec2(vB);\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB; // float\n    const iA = this.m_invIA;\n    const iB = this.m_invIB; // float\n\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    // Solve spring constraint\n    {\n      const Cdot = Vec2.dot(this.m_ax, vB) - Vec2.dot(this.m_ax, vA) + this.m_sBx\n          * wB - this.m_sAx * wA; // float\n      const impulse = -this.m_springMass\n          * (Cdot + this.m_bias + this.m_gamma * this.m_springImpulse); // float\n      this.m_springImpulse += impulse;\n\n      const P = Vec2.mulNumVec2(impulse, this.m_ax); // Vec2\n      const LA = impulse * this.m_sAx; // float\n      const LB = impulse * this.m_sBx; // float\n\n      vA.subMul(mA, P);\n      wA -= iA * LA;\n\n      vB.addMul(mB, P);\n      wB += iB * LB;\n    }\n\n    // Solve rotational motor constraint\n    {\n      const Cdot = wB - wA - this.m_motorSpeed; // float\n      let impulse = -this.m_motorMass * Cdot; // float\n\n      const oldImpulse = this.m_motorImpulse; // float\n      const maxImpulse = step.dt * this.m_maxMotorTorque; // float\n      this.m_motorImpulse = Math.clamp(this.m_motorImpulse + impulse,\n          -maxImpulse, maxImpulse);\n      impulse = this.m_motorImpulse - oldImpulse;\n\n      wA -= iA * impulse;\n      wB += iB * impulse;\n    }\n\n    // Solve point to line constraint\n    {\n      const Cdot = Vec2.dot(this.m_ay, vB) - Vec2.dot(this.m_ay, vA) + this.m_sBy\n          * wB - this.m_sAy * wA; // float\n      const impulse = -this.m_mass * Cdot; // float\n      this.m_impulse += impulse;\n\n      const P = Vec2.mulNumVec2(impulse, this.m_ay); // Vec2\n      const LA = impulse * this.m_sAy; // float\n      const LB = impulse * this.m_sBy; // float\n\n      vA.subMul(mA, P);\n      wA -= iA * LA;\n\n      vB.addMul(mB, P);\n      wB += iB * LB;\n    }\n\n    this.m_bodyA.c_velocity.v.setVec2(vA);\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v.setVec2(vB);\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    const cA = this.m_bodyA.c_position.c;\n    let aA = this.m_bodyA.c_position.a;\n    const cB = this.m_bodyB.c_position.c;\n    let aB = this.m_bodyB.c_position.a;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    const rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    const rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n    const d = Vec2.zero();\n    d.addCombine(1, cB, 1, rB);\n    d.subCombine(1, cA, 1, rA);\n\n    const ay = Rot.mulVec2(qA, this.m_localYAxisA);\n\n    const sAy = Vec2.crossVec2Vec2(Vec2.add(d, rA), ay); // float\n    const sBy = Vec2.crossVec2Vec2(rB, ay); // float\n\n    const C = Vec2.dot(d, ay); // float\n\n    const k = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_sAy\n        * this.m_sAy + this.m_invIB * this.m_sBy * this.m_sBy; // float\n\n    let impulse; // float\n    if (k != 0.0) {\n      impulse = -C / k;\n    } else {\n      impulse = 0.0;\n    }\n\n    const P = Vec2.mulNumVec2(impulse, ay); // Vec2\n    const LA = impulse * sAy; // float\n    const LB = impulse * sBy; // float\n\n    cA.subMul(this.m_invMassA, P);\n    aA -= this.m_invIA * LA;\n    cB.addMul(this.m_invMassB, P);\n    aB += this.m_invIB * LB;\n\n    this.m_bodyA.c_position.c.setVec2(cA);\n    this.m_bodyA.c_position.a = aA;\n    this.m_bodyB.c_position.c.setVec2(cB);\n    this.m_bodyB.c_position.a = aB;\n\n    return Math.abs(C) <= Settings.linearSlop;\n  }\n\n}\n","// tslint:disable:typedef\nimport { World } from '../dynamics/World';\nimport { Body } from '../dynamics/Body';\nimport { Joint } from '../dynamics/Joint';\nimport { Fixture } from '../dynamics/Fixture';\nimport { Shape } from '../collision/Shape';\nimport { Vec2 } from '../common/Vec2';\nimport { Vec3 } from '../common/Vec3';\nimport { ChainShape } from \"../collision/shape/ChainShape\";\nimport { BoxShape } from \"../collision/shape/BoxShape\";\nimport { EdgeShape } from \"../collision/shape/EdgeShape\";\nimport { PolygonShape } from \"../collision/shape/PolygonShape\";\nimport { CircleShape } from \"../collision/shape/CircleShape\";\nimport { DistanceJoint } from \"../dynamics/joint/DistanceJoint\";\nimport { FrictionJoint } from \"../dynamics/joint/FrictionJoint\";\nimport { GearJoint } from \"../dynamics/joint/GearJoint\";\nimport { MotorJoint } from \"../dynamics/joint/MotorJoint\";\nimport { MouseJoint } from \"../dynamics/joint/MouseJoint\";\nimport { PrismaticJoint } from \"../dynamics/joint/PrismaticJoint\";\nimport { PulleyJoint } from \"../dynamics/joint/PulleyJoint\";\nimport { RevoluteJoint } from \"../dynamics/joint/RevoluteJoint\";\nimport { RopeJoint } from \"../dynamics/joint/RopeJoint\";\nimport { WeldJoint } from \"../dynamics/joint/WeldJoint\";\nimport { WheelJoint } from \"../dynamics/joint/WheelJoint\";\n\nlet SID = 0;\n\nexport function Serializer(opts?) {\n  opts = opts || {};\n\n  const rootClass = opts.rootClass || World;\n\n  const preSerialize = opts.preSerialize || function(obj) { return obj; };\n  const postSerialize = opts.postSerialize || function(data, obj) { return data; };\n\n  const preDeserialize = opts.preDeserialize || function(data) { return data; };\n  const postDeserialize = opts.postDeserialize || function(obj, data) { return obj; };\n\n  // This is used to create ref objects during serialize\n  const refTypes = {\n    World,\n    Body,\n    Joint,\n    Fixture,\n    Shape,\n  };\n\n  // This is used by restore to deserialize objects and refs\n  const restoreTypes = {\n    Vec2,\n    Vec3,\n    ...refTypes\n  };\n\n  const CLASS_BY_TYPE_PROP = {\n    [Body.STATIC]: Body,\n    [Body.DYNAMIC]: Body,\n    [Body.KINEMATIC]: Body,\n    [ChainShape.TYPE]: ChainShape,\n    [BoxShape.TYPE]: BoxShape,\n    [EdgeShape.TYPE]: EdgeShape,\n    [PolygonShape.TYPE]: PolygonShape,\n    [CircleShape.TYPE]: CircleShape,\n    [DistanceJoint.TYPE]: DistanceJoint,\n    [FrictionJoint.TYPE]: FrictionJoint,\n    [GearJoint.TYPE]: GearJoint,\n    [MotorJoint.TYPE]: MotorJoint,\n    [MouseJoint.TYPE]: MouseJoint,\n    [PrismaticJoint.TYPE]: PrismaticJoint,\n    [PulleyJoint.TYPE]: PulleyJoint,\n    [RevoluteJoint.TYPE]: RevoluteJoint,\n    [RopeJoint.TYPE]: RopeJoint,\n    [WeldJoint.TYPE]: WeldJoint,\n    [WheelJoint.TYPE]: WheelJoint,\n  }\n\n  this.toJson = function(root) {\n    const json = [];\n\n    const queue = [root];\n    const refMap = {};\n\n    function storeRef(value, typeName) {\n      value.__sid = value.__sid || ++SID;\n      if (!refMap[value.__sid]) {\n        queue.push(value);\n        const index = json.length + queue.length;\n        const ref = {\n          refIndex: index,\n          refType: typeName\n        };\n        refMap[value.__sid] = ref;\n      }\n      return refMap[value.__sid];\n    }\n\n    function serialize(obj) {\n      obj = preSerialize(obj);\n      let data = obj._serialize();\n      data = postSerialize(data, obj);\n      return data;\n    }\n\n    function toJson(value, top?) {\n      if (typeof value !== 'object' || value === null) {\n        return value;\n      }\n      if (typeof value._serialize === 'function') {\n        if (value !== top) {\n          // tslint:disable-next-line:no-for-in\n          for (const typeName in refTypes) {\n            if (value instanceof refTypes[typeName]) {\n              return storeRef(value, typeName);\n            }\n          }\n        }\n        value = serialize(value);\n      }\n      if (Array.isArray(value)) {\n        const newValue = [];\n        for (let key = 0; key < value.length; key++) {\n          newValue[key] = toJson(value[key]);\n        }\n        value = newValue;\n\n      } else {\n        const newValue = {};\n        // tslint:disable-next-line:no-for-in\n        for (const key in value) {\n          if (value.hasOwnProperty(key)) {\n            newValue[key] = toJson(value[key]);\n          }\n        }\n        value = newValue;\n      }\n      return value;\n    }\n\n    while (queue.length) {\n      const obj = queue.shift();\n      const str = toJson(obj, obj);\n      json.push(str);\n    }\n\n    return json;\n  };\n\n  this.fromJson = function(json: object) {\n    const refMap = {};\n\n    function findDeserilizer(data, cls) {\n      if (!cls || !cls._deserialize) {\n        cls = CLASS_BY_TYPE_PROP[data.type]\n      }\n      return cls && cls._deserialize;\n    }\n\n    /**\n     * Deserialize a data object.\n     */\n    function deserialize(cls, data, ctx) {\n      const deserializer = findDeserilizer(data, cls);\n      if (!deserializer) {\n        return;\n      }\n      data = preDeserialize(data);\n      let obj = deserializer(data, ctx, restoreRef);\n      obj = postDeserialize(obj, data);\n      return obj;\n    }\n\n    /**\n     * Restore a ref object or deserialize a data object.\n     *\n     * This is passed as callback to class deserializers.\n     */\n    function restoreRef(cls, ref, ctx) {\n      if (!ref.refIndex) {\n        return cls && cls._deserialize && deserialize(cls, ref, ctx);\n      }\n      cls = restoreTypes[ref.refType] || cls;\n      const index = ref.refIndex;\n      if (!refMap[index]) {\n        const data = json[index];\n        const obj = deserialize(cls, data, ctx);\n        refMap[index] = obj;\n      }\n      return refMap[index];\n    }\n\n    const root = rootClass._deserialize(json[0], null, restoreRef);\n\n    return root;\n  };\n}\n\nconst serializer = new Serializer();\n\nSerializer.toJson = serializer.toJson;\nSerializer.fromJson = serializer.fromJson;\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n\nimport * as matrix from '../../common/Matrix';\nimport { Transform } from '../../common/Transform';\nimport { Contact } from '../../dynamics/Contact';\nimport { CircleShape } from './CircleShape';\nimport { Manifold, ContactFeatureType, ManifoldType } from \"../Manifold\";\nimport { Fixture } from \"../../dynamics/Fixture\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nContact.addType(CircleShape.TYPE, CircleShape.TYPE, CircleCircleContact);\n\nfunction CircleCircleContact(manifold: Manifold, xfA: Transform, fixtureA: Fixture, indexA: number, xfB: Transform, fixtureB: Fixture, indexB: number): void {\n  _ASSERT && console.assert(fixtureA.getType() == CircleShape.TYPE);\n  _ASSERT && console.assert(fixtureB.getType() == CircleShape.TYPE);\n  CollideCircles(manifold, fixtureA.getShape() as CircleShape, xfA, fixtureB.getShape() as CircleShape, xfB);\n}\n\nconst pA = matrix.vec2(0, 0);\nconst pB = matrix.vec2(0, 0);\n\nexport const CollideCircles = function (manifold: Manifold, circleA: CircleShape, xfA: Transform, circleB: CircleShape, xfB: Transform): void {\n  manifold.pointCount = 0;\n\n  matrix.transformVec2(pA, xfA, circleA.m_p);\n  matrix.transformVec2(pB, xfB, circleB.m_p);\n\n  const distSqr = matrix.distSqrVec2(pB, pA);\n  const rA = circleA.m_radius;\n  const rB = circleB.m_radius;\n  const radius = rA + rB;\n  if (distSqr > radius * radius) {\n    return;\n  }\n\n  manifold.type = ManifoldType.e_circles;\n  matrix.copyVec2(manifold.localPoint, circleA.m_p);\n  matrix.zeroVec2(manifold.localNormal)\n  manifold.pointCount = 1;\n  matrix.copyVec2(manifold.points[0].localPoint, circleB.m_p);\n\n  // manifold.points[0].id.key = 0;\n  manifold.points[0].id.setFeatures(0, ContactFeatureType.e_vertex, 0, ContactFeatureType.e_vertex)\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { TransformValue } from '../../common/Transform';\nimport * as matrix from '../../common/Matrix';\nimport { Contact } from '../../dynamics/Contact';\nimport { EdgeShape } from './EdgeShape';\nimport { ChainShape } from './ChainShape';\nimport { CircleShape } from './CircleShape';\nimport { Manifold, ContactFeatureType, ManifoldType } from \"../Manifold\";\nimport { Fixture } from \"../../dynamics/Fixture\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nContact.addType(EdgeShape.TYPE, CircleShape.TYPE, EdgeCircleContact);\nContact.addType(ChainShape.TYPE, CircleShape.TYPE, ChainCircleContact);\n\nfunction EdgeCircleContact(manifold: Manifold, xfA: TransformValue, fixtureA: Fixture, indexA: number, xfB: TransformValue, fixtureB: Fixture, indexB: number): void {\n  _ASSERT && console.assert(fixtureA.getType() == EdgeShape.TYPE);\n  _ASSERT && console.assert(fixtureB.getType() == CircleShape.TYPE);\n\n  const shapeA = fixtureA.getShape() as EdgeShape;\n  const shapeB = fixtureB.getShape() as CircleShape;\n\n  CollideEdgeCircle(manifold, shapeA, xfA, shapeB, xfB);\n}\n\nfunction ChainCircleContact(manifold: Manifold, xfA: TransformValue, fixtureA: Fixture, indexA: number, xfB: TransformValue, fixtureB: Fixture, indexB: number): void {\n  _ASSERT && console.assert(fixtureA.getType() == ChainShape.TYPE);\n  _ASSERT && console.assert(fixtureB.getType() == CircleShape.TYPE);\n\n  const chain = fixtureA.getShape() as ChainShape;\n  const edge = new EdgeShape();\n  chain.getChildEdge(edge, indexA);\n\n  const shapeA = edge;\n  const shapeB = fixtureB.getShape() as CircleShape;\n\n  CollideEdgeCircle(manifold, shapeA, xfA, shapeB, xfB);\n}\n\nconst e = matrix.vec2(0, 0);\nconst temp = matrix.vec2(0, 0);\nconst e1 = matrix.vec2(0, 0);\nconst e2 = matrix.vec2(0, 0);\nconst Q = matrix.vec2(0, 0);\nconst P = matrix.vec2(0, 0);\nconst n = matrix.vec2(0, 0);\n\n// Compute contact points for edge versus circle.\n// This accounts for edge connectivity.\nexport const CollideEdgeCircle = function (manifold: Manifold, edgeA: EdgeShape, xfA: TransformValue, circleB: CircleShape, xfB: TransformValue): void {\n  manifold.pointCount = 0;\n\n  // Compute circle in frame of edge\n  matrix.retransformVec2(Q, xfB, xfA, circleB.m_p);\n\n  const A = edgeA.m_vertex1;\n  const B = edgeA.m_vertex2;\n  matrix.diffVec2(e, B, A);\n\n  // Barycentric coordinates\n  const u = matrix.dotVec2(e, B) - matrix.dotVec2(e, Q);\n  const v = matrix.dotVec2(e, Q) - matrix.dotVec2(e, A);\n\n  const radius = edgeA.m_radius + circleB.m_radius;\n\n  // Region A\n  if (v <= 0.0) {\n    matrix.copyVec2(P, A);\n    const dd = matrix.distSqrVec2(Q, A);\n    if (dd > radius * radius) {\n      return;\n    }\n\n    // Is there an edge connected to A?\n    if (edgeA.m_hasVertex0) {\n      const A1 = edgeA.m_vertex0;\n      const B1 = A;\n      matrix.diffVec2(e1, B1, A1);\n      const u1 = matrix.dotVec2(e1, B1) - matrix.dotVec2(e1, Q);\n\n      // Is the circle in Region AB of the previous edge?\n      if (u1 > 0.0) {\n        return;\n      }\n    }\n\n    manifold.type = ManifoldType.e_circles;\n    matrix.zeroVec2(manifold.localNormal)\n    matrix.copyVec2(manifold.localPoint, P);\n    manifold.pointCount = 1;\n    matrix.copyVec2(manifold.points[0].localPoint, circleB.m_p);\n\n    // manifold.points[0].id.key = 0;\n    manifold.points[0].id.setFeatures(0, ContactFeatureType.e_vertex, 0, ContactFeatureType.e_vertex);\n    return;\n  }\n\n  // Region B\n  if (u <= 0.0) {\n    matrix.copyVec2(P, B);\n    const dd = matrix.distSqrVec2(Q, P);\n    if (dd > radius * radius) {\n      return;\n    }\n\n    // Is there an edge connected to B?\n    if (edgeA.m_hasVertex3) {\n      const B2 = edgeA.m_vertex3;\n      const A2 = B;\n      matrix.diffVec2(e2, B2, A2);\n      const v2 = matrix.dotVec2(e2, Q) - matrix.dotVec2(e2, A2);\n\n      // Is the circle in Region AB of the next edge?\n      if (v2 > 0.0) {\n        return;\n      }\n    }\n\n    manifold.type = ManifoldType.e_circles;\n    matrix.zeroVec2(manifold.localNormal)\n    matrix.copyVec2(manifold.localPoint, P);\n    manifold.pointCount = 1;\n    matrix.copyVec2(manifold.points[0].localPoint, circleB.m_p);\n\n    // manifold.points[0].id.key = 0;\n    manifold.points[0].id.setFeatures(1, ContactFeatureType.e_vertex, 0, ContactFeatureType.e_vertex);\n\n    return;\n  }\n\n  // Region AB\n  const den = matrix.lengthSqrVec2(e);\n  _ASSERT && console.assert(den > 0.0);\n  matrix.combineVec2(P, u / den, A, v / den, B);\n  const dd = matrix.distSqrVec2(Q, P);\n  if (dd > radius * radius) {\n    return;\n  }\n\n  matrix.crossNumVec2(n, 1, e);\n  if (matrix.dotVec2(n, Q) - matrix.dotVec2(n, A) < 0.0) {\n    matrix.negVec2(n);\n  }\n  matrix.normalizeVec2(n);\n\n  manifold.type = ManifoldType.e_faceA;\n  matrix.copyVec2(manifold.localNormal, n);\n  matrix.copyVec2(manifold.localPoint, A);\n  manifold.pointCount = 1;\n  matrix.copyVec2(manifold.points[0].localPoint, circleB.m_p);\n\n  // manifold.points[0].id.key = 0;\n  manifold.points[0].id.setFeatures(0, ContactFeatureType.e_face, 0, ContactFeatureType.e_vertex);\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { TransformValue } from '../../common/Transform';\nimport * as matrix from '../../common/Matrix';\nimport { SettingsInternal as Settings } from '../../Settings';\nimport { Manifold, clipSegmentToLine, ClipVertex, ContactFeatureType, ManifoldType } from '../Manifold';\nimport { Contact } from '../../dynamics/Contact';\nimport { PolygonShape } from './PolygonShape';\nimport { Fixture } from \"../../dynamics/Fixture\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\nconst incidentEdge = [ new ClipVertex(), new ClipVertex() ];\nconst clipPoints1 = [ new ClipVertex(), new ClipVertex() ];\nconst clipPoints2 = [ new ClipVertex(), new ClipVertex() ];\nconst clipSegmentToLineNormal = matrix.vec2(0, 0);\nconst v1 = matrix.vec2(0, 0);\nconst n = matrix.vec2(0, 0);\nconst xf = matrix.transform(0, 0, 0);\nconst temp = matrix.vec2(0, 0);\nconst v11 = matrix.vec2(0, 0);\nconst v12 = matrix.vec2(0, 0);\nconst localTangent = matrix.vec2(0, 0);\nconst localNormal = matrix.vec2(0, 0);\nconst planePoint = matrix.vec2(0, 0);\nconst tangent = matrix.vec2(0, 0);\nconst normal = matrix.vec2(0, 0);\nconst normal1 = matrix.vec2(0, 0);\n\n\nContact.addType(PolygonShape.TYPE, PolygonShape.TYPE, PolygonContact);\n\nfunction PolygonContact(\n  manifold: Manifold,\n  xfA: TransformValue,\n  fixtureA: Fixture,\n  indexA: number,\n  xfB: TransformValue,\n  fixtureB: Fixture,\n  indexB: number,\n): void {\n  _ASSERT && console.assert(fixtureA.getType() == PolygonShape.TYPE);\n  _ASSERT && console.assert(fixtureB.getType() == PolygonShape.TYPE);\n  CollidePolygons(manifold, fixtureA.getShape() as PolygonShape, xfA, fixtureB.getShape() as PolygonShape, xfB);\n}\n\ninterface MaxSeparation {\n  maxSeparation: number;\n  bestIndex: number;\n}\n\n/**\n * Find the max separation between poly1 and poly2 using edge normals from\n * poly1.\n */\nfunction findMaxSeparation(\n  poly1: PolygonShape,\n  xf1: TransformValue,\n  poly2: PolygonShape,\n  xf2: TransformValue,\n  output: MaxSeparation,\n): void {\n  const count1 = poly1.m_count;\n  const count2 = poly2.m_count;\n  const n1s = poly1.m_normals;\n  const v1s = poly1.m_vertices;\n  const v2s = poly2.m_vertices;\n\n  matrix.invTransformTransform(xf, xf2, xf1);\n\n  let bestIndex = 0;\n  let maxSeparation = -Infinity;\n  for (let i = 0; i < count1; ++i) {\n    // Get poly1 normal in frame2.\n    matrix.rotVec2(n, xf.q, n1s[i]);\n    matrix.transformVec2(v1, xf, v1s[i]);\n\n    // Find deepest point for normal i.\n    let si = Infinity;\n    for (let j = 0; j < count2; ++j) {\n      const sij = matrix.dotVec2(n, v2s[j]) - matrix.dotVec2(n, v1);\n      if (sij < si) {\n        si = sij;\n      }\n    }\n\n    if (si > maxSeparation) {\n      maxSeparation = si;\n      bestIndex = i;\n    }\n  }\n\n  // used to keep last FindMaxSeparation call values\n  output.maxSeparation = maxSeparation;\n  output.bestIndex = bestIndex;\n}\n\nfunction findIncidentEdge(\n  clipVertex: ClipVertex[],\n  poly1: PolygonShape,\n  xf1: TransformValue,\n  edge1: number,\n  poly2: PolygonShape,\n  xf2: TransformValue,\n): void {\n  const normals1 = poly1.m_normals;\n\n  const count2 = poly2.m_count;\n  const vertices2 = poly2.m_vertices;\n  const normals2 = poly2.m_normals;\n\n  _ASSERT && console.assert(0 <= edge1 && edge1 < poly1.m_count);\n\n  // Get the normal of the reference edge in poly2's frame.\n  matrix.rerotVec2(normal1, xf2.q, xf1.q, normals1[edge1]);\n\n  // Find the incident edge on poly2.\n  let index = 0;\n  let minDot = Infinity;\n  for (let i = 0; i < count2; ++i) {\n    const dot = matrix.dotVec2(normal1, normals2[i]);\n    if (dot < minDot) {\n      minDot = dot;\n      index = i;\n    }\n  }\n\n  // Build the clip vertices for the incident edge.\n  const i1 = index;\n  const i2 = i1 + 1 < count2 ? i1 + 1 : 0;\n\n  matrix.transformVec2(clipVertex[0].v, xf2, vertices2[i1]);\n  clipVertex[0].id.setFeatures(edge1, ContactFeatureType.e_face, i1, ContactFeatureType.e_vertex);\n\n  matrix.transformVec2(clipVertex[1].v, xf2, vertices2[i2]);\n  clipVertex[1].id.setFeatures(edge1, ContactFeatureType.e_face, i2, ContactFeatureType.e_vertex);\n}\n\nconst maxSeparation = {\n  maxSeparation: 0,\n  bestIndex: 0,\n};\n\n/**\n *\n * Find edge normal of max separation on A - return if separating axis is found<br>\n * Find edge normal of max separation on B - return if separation axis is found<br>\n * Choose reference edge as min(minA, minB)<br>\n * Find incident edge<br>\n * Clip\n *\n * The normal points from 1 to 2\n */\nexport const CollidePolygons = function (\n  manifold: Manifold,\n  polyA: PolygonShape,\n  xfA: TransformValue,\n  polyB: PolygonShape,\n  xfB: TransformValue,\n): void {\n  manifold.pointCount = 0;\n  const totalRadius = polyA.m_radius + polyB.m_radius;\n\n  findMaxSeparation(polyA, xfA, polyB, xfB, maxSeparation);\n  const edgeA = maxSeparation.bestIndex;\n  const separationA = maxSeparation.maxSeparation;\n  if (separationA > totalRadius)\n    return;\n\n  findMaxSeparation(polyB, xfB, polyA, xfA, maxSeparation);\n  const edgeB = maxSeparation.bestIndex;\n  const separationB = maxSeparation.maxSeparation;\n  if (separationB > totalRadius)\n    return;\n\n  let poly1: PolygonShape; // reference polygon\n  let poly2: PolygonShape; // incident polygon\n  let xf1: TransformValue;\n  let xf2: TransformValue;\n  let edge1: number; // reference edge\n  let flip: boolean;\n  const k_tol = 0.1 * Settings.linearSlop;\n\n  if (separationB > separationA + k_tol) {\n    poly1 = polyB;\n    poly2 = polyA;\n    xf1 = xfB;\n    xf2 = xfA;\n    edge1 = edgeB;\n    manifold.type = ManifoldType.e_faceB;\n    flip = true;\n  } else {\n    poly1 = polyA;\n    poly2 = polyB;\n    xf1 = xfA;\n    xf2 = xfB;\n    edge1 = edgeA;\n    manifold.type = ManifoldType.e_faceA;\n    flip = false;\n  }\n\n  incidentEdge[0].recycle(), incidentEdge[1].recycle();\n  findIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);\n\n  const count1 = poly1.m_count;\n  const vertices1 = poly1.m_vertices;\n\n  const iv1 = edge1;\n  const iv2 = edge1 + 1 < count1 ? edge1 + 1 : 0;\n\n  matrix.copyVec2(v11, vertices1[iv1]);\n  matrix.copyVec2(v12, vertices1[iv2]);\n\n  matrix.diffVec2(localTangent, v12, v11);\n  matrix.normalizeVec2(localTangent);\n\n  matrix.crossVec2Num(localNormal, localTangent, 1.0);\n  matrix.combineVec2(planePoint, 0.5, v11, 0.5, v12);\n\n  matrix.rotVec2(tangent, xf1.q, localTangent);\n  matrix.crossVec2Num(normal, tangent, 1.0);\n\n  matrix.transformVec2(v11, xf1, v11);\n  matrix.transformVec2(v12, xf1, v12);\n\n  // Face offset.\n  const frontOffset = matrix.dotVec2(normal, v11);\n\n  // Side offsets, extended by polytope skin thickness.\n  const sideOffset1 = -matrix.dotVec2(tangent, v11) + totalRadius;\n  const sideOffset2 = matrix.dotVec2(tangent, v12) + totalRadius;\n\n  // Clip incident edge against extruded edge1 side edges.\n  clipPoints1[0].recycle(), clipPoints1[1].recycle();\n  clipPoints2[0].recycle(), clipPoints2[1].recycle();\n\n  // Clip to box side 1\n  matrix.setVec2(clipSegmentToLineNormal, -tangent.x, -tangent.y);\n  const np1 = clipSegmentToLine(clipPoints1, incidentEdge, clipSegmentToLineNormal, sideOffset1, iv1);\n\n  if (np1 < 2) {\n    return;\n  }\n\n  // Clip to negative box side 1\n  matrix.setVec2(clipSegmentToLineNormal, tangent.x, tangent.y);\n  const np2 = clipSegmentToLine(clipPoints2, clipPoints1, clipSegmentToLineNormal, sideOffset2, iv2);\n\n  if (np2 < 2) {\n    return;\n  }\n\n  // Now clipPoints2 contains the clipped points.\n  matrix.copyVec2(manifold.localNormal, localNormal);\n  matrix.copyVec2(manifold.localPoint, planePoint);\n\n  let pointCount = 0;\n  for (let i = 0; i < clipPoints2.length/* maxManifoldPoints */; ++i) {\n    const separation = matrix.dotVec2(normal, clipPoints2[i].v) - frontOffset;\n\n    if (separation <= totalRadius) {\n      const cp = manifold.points[pointCount];\n      matrix.invTransformVec2(cp.localPoint, xf2, clipPoints2[i].v);\n      cp.id.set(clipPoints2[i].id);\n      if (flip) {\n        // Swap features\n        cp.id.swapFeatures();\n      }\n      ++pointCount;\n    }\n  }\n\n  manifold.pointCount = pointCount;\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport * as matrix from '../../common/Matrix';\nimport { math as Math } from '../../common/Math';\nimport { TransformValue } from '../../common/Transform';\nimport { Contact } from '../../dynamics/Contact';\nimport { CircleShape } from './CircleShape';\nimport { PolygonShape } from './PolygonShape';\nimport { Manifold, ContactFeatureType, ManifoldType } from \"../Manifold\";\nimport { Fixture } from \"../../dynamics/Fixture\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nContact.addType(PolygonShape.TYPE, CircleShape.TYPE, PolygonCircleContact);\n\nfunction PolygonCircleContact(manifold: Manifold, xfA: TransformValue, fixtureA: Fixture, indexA: number, xfB: TransformValue, fixtureB: Fixture, indexB: number): void {\n  _ASSERT && console.assert(fixtureA.getType() == PolygonShape.TYPE);\n  _ASSERT && console.assert(fixtureB.getType() == CircleShape.TYPE);\n  CollidePolygonCircle(manifold, fixtureA.getShape() as PolygonShape, xfA, fixtureB.getShape() as CircleShape, xfB);\n}\n\nconst cLocal = matrix.vec2(0, 0);\nconst faceCenter = matrix.vec2(0, 0);\n\nexport const CollidePolygonCircle = function (manifold: Manifold, polygonA: PolygonShape, xfA: TransformValue, circleB: CircleShape, xfB: TransformValue): void {\n  manifold.pointCount = 0;\n\n  // Compute circle position in the frame of the polygon.\n  matrix.retransformVec2(cLocal, xfB, xfA, circleB.m_p);\n\n  // Find the min separating edge.\n  let normalIndex = 0;\n  let separation = -Infinity;\n  const radius = polygonA.m_radius + circleB.m_radius;\n  const vertexCount = polygonA.m_count;\n  const vertices = polygonA.m_vertices;\n  const normals = polygonA.m_normals;\n\n  for (let i = 0; i < vertexCount; ++i) {\n    const s = matrix.dotVec2(normals[i], cLocal) - matrix.dotVec2(normals[i], vertices[i]);\n\n    if (s > radius) {\n      // Early out.\n      return;\n    }\n\n    if (s > separation) {\n      separation = s;\n      normalIndex = i;\n    }\n  }\n\n  // Vertices that subtend the incident face.\n  const vertIndex1 = normalIndex;\n  const vertIndex2 = vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0;\n  const v1 = vertices[vertIndex1];\n  const v2 = vertices[vertIndex2];\n\n  // If the center is inside the polygon ...\n  if (separation < Math.EPSILON) {\n    manifold.pointCount = 1;\n    manifold.type = ManifoldType.e_faceA;\n    matrix.copyVec2(manifold.localNormal, normals[normalIndex]);\n    matrix.combineVec2(manifold.localPoint, 0.5, v1, 0.5, v2);\n    matrix.copyVec2(manifold.points[0].localPoint, circleB.m_p);\n\n    // manifold.points[0].id.key = 0;\n    manifold.points[0].id.setFeatures(0, ContactFeatureType.e_vertex, 0, ContactFeatureType.e_vertex);\n    return;\n  }\n\n  // Compute barycentric coordinates\n  // u1 = (cLocal - v1) dot (v2 - v1))\n  const u1 = matrix.dotVec2(cLocal, v2) - matrix.dotVec2(cLocal, v1) - matrix.dotVec2(v1, v2) + matrix.dotVec2(v1, v1);\n  // u2 = (cLocal - v2) dot (v1 - v2)\n  const u2 = matrix.dotVec2(cLocal, v1) - matrix.dotVec2(cLocal, v2) - matrix.dotVec2(v2, v1) + matrix.dotVec2(v2, v2);\n  if (u1 <= 0.0) {\n    if (matrix.distSqrVec2(cLocal, v1) > radius * radius) {\n      return;\n    }\n\n    manifold.pointCount = 1;\n    manifold.type = ManifoldType.e_faceA;\n    matrix.diffVec2(manifold.localNormal, cLocal, v1);\n    matrix.normalizeVec2(manifold.localNormal);\n    matrix.copyVec2(manifold.localPoint, v1);\n    matrix.copyVec2(manifold.points[0].localPoint, circleB.m_p);\n\n    // manifold.points[0].id.key = 0;\n    manifold.points[0].id.setFeatures(0, ContactFeatureType.e_vertex, 0, ContactFeatureType.e_vertex);\n  } else if (u2 <= 0.0) {\n    if (matrix.distSqrVec2(cLocal, v2) > radius * radius) {\n      return;\n    }\n\n    manifold.pointCount = 1;\n    manifold.type = ManifoldType.e_faceA;\n    matrix.diffVec2(manifold.localNormal, cLocal, v2);\n    matrix.normalizeVec2(manifold.localNormal);\n    matrix.copyVec2(manifold.localPoint, v2);\n    matrix.copyVec2(manifold.points[0].localPoint, circleB.m_p);\n\n    // manifold.points[0].id.key = 0;\n    manifold.points[0].id.setFeatures(0, ContactFeatureType.e_vertex, 0, ContactFeatureType.e_vertex);\n  } else {\n    matrix.combineVec2(faceCenter, 0.5, v1, 0.5, v2);\n    const separation = matrix.dotVec2(cLocal, normals[vertIndex1]) - matrix.dotVec2(faceCenter, normals[vertIndex1]);\n    if (separation > radius) {\n      return;\n    }\n\n    manifold.pointCount = 1;\n    manifold.type = ManifoldType.e_faceA;\n    matrix.copyVec2(manifold.localNormal, normals[vertIndex1]);\n    matrix.copyVec2(manifold.localPoint, faceCenter);\n    matrix.copyVec2(manifold.points[0].localPoint, circleB.m_p);\n\n    // manifold.points[0].id.key = 0;\n    manifold.points[0].id.setFeatures(0, ContactFeatureType.e_vertex, 0, ContactFeatureType.e_vertex);\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport * as matrix from '../../common/Matrix';\nimport { TransformValue } from '../../common/Transform';\nimport { Vec2, Vec2Value } from '../../common/Vec2';\nimport { SettingsInternal as Settings } from '../../Settings';\nimport { Contact } from '../../dynamics/Contact';\nimport { Manifold, clipSegmentToLine, ClipVertex, ContactFeatureType, ManifoldType } from '../Manifold';\nimport { EdgeShape } from './EdgeShape';\nimport { ChainShape } from './ChainShape';\nimport { PolygonShape } from './PolygonShape';\nimport { Fixture } from \"../../dynamics/Fixture\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nContact.addType(EdgeShape.TYPE, PolygonShape.TYPE, EdgePolygonContact);\nContact.addType(ChainShape.TYPE, PolygonShape.TYPE, ChainPolygonContact);\n\nfunction EdgePolygonContact(manifold: Manifold, xfA: TransformValue, fA: Fixture, indexA: number, xfB: TransformValue, fB: Fixture, indexB: number): void {\n  _ASSERT && console.assert(fA.getType() == EdgeShape.TYPE);\n  _ASSERT && console.assert(fB.getType() == PolygonShape.TYPE);\n\n  CollideEdgePolygon(manifold, fA.getShape() as EdgeShape, xfA, fB.getShape() as PolygonShape, xfB);\n}\n\n// reused\nconst edge_reuse = new EdgeShape();\n\nfunction ChainPolygonContact(manifold: Manifold, xfA: TransformValue, fA: Fixture, indexA: number, xfB: TransformValue, fB: Fixture, indexB: number): void {\n  _ASSERT && console.assert(fA.getType() == ChainShape.TYPE);\n  _ASSERT && console.assert(fB.getType() == PolygonShape.TYPE);\n\n  const chain = fA.getShape() as ChainShape;\n  chain.getChildEdge(edge_reuse, indexA);\n\n  CollideEdgePolygon(manifold, edge_reuse, xfA, fB.getShape() as PolygonShape, xfB);\n}\n\nenum EPAxisType {\n  e_unknown = -1,\n  e_edgeA = 1,\n  e_edgeB = 2,\n}\n\n// unused?\nenum VertexType {\n e_isolated = 0,\n e_concave = 1,\n e_convex = 2,\n}\n\n/**\n * This structure is used to keep track of the best separating axis.\n */\nclass EPAxis {\n  type: EPAxisType;\n  index: number;\n  separation: number;\n}\n\n/**\n * This holds polygon B expressed in frame A.\n */\nclass TempPolygon {\n  vertices: Vec2Value[] = []; // [Settings.maxPolygonVertices]\n  normals: Vec2Value[] = []; // [Settings.maxPolygonVertices];\n  count: number = 0;\n  constructor() {\n    for (let i = 0; i < Settings.maxPolygonVertices; i++) {\n      this.vertices.push(matrix.vec2(0, 0));\n      this.normals.push(matrix.vec2(0, 0));\n    }\n  }\n}\n\n/**\n * Reference face used for clipping\n */\nclass ReferenceFace {\n  i1: number;\n  i2: number;\n  readonly v1 = matrix.vec2(0 ,0);\n  readonly v2 = matrix.vec2(0 ,0);\n  readonly normal = matrix.vec2(0 ,0);\n  readonly sideNormal1 = matrix.vec2(0 ,0);\n  sideOffset1: number;\n  readonly sideNormal2 = matrix.vec2(0 ,0);\n  sideOffset2: number;\n  recycle() {\n    matrix.zeroVec2(this.v1)\n    matrix.zeroVec2(this.v2)\n    matrix.zeroVec2(this.normal)\n    matrix.zeroVec2(this.sideNormal1)\n    matrix.zeroVec2(this.sideNormal2)\n  }\n}\n\n// reused\nconst clipPoints1 = [ new ClipVertex(), new ClipVertex() ];\nconst clipPoints2 = [ new ClipVertex(), new ClipVertex() ];\nconst ie = [ new ClipVertex(), new ClipVertex() ];\nconst edgeAxis = new EPAxis();\nconst polygonAxis = new EPAxis();\nconst polygonBA = new TempPolygon();\nconst rf = new ReferenceFace();\nconst centroidB = matrix.vec2(0, 0);\nconst edge0 = matrix.vec2(0, 0);\nconst edge1 = matrix.vec2(0, 0);\nconst edge2 = matrix.vec2(0, 0);\nconst xf = matrix.transform(0, 0, 0);\nconst normal = matrix.vec2(0, 0);\nconst normal0 = matrix.vec2(0, 0);\nconst normal1 = matrix.vec2(0, 0);\nconst normal2 = matrix.vec2(0, 0);\nconst lowerLimit = matrix.vec2(0, 0);\nconst upperLimit = matrix.vec2(0, 0);\nconst perp = matrix.vec2(0, 0);\nconst n = matrix.vec2(0, 0);\n\n/**\n * This function collides and edge and a polygon, taking into account edge\n * adjacency.\n */\nexport const CollideEdgePolygon = function (manifold: Manifold, edgeA: EdgeShape, xfA: TransformValue, polygonB: PolygonShape, xfB: TransformValue): void {\n  // Algorithm:\n  // 1. Classify v1 and v2\n  // 2. Classify polygon centroid as front or back\n  // 3. Flip normal if necessary\n  // 4. Initialize normal range to [-pi, pi] about face normal\n  // 5. Adjust normal range according to adjacent edges\n  // 6. Visit each separating axes, only accept axes within the range\n  // 7. Return if _any_ axis indicates separation\n  // 8. Clip\n\n  // let m_type1: VertexType;\n  // let m_type2: VertexType;\n\n  matrix.invTransformTransform(xf, xfA, xfB);\n  matrix.transformVec2(centroidB, xf, polygonB.m_centroid);\n\n  const v0 = edgeA.m_vertex0;\n  const v1 = edgeA.m_vertex1;\n  const v2 = edgeA.m_vertex2;\n  const v3 = edgeA.m_vertex3;\n\n  const hasVertex0 = edgeA.m_hasVertex0;\n  const hasVertex3 = edgeA.m_hasVertex3;\n\n  matrix.diffVec2(edge1, v2, v1);\n  matrix.normalizeVec2(edge1);\n  matrix.setVec2(normal1, edge1.y, -edge1.x)\n  const offset1 = matrix.dotVec2(normal1, centroidB) - matrix.dotVec2(normal1, v1);\n  let offset0 = 0.0;\n  let offset2 = 0.0;\n  let convex1 = false;\n  let convex2 = false;\n\n  matrix.zeroVec2(normal0);\n  matrix.zeroVec2(normal2);\n\n  // Is there a preceding edge?\n  if (hasVertex0) {\n    matrix.diffVec2(edge0, v1, v0);\n    matrix.normalizeVec2(edge0);\n    matrix.setVec2(normal0, edge0.y, -edge0.x);\n    convex1 = matrix.crossVec2Vec2(edge0, edge1) >= 0.0;\n    offset0 = Vec2.dot(normal0, centroidB) - Vec2.dot(normal0, v0);\n  }\n\n  // Is there a following edge?\n  if (hasVertex3) {\n    matrix.diffVec2(edge2, v3, v2);\n    matrix.normalizeVec2(edge2);\n    matrix.setVec2(normal2, edge2.y, -edge2.x);\n    convex2 = Vec2.crossVec2Vec2(edge1, edge2) > 0.0;\n    offset2 = Vec2.dot(normal2, centroidB) - Vec2.dot(normal2, v2);\n  }\n\n  let front: boolean;\n  matrix.zeroVec2(normal);\n  matrix.zeroVec2(lowerLimit);\n  matrix.zeroVec2(upperLimit);\n\n  // Determine front or back collision. Determine collision normal limits.\n  if (hasVertex0 && hasVertex3) {\n    if (convex1 && convex2) {\n      front = offset0 >= 0.0 || offset1 >= 0.0 || offset2 >= 0.0;\n      if (front) {\n        matrix.copyVec2(normal, normal1);\n        matrix.copyVec2(lowerLimit, normal0);\n        matrix.copyVec2(upperLimit, normal2);\n      } else {\n        matrix.setMulVec2(normal, -1, normal1);\n        matrix.setMulVec2(lowerLimit, -1, normal1);\n        matrix.setMulVec2(upperLimit, -1, normal1);\n      }\n    } else if (convex1) {\n      front = offset0 >= 0.0 || (offset1 >= 0.0 && offset2 >= 0.0);\n      if (front) {\n        matrix.copyVec2(normal, normal1);\n        matrix.copyVec2(lowerLimit, normal0);\n        matrix.copyVec2(upperLimit, normal1);\n      } else {\n        matrix.setMulVec2(normal, -1, normal1);\n        matrix.setMulVec2(lowerLimit, -1, normal2);\n        matrix.setMulVec2(upperLimit, -1, normal1);\n      }\n    } else if (convex2) {\n      front = offset2 >= 0.0 || (offset0 >= 0.0 && offset1 >= 0.0);\n      if (front) {\n        matrix.copyVec2(normal, normal1);\n        matrix.copyVec2(lowerLimit, normal1);\n        matrix.copyVec2(upperLimit, normal2);\n      } else {\n        matrix.setMulVec2(normal, -1, normal1);\n        matrix.setMulVec2(lowerLimit, -1, normal1);\n        matrix.setMulVec2(upperLimit, -1, normal0);\n      }\n    } else {\n      front = offset0 >= 0.0 && offset1 >= 0.0 && offset2 >= 0.0;\n      if (front) {\n        matrix.copyVec2(normal, normal1);\n        matrix.copyVec2(lowerLimit, normal1);\n        matrix.copyVec2(upperLimit, normal1);\n      } else {\n        matrix.setMulVec2(normal, -1, normal1);\n        matrix.setMulVec2(lowerLimit, -1, normal2);\n        matrix.setMulVec2(upperLimit, -1, normal0);\n      }\n    }\n  } else if (hasVertex0) {\n    if (convex1) {\n      front = offset0 >= 0.0 || offset1 >= 0.0;\n      if (front) {\n        matrix.copyVec2(normal, normal1);\n        matrix.copyVec2(lowerLimit, normal0);\n        matrix.setMulVec2(upperLimit, -1, normal1);\n      } else {\n        matrix.setMulVec2(normal, -1, normal1);\n        matrix.copyVec2(lowerLimit, normal1);\n        matrix.setMulVec2(upperLimit, -1, normal1);\n      }\n    } else {\n      front = offset0 >= 0.0 && offset1 >= 0.0;\n      if (front) {\n        matrix.copyVec2(normal, normal1);\n        matrix.copyVec2(lowerLimit, normal1);\n        matrix.setMulVec2(upperLimit, -1, normal1);\n      } else {\n        matrix.setMulVec2(normal, -1, normal1);\n        matrix.copyVec2(lowerLimit, normal1);\n        matrix.setMulVec2(upperLimit, -1, normal0);\n      }\n    }\n  } else if (hasVertex3) {\n    if (convex2) {\n      front = offset1 >= 0.0 || offset2 >= 0.0;\n      if (front) {\n        matrix.copyVec2(normal, normal1);\n        matrix.setMulVec2(lowerLimit, -1, normal1);\n        matrix.copyVec2(upperLimit, normal2);\n      } else {\n        matrix.setMulVec2(normal, -1, normal1);\n        matrix.setMulVec2(lowerLimit, -1, normal1);\n        matrix.copyVec2(upperLimit, normal1);\n      }\n    } else {\n      front = offset1 >= 0.0 && offset2 >= 0.0;\n      if (front) {\n        matrix.copyVec2(normal, normal1);\n        matrix.setMulVec2(lowerLimit, -1, normal1);\n        matrix.copyVec2(upperLimit, normal1);\n      } else {\n        matrix.setMulVec2(normal, -1, normal1);\n        matrix.setMulVec2(lowerLimit, -1, normal2);\n        matrix.copyVec2(upperLimit, normal1);\n      }\n    }\n  } else {\n    front = offset1 >= 0.0;\n    if (front) {\n      matrix.copyVec2(normal, normal1);\n      matrix.setMulVec2(lowerLimit, -1, normal1);\n      matrix.setMulVec2(upperLimit, -1, normal1);\n    } else {\n      matrix.setMulVec2(normal, -1, normal1);\n      matrix.copyVec2(lowerLimit, normal1);\n      matrix.copyVec2(upperLimit, normal1);\n    }\n  }\n\n  // Get polygonB in frameA\n  polygonBA.count = polygonB.m_count;\n  for (let i = 0; i < polygonB.m_count; ++i) {\n    matrix.transformVec2(polygonBA.vertices[i], xf, polygonB.m_vertices[i]);\n    matrix.rotVec2(polygonBA.normals[i], xf.q, polygonB.m_normals[i]);\n  }\n\n  const radius = polygonB.m_radius + edgeA.m_radius;\n\n  manifold.pointCount = 0;\n\n  { // ComputeEdgeSeparation\n    edgeAxis.type = EPAxisType.e_edgeA;\n    edgeAxis.index = front ? 0 : 1;\n    edgeAxis.separation = Infinity;\n\n    for (let i = 0; i < polygonBA.count; ++i) {\n      const v = polygonBA.vertices[i];\n      const s = matrix.dotVec2(normal, v) - matrix.dotVec2(normal, v1);\n      if (s < edgeAxis.separation) {\n        edgeAxis.separation = s;\n      }\n    }\n  }\n\n  // If no valid normal can be found than this edge should not collide.\n  // @ts-ignore\n  if (edgeAxis.type == EPAxisType.e_unknown) {\n    return;\n  }\n\n  if (edgeAxis.separation > radius) {\n    return;\n  }\n\n  { // ComputePolygonSeparation\n    polygonAxis.type = EPAxisType.e_unknown;\n    polygonAxis.index = -1;\n    polygonAxis.separation = -Infinity;\n\n    matrix.setVec2(perp, -normal.y, normal.x);\n\n    for (let i = 0; i < polygonBA.count; ++i) {\n      matrix.setMulVec2(n, -1, polygonBA.normals[i]);\n\n      const s1 = matrix.dotVec2(n, polygonBA.vertices[i]) - matrix.dotVec2(n, v1);\n      const s2 = matrix.dotVec2(n, polygonBA.vertices[i]) - matrix.dotVec2(n, v2);\n      const s = Math.min(s1, s2);\n\n      if (s > radius) {\n        // No collision\n        polygonAxis.type = EPAxisType.e_edgeB;\n        polygonAxis.index = i;\n        polygonAxis.separation = s;\n        break;\n      }\n\n      // Adjacency\n      if (matrix.dotVec2(n, perp) >= 0.0) {\n        if (matrix.dotVec2(n, normal) - matrix.dotVec2(upperLimit, normal) < -Settings.angularSlop) {\n          continue;\n        }\n      } else {\n        if (matrix.dotVec2(n, normal) - matrix.dotVec2(lowerLimit, normal) < -Settings.angularSlop) {\n          continue;\n        }\n      }\n\n      if (s > polygonAxis.separation) {\n        polygonAxis.type = EPAxisType.e_edgeB;\n        polygonAxis.index = i;\n        polygonAxis.separation = s;\n      }\n    }\n  }\n\n  if (polygonAxis.type != EPAxisType.e_unknown && polygonAxis.separation > radius) {\n    return;\n  }\n\n  // Use hysteresis for jitter reduction.\n  const k_relativeTol = 0.98;\n  const k_absoluteTol = 0.001;\n\n  let primaryAxis: EPAxis;\n  if (polygonAxis.type == EPAxisType.e_unknown) {\n    primaryAxis = edgeAxis;\n  } else if (polygonAxis.separation > k_relativeTol * edgeAxis.separation + k_absoluteTol) {\n    primaryAxis = polygonAxis;\n  } else {\n    primaryAxis = edgeAxis;\n  }\n\n  ie[0].recycle(), ie[1].recycle();\n\n  if (primaryAxis.type == EPAxisType.e_edgeA) {\n    manifold.type = ManifoldType.e_faceA;\n\n    // Search for the polygon normal that is most anti-parallel to the edge\n    // normal.\n    let bestIndex = 0;\n    let bestValue = matrix.dotVec2(normal, polygonBA.normals[0]);\n    for (let i = 1; i < polygonBA.count; ++i) {\n      const value = matrix.dotVec2(normal, polygonBA.normals[i]);\n      if (value < bestValue) {\n        bestValue = value;\n        bestIndex = i;\n      }\n    }\n\n    const i1 = bestIndex;\n    const i2 = i1 + 1 < polygonBA.count ? i1 + 1 : 0;\n\n    matrix.copyVec2(ie[0].v, polygonBA.vertices[i1]);\n    ie[0].id.setFeatures(0, ContactFeatureType.e_face, i1, ContactFeatureType.e_vertex);\n\n    matrix.copyVec2(ie[1].v, polygonBA.vertices[i2]);\n    ie[1].id.setFeatures(0, ContactFeatureType.e_face, i2, ContactFeatureType.e_vertex);\n\n    if (front) {\n      rf.i1 = 0;\n      rf.i2 = 1;\n      matrix.copyVec2(rf.v1, v1);\n      matrix.copyVec2(rf.v2, v2);\n      matrix.copyVec2(rf.normal, normal1);\n    } else {\n      rf.i1 = 1;\n      rf.i2 = 0;\n      matrix.copyVec2(rf.v1, v2);\n      matrix.copyVec2(rf.v2, v1);\n      matrix.setMulVec2(rf.normal, -1, normal1);\n    }\n  } else {\n    manifold.type = ManifoldType.e_faceB;\n\n    matrix.copyVec2(ie[0].v, v1);\n    ie[0].id.setFeatures(0, ContactFeatureType.e_vertex, primaryAxis.index, ContactFeatureType.e_face);\n\n    matrix.copyVec2(ie[1].v, v2);\n    ie[1].id.setFeatures(0, ContactFeatureType.e_vertex, primaryAxis.index, ContactFeatureType.e_face);\n\n    rf.i1 = primaryAxis.index;\n    rf.i2 = rf.i1 + 1 < polygonBA.count ? rf.i1 + 1 : 0;\n    matrix.copyVec2(rf.v1, polygonBA.vertices[rf.i1]);\n    matrix.copyVec2(rf.v2, polygonBA.vertices[rf.i2]);\n    matrix.copyVec2(rf.normal, polygonBA.normals[rf.i1]);\n  }\n\n  matrix.setVec2(rf.sideNormal1, rf.normal.y, -rf.normal.x);\n  matrix.setVec2(rf.sideNormal2, -rf.sideNormal1.x, -rf.sideNormal1.y);\n  rf.sideOffset1 = matrix.dotVec2(rf.sideNormal1, rf.v1);\n  rf.sideOffset2 = matrix.dotVec2(rf.sideNormal2, rf.v2);\n\n  // Clip incident edge against extruded edge1 side edges.\n  clipPoints1[0].recycle(), clipPoints1[1].recycle();\n  clipPoints2[0].recycle(), clipPoints2[1].recycle();\n\n  // Clip to box side 1\n  const np1 = clipSegmentToLine(clipPoints1, ie, rf.sideNormal1, rf.sideOffset1, rf.i1);\n\n  if (np1 < Settings.maxManifoldPoints) {\n    return;\n  }\n\n  // Clip to negative box side 1\n  const np2 = clipSegmentToLine(clipPoints2, clipPoints1, rf.sideNormal2, rf.sideOffset2, rf.i2);\n\n  if (np2 < Settings.maxManifoldPoints) {\n    return;\n  }\n\n  // Now clipPoints2 contains the clipped points.\n  if (primaryAxis.type == EPAxisType.e_edgeA) {\n    matrix.copyVec2(manifold.localNormal, rf.normal);\n    matrix.copyVec2(manifold.localPoint, rf.v1);\n  } else {\n    matrix.copyVec2(manifold.localNormal, polygonB.m_normals[rf.i1]);\n    matrix.copyVec2(manifold.localPoint, polygonB.m_vertices[rf.i1]);\n  }\n\n  let pointCount = 0;\n  for (let i = 0; i < Settings.maxManifoldPoints; ++i) {\n    const separation = matrix.dotVec2(rf.normal, clipPoints2[i].v) - matrix.dotVec2(rf.normal, rf.v1);\n\n    if (separation <= radius) {\n      const cp = manifold.points[pointCount]; // ManifoldPoint\n\n      if (primaryAxis.type == EPAxisType.e_edgeA) {\n        matrix.invTransformVec2(cp.localPoint, xf, clipPoints2[i].v);\n        cp.id.set(clipPoints2[i].id);\n      } else {\n        matrix.copyVec2(cp.localPoint, clipPoints2[i].v);\n        cp.id.set(clipPoints2[i].id);\n        cp.id.swapFeatures();\n      }\n\n      ++pointCount;\n    }\n  }\n\n  manifold.pointCount = pointCount;\n}\n","export * from './serializer/index';\n\nexport * from './common/Math';\n\nexport * from './common/Vec2';\nexport * from './common/Vec3';\nexport * from './common/Mat22';\nexport * from './common/Mat33';\nexport * from './common/Transform';\nexport * from './common/Rot';\n\nexport * from './collision/AABB';\n\nexport * from './collision/Shape';\nexport * from './dynamics/Fixture';\nexport * from './dynamics/Body';\nexport * from './dynamics/Contact';\nexport * from './dynamics/Joint';\nexport * from './dynamics/World';\n\nexport * from './collision/shape/CircleShape';\nexport * from './collision/shape/EdgeShape';\nexport * from './collision/shape/PolygonShape';\nexport * from './collision/shape/ChainShape';\nexport * from './collision/shape/BoxShape';\n\nexport * from './collision/shape/CollideCircle';\nexport * from './collision/shape/CollideEdgeCircle';\nexport * from './collision/shape/CollidePolygon';\nexport * from './collision/shape/CollideCirclePolygon';\nexport * from './collision/shape/CollideEdgePolygon';\n\nexport * from './dynamics/joint/DistanceJoint';\nexport * from './dynamics/joint/FrictionJoint';\nexport * from './dynamics/joint/GearJoint';\nexport * from './dynamics/joint/MotorJoint';\nexport * from './dynamics/joint/MouseJoint';\nexport * from './dynamics/joint/PrismaticJoint';\nexport * from './dynamics/joint/PulleyJoint';\nexport * from './dynamics/joint/RevoluteJoint';\nexport * from './dynamics/joint/RopeJoint';\nexport * from './dynamics/joint/WeldJoint';\nexport * from './dynamics/joint/WheelJoint';\n\nexport * from './Settings';\n\nexport * from './common/Sweep';\nexport * from './collision/Manifold';\nexport * from './collision/Distance';\nexport * from './collision/TimeOfImpact';\nexport * from './collision/DynamicTree';\nexport * from './util/stats';\n\nimport { math } from './common/Math';\n\nexport const Math = math;\n\nimport { CollidePolygons } from './collision/shape/CollidePolygon';\nimport { SettingsInternal as Settings } from './Settings';\nimport { Sweep } from './common/Sweep';\nimport { DynamicTree } from './collision/DynamicTree';\nimport { Manifold } from './collision/Manifold';\nimport { Distance } from './collision/Distance';\nimport { TimeOfImpact } from './collision/TimeOfImpact';\nimport { stats } from './util/stats';\n\n/** @deprecated Merged with main namespace */\nexport const internal = {\n  CollidePolygons,\n  Settings,\n  Sweep,\n  Manifold,\n  Distance,\n  TimeOfImpact,\n  DynamicTree,\n  stats\n};\n"],"names":["options","input","defaults","output","Object","assign","key","hasOwnProperty","getOwnPropertySymbols","symbols","i","length","symbol","propertyIsEnumerable","math","create","Math","EPSILON","isFinite","x","isNaN","assert","nextPowerOfTwo","isPowerOfTwo","mod","num","min","max","clamp","random","Vec2","[object Object]","y","this","data","obj","prototype","v","neo","JSON","stringify","o","clone","value","a","b","w","setCombine","setMul","addCombine","addMul","subCombine","subMul","m","lengthOf","lengthSquared","invLength","sqrt","dx","dy","combine","mulNumVec2","zero","abs","lengthSqr","scale","r","AABB","lower","upper","lowerBound","upperBound","setVec2","isValid","sub","lowerA","upperA","lowerB","upperB","lowerX","lowerY","upperX","upperY","setNum","aabb","result","extend","out","d1x","d2x","d1y","d2y","areEqual","wD","hD","tmin","Infinity","tmax","p","p1","d","p2","absD","normal","f","inv_d","t1","t2","s","temp","setZero","maxFraction","fraction","lx","ly","Settings","polygonRadius","linearSlop","lengthUnitsPerMeter","maxManifoldPoints","maxPolygonVertices","aabbExtension","aabbMultiplier","angularSlop","PI","maxSubSteps","maxTOIContacts","maxTOIIterations","maxDistnceIterations","velocityThreshold","maxLinearCorrection","maxAngularCorrection","maxTranslation","maxRotation","baumgarte","toiBaugarte","timeToSleep","linearSleepTolerance","angularSleepTolerance","SettingsInternal","linearSlopSquared","maxTranslationSquared","maxRotationSquared","linearSleepToleranceSqr","angularSleepToleranceSqr","Pool","opts","_list","_max","_hasCreateFn","_createCount","_hasAllocateFn","_allocateCount","_hasReleaseFn","_releaseCount","_hasDisposeFn","_disposeCount","_createFn","_allocateFn","allocate","_releaseFn","release","_disposeFn","dispose","n","item","shift","push","TreeNode","id","userData","parent","child1","child2","height","poolTreeNode","node","undefined","DynamicTree","inputPool","stack","stackPool","iteratorPool","Iterator","iterator","close","m_root","m_nodes","m_lastProxyId","allocateNode","set","insertLeaf","removeLeaf","freeNode","contains","leaf","leafAABB","index","isLeaf","area","getPerimeter","combinedArea","combinedPerimeter","cost","inheritanceCost","cost1","cost2","sibling","oldParent","newParent","balance","grandParent","iA","A","B","C","F","G","D","E","rootArea","totalArea","it","preorder","next","height1","computeHeight","height2","validateStructure","validateMetrics","maxBalance","nodes","count","minCost","iMin","jMin","aabbi","j","aabbj","newOrigin","queryCallback","pop","testOverlap","rayCastCallback","normalize","crossNumVec2","abs_v","segmentAABB","t","combinePoints","subInput","c","getCenter","h","getExtents","dot","parents","states","root","BroadPhase","m_tree","m_moveBuffer","query","proxyId","m_queryProxyId","proxyIdA","proxyIdB","userDataA","getUserData","userDataB","m_callback","aabbA","getFatAABB","aabbB","getHeight","getMaxBalance","getAreaRatio","rayCast","shiftOrigin","createProxy","bufferMove","unbufferMove","destroyProxy","displacement","moveProxy","addPairCallback","fatAABB","vec2","copyVec2","zeroVec2","negVec2","addVec2","subVec2","diffVec2","scaleVec2","setMulVec2","addMulVec2","subMulVec2","combineVec2","am","bm","normalizeVec2","crossVec2Num","crossVec2Vec2","dotVec2","lengthSqrVec2","distVec2","distSqrVec2","rotVec2","q","invRotVec2","transform","angle","sin","cos","copyTransform","transformVec2","xf","invTransformVec2","px","py","retransformVec2","from","to","x0","y0","invTransformTransform","Rot","setAngle","setRot","setIdentity","rot","atan2","qr","identity","matrix.vec2","Sweep","localCenter","alpha0","c0","a0","matrix.zeroVec2","matrix.transformVec2","matrix.copyVec2","beta","matrix.setRotAngle","matrix.combineVec2","matrix.subVec2","matrix.rotVec2","alpha","that","Transform","position","rotation","Array","isArray","arr","mul","mulVec2","mulXf","mulRot","add","mulTVec2","mulTXf","mulTRot","Velocity","Position","getTransform","Shape","m_type","m_radius","synchronize_aabb1","synchronize_aabb2","FixtureDefDefault","friction","restitution","density","isSensor","filterGroupIndex","filterCategoryBits","filterMaskBits","FixtureProxy","fixture","childIndex","Fixture","body","shape","def","m_body","m_friction","m_restitution","m_density","m_isSensor","m_filterGroupIndex","m_filterCategoryBits","m_filterMaskBits","m_shape","m_next","m_proxies","childCount","getChildCount","m_userData","getBody","broadPhase","m_world","m_broadPhase","destroyProxies","_reset","createProxies","m_xf","resetMassData","restore","sensor","setAwake","testPoint","massData","computeMass","proxy","computeAABB","xf1","xf2","matrix.diffVec2","filter","groupIndex","categoryBits","maskBits","refilter","edge","getContactList","contact","fixtureA","getFixtureA","fixtureB","getFixtureB","flagForFiltering","world","getWorld","touchProxy","collideA","collideB","STATIC","KINEMATIC","DYNAMIC","oldCenter","matrix.transform","BodyDefDefault","type","linearVelocity","angularVelocity","linearDamping","angularDamping","fixedRotation","bullet","gravityScale","allowSleep","awake","active","MassData","mass","center","I","Body","m_awakeFlag","m_autoSleepFlag","m_bulletFlag","m_fixedRotationFlag","m_activeFlag","m_islandFlag","m_toiFlag","m_mass","m_invMass","m_I","m_invI","m_sweep","setTransform","c_velocity","c_position","m_force","m_torque","m_linearVelocity","m_angularVelocity","m_linearDamping","m_angularDamping","m_gravityScale","m_sleepTime","m_jointList","m_contactList","m_fixtureList","m_prev","m_destroyed","fixtures","getAngle","_addFixture","isLocked","setType","isWorldLocked","forward","synchronizeFixtures","ce","ce0","destroyContact","flag","synchronize","advance","worldPoint","localPoint","getLinearVelocityFromWorldPoint","getWorldPoint","getInertia","isStatic","isKinematic","getMassData","matrix.addMulVec2","matrix.setMulVec2","matrix.dotVec2","setLocalCenter","matrix.crossNumVec2","force","point","wake","torque","impulse","jn","other","joint","m_collideConnected","m_newFixture","fixdef","publish","localVector","worldVector","JointEdge","prev","Joint","bodyA","bodyB","m_edgeA","m_edgeB","m_bodyA","m_bodyB","collideConnected","isActive","stats","gjkCalls","gjkIters","gjkMaxIters","toiTime","toiMaxTime","toiCalls","toiIters","toiMaxIters","toiRootIters","toiMaxRootIters","newline","string","name","Timer","Date","now","time","e12","e13","e23","temp1","temp2","DistanceInput","proxyA","DistanceProxy","proxyB","transformA","transformB","useRadii","recycle","DistanceOutput","pointA","pointB","distance","iterations","SimplexCache","metric","indexA","indexB","Distance","cache","xfA","xfB","simplex","readCache","vertices","m_v","k_maxIters","saveA","saveB","saveCount","iter","m_count","solve","getSearchDirection","matrix.lengthSqrVec2","vertex","getSupport","matrix.invRotVec2","wA","getVertex","wB","duplicate","getWitnessPoints","matrix.distVec2","writeCache","rA","rB","matrix.normalizeVec2","matrix.subMulVec2","m_vertices","bestIndex","bestValue","computeDistanceProxy","radius","SimplexVertex","searchDirection_reuse","closestPoint_reuse","Simplex","m_v1","m_v2","m_v3","toString","wALocal","wBLocal","metric1","metric2","getMetric","v1","v2","matrix.setVec2","matrix.crossVec2Vec2","pA","pB","v3","solve2","solve3","w1","w2","d12_2","d12_1","inv_d12","w3","w1e12","w1e13","d13_1","d13_2","w2e23","d23_1","d23_2","n123","d123_1","d123_2","d123_3","inv_d13","inv_d23","inv_d123","shapeA","shapeB","matrix.copyTransform","Input","Output","Proxy","Cache","ShapeCastInput","translationB","ShapeCastOutput","lambda","ShapeCast","radiusA","neg","sigma","tolerance","vp","vr","getClosestPoint","TOIInput","sweepA","sweepB","tMax","TOIOutputState","exports","TOIOutput","state","e_unset","distanceInput","distanceOutput","axisA","axisB","localPointA","localPointB","TimeOfImpact","timer","e_unknown","totalRadius","target","k_maxIterations","setVertices","e_overlapped","e_touching","separationFunction","initialize","done","pushBackIter","s2","findMinSeparation","e_separated","s1","evaluate","e_failed","rootIterCount","a1","a2","SeparationFunctionType","m_proxyA","m_proxyB","m_sweepA","m_sweepB","m_localPoint","m_axis","e_points","matrix.normalizeVec2Length","e_faceB","localPointB1","localPointB2","matrix.crossVec2Num","matrix.negVec2","e_faceA","localPointA1","localPointA2","find","compute","TimeStep","dt","inv_dt","velocityIterations","positionIterations","warmStarting","blockSolve","inv_dt0","dtRatio","s_subStep","translation","backup","backup1","backup2","ContactImpulse","normals","tangents","normalImpulses","v_points","normalImpulse","tangentImpulses","tangentImpulse","Solver","m_stack","m_bodies","m_contacts","m_joints","step","m_bodyList","seed","isAwake","clear","addBody","isEnabled","isTouching","sensorA","m_fixtureA","sensorB","m_fixtureB","addContact","je","addJoint","solveIsland","gravity","m_gravity","m_allowSleep","isDynamic","initConstraint","initVelocityConstraint","warmStartConstraint","initVelocityConstraints","solveVelocityConstraints","solveVelocityConstraint","storeConstraintImpulses","translationLengthSqr","ratio","matrix.scaleVec2","positionSolved","minSeparation","separation","solvePositionConstraint","contactsOkay","jointsOkay","jointOkay","solvePositionConstraints","synchronizeTransform","postSolveIsland","minSleepTime","linTolSqr","angTolSqr","m_stepComplete","m_toiCount","m_toi","minContact","minAlpha","fA","fB","bA","bB","activeA","activeB","isBullet","getChildIndexA","getChildIndexB","getShape","update","setEnabled","bodies","reset","solveIslandTOI","findNewContacts","m_subStepping","subStep","toiA","toiB","solvePositionConstraintTOI","postSolve","m_impulse","Mat22","ex","ey","det","imx","mx","c1","c2","mx1","mx2","cA","cB","dist","planePoint","clipPoint","ManifoldType","ContactFeatureType","PointState","ClipVertex","ContactID","Manifold","localNormal","points","ManifoldPoint","pointCount","wm","radiusB","WorldManifold","separations","e_circles","manifoldPoint","clipSegmentToLine","getPointStates","typeA","typeB","state1","state2","manifold1","manifold2","removeState","persistState","addState","vOut","vIn","offset","vertexIndexA","numOut","distance0","distance1","interp","setFeatures","e_vertex","e_face","contactPool","Contact","oldManifold","worldManifold","ContactEdge","mixFriction","friction1","friction2","mixRestitution","restitution1","restitution2","s_registers","VelocityConstraintPoint","normalMass","tangentMass","velocityBias","vA","vB","tangent","P","dv","dv1","dv2","P1","P2","m_nodeA","m_nodeB","m_indexA","m_indexB","m_evaluateFcn","m_manifold","m_tangentSpeed","m_enabledFlag","m_touchingFlag","m_filterFlag","m_bulletHitFlag","v_normal","v_normalMass","v_K","v_pointCount","v_tangentSpeed","v_friction","v_restitution","v_invMassA","v_invMassB","v_invIA","v_invIB","p_localPoints","p_localNormal","p_localPoint","p_localCenterA","p_localCenterB","p_type","p_radiusA","p_radiusB","p_pointCount","p_invMassA","p_invMassB","p_invIA","p_invIB","evaluateFcn","manifold","cp","vcp","getWorldManifold","speed","listener","touching","wasTouching","nmp","omp","hasListener","beginContact","endContact","preSolve","_solvePositionConstraint","toi","positionA","positionB","localCenterA","localCenterB","mA","mB","iB","aA","aB","rnA","rnB","K","velocityA","velocityB","wmp","kNormal","rtA","rtB","kTangent","vRel","vcp1","vcp2","rn1A","rn1B","rn2A","rn2B","k11","k22","k12","matrix.addVec2","vt","maxFriction","newImpulse","vn","vn1","vn2","type1","type2","callback","WorldDefDefault","continuousPhysics","subStepping","World","s_step","m_solver","m_contactCount","m_bodyCount","m_jointCount","m_clearForces","m_locked","m_warmStarting","m_continuousPhysics","m_blockSolve","m_velocityIterations","m_positionIterations","m_t","joints","getBodyList","getNext","getJointList","_serialize","context","_addBody","createJoint","point1","point2","getProxyCount","getTreeHeight","getTreeBalance","getTreeQuality","arg1","arg2","createBody","je0","destroyJoint","f0","timeStep","updateContacts","solveWorld","solveWorldTOI","clearForces","updatePairs","createContact","shouldCollide","next_c","destroy","_listeners","listeners","indexOf","splice","arg3","l","call","Vec3","z","EdgeShape","super","TYPE","m_vertex1","m_vertex2","m_vertex0","m_vertex3","m_hasVertex0","m_hasVertex3","vertex1","vertex2","vertex0","vertex3","hasVertex0","hasVertex3","setPrevVertex","setNextVertex","e","numerator","denominator","rr","Edge","ChainShape","loop","m_prevVertex","m_nextVertex","m_hasPrevVertex","m_hasNextVertex","m_isLoop","_createLoop","_createChain","isLoop","hasPrevVertex","hasNextVertex","prevVertex","nextVertex","Chain","e1","e2","PolygonShape","m_centroid","m_normals","_set","_setAsBox","ps","unique","distanceSquared","i0","hull","ih","ie","i1","i2","vs","pRef","inv3","p3","triangleArea","ComputeCentroid","hx","hy","pLocal","matrix.invTransformVec2","minX","minY","maxX","maxY","k_inv3","ex1","ey1","ex2","ey2","matrix.sumVec2","Polygon","BoxShape","Box","CircleShape","m_p","matrix.distSqrVec2","Circle","DEFAULTS","frequencyHz","dampingRatio","DistanceJoint","anchorA","anchorB","m_localAnchorA","getLocalPoint","localAnchorA","m_localAnchorB","localAnchorB","m_length","m_frequencyHz","m_dampingRatio","m_gamma","m_bias","gamma","bias","hz","m_u","m_localCenterA","m_localCenterB","m_invMassA","m_invMassB","m_invIA","m_invIB","qA","qB","m_rA","m_rB","crAu","crBu","invMass","omega","k","vpA","vpB","Cdot","mulSub","u","maxForce","maxTorque","FrictionJoint","anchor","m_linearImpulse","m_angularImpulse","m_maxForce","m_maxTorque","m_linearMass","getInverse","m_angularMass","oldImpulse","maxImpulse","Mat33","ez","cross_x","cross_y","cross_z","a11","a12","a21","a22","M","cross","a13","a23","a33","lowerAngle","upperAngle","maxMotorTorque","motorSpeed","enableLimit","enableMotor","RevoluteJoint","m_limitState","m_referenceAngle","referenceAngle","m_motorImpulse","m_lowerAngle","m_upperAngle","m_maxMotorTorque","m_motorSpeed","m_enableLimit","m_enableMotor","m_motorMass","jointAngle","Cdot1","Cdot2","solve33","rhs","reduced","solve22","angularError","positionError","limitImpulse","lowerTranslation","upperTranslation","maxMotorForce","PrismaticJoint","axis","m_localXAxisA","getLocalVector","localAxisA","m_localYAxisA","m_lowerTranslation","m_upperTranslation","m_maxMotorForce","m_perp","m_K","getWorldVector","addCrossNumVec2","m_a1","m_a2","m_s1","m_s2","k13","k23","k33","jointTranslation","LA","LB","f1","df","f2r","perp","C1","linearError","C2","impulse1","GearJoint","joint1","joint2","coordinateA","coordinateB","m_joint1","m_joint2","m_ratio","m_type1","getType","m_type2","m_bodyC","getBodyA","getBodyB","xfC","aC","revolute","m_localAnchorC","m_referenceAngleA","m_localAxisC","prismatic","pC","m_bodyD","xfD","aD","m_localAnchorD","m_referenceAngleB","m_localAxisD","pD","m_constant","m_JvAC","m_JwA","m_lcA","m_lcB","m_lcC","m_lcD","m_mA","m_mB","m_mC","m_mD","m_iA","m_iB","m_iC","m_iD","vC","wC","vD","qC","qD","m_JwC","rC","m_JvBD","m_JwB","m_JwD","rD","cC","cD","JvAC","JvBD","JwA","JwB","JwC","JwD","correctionFactor","MotorJoint","m_linearOffset","linearOffset","getPosition","m_angularOffset","angularOffset","m_correctionFactor","factor","m_linearError","m_angularError","inv_h","MouseJoint","m_targetA","m_beta","m_C","_localAnchorB","velocity","getMass","PulleyJoint","groundA","groundB","m_groundAnchorA","groundAnchorA","m_groundAnchorB","groundAnchorB","m_lengthA","lengthA","m_lengthB","lengthB","m_uB","m_uA","ruA","ruB","PA","PB","uA","uB","maxLength","RopeJoint","m_maxLength","m_state","crA","crB","WeldJoint","getInverse22","invM","getSymInverse33","impulse2","mulVec3","WheelJoint","m_ax","m_ay","localAxis","m_springMass","m_springImpulse","m_sAy","m_sBy","m_sAx","m_sBx","damp","ay","sAy","sBy","SID","Serializer","rootClass","preSerialize","postSerialize","preDeserialize","postDeserialize","refTypes","restoreTypes","CLASS_BY_TYPE_PROP","toJson","json","queue","refMap","storeRef","typeName","__sid","ref","refIndex","refType","top","serialize","newValue","str","fromJson","deserialize","cls","ctx","deserializer","_deserialize","findDeserilizer","restoreRef","serializer","addType","CollideCircles","circleA","circleB","distSqr","CollideEdgeCircle","chain","getChildEdge","Q","edgeA","matrix.retransformVec2","A1","B1","B2","A2","den","incidentEdge","clipPoints1","clipPoints2","clipSegmentToLineNormal","v11","v12","localTangent","normal1","findMaxSeparation","poly1","poly2","count1","count2","n1s","v1s","v2s","matrix.invTransformTransform","maxSeparation","si","sij","CollidePolygons","polyA","polyB","separationA","separationB","edge1","flip","clipVertex","normals1","vertices2","normals2","before","after","matrix.rerotVec2","minDot","findIncidentEdge","vertices1","iv1","iv2","frontOffset","sideOffset1","sideOffset2","swapFeatures","CollidePolygonCircle","cLocal","faceCenter","polygonA","normalIndex","vertexCount","vertIndex1","vertIndex2","u1","u2","CollideEdgePolygon","edge_reuse","EPAxisType","VertexType","EPAxis","edgeAxis","polygonAxis","polygonBA","rf","sideNormal1","sideNormal2","centroidB","edge0","edge2","normal0","normal2","lowerLimit","upperLimit","polygonB","v0","offset1","front","offset0","offset2","convex1","convex2","e_edgeA","e_edgeB","primaryAxis","internal"],"mappings":"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"}